var Ie=Object.defineProperty;var Fe=(t,e,o)=>e in t?Ie(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o;var w=(t,e,o)=>Fe(t,typeof e!="symbol"?e+"":e,o);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const s of r.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&n(s)}).observe(document,{childList:!0,subtree:!0});function o(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=o(i);fetch(i.href,r)}})();class Me{constructor(){w(this,"blocks",new Map);w(this,"edges",[]);w(this,"nextBlockId",0);w(this,"nextEdgeId",0)}addBlock(e,o={},n){const i=`b${this.nextBlockId++}`;return this.blocks.set(i,{id:i,type:e,params:o,label:n}),i}addEdge(e,o,n){const i=`e${this.nextEdgeId++}`;return this.edges.push({id:i,from:e,to:o,enabled:(n==null?void 0:n.enabled)??!0,sortKey:n==null?void 0:n.sortKey}),this}wire(e,o,n,i,r){return this.addEdge({kind:"port",blockId:e,slotId:o},{kind:"port",blockId:n,slotId:i},r)}build(){return{blocks:new Map(this.blocks),edges:[...this.edges]}}}function ve(t){const e=new Me;return t(e),e.build()}function Se(t){const e=[],o=new Map,n=[],i=[...t.blocks.keys()].sort();for(const s of i){if(o.has(s)){e.push({kind:"DuplicateBlockId",id:s});continue}const d=n.length;o.set(s,d),n.push(t.blocks.get(s))}const r=[];for(const s of t.edges){if(s.enabled===!1)continue;const d=o.get(s.from.blockId),a=o.get(s.to.blockId);if(d===void 0){e.push({kind:"DanglingEdge",edge:s,missing:"from"});continue}if(a===void 0){e.push({kind:"DanglingEdge",edge:s,missing:"to"});continue}r.push({fromBlock:d,fromPort:s.from.slotId,toBlock:a,toPort:s.to.slotId})}return r.sort((s,d)=>s.toBlock!==d.toBlock?s.toBlock-d.toBlock:s.toPort!==d.toPort?s.toPort.localeCompare(d.toPort):s.fromBlock!==d.fromBlock?s.fromBlock-d.fromBlock:s.fromPort.localeCompare(d.fromPort)),e.length>0?{kind:"error",errors:e}:{kind:"ok",patch:{patch:t,blockIndex:o,blocks:n,edges:r}}}var h=(t=>(t.Add="add",t.Sub="sub",t.Mul="mul",t.Div="div",t.Mod="mod",t.Neg="neg",t.Abs="abs",t.Sin="sin",t.Cos="cos",t.Tan="tan",t.Min="min",t.Max="max",t.Clamp="clamp",t.Lerp="lerp",t.Eq="eq",t.Lt="lt",t.Gt="gt",t.Wrap01="wrap01",t))(h||{});class Ee{constructor(){w(this,"signals",new Map);w(this,"fields",new Map);w(this,"events",new Map);w(this,"domains",new Map);w(this,"steps",[]);w(this,"nextSigId",0);w(this,"nextFieldId",0);w(this,"nextEventId",0);w(this,"nextDomainId",0);w(this,"nextSlotId",0);w(this,"timeModel",{kind:"infinite"})}setTimeModel(e){this.timeModel=e}allocSlot(){return this.nextSlotId++}sigConst(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"const",value:e,type:o}),n}sigSlot(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"slot",slot:e,type:o}),n}sigTime(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"time",which:e,type:o}),n}sigExternal(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"external",which:e,type:o}),n}sigMap(e,o,n){const i=this.nextSigId++;return this.signals.set(i,{kind:"map",input:e,fn:o,type:n}),i}sigZip(e,o,n){const i=this.nextSigId++;return this.signals.set(i,{kind:"zip",inputs:e,fn:o,type:n}),i}sigBinOp(e,o,n,i){return this.sigZip([e,o],{kind:"opcode",opcode:n},i)}sigUnaryOp(e,o,n){return this.sigMap(e,{kind:"opcode",opcode:o},n)}fieldConst(e,o){const n=this.nextFieldId++;return this.fields.set(n,{kind:"const",value:e,type:o}),n}fieldSource(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"source",domain:e,sourceId:o,type:n}),i}fieldBroadcast(e,o){const n=this.nextFieldId++;return this.fields.set(n,{kind:"broadcast",signal:e,type:o}),n}fieldMap(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"map",input:e,fn:o,type:n}),i}fieldZip(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"zip",inputs:e,fn:o,type:n}),i}fieldZipSig(e,o,n,i){const r=this.nextFieldId++;return this.fields.set(r,{kind:"zipSig",field:e,signals:o,fn:n,type:i}),r}fieldMapIndexed(e,o,n,i){const r=this.nextFieldId++;return this.fields.set(r,{kind:"mapIndexed",domain:e,fn:o,type:n,signals:i}),r}eventPulse(){const e=this.nextEventId++;return this.events.set(e,{kind:"pulse",source:"timeRoot"}),e}eventWrap(e){const o=this.nextEventId++;return this.events.set(o,{kind:"wrap",signal:e}),o}eventCombine(e,o){const n=this.nextEventId++;return this.events.set(n,{kind:"combine",events:e,mode:o}),n}domainGrid(e,o){const n=`domain_${this.nextDomainId++}`,i=e*o,r=Array.from({length:i},(s,d)=>this.seededId(e*1e4+o+d));return this.domains.set(n,{id:n,kind:"grid",count:i,elementIds:r,params:{rows:e,cols:o}}),n}domainN(e,o=0){const n=`domain_${this.nextDomainId++}`,i=Array.from({length:e},(r,s)=>this.seededId(o*1e5+e+s));return this.domains.set(n,{id:n,kind:"n",count:e,elementIds:i,params:{n:e,seed:o}}),n}seededId(e){let o=e;return o=(o>>16^o)*73244475,o=(o>>16^o)*73244475,o=o>>16^o,Math.abs(o).toString(36).slice(0,8).padStart(8,"0")}stepEvalSig(e,o){this.steps.push({kind:"evalSig",expr:e,target:o})}stepMaterialize(e,o,n){this.steps.push({kind:"materialize",field:e,domain:o,target:n})}stepRender(e,o,n,i){this.steps.push({kind:"render",domain:e,position:o,color:n,size:i})}build(){return{timeModel:this.timeModel,signals:new Map(this.signals),fields:new Map(this.fields),events:new Map(this.events),domains:new Map(this.domains),steps:[...this.steps],slotCount:this.nextSlotId}}}function y(){return{kind:"default"}}function X(t){return{kind:"instantiated",value:t}}function xe(t){return t.kind==="instantiated"}function ne(t){return{kind:"domain",id:t}}function ie(){return{kind:"one"}}function Be(t){return{kind:"many",domain:t}}function re(){return{kind:"continuous"}}function Pe(){return{cardinality:y(),temporality:y(),binding:y(),perspective:y(),branch:y()}}function Te(t){return{cardinality:t.cardinality??y(),temporality:t.temporality??y(),binding:t.binding??y(),perspective:t.perspective??y(),branch:t.branch??y()}}function se(t,e){return{payload:t,extent:e?Te(e):Pe()}}const $e={cardinality:ie()};function de(t){return se(t,{cardinality:X(ie()),temporality:X(re())})}function Ae(t,e){return se(t,{cardinality:X(Be(ne(e))),temporality:X(re())})}const G=new Map;function k(t){if(G.has(t.type))throw new Error(`Block type already registered: ${t.type}`);const e=new Set(t.inputs.map(n=>n.portId)),o=new Set(t.outputs.map(n=>n.portId));if(e.size!==t.inputs.length)throw new Error(`Duplicate input port IDs in block ${t.type}`);if(o.size!==t.outputs.length)throw new Error(`Duplicate output port IDs in block ${t.type}`);G.set(t.type,t)}function Z(t){return G.get(t)}function c(t){return de(t)}function l(t){return Ae(t,"__default__")}function le(t="float"){return de(t)}function Y(t="__domain__"){return ne(t)}const qe=({b:t,config:e})=>{t.setTimeModel({kind:"infinite",windowMs:6e4});const o=t.sigTime("t",c("float")),n=t.sigTime("dt",c("float")),i=typeof e.periodMs=="number"?e.periodMs:4e3,r=t.sigConst(i,c("float")),s=t.sigBinOp(o,r,h.Div,c("float")),d=t.sigUnaryOp(s,h.Wrap01,c("phase")),a=t.eventWrap(d),u=t.sigConst(1,c("float"));return{t:{kind:"sig",id:o,type:c("float")},dt:{kind:"sig",id:n,type:c("float")},phase:{kind:"sig",id:d,type:c("phase")},pulse:{kind:"event",id:a},energy:{kind:"sig",id:u,type:c("float")}}};k({type:"InfiniteTimeRoot",inputs:[],outputs:[{portId:"t",type:c("float")},{portId:"dt",type:c("float")},{portId:"phase",type:c("phase")},{portId:"pulse",type:le("float")},{portId:"energy",type:c("float")}],lower:qe});const Ce=({b:t,config:e})=>{const o=typeof e.durationMs=="number"?e.durationMs:1e4;t.setTimeModel({kind:"finite",durationMs:o});const n=t.sigTime("t",c("float")),i=t.sigTime("dt",c("float")),r=t.sigConst(o,c("float")),s=t.sigBinOp(n,r,h.Div,c("float")),d=typeof e.periodMs=="number"?e.periodMs:0;let a,u;if(d>0){const f=t.sigConst(d,c("float")),g=t.sigBinOp(n,f,h.Div,c("float"));a=t.sigUnaryOp(g,h.Wrap01,c("phase")),u=t.eventWrap(a)}else a=s,u=t.eventPulse();const p=t.sigConst(1,c("float"));return{t:{kind:"sig",id:n,type:c("float")},dt:{kind:"sig",id:i,type:c("float")},progress:{kind:"sig",id:s,type:c("float")},phase:{kind:"sig",id:a,type:c("phase")},pulse:{kind:"event",id:u},energy:{kind:"sig",id:p,type:c("float")}}};k({type:"FiniteTimeRoot",inputs:[],outputs:[{portId:"t",type:c("float")},{portId:"dt",type:c("float")},{portId:"progress",type:c("float")},{portId:"phase",type:c("phase")},{portId:"pulse",type:le("float")},{portId:"energy",type:c("float")}],lower:Ce});const De=({b:t,config:e})=>{const o=typeof e.value=="number"?e.value:0;return{out:{kind:"sig",id:t.sigConst(o,c("float")),type:c("float")}}};k({type:"ConstFloat",inputs:[],outputs:[{portId:"out",type:c("float")}],lower:De});const Re=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||!n||o.kind!=="sig"||n.kind!=="sig")throw new Error("AddSignal requires two signal inputs");return{out:{kind:"sig",id:t.sigBinOp(o.id,n.id,h.Add,c("float")),type:c("float")}}};k({type:"AddSignal",inputs:[{portId:"a",type:c("float")},{portId:"b",type:c("float")}],outputs:[{portId:"out",type:c("float")}],lower:Re});const ze=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||!n||o.kind!=="sig"||n.kind!=="sig")throw new Error("MulSignal requires two signal inputs");return{out:{kind:"sig",id:t.sigBinOp(o.id,n.id,h.Mul,c("float")),type:c("float")}}};k({type:"MulSignal",inputs:[{portId:"a",type:c("float")},{portId:"b",type:c("float")}],outputs:[{portId:"out",type:c("float")}],lower:ze});const Ue=({b:t,inputsById:e,config:o})=>{const n=e.phase;if(!n||n.kind!=="sig")throw new Error("Oscillator requires phase input");const i=typeof o.waveform=="string"?o.waveform:"sin",r=t.sigConst(Math.PI*2,c("float")),s=t.sigBinOp(n.id,r,h.Mul,c("float"));let d;switch(i){case"sin":d=t.sigUnaryOp(s,h.Sin,c("float"));break;case"cos":d=t.sigUnaryOp(s,h.Cos,c("float"));break;case"saw":const a=t.sigConst(2,c("float")),u=t.sigConst(1,c("float")),p=t.sigBinOp(n.id,a,h.Mul,c("float"));d=t.sigBinOp(p,u,h.Sub,c("float"));break;default:d=t.sigUnaryOp(s,h.Sin,c("float"))}return{out:{kind:"sig",id:d,type:c("float")}}};k({type:"Oscillator",inputs:[{portId:"phase",type:c("phase")}],outputs:[{portId:"out",type:c("float")}],lower:Ue});k({type:"MousePosition",inputs:[],outputs:[{portId:"x",type:c("float")},{portId:"y",type:c("float")}],lower:({b:t})=>({x:{kind:"sig",id:t.sigExternal("mouseX",c("float")),type:c("float")},y:{kind:"sig",id:t.sigExternal("mouseY",c("float")),type:c("float")}})});const Oe=({b:t,config:e})=>{const o=typeof e.rows=="number"?e.rows:4,n=typeof e.cols=="number"?e.cols:4,i=t.domainGrid(o,n),r=t.fieldSource(i,"pos0",l("vec2")),s=t.fieldSource(i,"index",l("float")),d=t.fieldSource(i,"normalizedIndex",l("float")),a=t.fieldSource(i,"idRand",l("float"));return{domain:{kind:"domain",id:i},pos:{kind:"field",id:r,type:l("vec2")},index:{kind:"field",id:s,type:l("float")},normIndex:{kind:"field",id:d,type:l("float")},rand:{kind:"field",id:a,type:l("float")}}};k({type:"GridDomain",inputs:[],outputs:[{portId:"domain",type:Y()},{portId:"pos",type:l("vec2")},{portId:"index",type:l("float")},{portId:"normIndex",type:l("float")},{portId:"rand",type:l("float")}],lower:Oe});const Ze=({b:t,config:e})=>{const o=typeof e.n=="number"?e.n:10,n=typeof e.seed=="number"?e.seed:0,i=t.domainN(o,n),r=t.fieldSource(i,"index",l("float")),s=t.fieldSource(i,"normalizedIndex",l("float")),d=t.fieldSource(i,"idRand",l("float"));return{domain:{kind:"domain",id:i},index:{kind:"field",id:r,type:l("float")},normIndex:{kind:"field",id:s,type:l("float")},rand:{kind:"field",id:d,type:l("float")}}};k({type:"DomainN",inputs:[],outputs:[{portId:"domain",type:Y()},{portId:"index",type:l("float")},{portId:"normIndex",type:l("float")},{portId:"rand",type:l("float")}],lower:Ze});const Xe=({b:t,inputsById:e})=>{const o=e.signal;if(!o||o.kind!=="sig")throw new Error("FieldBroadcast requires signal input");return{out:{kind:"field",id:t.fieldBroadcast(o.id,l(o.type.payload)),type:l(o.type.payload)}}};k({type:"FieldBroadcast",inputs:[{portId:"signal",type:c("float")}],outputs:[{portId:"out",type:l("float")}],lower:Xe});const Ye=({b:t,inputsById:e,config:o})=>{const n=e.field;if(!n||n.kind!=="field")throw new Error("FieldMap requires field input");const i=typeof o.expr=="string"?o.expr:"x";return{out:{kind:"field",id:t.fieldMap(n.id,{kind:"expr",expr:i},l(n.type.payload)),type:l(n.type.payload)}}};k({type:"FieldMap",inputs:[{portId:"field",type:l("float")}],outputs:[{portId:"out",type:l("float")}],lower:Ye});const be=({b:t,inputsById:e,config:o})=>{const n=e.field,i=e.signal;if(!n||n.kind!=="field")throw new Error("FieldZipSig requires field input");if(!i||i.kind!=="sig")throw new Error("FieldZipSig requires signal input");const r=typeof o.op=="string"?o.op:"mul";let s;switch(r){case"add":s=h.Add;break;case"sub":s=h.Sub;break;case"mul":s=h.Mul;break;case"div":s=h.Div;break;default:s=h.Mul}return{out:{kind:"field",id:t.fieldZipSig(n.id,[i.id],{kind:"opcode",opcode:s},l("float")),type:l("float")}}};k({type:"FieldZipSig",inputs:[{portId:"field",type:l("float")},{portId:"signal",type:c("float")}],outputs:[{portId:"out",type:l("float")}],lower:be});const _e=({b:t,inputsById:e})=>{const o=e.domain;if(!o||o.kind!=="domain")throw new Error("FieldFromDomainId requires domain input");return{id01:{kind:"field",id:t.fieldSource(o.id,"normalizedIndex",l("float")),type:l("float")}}};k({type:"FieldFromDomainId",inputs:[{portId:"domain",type:Y()}],outputs:[{portId:"id01",type:l("float")}],lower:_e});const Ve=({b:t,inputsById:e})=>{const o=e.phase,n=e.id01,i=e.base,r=e.amplitude,s=e.spread;if(!o||o.kind!=="sig")throw new Error("FieldPulse requires phase (signal) input");if(!n||n.kind!=="field")throw new Error("FieldPulse requires id01 (field) input");if(!i||i.kind!=="sig")throw new Error("FieldPulse requires base (signal) input");if(!r||r.kind!=="sig")throw new Error("FieldPulse requires amplitude (signal) input");if(!s||s.kind!=="sig")throw new Error("FieldPulse requires spread (signal) input");const d=t.fieldBroadcast(s.id,l("float")),a=t.fieldZip([n.id,d],{kind:"opcode",opcode:h.Mul},l("float")),u=t.fieldBroadcast(o.id,l("float")),p=t.fieldZip([u,a],{kind:"opcode",opcode:h.Add},l("float")),f=t.sigConst(Math.PI*2,c("float")),g=t.fieldBroadcast(f,l("float")),m=t.fieldZip([p,g],{kind:"opcode",opcode:h.Mul},l("float")),I=t.fieldMap(m,{kind:"opcode",opcode:h.Sin},l("float")),F=t.fieldBroadcast(r.id,l("float")),M=t.fieldZip([I,F],{kind:"opcode",opcode:h.Mul},l("float")),S=t.fieldBroadcast(i.id,l("float"));return{value:{kind:"field",id:t.fieldZip([S,M],{kind:"opcode",opcode:h.Add},l("float")),type:l("float")}}};k({type:"FieldPulse",inputs:[{portId:"phase",type:c("phase")},{portId:"id01",type:l("float")},{portId:"base",type:c("float")},{portId:"amplitude",type:c("float")},{portId:"spread",type:c("float")}],outputs:[{portId:"value",type:l("float")}],lower:Ve});const He=({b:t,inputsById:e,config:o})=>{const n=e.id01;if(!n||n.kind!=="field")throw new Error("FieldGoldenAngle requires id01 (field) input");const i=2.399963229728653,r=typeof o.turns=="number"?o.turns:50,s=t.sigConst(i*r,c("float")),d=t.fieldBroadcast(s,l("float"));return{angle:{kind:"field",id:t.fieldZip([n.id,d],{kind:"opcode",opcode:h.Mul},l("float")),type:l("float")}}};k({type:"FieldGoldenAngle",inputs:[{portId:"id01",type:l("float")}],outputs:[{portId:"angle",type:l("float")}],lower:He});const je=({b:t,inputsById:e})=>{const o=e.phase,n=e.spin,i=e.id01;if(!o||o.kind!=="sig")throw new Error("FieldAngularOffset requires phase (signal) input");if(!n||n.kind!=="sig")throw new Error("FieldAngularOffset requires spin (signal) input");if(!i||i.kind!=="field")throw new Error("FieldAngularOffset requires id01 (field) input");const r=t.sigConst(2,c("float")),s=t.fieldBroadcast(r,l("float")),d=t.fieldZip([s,i.id],{kind:"opcode",opcode:h.Sub},l("float")),a=t.sigConst(Math.PI*2,c("float")),u=t.sigBinOp(o.id,a,h.Mul,c("float")),p=t.sigBinOp(u,n.id,h.Mul,c("float")),f=t.fieldBroadcast(p,l("float"));return{offset:{kind:"field",id:t.fieldZip([f,d],{kind:"opcode",opcode:h.Mul},l("float")),type:l("float")}}};k({type:"FieldAngularOffset",inputs:[{portId:"phase",type:c("phase")},{portId:"spin",type:c("float")},{portId:"id01",type:l("float")}],outputs:[{portId:"offset",type:l("float")}],lower:je});const Le=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||o.kind!=="field")throw new Error("FieldAdd requires a (field) input");if(!n||n.kind!=="field")throw new Error("FieldAdd requires b (field) input");return{out:{kind:"field",id:t.fieldZip([o.id,n.id],{kind:"opcode",opcode:h.Add},l("float")),type:l("float")}}};k({type:"FieldAdd",inputs:[{portId:"a",type:l("float")},{portId:"b",type:l("float")}],outputs:[{portId:"out",type:l("float")}],lower:Le});const Ge=({b:t,inputsById:e})=>{const o=e.radius,n=e.id01;if(!o||o.kind!=="sig"&&o.kind!=="field")throw new Error("FieldRadiusSqrt requires radius (signal or field) input");if(!n||n.kind!=="field")throw new Error("FieldRadiusSqrt requires id01 (field) input");const i=t.fieldMap(n.id,{kind:"kernel",name:"sqrt"},l("float")),r=o.kind==="sig"?t.fieldBroadcast(o.id,l("float")):o.id;return{radius:{kind:"field",id:t.fieldZip([r,i],{kind:"opcode",opcode:h.Mul},l("float")),type:l("float")}}};k({type:"FieldRadiusSqrt",inputs:[{portId:"radius",type:l("float")},{portId:"id01",type:l("float")}],outputs:[{portId:"radius",type:l("float")}],lower:Ge});const Je=({b:t,inputsById:e})=>{const o=e.centerX,n=e.centerY,i=e.radius,r=e.angle;if(!o||o.kind!=="sig")throw new Error("FieldPolarToCartesian requires centerX (signal) input");if(!n||n.kind!=="sig")throw new Error("FieldPolarToCartesian requires centerY (signal) input");if(!i||i.kind!=="field")throw new Error("FieldPolarToCartesian requires radius (field) input");if(!r||r.kind!=="field")throw new Error("FieldPolarToCartesian requires angle (field) input");const s=t.fieldMap(r.id,{kind:"opcode",opcode:h.Cos},l("float")),d=t.fieldMap(r.id,{kind:"opcode",opcode:h.Sin},l("float")),a=t.fieldZip([i.id,s],{kind:"opcode",opcode:h.Mul},l("float")),u=t.fieldBroadcast(o.id,l("float")),p=t.fieldZip([u,a],{kind:"opcode",opcode:h.Add},l("float")),f=t.fieldZip([i.id,d],{kind:"opcode",opcode:h.Mul},l("float")),g=t.fieldBroadcast(n.id,l("float")),m=t.fieldZip([g,f],{kind:"opcode",opcode:h.Add},l("float"));return{pos:{kind:"field",id:t.fieldZip([p,m],{kind:"kernel",name:"makeVec2"},l("vec2")),type:l("vec2")}}};k({type:"FieldPolarToCartesian",inputs:[{portId:"centerX",type:c("float")},{portId:"centerY",type:c("float")},{portId:"radius",type:l("float")},{portId:"angle",type:l("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:Je});const Ke=({b:t,inputsById:e})=>{const o=e.phase,n=e.id01;if(!o||o.kind!=="sig")throw new Error("FieldHueFromPhase requires phase (signal) input");if(!n||n.kind!=="field")throw new Error("FieldHueFromPhase requires id01 (field) input");const i=t.fieldBroadcast(o.id,l("float")),r=t.fieldZip([i,n.id],{kind:"opcode",opcode:h.Add},l("float"));return{hue:{kind:"field",id:t.fieldMap(r,{kind:"opcode",opcode:h.Wrap01},l("float")),type:l("float")}}};k({type:"FieldHueFromPhase",inputs:[{portId:"phase",type:c("phase")},{portId:"id01",type:l("float")}],outputs:[{portId:"hue",type:l("float")}],lower:Ke});const We=({b:t,inputsById:e})=>{const o=e.hue,n=e.sat,i=e.val;if(!o||o.kind!=="field")throw new Error("HsvToRgb requires hue (field) input");if(!n||n.kind!=="sig")throw new Error("HsvToRgb requires sat (signal) input");if(!i||i.kind!=="sig")throw new Error("HsvToRgb requires val (signal) input");const r=t.fieldBroadcast(n.id,l("float")),s=t.fieldBroadcast(i.id,l("float"));return{color:{kind:"field",id:t.fieldZip([o.id,r,s],{kind:"kernel",name:"hsvToRgb"},l("color")),type:l("color")}}};k({type:"HsvToRgb",inputs:[{portId:"hue",type:l("float")},{portId:"sat",type:c("float")},{portId:"val",type:c("float")}],outputs:[{portId:"color",type:l("color")}],lower:We});const Ne=({b:t,inputsById:e})=>{const o=e.domain,n=e.pos,i=e.color,r=e.size,s=e.opacity;if(!o||o.kind!=="domain")throw new Error("RenderInstances2D requires domain input");if(!n||n.kind!=="field")throw new Error("RenderInstances2D requires pos (field<vec2>) input");if(!i||i.kind!=="field")throw new Error("RenderInstances2D requires color (field<color>) input");let d;r&&(r.kind==="sig"||r.kind==="field")&&(d=r.id);let a;s&&s.kind==="sig"&&(a=s.id);let u=i.id;return a&&(u=t.fieldZipSig(i.id,[a],{kind:"kernel",name:"applyOpacity"},l("color"))),t.stepRender(o.id,n.id,u,d),{}};k({type:"RenderInstances2D",inputs:[{portId:"domain",type:Y()},{portId:"pos",type:l("vec2")},{portId:"color",type:l("color")},{portId:"size",type:l("float"),optional:!0},{portId:"opacity",type:c("float"),optional:!0}],outputs:[],lower:Ne});const Qe=({b:t,inputsById:e})=>{const o=e.pos,n=e.rand,i=e.amountX,r=e.amountY;if(!o||o.kind!=="field")throw new Error("FieldJitter2D requires pos (field<vec2>) input");if(!n||n.kind!=="field")throw new Error("FieldJitter2D requires rand (field<float>) input");if(!i||i.kind!=="sig")throw new Error("FieldJitter2D requires amountX (signal) input");if(!r||r.kind!=="sig")throw new Error("FieldJitter2D requires amountY (signal) input");const s=t.fieldBroadcast(i.id,l("float")),d=t.fieldBroadcast(r.id,l("float"));return{pos:{kind:"field",id:t.fieldZip([o.id,n.id,s,d],{kind:"kernel",name:"jitter2d"},l("vec2")),type:l("vec2")}}};k({type:"FieldJitter2D",inputs:[{portId:"pos",type:l("vec2")},{portId:"rand",type:l("float")},{portId:"amountX",type:c("float")},{portId:"amountY",type:c("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:Qe});k({type:"FieldAttract2D",inputs:[{portId:"pos",type:l("vec2")},{portId:"targetX",type:c("float")},{portId:"targetY",type:c("float")},{portId:"phase",type:c("phase")},{portId:"strength",type:c("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:({b:t,inputsById:e})=>{const o=e.pos,n=e.targetX,i=e.targetY,r=e.phase,s=e.strength,d=t.fieldBroadcast(n.id,l("float")),a=t.fieldBroadcast(i.id,l("float")),u=t.fieldBroadcast(r.id,l("float")),p=t.fieldBroadcast(s.id,l("float"));return{pos:{kind:"field",id:t.fieldZip([o.id,d,a,u,p],{kind:"kernel",name:"attract2d"},l("vec2")),type:l("vec2")}}}});function et(t){const e=[];for(const o of t.edges){const n=t.blocks[o.fromBlock],i=t.blocks[o.toBlock],r=Z(n.type),s=Z(i.type);if(!r||!s)continue;const d=r.outputs.find(p=>p.portId===o.fromPort),a=s.inputs.find(p=>p.portId===o.toPort);if(!d){e.push({kind:"UnknownPort",message:`Source block '${n.type}' does not have output port '${o.fromPort}'`,blockId:n.id,portId:o.fromPort});continue}if(!a){e.push({kind:"UnknownPort",message:`Target block '${i.type}' does not have input port '${o.toPort}'`,blockId:i.id,portId:o.toPort});continue}if(tt(d.type,a.type)===null){const p=N(d.type),f=N(a.type);e.push({kind:"TypeMismatch",message:`Cannot connect ${p} to ${f} (${n.type}.${o.fromPort} â†’ ${i.type}.${o.toPort})`,blockId:n.id,portId:o.fromPort})}}for(const o of t.blocks){const n=Z(o.type);if(n)for(const i of n.inputs){if(i.optional)continue;!t.edges.some(s=>s.toBlock===t.blocks.indexOf(o)&&s.toPort===i.portId)&&!i.defaultValue&&e.push({kind:"MissingRequiredInput",message:`Block '${o.type}' is missing required input '${i.portId}'`,blockId:o.id,portId:i.portId})}}return e}function q(t){return"kind"in t&&t.kind==="domain"}function J(t){const e=t.extent.cardinality;return xe(e)?e.value:$e.cardinality}function K(t){return t.kind==="zero"?"zero":t.kind==="one"?"one":"many"}function tt(t,e){if(q(t)||q(e))return q(t)&&q(e)?{kind:"direct"}:null;const o=t,n=e,i=K(J(o)),r=K(J(n));return i===r&&o.payload===n.payload?{kind:"direct"}:o.payload!==n.payload?null:i==="zero"&&r==="one"?{kind:"promote",from:"zero",to:"one"}:i==="one"&&r==="many"?{kind:"broadcast"}:i==="zero"&&r==="many"?{kind:"promote-broadcast"}:null}function N(t){if(q(t))return`domain:${t.id}`;const e=t;return`${K(J(e))}:${e.payload}`}function ot(t){const e=[],o=Se(t);if(o.kind==="error")return{kind:"error",errors:o.errors.map(u=>({kind:u.kind,message:nt(u)}))};const n=o.patch,i=it(n);i.kind==="error"&&e.push(...i.errors);const r=et(n);if(r.length>0&&e.push(...r),e.length>0)return{kind:"error",errors:e};const s=rt(n),d=new Ee,a=new Map;for(const u of s){const p=n.blocks[u],f=Z(p.type);if(!f){e.push({kind:"UnknownBlockType",message:`Unknown block type: ${p.type}`,blockId:p.id});continue}const g=st(n,u,a);try{const m=f.lower({b:d,config:p.params,inputsById:g});a.set(u,m)}catch(m){e.push({kind:"LoweringError",message:m instanceof Error?m.message:String(m),blockId:p.id})}}return e.length>0?{kind:"error",errors:e}:{kind:"ok",program:d.build()}}function nt(t){switch(t.kind){case"DanglingEdge":return"Edge references non-existent block";case"DuplicateBlockId":return"Duplicate block ID";default:return t.kind}}function it(t){const e=[];for(let o=0;o<t.blocks.length;o++){const n=t.blocks[o];(n.type==="InfiniteTimeRoot"||n.type==="FiniteTimeRoot"||n.type==="TimeRoot")&&e.push(o)}return e.length===0?{kind:"error",errors:[{kind:"NoTimeRoot",message:"No TimeRoot block found. Every patch needs exactly one."}]}:e.length>1?{kind:"error",errors:[{kind:"MultipleTimeRoots",message:`Found ${e.length} TimeRoot blocks. Only one allowed.`}]}:{kind:"ok",blockIdx:e[0]}}function rt(t){const e=new Map,o=new Map;for(let r=0;r<t.blocks.length;r++)e.set(r,new Set),o.set(r,new Set);for(const r of t.edges)e.get(r.toBlock).add(r.fromBlock),o.get(r.fromBlock).add(r.toBlock);const n=[],i=[];for(let r=0;r<t.blocks.length;r++)e.get(r).size===0&&i.push(r);for(;i.length>0;){const r=i.shift();n.push(r);for(const s of o.get(r))e.get(s).delete(r),e.get(s).size===0&&i.push(s)}if(n.length!==t.blocks.length){const r=new Set;for(let d=0;d<t.blocks.length;d++)n.includes(d)||r.add(d);const s=[...r].map(d=>t.blocks[d].id);throw new Error(`Dependency cycle detected involving blocks: ${s.join(", ")}`)}return n}function st(t,e,o){const n={};for(const i of t.edges)if(i.toBlock===e){const r=o.get(i.fromBlock);if(r){const s=i.fromPort;n[i.toPort]=r[s]}}return n}function dt(t){switch(t){case"float":case"int":case"bool":case"unit":case"phase":return"f32";case"vec2":return"vec2f32";case"color":return"rgba8"}}class lt{constructor(){w(this,"pools",new Map);w(this,"inUse",new Map);w(this,"maxPoolSize",100)}alloc(e,o){const n=`${e}:${o}`;this.pools.size>this.maxPoolSize&&this.trimPools();const i=this.pools.get(n)??[];if(i.length>0){const s=i.pop();return this.trackInUse(n,s),s}const r=at(e,o);return this.trackInUse(n,r),r}releaseAll(){for(const[e,o]of this.inUse){const n=this.pools.get(e)??[];n.push(...o),this.pools.set(e,n)}this.inUse.clear()}trackInUse(e,o){const n=this.inUse.get(e)??[];n.push(o),this.inUse.set(e,n)}getStats(){let e=0;for(const n of this.pools.values())e+=n.length;let o=0;for(const n of this.inUse.values())o+=n.length;return{pooled:e,inUse:o,poolKeys:this.pools.size}}trimPools(){const e=new Set(this.inUse.keys());for(const[o,n]of this.pools)!e.has(o)&&n.length>0&&this.pools.delete(o)}clearUnusedPools(){for(const[e,o]of this.pools)this.inUse.has(e)||this.pools.delete(e)}}function at(t,e){switch(t){case"f32":return new Float32Array(e);case"vec2f32":return new Float32Array(e*2);case"rgba8":return new Uint8ClampedArray(e*4);default:{const o=t;throw new Error(`Unknown buffer format: ${String(o)}`)}}}function ct(){return{prevTAbsMs:null,prevTModelMs:null,wrapCount:0}}function pt(t,e,o){const n=o.prevTAbsMs!==null?t-o.prevTAbsMs:0;switch(o.prevTAbsMs=t,e.kind){case"finite":{const i=Math.max(0,Math.min(t,e.durationMs)),r=e.durationMs>0?i/e.durationMs:0;return{tAbsMs:t,tModelMs:i,dt:n,progress:r}}case"cyclic":{const i=e.periodMs,r=(t%i+i)%i,s=i>0?r/i:0;let d=0;o.prevTModelMs!==null&&r<o.prevTModelMs&&(d=1,o.wrapCount++),o.prevTModelMs=r;const a=o.wrapCount;return{tAbsMs:t,tModelMs:r,dt:n,phase:s,pulse:d,energy:a}}case"infinite":return{tAbsMs:t,tModelMs:t,dt:n};default:{const i=e;throw new Error(`Unknown time model: ${String(i)}`)}}}function ut(t){return{f64:new Float64Array(t),objects:new Map}}function ft(t=1e3,e=1e3){return{frameId:0,sigValues:new Float64Array(t),sigStamps:new Uint32Array(t),fieldBuffers:new Map,fieldStamps:new Map}}function ht(){return{mouseX:.5,mouseY:.5,mouseOver:!1,smoothX:.5,smoothY:.5}}function gt(t){return{values:ut(t),cache:ft(),timeState:ct(),time:null,external:ht()}}function b(t,e){return e.length===1?ae(t,e[0]):mt(t,e)}function ae(t,e){switch(t){case"neg":return-e;case"abs":return Math.abs(e);case"sin":return Math.sin(e);case"cos":return Math.cos(e);case"tan":return Math.tan(e);case"wrap01":return(e%1+1)%1;default:throw new Error(`OpCode ${t} is not unary`)}}function mt(t,e){switch(t){case"add":return e.reduce((o,n)=>o+n,0);case"sub":return e.length>=2?e[0]-e[1]:-e[0];case"mul":return e.reduce((o,n)=>o*n,1);case"div":return e.length>=2?e[0]/e[1]:1/e[0];case"mod":return e.length>=2?e[0]%e[1]:0;case"min":return Math.min(...e);case"max":return Math.max(...e);case"clamp":return e.length>=3?Math.max(e[1],Math.min(e[2],e[0])):e[0];case"lerp":return e.length>=3?e[0]*(1-e[2])+e[1]*e[2]:e[0];default:if(e.length===1)return ae(t,e[0]);throw new Error(`OpCode ${t} not implemented for ${e.length} args`)}}function B(t,e,o){const n=o.cache.sigValues[t];if(o.cache.sigStamps[t]===o.cache.frameId)return n;const r=e.get(t);if(!r)throw new Error(`Signal expression ${t} not found`);const s=kt(r,e,o);return o.cache.sigValues[t]=s,o.cache.sigStamps[t]=o.cache.frameId,s}function kt(t,e,o){if(!o.time)throw new Error("Effective time not set");switch(t.kind){case"const":return typeof t.value=="number"?t.value:0;case"slot":return o.values.f64[t.slot];case"time":{const n=t;switch(n.which){case"t":return o.time.tModelMs;case"dt":return o.time.dt;case"phase":return o.time.phase??0;case"pulse":return o.time.pulse??0;case"energy":return o.time.energy??0;default:{const i=n.which;throw new Error(`Unknown time signal: ${String(i)}`)}}}case"external":{const n=t;if(n.which==="mouseX")return o.external.smoothX;if(n.which==="mouseY")return o.external.smoothY;if(n.which==="mouseOver")return o.external.mouseOver?1:0;throw new Error(`Unknown external signal: ${n.which}`)}case"map":{const n=B(t.input,e,o);return Q(t.fn,[n])}case"zip":{const n=t.inputs.map(i=>B(i,e,o));return Q(t.fn,n)}default:{const n=t;throw new Error(`Unknown signal expr kind: ${n.kind}`)}}}function Q(t,e){if(t.kind==="opcode")return b(t.opcode,e);throw new Error(`PureFn kind ${t.kind} not implemented`)}function x(t,e,o,n,i,r,s){const d=`${t}:${e}`,a=r.cache.fieldBuffers.get(d),u=r.cache.fieldStamps.get(d);if(a&&u===r.cache.frameId)return a;const p=o.get(t);if(!p)throw new Error(`Field expression ${t} not found`);const f=i.get(e);if(!f)throw new Error(`Domain ${e} not found`);const g=dt(p.type.payload),m=s.alloc(g,f.count);return wt(p,m,f,o,n,i,r,s),r.cache.fieldBuffers.set(d,m),r.cache.fieldStamps.set(d,r.cache.frameId),m}function wt(t,e,o,n,i,r,s,d){var u;const a=o.count;switch(t.kind){case"const":{const p=e,f=typeof t.value=="number"?t.value:0;if(t.type.payload==="color"){const g=e;for(let m=0;m<a;m++)g[m*4+0]=255,g[m*4+1]=255,g[m*4+2]=255,g[m*4+3]=255}else if(t.type.payload==="vec2"){const g=e;for(let m=0;m<a;m++)g[m*2+0]=f,g[m*2+1]=f}else for(let g=0;g<a;g++)p[g]=f;break}case"source":{yt(t.sourceId,e,o);break}case"broadcast":{const p=B(t.signal,i,s),f=e;for(let g=0;g<a;g++)f[g]=p;break}case"map":{const p=x(t.input,o.id,n,i,r,s,d);It(e,p,t.fn,a,t.type);break}case"zip":{const p=t.inputs.map(f=>x(f,o.id,n,i,r,s,d));Ft(e,p,t.fn,a,t.type);break}case"zipSig":{const p=x(t.field,o.id,n,i,r,s,d),f=t.signals.map(g=>B(g,i,s));Mt(e,p,f,t.fn,a,t.type);break}case"mapIndexed":{const p=((u=t.signals)==null?void 0:u.map(f=>B(f,i,s)))??[];vt(e,t.fn,p,a,o,t.type);break}default:{const p=t;throw new Error(`Unknown field expr kind: ${p.kind}`)}}}function yt(t,e,o){const n=o.count;switch(t){case"index":{const i=e;for(let r=0;r<n;r++)i[r]=r;break}case"normalizedIndex":{const i=e;for(let r=0;r<n;r++)i[r]=n>1?r/(n-1):0;break}case"pos0":{if(o.kind==="grid"){const i=o.params.rows||1,r=o.params.cols||1,s=e;for(let d=0;d<n;d++){const a=Math.floor(d/r),u=d%r;s[d*2+0]=r>1?u/(r-1):.5,s[d*2+1]=i>1?a/(i-1):.5}}else{const i=e;for(let r=0;r<n;r++)i[r*2+0]=0,i[r*2+1]=0}break}case"idRand":{const i=e;for(let r=0;r<n;r++){const s=o.elementIds[r]||String(r);i[r]=Bt(s)}break}default:{const i=t;throw new Error(`Unknown source ID: ${String(i)}`)}}}function It(t,e,o,n,i){const r=t,s=e;if(o.kind==="opcode"){const d=o.opcode;for(let a=0;a<n;a++)r[a]=b(d,[s[a]])}else if(o.kind==="kernel")switch(o.name){case"sqrt":for(let d=0;d<n;d++)r[d]=Math.sqrt(s[d]);break;case"floor":for(let d=0;d<n;d++)r[d]=Math.floor(s[d]);break;case"ceil":for(let d=0;d<n;d++)r[d]=Math.ceil(s[d]);break;case"round":for(let d=0;d<n;d++)r[d]=Math.round(s[d]);break;default:throw new Error(`Unknown map kernel: ${o.name}`)}else throw new Error(`Map function kind ${o.kind} not implemented`)}function Ft(t,e,o,n,i){if(o.kind==="opcode"){const r=t,s=e.map(a=>a),d=o.opcode;for(let a=0;a<n;a++){const u=s.map(p=>p[a]);r[a]=b(d,u)}}else if(o.kind==="kernel")St(t,e,o.name,n);else throw new Error(`Zip function kind ${o.kind} not implemented`)}function Mt(t,e,o,n,i,r){const s=t,d=e;if(n.kind==="opcode"){const a=n.opcode;for(let u=0;u<i;u++){const p=[d[u],...o];s[u]=b(a,p)}}else if(n.kind==="kernel")Et(t,e,o,n.name,i);else throw new Error(`ZipSig function kind ${n.kind} not implemented`)}function vt(t,e,o,n,i,r){const s=t;if(e.kind==="kernel")if(e.name==="gridPos"){const d=i.params.rows||1,a=i.params.cols||1;for(let u=0;u<n;u++){const p=Math.floor(u/a),f=u%a;s[u*2+0]=a>1?f/(a-1):.5,s[u*2+1]=d>1?p/(d-1):.5}}else throw new Error(`Unknown kernel function: ${e.name}`);else throw new Error(`MapIndexed function kind ${e.kind} not implemented`)}function St(t,e,o,n,i){if(o==="makeVec2"){if(e.length!==2)throw new Error("makeVec2 requires exactly 2 inputs");const r=t,s=e[0],d=e[1];for(let a=0;a<n;a++)r[a*2+0]=s[a],r[a*2+1]=d[a]}else if(o==="hsvToRgb"){if(e.length!==3)throw new Error("hsvToRgb requires exactly 3 inputs (h, s, v)");const r=t,s=e[0],d=e[1],a=e[2];for(let u=0;u<n;u++){const[p,f,g]=xt(s[u],d[u],a[u]);r[u*4+0]=p,r[u*4+1]=f,r[u*4+2]=g,r[u*4+3]=255}}else if(o==="jitter2d"){if(e.length!==4)throw new Error("jitter2d requires exactly 4 inputs (pos, rand, amountX, amountY)");const r=t,s=e[0],d=e[1],a=e[2],u=e[3];for(let p=0;p<n;p++){const f=d[p],g=Math.sin(f*12.9898+78.233)*43758.5453,m=Math.sin(f*93.9898+67.345)*24571.2341,I=((g-Math.floor(g))*2-1)*a[p],F=((m-Math.floor(m))*2-1)*u[p];r[p*2+0]=s[p*2+0]+I,r[p*2+1]=s[p*2+1]+F}}else if(o==="attract2d"){if(e.length!==5)throw new Error("attract2d requires 5 inputs (pos, targetX, targetY, phase, strength)");const r=t,s=e[0],d=e[1],a=e[2],u=e[3],p=e[4];for(let f=0;f<n;f++){const g=s[f*2+0],m=s[f*2+1],I=d[f],F=a[f],M=u[f],S=p[f],P=I-g,E=F-m,C=M*S;r[f*2+0]=g+P*C,r[f*2+1]=m+E*C}}else throw new Error(`Unknown kernel function: ${o}`)}function Et(t,e,o,n,i,r){if(n==="applyOpacity"){if(o.length!==1)throw new Error("applyOpacity requires exactly 1 signal (opacity)");const s=t,d=e,a=Math.max(0,Math.min(1,o[0])),u=Math.round(a*255);for(let p=0;p<i;p++)s[p*4+0]=d[p*4+0],s[p*4+1]=d[p*4+1],s[p*4+2]=d[p*4+2],s[p*4+3]=u}else throw new Error(`Unknown zipSig kernel function: ${n}`)}function xt(t,e,o){t=(t%1+1)%1,e=Math.max(0,Math.min(1,e)),o=Math.max(0,Math.min(1,o));const n=o*e,i=n*(1-Math.abs(t*6%2-1)),r=o-n;let s,d,a;const u=t*6;return u<1?[s,d,a]=[n,i,0]:u<2?[s,d,a]=[i,n,0]:u<3?[s,d,a]=[0,n,i]:u<4?[s,d,a]=[0,i,n]:u<5?[s,d,a]=[i,0,n]:[s,d,a]=[n,0,i],[Math.round((s+r)*255),Math.round((d+r)*255),Math.round((a+r)*255)]}function Bt(t){let e=0;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n)|0;e=Math.imul(e,1540483477),e^=e>>>15;const o=(e*12.9898+78.233)*43758.5453;return o-Math.floor(o)}function Pt(t,e,o,n){e.cache.frameId++;const i=pt(n,t.timeModel,e.timeState);e.time=i;const r=[];for(const s of t.steps)switch(s.kind){case"evalSig":{const d=B(s.expr,t.signals,e);e.values.f64[s.target]=d,e.cache.sigValues[s.expr]=d,e.cache.sigStamps[s.expr]=e.cache.frameId;break}case"materialize":{const d=x(s.field,s.domain,t.fields,t.signals,t.domains,e,o);e.values.objects.set(s.target,d);break}case"render":{const d=t.domains.get(s.domain);if(!d)throw new Error(`Domain ${s.domain} not found`);const a=x(s.position,s.domain,t.fields,t.signals,t.domains,e,o),u=x(s.color,s.domain,t.fields,t.signals,t.domains,e,o);let p;if(s.size!==void 0){const f=t.signals.has(s.size);t.fields.has(s.size)?p=x(s.size,s.domain,t.fields,t.signals,t.domains,e,o):f?p=B(s.size,t.signals,e):p=10}else p=10;r.push({kind:"instances2d",count:d.count,position:a,color:u,size:p});break}default:{const d=s;throw new Error(`Unknown step kind: ${d.kind}`)}}return{version:1,passes:r}}function Tt(t,e,o,n){t.fillStyle="#000000",t.fillRect(0,0,o,n);for(const i of e.passes)$t(t,i,o,n)}function $t(t,e,o,n){if(e.kind==="instances2d")At(t,e,o,n);else throw new Error(`Unknown pass kind: ${e.kind}`)}function At(t,e,o,n){const i=e.position,r=e.color,s=typeof e.size=="number"?null:e.size,d=typeof e.size=="number"?e.size:3;for(let a=0;a<e.count;a++){const u=i[a*2]*o,p=i[a*2+1]*n,f=s?s[a]:d;t.fillStyle=`rgba(${r[a*4]},${r[a*4+1]},${r[a*4+2]},${r[a*4+3]/255})`,t.fillRect(u-f/2,p-f/2,f,f)}}const V=document.getElementById("log"),qt=document.getElementById("stats");function v(t,e="info"){const o=document.createElement("div");o.className=`log-${e}`,o.textContent=`[${new Date().toISOString().slice(11,19)}] ${t}`,V.appendChild(o),V.scrollTop=V.scrollHeight,console.log(`[${e}] ${t}`)}let ce=null,pe=null;function ue(t){v(`Building patch with ${t} particles...`);const e=ve(i=>{const r=i.addBlock("InfiniteTimeRoot",{periodMs:16e3}),s=i.addBlock("DomainN",{n:t,seed:42}),d=i.addBlock("FieldFromDomainId",{}),a=i.addBlock("ConstFloat",{value:.5}),u=i.addBlock("ConstFloat",{value:.5}),p=i.addBlock("ConstFloat",{value:.35}),f=i.addBlock("ConstFloat",{value:.08}),g=i.addBlock("ConstFloat",{value:3}),m=i.addBlock("FieldPulse",{}),I=i.addBlock("ConstFloat",{value:2}),F=i.addBlock("FieldGoldenAngle",{turns:50}),M=i.addBlock("FieldAngularOffset",{}),S=i.addBlock("FieldAdd",{}),P=i.addBlock("FieldRadiusSqrt",{}),E=i.addBlock("FieldPolarToCartesian",{}),C=i.addBlock("ConstFloat",{value:.012}),he=i.addBlock("ConstFloat",{value:.012}),$=i.addBlock("FieldJitter2D",{}),ge=i.addBlock("ConstFloat",{value:.85}),me=i.addBlock("ConstFloat",{value:.9}),_=i.addBlock("FieldHueFromPhase",{}),D=i.addBlock("HsvToRgb",{}),ke=i.addBlock("ConstFloat",{value:3}),we=i.addBlock("ConstFloat",{value:2}),ye=i.addBlock("ConstFloat",{value:1}),T=i.addBlock("FieldPulse",{}),R=i.addBlock("RenderInstances2D",{});i.wire(s,"domain",d,"domain"),i.wire(s,"domain",R,"domain"),i.wire(r,"phase",m,"phase"),i.wire(r,"phase",M,"phase"),i.wire(r,"phase",_,"phase"),i.wire(d,"id01",m,"id01"),i.wire(p,"out",m,"base"),i.wire(f,"out",m,"amplitude"),i.wire(g,"out",m,"spread"),i.wire(d,"id01",F,"id01"),i.wire(d,"id01",M,"id01"),i.wire(d,"id01",_,"id01"),i.wire(d,"id01",P,"id01"),i.wire(I,"out",M,"spin"),i.wire(F,"angle",S,"a"),i.wire(M,"offset",S,"b"),i.wire(a,"out",E,"centerX"),i.wire(u,"out",E,"centerY"),i.wire(m,"value",P,"radius"),i.wire(S,"out",E,"angle"),i.wire(P,"radius",E,"radius"),i.wire(E,"pos",$,"pos"),i.wire(s,"rand",$,"rand"),i.wire(C,"out",$,"amountX"),i.wire(he,"out",$,"amountY"),i.wire(_,"hue",D,"hue"),i.wire(ge,"out",D,"sat"),i.wire(me,"out",D,"val"),i.wire(r,"phase",T,"phase"),i.wire(d,"id01",T,"id01"),i.wire(ke,"out",T,"base"),i.wire(we,"out",T,"amplitude"),i.wire(ye,"out",T,"spread"),i.wire($,"pos",R,"pos"),i.wire(D,"color",R,"color"),i.wire(T,"value",R,"size")});v(`Patch built: ${e.blocks.size} blocks, ${e.edges.length} edges`);const o=ot(e);if(o.kind!=="ok")throw v(`Compile failed: ${JSON.stringify(o.errors)}`,"error"),new Error("Compile failed");const n=o.program;v(`Compiled: ${n.signals.size} signals, ${n.fields.size} fields, ${n.steps.length} steps`),ce=n,pe=gt(n.slotCount)}const W=document.getElementById("canvas"),Ct=W.getContext("2d"),Dt=new lt;ue(5e3);v("Runtime initialized");let z=0,H=performance.now(),j=0,U=0,ee=0,te=0,oe=0,O=1/0,A=0,L=0;function fe(t){try{const e=performance.now(),o=performance.now(),n=Pt(ce,pe,Dt,t);te=performance.now()-o;const i=performance.now();Tt(Ct,n,W.width,W.height),oe=performance.now()-i,ee=performance.now()-e,U=ee,O=Math.min(O,U),A=Math.max(A,U),L+=U,z++;const r=performance.now();if(r-H>500){j=Math.round(z*1e3/(r-H));const s=1e3/j,d=L/z,a=Math.max(0,Math.round((s-A)/s*100));qt.textContent=`FPS: ${j} | ${te.toFixed(1)}/${oe.toFixed(1)}ms | Min/Max: ${O.toFixed(1)}/${A.toFixed(1)}ms`,z=0,H=r,O=1/0,A=0,L=0}requestAnimationFrame(fe)}catch(e){v(`Runtime error: ${e}`,"error"),console.error(e)}}v("Starting animation loop...");requestAnimationFrame(fe);const Rt=document.getElementById("particleSlider"),zt=document.getElementById("particleCount");Rt.addEventListener("input",t=>{const e=parseInt(t.target.value);zt.textContent=e.toString(),ue(e),v(`Particle count changed to ${e}`)});
