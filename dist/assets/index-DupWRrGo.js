var ve=Object.defineProperty;var Se=(t,e,o)=>e in t?ve(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o;var y=(t,e,o)=>Se(t,typeof e!="symbol"?e+"":e,o);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const s of r.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&n(s)}).observe(document,{childList:!0,subtree:!0});function o(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=o(i);fetch(i.href,r)}})();class xe{constructor(){y(this,"blocks",new Map);y(this,"edges",[]);y(this,"nextBlockId",0);y(this,"nextEdgeId",0)}addBlock(e,o={},n){const i=`b${this.nextBlockId++}`;return this.blocks.set(i,{id:i,type:e,params:o,label:n}),i}addEdge(e,o,n){const i=`e${this.nextEdgeId++}`;return this.edges.push({id:i,from:e,to:o,enabled:(n==null?void 0:n.enabled)??!0,sortKey:n==null?void 0:n.sortKey}),this}wire(e,o,n,i,r){return this.addEdge({kind:"port",blockId:e,slotId:o},{kind:"port",blockId:n,slotId:i},r)}build(){return{blocks:new Map(this.blocks),edges:[...this.edges]}}}function Ee(t){const e=new xe;return t(e),e.build()}function Te(t){const e=[],o=new Map,n=[],i=[...t.blocks.keys()].sort();for(const s of i){if(o.has(s)){e.push({kind:"DuplicateBlockId",id:s});continue}const d=n.length;o.set(s,d),n.push(t.blocks.get(s))}const r=[];for(const s of t.edges){if(s.enabled===!1)continue;const d=o.get(s.from.blockId),a=o.get(s.to.blockId);if(d===void 0){e.push({kind:"DanglingEdge",edge:s,missing:"from"});continue}if(a===void 0){e.push({kind:"DanglingEdge",edge:s,missing:"to"});continue}r.push({fromBlock:d,fromPort:s.from.slotId,toBlock:a,toPort:s.to.slotId})}return r.sort((s,d)=>s.toBlock!==d.toBlock?s.toBlock-d.toBlock:s.toPort!==d.toPort?s.toPort.localeCompare(d.toPort):s.fromBlock!==d.fromBlock?s.fromBlock-d.fromBlock:s.fromPort.localeCompare(d.fromPort)),e.length>0?{kind:"error",errors:e}:{kind:"ok",patch:{patch:t,blockIndex:o,blocks:n,edges:r}}}var m=(t=>(t.Add="add",t.Sub="sub",t.Mul="mul",t.Div="div",t.Mod="mod",t.Neg="neg",t.Abs="abs",t.Sin="sin",t.Cos="cos",t.Tan="tan",t.Min="min",t.Max="max",t.Clamp="clamp",t.Lerp="lerp",t.Eq="eq",t.Lt="lt",t.Gt="gt",t.Wrap01="wrap01",t))(m||{});function v(){return{kind:"default"}}function Y(t){return{kind:"instantiated",value:t}}function Be(t){return t.kind==="instantiated"}function R(t,e){return t.kind==="instantiated"?t.value:e}function de(t){return{kind:"domain",id:t}}function le(){return{kind:"one"}}function Pe(t){return{kind:"many",domain:t}}function te(){return{kind:"continuous"}}function Ae(){return{kind:"unbound"}}function $e(){return{cardinality:v(),temporality:v(),binding:v(),perspective:v(),branch:v()}}function Re(t){return{cardinality:t.cardinality??v(),temporality:t.temporality??v(),binding:t.binding??v(),perspective:t.perspective??v(),branch:t.branch??v()}}function ae(t,e){return{payload:t,extent:e?Re(e):$e()}}const A={cardinality:le(),temporality:te(),binding:Ae(),perspective:"global",branch:"main"};function ce(t){return ae(t,{cardinality:Y(le()),temporality:Y(te())})}function be(t,e){return ae(t,{cardinality:Y(Pe(de(e))),temporality:Y(te())})}function De(t){const e=R(t.cardinality,A.cardinality),o=R(t.temporality,A.temporality),n=R(t.binding,A.binding),i=R(t.perspective,A.perspective);R(t.branch,A.branch);const r=qe(e),s=Ce(o),d=ze(i),a=Oe(),u=Ue(n);return{domain:r,temporality:s,perspective:d,branch:a,identity:u}}function qe(t){switch(t.kind){case"zero":return"value";case"one":return"signal";case"many":return"field"}}function Ce(t){switch(t.kind){case"continuous":return"continuous";case"discrete":return"instant"}}function ze(t){return t==="global"?"global":"frame"}function Oe(t){return"single"}function Ue(t){switch(t.kind){case"unbound":return{kind:"none"};case"weak":case"strong":case"identity":return{kind:"keyed",keySpace:"entity",keyTag:t.referent.id}}}function Ze(t){switch(t){case"float":return{kind:"number"};case"int":return{kind:"number"};case"bool":return{kind:"bool"};case"vec2":return{kind:"vec",lanes:2,element:"number"};case"color":return{kind:"vec",lanes:4,element:"number"};case"phase":return{kind:"number"};case"unit":return{kind:"number"}}}function Xe(t){return{axes:De(t.extent),shape:Ze(t.payload)}}class Ye{constructor(){y(this,"signals",new Map);y(this,"fields",new Map);y(this,"events",new Map);y(this,"domains",new Map);y(this,"steps",[]);y(this,"nextSigId",0);y(this,"nextFieldId",0);y(this,"nextEventId",0);y(this,"nextDomainId",0);y(this,"nextSlotId",0);y(this,"timeModel",{kind:"infinite"});y(this,"slotTypes",new Map);y(this,"stepToBlock",new Map);y(this,"slotToBlock",new Map);y(this,"renderOutputSlot",null)}setTimeModel(e){this.timeModel=e}allocSlot(){return this.nextSlotId++}allocTypedSlot(e,o){const n=this.nextSlotId++;return this.slotTypes.set(n,e),n}sigConst(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"const",value:e,type:o}),n}sigSlot(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"slot",slot:e,type:o}),n}sigTime(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"time",which:e,type:o}),n}sigExternal(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"external",which:e,type:o}),n}sigMap(e,o,n){const i=this.nextSigId++;return this.signals.set(i,{kind:"map",input:e,fn:o,type:n}),i}sigZip(e,o,n){const i=this.nextSigId++;return this.signals.set(i,{kind:"zip",inputs:e,fn:o,type:n}),i}sigBinOp(e,o,n,i){return this.sigZip([e,o],{kind:"opcode",opcode:n},i)}sigUnaryOp(e,o,n){return this.sigMap(e,{kind:"opcode",opcode:o},n)}fieldConst(e,o){const n=this.nextFieldId++;return this.fields.set(n,{kind:"const",value:e,type:o}),n}fieldSource(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"source",domain:e,sourceId:o,type:n}),i}fieldBroadcast(e,o){const n=this.nextFieldId++;return this.fields.set(n,{kind:"broadcast",signal:e,type:o}),n}fieldMap(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"map",input:e,fn:o,type:n}),i}fieldZip(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"zip",inputs:e,fn:o,type:n}),i}fieldZipSig(e,o,n,i){const r=this.nextFieldId++;return this.fields.set(r,{kind:"zipSig",field:e,signals:o,fn:n,type:i}),r}fieldMapIndexed(e,o,n,i){const r=this.nextFieldId++;return this.fields.set(r,{kind:"mapIndexed",domain:e,fn:o,type:n,signals:i}),r}eventPulse(){const e=this.nextEventId++;return this.events.set(e,{kind:"pulse",source:"timeRoot"}),e}eventWrap(e){const o=this.nextEventId++;return this.events.set(o,{kind:"wrap",signal:e}),o}eventCombine(e,o){const n=this.nextEventId++;return this.events.set(n,{kind:"combine",events:e,mode:o}),n}domainGrid(e,o){const n=`domain_${this.nextDomainId++}`,i=e*o,r=Array.from({length:i},(s,d)=>this.seededId(e*1e4+o+d));return this.domains.set(n,{id:n,kind:"grid",count:i,elementIds:r,params:{rows:e,cols:o}}),n}domainN(e,o=0){const n=`domain_${this.nextDomainId++}`,i=Array.from({length:e},(r,s)=>this.seededId(o*1e5+e+s));return this.domains.set(n,{id:n,kind:"n",count:e,elementIds:i,params:{n:e,seed:o}}),n}seededId(e){let o=e;return o=(o>>16^o)*73244475,o=(o>>16^o)*73244475,o=o>>16^o,Math.abs(o).toString(36).slice(0,8).padStart(8,"0")}stepEvalSig(e,o,n){const i=this.steps.length;this.steps.push({kind:"evalSig",expr:e,target:o}),n!==void 0&&(this.stepToBlock.set(i,n),this.slotToBlock.set(o,n))}stepMaterialize(e,o,n,i){const r=this.steps.length;this.steps.push({kind:"materialize",field:e,domain:o,target:n}),i!==void 0&&(this.stepToBlock.set(r,i),this.slotToBlock.set(n,i))}stepRender(e,o,n,i,r){const s=this.steps.length;this.steps.push({kind:"render",domain:e,position:o,color:n,size:i}),r!==void 0&&this.stepToBlock.set(s,r)}build(){const e={nodes:Array.from(this.signals.values())},o={nodes:Array.from(this.fields.values())},n={nodes:Array.from(this.events.values())};this.steps.find(c=>c.kind==="render")&&!this.renderOutputSlot&&(this.renderOutputSlot=this.nextSlotId++);const r=[],s=new Map([["f64",[]],["object",[]]]);for(let c=0;c<this.nextSlotId;c++){const f=c,g=f===this.renderOutputSlot?"object":"f64";s.get(g).push(f)}for(let c=0;c<this.nextSlotId;c++){const f=c,g=this.slotTypes.get(f),h=f===this.renderOutputSlot?"object":"f64",F=s.get(h).indexOf(f);let I;f===this.renderOutputSlot?I={axes:{domain:"value",temporality:"discrete",perspective:"frame",branch:"single",identity:{kind:"none"}},shape:{kind:"object",class:"RenderFrameIR"}}:g?I=Xe(g):I={axes:{domain:"signal",temporality:"continuous",perspective:"global",branch:"single",identity:{kind:"none"}},shape:{kind:"number"}},r.push({slot:f,storage:h,offset:F,type:I})}const d=this.renderOutputSlot?[{kind:"renderFrame",slot:this.renderOutputSlot}]:[],a={stepToBlock:new Map(this.stepToBlock),slotToBlock:new Map(this.slotToBlock),ports:[],slotToPort:new Map},u={timeModel:this.timeModel,steps:this.steps,domains:this.domains};return{irVersion:1,signalExprs:e,fieldExprs:o,eventExprs:n,constants:{json:[]},schedule:u,outputs:d,slotMeta:r,debugIndex:a}}getDomains(){return new Map(this.domains)}getSignals(){return new Map(this.signals)}getFields(){return new Map(this.fields)}getSlotCount(){return this.nextSlotId}}const W=new Map;function w(t){if(W.has(t.type))throw new Error(`Block type already registered: ${t.type}`);const e=new Set(t.inputs.map(n=>n.portId)),o=new Set(t.outputs.map(n=>n.portId));if(e.size!==t.inputs.length)throw new Error(`Duplicate input port IDs in block ${t.type}`);if(o.size!==t.outputs.length)throw new Error(`Duplicate output port IDs in block ${t.type}`);W.set(t.type,t)}function X(t){return W.get(t)}function p(t){return ce(t)}function l(t){return be(t,"__default__")}function pe(t="float"){return ce(t)}function _(t="__domain__"){return de(t)}const _e=({b:t,config:e})=>{t.setTimeModel({kind:"infinite",windowMs:6e4});const o=t.sigTime("t",p("float")),n=t.sigTime("dt",p("float")),i=typeof e.periodMs=="number"?e.periodMs:4e3,r=t.sigConst(i,p("float")),s=t.sigBinOp(o,r,m.Div,p("float")),d=t.sigUnaryOp(s,m.Wrap01,p("phase")),a=t.eventWrap(d),u=t.sigConst(1,p("float"));return{t:{kind:"sig",id:o,type:p("float")},dt:{kind:"sig",id:n,type:p("float")},phase:{kind:"sig",id:d,type:p("phase")},pulse:{kind:"event",id:a},energy:{kind:"sig",id:u,type:p("float")}}};w({type:"InfiniteTimeRoot",inputs:[],outputs:[{portId:"t",type:p("float")},{portId:"dt",type:p("float")},{portId:"phase",type:p("phase")},{portId:"pulse",type:pe("float")},{portId:"energy",type:p("float")}],lower:_e});const je=({b:t,config:e})=>{const o=typeof e.durationMs=="number"?e.durationMs:1e4;t.setTimeModel({kind:"finite",durationMs:o});const n=t.sigTime("t",p("float")),i=t.sigTime("dt",p("float")),r=t.sigConst(o,p("float")),s=t.sigBinOp(n,r,m.Div,p("float")),d=typeof e.periodMs=="number"?e.periodMs:0;let a,u;if(d>0){const f=t.sigConst(d,p("float")),g=t.sigBinOp(n,f,m.Div,p("float"));a=t.sigUnaryOp(g,m.Wrap01,p("phase")),u=t.eventWrap(a)}else a=s,u=t.eventPulse();const c=t.sigConst(1,p("float"));return{t:{kind:"sig",id:n,type:p("float")},dt:{kind:"sig",id:i,type:p("float")},progress:{kind:"sig",id:s,type:p("float")},phase:{kind:"sig",id:a,type:p("phase")},pulse:{kind:"event",id:u},energy:{kind:"sig",id:c,type:p("float")}}};w({type:"FiniteTimeRoot",inputs:[],outputs:[{portId:"t",type:p("float")},{portId:"dt",type:p("float")},{portId:"progress",type:p("float")},{portId:"phase",type:p("phase")},{portId:"pulse",type:pe("float")},{portId:"energy",type:p("float")}],lower:je});const Ve=({b:t,config:e})=>{const o=typeof e.value=="number"?e.value:0;return{out:{kind:"sig",id:t.sigConst(o,p("float")),type:p("float")}}};w({type:"ConstFloat",inputs:[],outputs:[{portId:"out",type:p("float")}],lower:Ve});const He=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||!n||o.kind!=="sig"||n.kind!=="sig")throw new Error("AddSignal requires two signal inputs");return{out:{kind:"sig",id:t.sigBinOp(o.id,n.id,m.Add,p("float")),type:p("float")}}};w({type:"AddSignal",inputs:[{portId:"a",type:p("float")},{portId:"b",type:p("float")}],outputs:[{portId:"out",type:p("float")}],lower:He});const Le=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||!n||o.kind!=="sig"||n.kind!=="sig")throw new Error("MulSignal requires two signal inputs");return{out:{kind:"sig",id:t.sigBinOp(o.id,n.id,m.Mul,p("float")),type:p("float")}}};w({type:"MulSignal",inputs:[{portId:"a",type:p("float")},{portId:"b",type:p("float")}],outputs:[{portId:"out",type:p("float")}],lower:Le});const Ge=({b:t,inputsById:e,config:o})=>{const n=e.phase;if(!n||n.kind!=="sig")throw new Error("Oscillator requires phase input");const i=typeof o.waveform=="string"?o.waveform:"sin",r=t.sigConst(Math.PI*2,p("float")),s=t.sigBinOp(n.id,r,m.Mul,p("float"));let d;switch(i){case"sin":d=t.sigUnaryOp(s,m.Sin,p("float"));break;case"cos":d=t.sigUnaryOp(s,m.Cos,p("float"));break;case"saw":const a=t.sigConst(2,p("float")),u=t.sigConst(1,p("float")),c=t.sigBinOp(n.id,a,m.Mul,p("float"));d=t.sigBinOp(c,u,m.Sub,p("float"));break;default:d=t.sigUnaryOp(s,m.Sin,p("float"))}return{out:{kind:"sig",id:d,type:p("float")}}};w({type:"Oscillator",inputs:[{portId:"phase",type:p("phase")}],outputs:[{portId:"out",type:p("float")}],lower:Ge});w({type:"MousePosition",inputs:[],outputs:[{portId:"x",type:p("float")},{portId:"y",type:p("float")}],lower:({b:t})=>({x:{kind:"sig",id:t.sigExternal("mouseX",p("float")),type:p("float")},y:{kind:"sig",id:t.sigExternal("mouseY",p("float")),type:p("float")}})});const Je=({b:t,config:e})=>{const o=typeof e.rows=="number"?e.rows:4,n=typeof e.cols=="number"?e.cols:4,i=t.domainGrid(o,n),r=t.fieldSource(i,"pos0",l("vec2")),s=t.fieldSource(i,"index",l("float")),d=t.fieldSource(i,"normalizedIndex",l("float")),a=t.fieldSource(i,"idRand",l("float"));return{domain:{kind:"domain",id:i},pos:{kind:"field",id:r,type:l("vec2")},index:{kind:"field",id:s,type:l("float")},normIndex:{kind:"field",id:d,type:l("float")},rand:{kind:"field",id:a,type:l("float")}}};w({type:"GridDomain",inputs:[],outputs:[{portId:"domain",type:_()},{portId:"pos",type:l("vec2")},{portId:"index",type:l("float")},{portId:"normIndex",type:l("float")},{portId:"rand",type:l("float")}],lower:Je});const Ke=({b:t,config:e})=>{const o=typeof e.n=="number"?e.n:10,n=typeof e.seed=="number"?e.seed:0,i=t.domainN(o,n),r=t.fieldSource(i,"index",l("float")),s=t.fieldSource(i,"normalizedIndex",l("float")),d=t.fieldSource(i,"idRand",l("float"));return{domain:{kind:"domain",id:i},index:{kind:"field",id:r,type:l("float")},normIndex:{kind:"field",id:s,type:l("float")},rand:{kind:"field",id:d,type:l("float")}}};w({type:"DomainN",inputs:[],outputs:[{portId:"domain",type:_()},{portId:"index",type:l("float")},{portId:"normIndex",type:l("float")},{portId:"rand",type:l("float")}],lower:Ke});const We=({b:t,inputsById:e})=>{const o=e.signal;if(!o||o.kind!=="sig")throw new Error("FieldBroadcast requires signal input");return{out:{kind:"field",id:t.fieldBroadcast(o.id,l(o.type.payload)),type:l(o.type.payload)}}};w({type:"FieldBroadcast",inputs:[{portId:"signal",type:p("float")}],outputs:[{portId:"out",type:l("float")}],lower:We});const Ne=({b:t,inputsById:e,config:o})=>{const n=e.field;if(!n||n.kind!=="field")throw new Error("FieldMap requires field input");const i=typeof o.expr=="string"?o.expr:"x";return{out:{kind:"field",id:t.fieldMap(n.id,{kind:"expr",expr:i},l(n.type.payload)),type:l(n.type.payload)}}};w({type:"FieldMap",inputs:[{portId:"field",type:l("float")}],outputs:[{portId:"out",type:l("float")}],lower:Ne});const Qe=({b:t,inputsById:e,config:o})=>{const n=e.field,i=e.signal;if(!n||n.kind!=="field")throw new Error("FieldZipSig requires field input");if(!i||i.kind!=="sig")throw new Error("FieldZipSig requires signal input");const r=typeof o.op=="string"?o.op:"mul";let s;switch(r){case"add":s=m.Add;break;case"sub":s=m.Sub;break;case"mul":s=m.Mul;break;case"div":s=m.Div;break;default:s=m.Mul}return{out:{kind:"field",id:t.fieldZipSig(n.id,[i.id],{kind:"opcode",opcode:s},l("float")),type:l("float")}}};w({type:"FieldZipSig",inputs:[{portId:"field",type:l("float")},{portId:"signal",type:p("float")}],outputs:[{portId:"out",type:l("float")}],lower:Qe});const et=({b:t,inputsById:e})=>{const o=e.domain;if(!o||o.kind!=="domain")throw new Error("FieldFromDomainId requires domain input");return{id01:{kind:"field",id:t.fieldSource(o.id,"normalizedIndex",l("float")),type:l("float")}}};w({type:"FieldFromDomainId",inputs:[{portId:"domain",type:_()}],outputs:[{portId:"id01",type:l("float")}],lower:et});const tt=({b:t,inputsById:e})=>{const o=e.phase,n=e.id01,i=e.base,r=e.amplitude,s=e.spread;if(!o||o.kind!=="sig")throw new Error("FieldPulse requires phase (signal) input");if(!n||n.kind!=="field")throw new Error("FieldPulse requires id01 (field) input");if(!i||i.kind!=="sig")throw new Error("FieldPulse requires base (signal) input");if(!r||r.kind!=="sig")throw new Error("FieldPulse requires amplitude (signal) input");if(!s||s.kind!=="sig")throw new Error("FieldPulse requires spread (signal) input");const d=t.fieldBroadcast(s.id,l("float")),a=t.fieldZip([n.id,d],{kind:"opcode",opcode:m.Mul},l("float")),u=t.fieldBroadcast(o.id,l("float")),c=t.fieldZip([u,a],{kind:"opcode",opcode:m.Add},l("float")),f=t.sigConst(Math.PI*2,p("float")),g=t.fieldBroadcast(f,l("float")),h=t.fieldZip([c,g],{kind:"opcode",opcode:m.Mul},l("float")),k=t.fieldMap(h,{kind:"opcode",opcode:m.Sin},l("float")),F=t.fieldBroadcast(r.id,l("float")),I=t.fieldZip([k,F],{kind:"opcode",opcode:m.Mul},l("float")),M=t.fieldBroadcast(i.id,l("float"));return{value:{kind:"field",id:t.fieldZip([M,I],{kind:"opcode",opcode:m.Add},l("float")),type:l("float")}}};w({type:"FieldPulse",inputs:[{portId:"phase",type:p("phase")},{portId:"id01",type:l("float")},{portId:"base",type:p("float")},{portId:"amplitude",type:p("float")},{portId:"spread",type:p("float")}],outputs:[{portId:"value",type:l("float")}],lower:tt});const ot=({b:t,inputsById:e,config:o})=>{const n=e.id01;if(!n||n.kind!=="field")throw new Error("FieldGoldenAngle requires id01 (field) input");const i=2.399963229728653,r=typeof o.turns=="number"?o.turns:50,s=t.sigConst(i*r,p("float")),d=t.fieldBroadcast(s,l("float"));return{angle:{kind:"field",id:t.fieldZip([n.id,d],{kind:"opcode",opcode:m.Mul},l("float")),type:l("float")}}};w({type:"FieldGoldenAngle",inputs:[{portId:"id01",type:l("float")}],outputs:[{portId:"angle",type:l("float")}],lower:ot});const nt=({b:t,inputsById:e})=>{const o=e.phase,n=e.spin,i=e.id01;if(!o||o.kind!=="sig")throw new Error("FieldAngularOffset requires phase (signal) input");if(!n||n.kind!=="sig")throw new Error("FieldAngularOffset requires spin (signal) input");if(!i||i.kind!=="field")throw new Error("FieldAngularOffset requires id01 (field) input");const r=t.sigConst(2,p("float")),s=t.fieldBroadcast(r,l("float")),d=t.fieldZip([s,i.id],{kind:"opcode",opcode:m.Sub},l("float")),a=t.sigConst(Math.PI*2,p("float")),u=t.sigBinOp(o.id,a,m.Mul,p("float")),c=t.sigBinOp(u,n.id,m.Mul,p("float")),f=t.fieldBroadcast(c,l("float"));return{offset:{kind:"field",id:t.fieldZip([f,d],{kind:"opcode",opcode:m.Mul},l("float")),type:l("float")}}};w({type:"FieldAngularOffset",inputs:[{portId:"phase",type:p("phase")},{portId:"spin",type:p("float")},{portId:"id01",type:l("float")}],outputs:[{portId:"offset",type:l("float")}],lower:nt});const it=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||o.kind!=="field")throw new Error("FieldAdd requires a (field) input");if(!n||n.kind!=="field")throw new Error("FieldAdd requires b (field) input");return{out:{kind:"field",id:t.fieldZip([o.id,n.id],{kind:"opcode",opcode:m.Add},l("float")),type:l("float")}}};w({type:"FieldAdd",inputs:[{portId:"a",type:l("float")},{portId:"b",type:l("float")}],outputs:[{portId:"out",type:l("float")}],lower:it});const rt=({b:t,inputsById:e})=>{const o=e.radius,n=e.id01;if(!o||o.kind!=="sig"&&o.kind!=="field")throw new Error("FieldRadiusSqrt requires radius (signal or field) input");if(!n||n.kind!=="field")throw new Error("FieldRadiusSqrt requires id01 (field) input");const i=t.fieldMap(n.id,{kind:"kernel",name:"sqrt"},l("float")),r=o.kind==="sig"?t.fieldBroadcast(o.id,l("float")):o.id;return{radius:{kind:"field",id:t.fieldZip([r,i],{kind:"opcode",opcode:m.Mul},l("float")),type:l("float")}}};w({type:"FieldRadiusSqrt",inputs:[{portId:"radius",type:l("float")},{portId:"id01",type:l("float")}],outputs:[{portId:"radius",type:l("float")}],lower:rt});const st=({b:t,inputsById:e})=>{const o=e.centerX,n=e.centerY,i=e.radius,r=e.angle;if(!o||o.kind!=="sig")throw new Error("FieldPolarToCartesian requires centerX (signal) input");if(!n||n.kind!=="sig")throw new Error("FieldPolarToCartesian requires centerY (signal) input");if(!i||i.kind!=="field")throw new Error("FieldPolarToCartesian requires radius (field) input");if(!r||r.kind!=="field")throw new Error("FieldPolarToCartesian requires angle (field) input");const s=t.fieldMap(r.id,{kind:"opcode",opcode:m.Cos},l("float")),d=t.fieldMap(r.id,{kind:"opcode",opcode:m.Sin},l("float")),a=t.fieldZip([i.id,s],{kind:"opcode",opcode:m.Mul},l("float")),u=t.fieldBroadcast(o.id,l("float")),c=t.fieldZip([u,a],{kind:"opcode",opcode:m.Add},l("float")),f=t.fieldZip([i.id,d],{kind:"opcode",opcode:m.Mul},l("float")),g=t.fieldBroadcast(n.id,l("float")),h=t.fieldZip([g,f],{kind:"opcode",opcode:m.Add},l("float"));return{pos:{kind:"field",id:t.fieldZip([c,h],{kind:"kernel",name:"makeVec2"},l("vec2")),type:l("vec2")}}};w({type:"FieldPolarToCartesian",inputs:[{portId:"centerX",type:p("float")},{portId:"centerY",type:p("float")},{portId:"radius",type:l("float")},{portId:"angle",type:l("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:st});const dt=({b:t,inputsById:e})=>{const o=e.phase,n=e.id01;if(!o||o.kind!=="sig")throw new Error("FieldHueFromPhase requires phase (signal) input");if(!n||n.kind!=="field")throw new Error("FieldHueFromPhase requires id01 (field) input");const i=t.fieldBroadcast(o.id,l("float")),r=t.fieldZip([i,n.id],{kind:"opcode",opcode:m.Add},l("float"));return{hue:{kind:"field",id:t.fieldMap(r,{kind:"opcode",opcode:m.Wrap01},l("float")),type:l("float")}}};w({type:"FieldHueFromPhase",inputs:[{portId:"phase",type:p("phase")},{portId:"id01",type:l("float")}],outputs:[{portId:"hue",type:l("float")}],lower:dt});const lt=({b:t,inputsById:e})=>{const o=e.hue,n=e.sat,i=e.val;if(!o||o.kind!=="field")throw new Error("HsvToRgb requires hue (field) input");if(!n||n.kind!=="sig")throw new Error("HsvToRgb requires sat (signal) input");if(!i||i.kind!=="sig")throw new Error("HsvToRgb requires val (signal) input");const r=t.fieldBroadcast(n.id,l("float")),s=t.fieldBroadcast(i.id,l("float"));return{color:{kind:"field",id:t.fieldZip([o.id,r,s],{kind:"kernel",name:"hsvToRgb"},l("color")),type:l("color")}}};w({type:"HsvToRgb",inputs:[{portId:"hue",type:l("float")},{portId:"sat",type:p("float")},{portId:"val",type:p("float")}],outputs:[{portId:"color",type:l("color")}],lower:lt});const at=({b:t,inputsById:e})=>{const o=e.domain,n=e.pos,i=e.color,r=e.size,s=e.opacity;if(!o||o.kind!=="domain")throw new Error("RenderInstances2D requires domain input");if(!n||n.kind!=="field")throw new Error("RenderInstances2D requires pos (field<vec2>) input");if(!i||i.kind!=="field")throw new Error("RenderInstances2D requires color (field<color>) input");let d;r&&(r.kind==="sig"||r.kind==="field")&&(d=r.id);let a;s&&s.kind==="sig"&&(a=s.id);let u=i.id;return a&&(u=t.fieldZipSig(i.id,[a],{kind:"kernel",name:"applyOpacity"},l("color"))),t.stepRender(o.id,n.id,u,d),{}};w({type:"RenderInstances2D",inputs:[{portId:"domain",type:_()},{portId:"pos",type:l("vec2")},{portId:"color",type:l("color")},{portId:"size",type:l("float"),optional:!0},{portId:"opacity",type:p("float"),optional:!0}],outputs:[],lower:at});const ct=({b:t,inputsById:e})=>{const o=e.pos,n=e.rand,i=e.amountX,r=e.amountY;if(!o||o.kind!=="field")throw new Error("FieldJitter2D requires pos (field<vec2>) input");if(!n||n.kind!=="field")throw new Error("FieldJitter2D requires rand (field<float>) input");if(!i||i.kind!=="sig")throw new Error("FieldJitter2D requires amountX (signal) input");if(!r||r.kind!=="sig")throw new Error("FieldJitter2D requires amountY (signal) input");const s=t.fieldBroadcast(i.id,l("float")),d=t.fieldBroadcast(r.id,l("float"));return{pos:{kind:"field",id:t.fieldZip([o.id,n.id,s,d],{kind:"kernel",name:"jitter2d"},l("vec2")),type:l("vec2")}}};w({type:"FieldJitter2D",inputs:[{portId:"pos",type:l("vec2")},{portId:"rand",type:l("float")},{portId:"amountX",type:p("float")},{portId:"amountY",type:p("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:ct});w({type:"FieldAttract2D",inputs:[{portId:"pos",type:l("vec2")},{portId:"targetX",type:p("float")},{portId:"targetY",type:p("float")},{portId:"phase",type:p("phase")},{portId:"strength",type:p("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:({b:t,inputsById:e})=>{const o=e.pos,n=e.targetX,i=e.targetY,r=e.phase,s=e.strength,d=t.fieldBroadcast(n.id,l("float")),a=t.fieldBroadcast(i.id,l("float")),u=t.fieldBroadcast(r.id,l("float")),c=t.fieldBroadcast(s.id,l("float"));return{pos:{kind:"field",id:t.fieldZip([o.id,d,a,u,c],{kind:"kernel",name:"attract2d"},l("vec2")),type:l("vec2")}}}});function pt(t){const e=[];for(const o of t.edges){const n=t.blocks[o.fromBlock],i=t.blocks[o.toBlock],r=X(n.type),s=X(i.type);if(!r||!s)continue;const d=r.outputs.find(c=>c.portId===o.fromPort),a=s.inputs.find(c=>c.portId===o.toPort);if(!d){e.push({kind:"UnknownPort",message:`Source block '${n.type}' does not have output port '${o.fromPort}'`,blockId:n.id,portId:o.fromPort});continue}if(!a){e.push({kind:"UnknownPort",message:`Target block '${i.type}' does not have input port '${o.toPort}'`,blockId:i.id,portId:o.toPort});continue}if(ut(d.type,a.type)===null){const c=oe(d.type),f=oe(a.type);e.push({kind:"TypeMismatch",message:`Cannot connect ${c} to ${f} (${n.type}.${o.fromPort} â†’ ${i.type}.${o.toPort})`,blockId:n.id,portId:o.fromPort})}}for(const o of t.blocks){const n=X(o.type);if(n)for(const i of n.inputs){if(i.optional)continue;!t.edges.some(s=>s.toBlock===t.blocks.indexOf(o)&&s.toPort===i.portId)&&!i.defaultValue&&e.push({kind:"MissingRequiredInput",message:`Block '${o.type}' is missing required input '${i.portId}'`,blockId:o.id,portId:i.portId})}}return e}function D(t){return"kind"in t&&t.kind==="domain"}function N(t){const e=t.extent.cardinality;return Be(e)?e.value:A.cardinality}function Q(t){return t.kind==="zero"?"zero":t.kind==="one"?"one":"many"}function ut(t,e){if(D(t)||D(e))return D(t)&&D(e)?{kind:"direct"}:null;const o=t,n=e,i=Q(N(o)),r=Q(N(n));return i===r&&o.payload===n.payload?{kind:"direct"}:o.payload!==n.payload?null:i==="zero"&&r==="one"?{kind:"promote",from:"zero",to:"one"}:i==="one"&&r==="many"?{kind:"broadcast"}:i==="zero"&&r==="many"?{kind:"promote-broadcast"}:null}function oe(t){if(D(t))return`domain:${t.id}`;const e=t;return`${Q(N(e))}:${e.payload}`}function ft(t){const e=[],o=Te(t);if(o.kind==="error")return{kind:"error",errors:o.errors.map(c=>({kind:c.kind,message:ht(c)}))};const n=o.patch,i=gt(n);i.kind==="error"&&e.push(...i.errors);const r=pt(n);if(r.length>0&&e.push(...r),e.length>0)return{kind:"error",errors:e};const s=mt(n),d=new Ye,a=new Map;for(const c of s){const f=n.blocks[c],g=X(f.type);if(!g){e.push({kind:"UnknownBlockType",message:`Unknown block type: ${f.type}`,blockId:f.id});continue}const h=kt(n,c,a);try{const k=g.lower({b:d,config:f.params,inputsById:h});a.set(c,k)}catch(k){e.push({kind:"LoweringError",message:k instanceof Error?k.message:String(k),blockId:f.id})}}return e.length>0?{kind:"error",errors:e}:{kind:"ok",program:d.build()}}function ht(t){switch(t.kind){case"DanglingEdge":return"Edge references non-existent block";case"DuplicateBlockId":return"Duplicate block ID";default:return t.kind}}function gt(t){const e=[];for(let o=0;o<t.blocks.length;o++){const n=t.blocks[o];(n.type==="InfiniteTimeRoot"||n.type==="FiniteTimeRoot"||n.type==="TimeRoot")&&e.push(o)}return e.length===0?{kind:"error",errors:[{kind:"NoTimeRoot",message:"No TimeRoot block found. Every patch needs exactly one."}]}:e.length>1?{kind:"error",errors:[{kind:"MultipleTimeRoots",message:`Found ${e.length} TimeRoot blocks. Only one allowed.`}]}:{kind:"ok",blockIdx:e[0]}}function mt(t){const e=new Map,o=new Map;for(let r=0;r<t.blocks.length;r++)e.set(r,new Set),o.set(r,new Set);for(const r of t.edges)e.get(r.toBlock).add(r.fromBlock),o.get(r.fromBlock).add(r.toBlock);const n=[],i=[];for(let r=0;r<t.blocks.length;r++)e.get(r).size===0&&i.push(r);for(;i.length>0;){const r=i.shift();n.push(r);for(const s of o.get(r))e.get(s).delete(r),e.get(s).size===0&&i.push(s)}if(n.length!==t.blocks.length){const r=new Set;for(let d=0;d<t.blocks.length;d++)n.includes(d)||r.add(d);const s=[...r].map(d=>t.blocks[d].id);throw new Error(`Dependency cycle detected involving blocks: ${s.join(", ")}`)}return n}function kt(t,e,o){const n={};for(const i of t.edges)if(i.toBlock===e){const r=o.get(i.fromBlock);if(r){const s=i.fromPort;n[i.toPort]=r[s]}}return n}function wt(t){switch(t){case"float":case"int":case"bool":case"unit":case"phase":return"f32";case"vec2":return"vec2f32";case"color":return"rgba8"}}class yt{constructor(){y(this,"pools",new Map);y(this,"inUse",new Map);y(this,"maxPoolSize",100)}alloc(e,o){const n=`${e}:${o}`;this.pools.size>this.maxPoolSize&&this.trimPools();const i=this.pools.get(n)??[];if(i.length>0){const s=i.pop();return this.trackInUse(n,s),s}const r=It(e,o);return this.trackInUse(n,r),r}releaseAll(){for(const[e,o]of this.inUse){const n=this.pools.get(e)??[];n.push(...o),this.pools.set(e,n)}this.inUse.clear()}trackInUse(e,o){const n=this.inUse.get(e)??[];n.push(o),this.inUse.set(e,n)}getStats(){let e=0;for(const n of this.pools.values())e+=n.length;let o=0;for(const n of this.inUse.values())o+=n.length;return{pooled:e,inUse:o,poolKeys:this.pools.size}}trimPools(){const e=new Set(this.inUse.keys());for(const[o,n]of this.pools)!e.has(o)&&n.length>0&&this.pools.delete(o)}clearUnusedPools(){for(const[e,o]of this.pools)this.inUse.has(e)||this.pools.delete(e)}}function It(t,e){switch(t){case"f32":return new Float32Array(e);case"vec2f32":return new Float32Array(e*2);case"rgba8":return new Uint8ClampedArray(e*4);default:{const o=t;throw new Error(`Unknown buffer format: ${String(o)}`)}}}function Ft(){return{prevTAbsMs:null,prevTModelMs:null,wrapCount:0}}function Mt(t,e,o){const n=o.prevTAbsMs!==null?t-o.prevTAbsMs:0;switch(o.prevTAbsMs=t,e.kind){case"finite":{const i=Math.max(0,Math.min(t,e.durationMs)),r=e.durationMs>0?i/e.durationMs:0;return{tAbsMs:t,tModelMs:i,dt:n,progress:r}}case"cyclic":{const i=e.periodMs,r=(t%i+i)%i,s=i>0?r/i:0;let d=0;o.prevTModelMs!==null&&r<o.prevTModelMs&&(d=1,o.wrapCount++),o.prevTModelMs=r;const a=o.wrapCount;return{tAbsMs:t,tModelMs:r,dt:n,phase:s,pulse:d,energy:a}}case"infinite":return{tAbsMs:t,tModelMs:t,dt:n};default:{const i=e;throw new Error(`Unknown time model: ${String(i)}`)}}}function vt(t){return{f64:new Float64Array(t),objects:new Map}}function St(t=1e3,e=1e3){return{frameId:0,sigValues:new Float64Array(t),sigStamps:new Uint32Array(t),fieldBuffers:new Map,fieldStamps:new Map}}function xt(){return{mouseX:.5,mouseY:.5,mouseOver:!1,smoothX:.5,smoothY:.5}}function Et(t){return{values:vt(t),cache:St(),timeState:Ft(),time:null,external:xt()}}function j(t,e){return e.length===1?ue(t,e[0]):Tt(t,e)}function ue(t,e){switch(t){case"neg":return-e;case"abs":return Math.abs(e);case"sin":return Math.sin(e);case"cos":return Math.cos(e);case"tan":return Math.tan(e);case"wrap01":return(e%1+1)%1;default:throw new Error(`OpCode ${t} is not unary`)}}function Tt(t,e){switch(t){case"add":return e.reduce((o,n)=>o+n,0);case"sub":return e.length>=2?e[0]-e[1]:-e[0];case"mul":return e.reduce((o,n)=>o*n,1);case"div":return e.length>=2?e[0]/e[1]:1/e[0];case"mod":return e.length>=2?e[0]%e[1]:0;case"min":return Math.min(...e);case"max":return Math.max(...e);case"clamp":return e.length>=3?Math.max(e[1],Math.min(e[2],e[0])):e[0];case"lerp":return e.length>=3?e[0]*(1-e[2])+e[1]*e[2]:e[0];default:if(e.length===1)return ue(t,e[0]);throw new Error(`OpCode ${t} not implemented for ${e.length} args`)}}function B(t,e,o){const n=o.cache.sigValues[t];if(o.cache.sigStamps[t]===o.cache.frameId)return n;const r=e[t];if(!r)throw new Error(`Signal expression ${t} not found`);const s=Bt(r,e,o);return o.cache.sigValues[t]=s,o.cache.sigStamps[t]=o.cache.frameId,s}function Bt(t,e,o){if(!o.time)throw new Error("Effective time not set");switch(t.kind){case"const":return typeof t.value=="number"?t.value:0;case"slot":return o.values.f64[t.slot];case"time":{const n=t;switch(n.which){case"t":return o.time.tModelMs;case"dt":return o.time.dt;case"phase":return o.time.phase??0;case"pulse":return o.time.pulse??0;case"energy":return o.time.energy??0;default:{const i=n.which;throw new Error(`Unknown time signal: ${String(i)}`)}}}case"external":{const n=t;if(n.which==="mouseX")return o.external.smoothX;if(n.which==="mouseY")return o.external.smoothY;if(n.which==="mouseOver")return o.external.mouseOver?1:0;throw new Error(`Unknown external signal: ${n.which}`)}case"map":{const n=B(t.input,e,o);return ne(t.fn,[n])}case"zip":{const n=t.inputs.map(i=>B(i,e,o));return ne(t.fn,n)}default:{const n=t;throw new Error(`Unknown signal expr kind: ${n.kind}`)}}}function ne(t,e){if(t.kind==="opcode")return j(t.opcode,e);throw new Error(`PureFn kind ${t.kind} not implemented`)}function T(t,e,o,n,i,r,s){const d=`${t}:${e}`,a=r.cache.fieldBuffers.get(d),u=r.cache.fieldStamps.get(d);if(a&&u===r.cache.frameId)return a;const c=o[t];if(!c)throw new Error(`Field expression ${t} not found`);const f=i.get(e);if(!f)throw new Error(`Domain ${e} not found`);const g=wt(c.type.payload),h=s.alloc(g,f.count);return Pt(c,h,f,o,n,i,r,s),r.cache.fieldBuffers.set(d,h),r.cache.fieldStamps.set(d,r.cache.frameId),h}function Pt(t,e,o,n,i,r,s,d){var u;const a=o.count;switch(t.kind){case"const":{const c=e,f=typeof t.value=="number"?t.value:0;if(t.type.payload==="color"){const g=e;for(let h=0;h<a;h++)g[h*4+0]=255,g[h*4+1]=255,g[h*4+2]=255,g[h*4+3]=255}else if(t.type.payload==="vec2"){const g=e;for(let h=0;h<a;h++)g[h*2+0]=f,g[h*2+1]=f}else for(let g=0;g<a;g++)c[g]=f;break}case"source":{At(t.sourceId,e,o);break}case"broadcast":{const c=B(t.signal,i,s),f=e;for(let g=0;g<a;g++)f[g]=c;break}case"map":{const c=T(t.input,o.id,n,i,r,s,d);$t(e,c,t.fn,a,t.type);break}case"zip":{const c=t.inputs.map(f=>T(f,o.id,n,i,r,s,d));Rt(e,c,t.fn,a,t.type);break}case"zipSig":{const c=T(t.field,o.id,n,i,r,s,d),f=t.signals.map(g=>B(g,i,s));bt(e,c,f,t.fn,a,t.type);break}case"mapIndexed":{const c=((u=t.signals)==null?void 0:u.map(f=>B(f,i,s)))??[];Dt(e,t.fn,c,a,o,t.type);break}default:{const c=t;throw new Error(`Unknown field expr kind: ${c.kind}`)}}}function At(t,e,o){const n=o.count;switch(t){case"index":{const i=e;for(let r=0;r<n;r++)i[r]=r;break}case"normalizedIndex":{const i=e;for(let r=0;r<n;r++)i[r]=n>1?r/(n-1):0;break}case"pos0":{if(o.kind==="grid"){const i=o.params.rows||1,r=o.params.cols||1,s=e;for(let d=0;d<n;d++){const a=Math.floor(d/r),u=d%r;s[d*2+0]=r>1?u/(r-1):.5,s[d*2+1]=i>1?a/(i-1):.5}}else{const i=e;for(let r=0;r<n;r++)i[r*2+0]=0,i[r*2+1]=0}break}case"idRand":{const i=e;for(let r=0;r<n;r++){const s=o.elementIds[r]||String(r);i[r]=Ot(s)}break}default:{const i=t;throw new Error(`Unknown source ID: ${String(i)}`)}}}function $t(t,e,o,n,i){const r=t,s=e;if(o.kind==="opcode"){const d=o.opcode;for(let a=0;a<n;a++)r[a]=j(d,[s[a]])}else if(o.kind==="kernel")switch(o.name){case"sqrt":for(let d=0;d<n;d++)r[d]=Math.sqrt(s[d]);break;case"floor":for(let d=0;d<n;d++)r[d]=Math.floor(s[d]);break;case"ceil":for(let d=0;d<n;d++)r[d]=Math.ceil(s[d]);break;case"round":for(let d=0;d<n;d++)r[d]=Math.round(s[d]);break;default:throw new Error(`Unknown map kernel: ${o.name}`)}else throw new Error(`Map function kind ${o.kind} not implemented`)}function Rt(t,e,o,n,i){if(o.kind==="opcode"){const r=t,s=e.map(a=>a),d=o.opcode;for(let a=0;a<n;a++){const u=s.map(c=>c[a]);r[a]=j(d,u)}}else if(o.kind==="kernel")qt(t,e,o.name,n);else throw new Error(`Zip function kind ${o.kind} not implemented`)}function bt(t,e,o,n,i,r){const s=t,d=e;if(n.kind==="opcode"){const a=n.opcode;for(let u=0;u<i;u++){const c=[d[u],...o];s[u]=j(a,c)}}else if(n.kind==="kernel")Ct(t,e,o,n.name,i);else throw new Error(`ZipSig function kind ${n.kind} not implemented`)}function Dt(t,e,o,n,i,r){const s=t;if(e.kind==="kernel")if(e.name==="gridPos"){const d=i.params.rows||1,a=i.params.cols||1;for(let u=0;u<n;u++){const c=Math.floor(u/a),f=u%a;s[u*2+0]=a>1?f/(a-1):.5,s[u*2+1]=d>1?c/(d-1):.5}}else throw new Error(`Unknown kernel function: ${e.name}`);else throw new Error(`MapIndexed function kind ${e.kind} not implemented`)}function qt(t,e,o,n,i){if(o==="makeVec2"){if(e.length!==2)throw new Error("makeVec2 requires exactly 2 inputs");const r=t,s=e[0],d=e[1];for(let a=0;a<n;a++)r[a*2+0]=s[a],r[a*2+1]=d[a]}else if(o==="hsvToRgb"){if(e.length!==3)throw new Error("hsvToRgb requires exactly 3 inputs (h, s, v)");const r=t,s=e[0],d=e[1],a=e[2];for(let u=0;u<n;u++){const[c,f,g]=zt(s[u],d[u],a[u]);r[u*4+0]=c,r[u*4+1]=f,r[u*4+2]=g,r[u*4+3]=255}}else if(o==="jitter2d"){if(e.length!==4)throw new Error("jitter2d requires exactly 4 inputs (pos, rand, amountX, amountY)");const r=t,s=e[0],d=e[1],a=e[2],u=e[3];for(let c=0;c<n;c++){const f=d[c],g=Math.sin(f*12.9898+78.233)*43758.5453,h=Math.sin(f*93.9898+67.345)*24571.2341,k=((g-Math.floor(g))*2-1)*a[c],F=((h-Math.floor(h))*2-1)*u[c];r[c*2+0]=s[c*2+0]+k,r[c*2+1]=s[c*2+1]+F}}else if(o==="attract2d"){if(e.length!==5)throw new Error("attract2d requires 5 inputs (pos, targetX, targetY, phase, strength)");const r=t,s=e[0],d=e[1],a=e[2],u=e[3],c=e[4];for(let f=0;f<n;f++){const g=s[f*2+0],h=s[f*2+1],k=d[f],F=a[f],I=u[f],M=c[f],S=k-g,x=F-h,q=I*M;r[f*2+0]=g+S*q,r[f*2+1]=h+x*q}}else throw new Error(`Unknown kernel function: ${o}`)}function Ct(t,e,o,n,i,r){if(n==="applyOpacity"){if(o.length!==1)throw new Error("applyOpacity requires exactly 1 signal (opacity)");const s=t,d=e,a=Math.max(0,Math.min(1,o[0])),u=Math.round(a*255);for(let c=0;c<i;c++)s[c*4+0]=d[c*4+0],s[c*4+1]=d[c*4+1],s[c*4+2]=d[c*4+2],s[c*4+3]=u}else throw new Error(`Unknown zipSig kernel function: ${n}`)}function zt(t,e,o){t=(t%1+1)%1,e=Math.max(0,Math.min(1,e)),o=Math.max(0,Math.min(1,o));const n=o*e,i=n*(1-Math.abs(t*6%2-1)),r=o-n;let s,d,a;const u=t*6;return u<1?[s,d,a]=[n,i,0]:u<2?[s,d,a]=[i,n,0]:u<3?[s,d,a]=[0,n,i]:u<4?[s,d,a]=[0,i,n]:u<5?[s,d,a]=[i,0,n]:[s,d,a]=[n,0,i],[Math.round((s+r)*255),Math.round((d+r)*255),Math.round((a+r)*255)]}function Ot(t){let e=0;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n)|0;e=Math.imul(e,1540483477),e^=e>>>15;const o=(e*12.9898+78.233)*43758.5453;return o-Math.floor(o)}function H(t,e){const o=t.slotMeta.find(n=>n.slot===e);if(!o)throw new Error(`Slot ${e} not found in slotMeta`);return{storage:o.storage,offset:o.offset,slot:e}}function Ut(t,e,o,n){const i=t.schedule,r=i.timeModel||{kind:"infinite"},s=i.domains||new Map,d=i.steps||[];e.cache.frameId++;const a=Mt(n,r,e.timeState);e.time=a;const u=[],c=t.signalExprs.nodes,f=t.fieldExprs.nodes;for(const h of d)switch(h.kind){case"evalSig":{const k=B(h.expr,c,e),{storage:F,offset:I}=H(t,h.target);if(F==="f64")e.values.f64[I]=k;else throw new Error(`evalSig expects f64 storage, got ${F}`);e.cache.sigValues[h.expr]=k,e.cache.sigStamps[h.expr]=e.cache.frameId;break}case"materialize":{const k=T(h.field,h.domain,f,c,s,e,o),{storage:F,slot:I}=H(t,h.target);if(F==="object")e.values.objects.set(I,k);else throw new Error(`materialize expects object storage, got ${F}`);break}case"render":{const k=s.get(h.domain);if(!k)throw new Error(`Domain ${h.domain} not found`);const F=T(h.position,h.domain,f,c,s,e,o),I=T(h.color,h.domain,f,c,s,e,o);let M;if(h.size!==void 0){const S=h.size<c.length;h.size<f.length?M=T(h.size,h.domain,f,c,s,e,o):S?M=B(h.size,c,e):M=10}else M=10;u.push({kind:"instances2d",count:k.count,position:F,color:I,size:M});break}default:{const k=h;throw new Error(`Unknown step kind: ${k.kind}`)}}const g={version:1,passes:u};if(t.outputs.length>0){const h=t.outputs[0],{storage:k,slot:F}=H(t,h.slot);if(k==="object")e.values.objects.set(F,g);else throw new Error(`Output slot expects object storage, got ${k}`);const I=e.values.objects.get(F);if(!I)throw new Error("Output frame not found in slot");return I}return g}function Zt(t,e,o,n){t.fillStyle="#000000",t.fillRect(0,0,o,n);for(const i of e.passes)Xt(t,i,o,n)}function Xt(t,e,o,n){if(e.kind==="instances2d")Yt(t,e,o,n);else throw new Error(`Unknown pass kind: ${e.kind}`)}function Yt(t,e,o,n){const i=e.position,r=e.color,s=typeof e.size=="number"?null:e.size,d=typeof e.size=="number"?e.size:3;for(let a=0;a<e.count;a++){const u=i[a*2]*o,c=i[a*2+1]*n,f=s?s[a]:d;t.fillStyle=`rgba(${r[a*4]},${r[a*4+1]},${r[a*4+2]},${r[a*4+3]/255})`,t.fillRect(u-f/2,c-f/2,f,f)}}const L=document.getElementById("log"),_t=document.getElementById("stats");function E(t,e="info"){const o=document.createElement("div");o.className=`log-${e}`,o.textContent=`[${new Date().toISOString().slice(11,19)}] ${t}`,L.appendChild(o),L.scrollTop=L.scrollHeight,console.log(`[${e}] ${t}`)}let fe=null,he=null;function ge(t){E(`Building patch with ${t} particles...`);const e=Ee(i=>{const r=i.addBlock("InfiniteTimeRoot",{periodMs:16e3}),s=i.addBlock("DomainN",{n:t,seed:42}),d=i.addBlock("FieldFromDomainId",{}),a=i.addBlock("ConstFloat",{value:.5}),u=i.addBlock("ConstFloat",{value:.5}),c=i.addBlock("ConstFloat",{value:.35}),f=i.addBlock("ConstFloat",{value:.08}),g=i.addBlock("ConstFloat",{value:3}),h=i.addBlock("FieldPulse",{}),k=i.addBlock("ConstFloat",{value:2}),F=i.addBlock("FieldGoldenAngle",{turns:50}),I=i.addBlock("FieldAngularOffset",{}),M=i.addBlock("FieldAdd",{}),S=i.addBlock("FieldRadiusSqrt",{}),x=i.addBlock("FieldPolarToCartesian",{}),q=i.addBlock("ConstFloat",{value:.012}),ke=i.addBlock("ConstFloat",{value:.012}),$=i.addBlock("FieldJitter2D",{}),we=i.addBlock("ConstFloat",{value:.85}),ye=i.addBlock("ConstFloat",{value:.9}),V=i.addBlock("FieldHueFromPhase",{}),C=i.addBlock("HsvToRgb",{}),Ie=i.addBlock("ConstFloat",{value:3}),Fe=i.addBlock("ConstFloat",{value:2}),Me=i.addBlock("ConstFloat",{value:1}),P=i.addBlock("FieldPulse",{}),z=i.addBlock("RenderInstances2D",{});i.wire(s,"domain",d,"domain"),i.wire(s,"domain",z,"domain"),i.wire(r,"phase",h,"phase"),i.wire(r,"phase",I,"phase"),i.wire(r,"phase",V,"phase"),i.wire(d,"id01",h,"id01"),i.wire(c,"out",h,"base"),i.wire(f,"out",h,"amplitude"),i.wire(g,"out",h,"spread"),i.wire(d,"id01",F,"id01"),i.wire(d,"id01",I,"id01"),i.wire(d,"id01",V,"id01"),i.wire(d,"id01",S,"id01"),i.wire(k,"out",I,"spin"),i.wire(F,"angle",M,"a"),i.wire(I,"offset",M,"b"),i.wire(a,"out",x,"centerX"),i.wire(u,"out",x,"centerY"),i.wire(h,"value",S,"radius"),i.wire(M,"out",x,"angle"),i.wire(S,"radius",x,"radius"),i.wire(x,"pos",$,"pos"),i.wire(s,"rand",$,"rand"),i.wire(q,"out",$,"amountX"),i.wire(ke,"out",$,"amountY"),i.wire(V,"hue",C,"hue"),i.wire(we,"out",C,"sat"),i.wire(ye,"out",C,"val"),i.wire(r,"phase",P,"phase"),i.wire(d,"id01",P,"id01"),i.wire(Ie,"out",P,"base"),i.wire(Fe,"out",P,"amplitude"),i.wire(Me,"out",P,"spread"),i.wire($,"pos",z,"pos"),i.wire(C,"color",z,"color"),i.wire(P,"value",z,"size")});E(`Patch built: ${e.blocks.size} blocks, ${e.edges.length} edges`);const o=ft(e);if(o.kind!=="ok")throw E(`Compile failed: ${JSON.stringify(o.errors)}`,"error"),new Error("Compile failed");const n=o.program;E(`Compiled: ${n.signalExprs.nodes.length} signals, ${n.fieldExprs.nodes.length} fields, ${n.slotMeta.length} slots`),fe=n,he=Et(n.slotMeta.length)}const ee=document.getElementById("canvas"),jt=ee.getContext("2d"),Vt=new yt;ge(5e3);E("Runtime initialized");let O=0,G=performance.now(),J=0,U=0,ie=0,re=0,se=0,Z=1/0,b=0,K=0;function me(t){try{const e=performance.now(),o=performance.now(),n=Ut(fe,he,Vt,t);re=performance.now()-o;const i=performance.now();Zt(jt,n,ee.width,ee.height),se=performance.now()-i,ie=performance.now()-e,U=ie,Z=Math.min(Z,U),b=Math.max(b,U),K+=U,O++;const r=performance.now();if(r-G>500){J=Math.round(O*1e3/(r-G));const s=1e3/J,d=K/O,a=Math.max(0,Math.round((s-b)/s*100));_t.textContent=`FPS: ${J} | ${re.toFixed(1)}/${se.toFixed(1)}ms | Min/Max: ${Z.toFixed(1)}/${b.toFixed(1)}ms`,O=0,G=r,Z=1/0,b=0,K=0}requestAnimationFrame(me)}catch(e){E(`Runtime error: ${e}`,"error"),console.error(e)}}E("Starting animation loop...");requestAnimationFrame(me);const Ht=document.getElementById("particleSlider"),Lt=document.getElementById("particleCount");Ht.addEventListener("input",t=>{const e=parseInt(t.target.value);Lt.textContent=e.toString(),ge(e),E(`Particle count changed to ${e}`)});
