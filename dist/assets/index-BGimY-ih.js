var de=Object.defineProperty;var le=(t,e,o)=>e in t?de(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o;var w=(t,e,o)=>le(t,typeof e!="symbol"?e+"":e,o);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const s of r.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&n(s)}).observe(document,{childList:!0,subtree:!0});function o(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=o(i);fetch(i.href,r)}})();class ae{constructor(){w(this,"blocks",new Map);w(this,"edges",[]);w(this,"nextId",0)}addBlock(e,o={}){const n=`b${this.nextId++}`;return this.blocks.set(n,{id:n,type:e,params:o}),n}addEdge(e,o){return this.edges.push({from:e,to:o}),this}wire(e,o,n,i){return this.addEdge({blockId:e,portId:o},{blockId:n,portId:i})}build(){return{blocks:new Map(this.blocks),edges:[...this.edges]}}}function ce(t){const e=new ae;return t(e),e.build()}function pe(t){const e=[],o=new Map,n=[],i=[...t.blocks.keys()].sort();for(const s of i){if(o.has(s)){e.push({kind:"DuplicateBlockId",id:s});continue}const d=n.length;o.set(s,d),n.push(t.blocks.get(s))}const r=[];for(const s of t.edges){const d=o.get(s.from.blockId),a=o.get(s.to.blockId);if(d===void 0){e.push({kind:"DanglingEdge",edge:s,missing:"from"});continue}if(a===void 0){e.push({kind:"DanglingEdge",edge:s,missing:"to"});continue}r.push({fromBlock:d,fromPort:s.from.portId,toBlock:a,toPort:s.to.portId})}return r.sort((s,d)=>s.toBlock!==d.toBlock?s.toBlock-d.toBlock:s.toPort!==d.toPort?s.toPort.localeCompare(d.toPort):s.fromBlock!==d.fromBlock?s.fromBlock-d.fromBlock:s.fromPort.localeCompare(d.fromPort)),e.length>0?{kind:"error",errors:e}:{kind:"ok",patch:{patch:t,blockIndex:o,blocks:n,edges:r}}}var h=(t=>(t.Add="add",t.Sub="sub",t.Mul="mul",t.Div="div",t.Mod="mod",t.Neg="neg",t.Abs="abs",t.Sin="sin",t.Cos="cos",t.Tan="tan",t.Min="min",t.Max="max",t.Clamp="clamp",t.Lerp="lerp",t.Eq="eq",t.Lt="lt",t.Gt="gt",t.Wrap01="wrap01",t))(h||{});class ue{constructor(){w(this,"signals",new Map);w(this,"fields",new Map);w(this,"events",new Map);w(this,"domains",new Map);w(this,"steps",[]);w(this,"nextSigId",0);w(this,"nextFieldId",0);w(this,"nextEventId",0);w(this,"nextDomainId",0);w(this,"nextSlotId",0);w(this,"timeModel",{kind:"infinite"})}setTimeModel(e){this.timeModel=e}allocSlot(){return this.nextSlotId++}sigConst(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"const",value:e,type:o}),n}sigSlot(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"slot",slot:e,type:o}),n}sigTime(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"time",which:e,type:o}),n}sigExternal(e,o){const n=this.nextSigId++;return this.signals.set(n,{kind:"external",which:e,type:o}),n}sigMap(e,o,n){const i=this.nextSigId++;return this.signals.set(i,{kind:"map",input:e,fn:o,type:n}),i}sigZip(e,o,n){const i=this.nextSigId++;return this.signals.set(i,{kind:"zip",inputs:e,fn:o,type:n}),i}sigBinOp(e,o,n,i){return this.sigZip([e,o],{kind:"opcode",opcode:n},i)}sigUnaryOp(e,o,n){return this.sigMap(e,{kind:"opcode",opcode:o},n)}fieldConst(e,o){const n=this.nextFieldId++;return this.fields.set(n,{kind:"const",value:e,type:o}),n}fieldSource(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"source",domain:e,sourceId:o,type:n}),i}fieldBroadcast(e,o){const n=this.nextFieldId++;return this.fields.set(n,{kind:"broadcast",signal:e,type:o}),n}fieldMap(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"map",input:e,fn:o,type:n}),i}fieldZip(e,o,n){const i=this.nextFieldId++;return this.fields.set(i,{kind:"zip",inputs:e,fn:o,type:n}),i}fieldZipSig(e,o,n,i){const r=this.nextFieldId++;return this.fields.set(r,{kind:"zipSig",field:e,signals:o,fn:n,type:i}),r}fieldMapIndexed(e,o,n,i){const r=this.nextFieldId++;return this.fields.set(r,{kind:"mapIndexed",domain:e,fn:o,type:n,signals:i}),r}eventPulse(){const e=this.nextEventId++;return this.events.set(e,{kind:"pulse",source:"timeRoot"}),e}eventWrap(e){const o=this.nextEventId++;return this.events.set(o,{kind:"wrap",signal:e}),o}eventCombine(e,o){const n=this.nextEventId++;return this.events.set(n,{kind:"combine",events:e,mode:o}),n}domainGrid(e,o){const n=this.nextDomainId++,i=e*o,r=Array.from({length:i},(s,d)=>this.seededId(e*1e4+o+d));return this.domains.set(n,{id:n,kind:"grid",count:i,elementIds:r,params:{rows:e,cols:o}}),n}domainN(e,o=0){const n=this.nextDomainId++,i=Array.from({length:e},(r,s)=>this.seededId(o*1e5+e+s));return this.domains.set(n,{id:n,kind:"n",count:e,elementIds:i,params:{n:e,seed:o}}),n}seededId(e){let o=e;return o=(o>>16^o)*73244475,o=(o>>16^o)*73244475,o=o>>16^o,Math.abs(o).toString(36).slice(0,8).padStart(8,"0")}stepEvalSig(e,o){this.steps.push({kind:"evalSig",expr:e,target:o})}stepMaterialize(e,o,n){this.steps.push({kind:"materialize",field:e,domain:o,target:n})}stepRender(e,o,n,i){this.steps.push({kind:"render",domain:e,position:o,color:n,size:i})}build(){return{timeModel:this.timeModel,signals:new Map(this.signals),fields:new Map(this.fields),events:new Map(this.events),domains:new Map(this.domains),steps:[...this.steps],slotCount:this.nextSlotId}}}const H=new Map;function k(t){if(H.has(t.type))throw new Error(`Block type already registered: ${t.type}`);const e=new Set(t.inputs.map(n=>n.portId)),o=new Set(t.outputs.map(n=>n.portId));if(e.size!==t.inputs.length)throw new Error(`Duplicate input port IDs in block ${t.type}`);if(o.size!==t.outputs.length)throw new Error(`Duplicate output port IDs in block ${t.type}`);H.set(t.type,t)}function U(t){return H.get(t)}function c(t){return{world:"signal",domain:t}}function l(t){return{world:"field",domain:t}}const fe=({b:t,config:e})=>{t.setTimeModel({kind:"infinite"});const o=t.sigTime("t",c("time")),n=t.sigTime("dt",c("time")),i=typeof e.periodMs=="number"?e.periodMs:4e3,r=t.sigConst(i,c("float")),s=t.sigBinOp(o,r,h.Div,c("float")),d=t.sigUnaryOp(s,h.Wrap01,c("phase")),a=t.eventWrap(d),u=t.sigConst(1,c("float"));return{t:{kind:"sig",id:o,type:c("time")},dt:{kind:"sig",id:n,type:c("time")},phase:{kind:"sig",id:d,type:c("phase")},pulse:{kind:"event",id:a},energy:{kind:"sig",id:u,type:c("float")}}};k({type:"InfiniteTimeRoot",inputs:[],outputs:[{portId:"t",type:c("time")},{portId:"dt",type:c("time")},{portId:"phase",type:c("phase")},{portId:"pulse",type:{world:"event",domain:"float"}},{portId:"energy",type:c("float")}],lower:fe});const he=({b:t,config:e})=>{const o=typeof e.durationMs=="number"?e.durationMs:1e4;t.setTimeModel({kind:"finite",durationMs:o});const n=t.sigTime("t",c("time")),i=t.sigTime("dt",c("time")),r=t.sigConst(o,c("float")),s=t.sigBinOp(n,r,h.Div,c("float")),d=typeof e.periodMs=="number"?e.periodMs:0;let a,u;if(d>0){const f=t.sigConst(d,c("float")),m=t.sigBinOp(n,f,h.Div,c("float"));a=t.sigUnaryOp(m,h.Wrap01,c("phase")),u=t.eventWrap(a)}else a=s,u=t.eventPulse();const p=t.sigConst(1,c("float"));return{t:{kind:"sig",id:n,type:c("time")},dt:{kind:"sig",id:i,type:c("time")},progress:{kind:"sig",id:s,type:c("float")},phase:{kind:"sig",id:a,type:c("phase")},pulse:{kind:"event",id:u},energy:{kind:"sig",id:p,type:c("float")}}};k({type:"FiniteTimeRoot",inputs:[],outputs:[{portId:"t",type:c("time")},{portId:"dt",type:c("time")},{portId:"progress",type:c("float")},{portId:"phase",type:c("phase")},{portId:"pulse",type:{world:"event",domain:"float"}},{portId:"energy",type:c("float")}],lower:he});const me=({b:t,config:e})=>{const o=typeof e.value=="number"?e.value:0;return{out:{kind:"sig",id:t.sigConst(o,c("float")),type:c("float")}}};k({type:"ConstFloat",inputs:[],outputs:[{portId:"out",type:c("float")}],lower:me});const ge=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||!n||o.kind!=="sig"||n.kind!=="sig")throw new Error("AddSignal requires two signal inputs");return{out:{kind:"sig",id:t.sigBinOp(o.id,n.id,h.Add,c("float")),type:c("float")}}};k({type:"AddSignal",inputs:[{portId:"a",type:c("float")},{portId:"b",type:c("float")}],outputs:[{portId:"out",type:c("float")}],lower:ge});const ke=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||!n||o.kind!=="sig"||n.kind!=="sig")throw new Error("MulSignal requires two signal inputs");return{out:{kind:"sig",id:t.sigBinOp(o.id,n.id,h.Mul,c("float")),type:c("float")}}};k({type:"MulSignal",inputs:[{portId:"a",type:c("float")},{portId:"b",type:c("float")}],outputs:[{portId:"out",type:c("float")}],lower:ke});const we=({b:t,inputsById:e,config:o})=>{const n=e.phase;if(!n||n.kind!=="sig")throw new Error("Oscillator requires phase input");const i=typeof o.waveform=="string"?o.waveform:"sin",r=t.sigConst(Math.PI*2,c("float")),s=t.sigBinOp(n.id,r,h.Mul,c("float"));let d;switch(i){case"sin":d=t.sigUnaryOp(s,h.Sin,c("float"));break;case"cos":d=t.sigUnaryOp(s,h.Cos,c("float"));break;case"saw":const a=t.sigConst(2,c("float")),u=t.sigConst(1,c("float")),p=t.sigBinOp(n.id,a,h.Mul,c("float"));d=t.sigBinOp(p,u,h.Sub,c("float"));break;default:d=t.sigUnaryOp(s,h.Sin,c("float"))}return{out:{kind:"sig",id:d,type:c("float")}}};k({type:"Oscillator",inputs:[{portId:"phase",type:c("phase")}],outputs:[{portId:"out",type:c("float")}],lower:we});k({type:"MousePosition",inputs:[],outputs:[{portId:"x",type:c("float")},{portId:"y",type:c("float")}],lower:({b:t})=>({x:{kind:"sig",id:t.sigExternal("mouseX",c("float")),type:c("float")},y:{kind:"sig",id:t.sigExternal("mouseY",c("float")),type:c("float")}})});const ye=({b:t,config:e})=>{const o=typeof e.rows=="number"?e.rows:4,n=typeof e.cols=="number"?e.cols:4,i=t.domainGrid(o,n),r=t.fieldSource(i,"pos0",l("vec2")),s=t.fieldSource(i,"index",l("float")),d=t.fieldSource(i,"normalizedIndex",l("float")),a=t.fieldSource(i,"idRand",l("float"));return{domain:{kind:"domain",id:i},pos:{kind:"field",id:r,type:l("vec2")},index:{kind:"field",id:s,type:l("float")},normIndex:{kind:"field",id:d,type:l("float")},rand:{kind:"field",id:a,type:l("float")}}};k({type:"GridDomain",inputs:[],outputs:[{portId:"domain",type:{world:"scalar",domain:"float"}},{portId:"pos",type:l("vec2")},{portId:"index",type:l("float")},{portId:"normIndex",type:l("float")},{portId:"rand",type:l("float")}],lower:ye});const Ie=({b:t,config:e})=>{const o=typeof e.n=="number"?e.n:10,n=typeof e.seed=="number"?e.seed:0,i=t.domainN(o,n),r=t.fieldSource(i,"index",l("float")),s=t.fieldSource(i,"normalizedIndex",l("float")),d=t.fieldSource(i,"idRand",l("float"));return{domain:{kind:"domain",id:i},index:{kind:"field",id:r,type:l("float")},normIndex:{kind:"field",id:s,type:l("float")},rand:{kind:"field",id:d,type:l("float")}}};k({type:"DomainN",inputs:[],outputs:[{portId:"domain",type:{world:"scalar",domain:"float"}},{portId:"index",type:l("float")},{portId:"normIndex",type:l("float")},{portId:"rand",type:l("float")}],lower:Ie});const Fe=({b:t,inputsById:e})=>{const o=e.signal;if(!o||o.kind!=="sig")throw new Error("FieldBroadcast requires signal input");return{out:{kind:"field",id:t.fieldBroadcast(o.id,l(o.type.domain)),type:l(o.type.domain)}}};k({type:"FieldBroadcast",inputs:[{portId:"signal",type:c("float")}],outputs:[{portId:"out",type:l("float")}],lower:Fe});const Me=({b:t,inputsById:e,config:o})=>{const n=e.field;if(!n||n.kind!=="field")throw new Error("FieldMap requires field input");const i=typeof o.expr=="string"?o.expr:"x";return{out:{kind:"field",id:t.fieldMap(n.id,{kind:"expr",expr:i},l(n.type.domain)),type:l(n.type.domain)}}};k({type:"FieldMap",inputs:[{portId:"field",type:l("float")}],outputs:[{portId:"out",type:l("float")}],lower:Me});const ve=({b:t,inputsById:e,config:o})=>{const n=e.field,i=e.signal;if(!n||n.kind!=="field")throw new Error("FieldZipSig requires field input");if(!i||i.kind!=="sig")throw new Error("FieldZipSig requires signal input");const r=typeof o.op=="string"?o.op:"mul";let s;switch(r){case"add":s=h.Add;break;case"sub":s=h.Sub;break;case"mul":s=h.Mul;break;case"div":s=h.Div;break;default:s=h.Mul}return{out:{kind:"field",id:t.fieldZipSig(n.id,[i.id],{kind:"opcode",opcode:s},l("float")),type:l("float")}}};k({type:"FieldZipSig",inputs:[{portId:"field",type:l("float")},{portId:"signal",type:c("float")}],outputs:[{portId:"out",type:l("float")}],lower:ve});const Se=({b:t,inputsById:e})=>{const o=e.domain;if(!o||o.kind!=="domain")throw new Error("FieldFromDomainId requires domain input");return{id01:{kind:"field",id:t.fieldSource(o.id,"normalizedIndex",l("float")),type:l("float")}}};k({type:"FieldFromDomainId",inputs:[{portId:"domain",type:{world:"scalar",domain:"float"}}],outputs:[{portId:"id01",type:l("float")}],lower:Se});const Ee=({b:t,inputsById:e})=>{const o=e.phase,n=e.id01,i=e.base,r=e.amplitude,s=e.spread;if(!o||o.kind!=="sig")throw new Error("FieldPulse requires phase (signal) input");if(!n||n.kind!=="field")throw new Error("FieldPulse requires id01 (field) input");if(!i||i.kind!=="sig")throw new Error("FieldPulse requires base (signal) input");if(!r||r.kind!=="sig")throw new Error("FieldPulse requires amplitude (signal) input");if(!s||s.kind!=="sig")throw new Error("FieldPulse requires spread (signal) input");const d=t.fieldBroadcast(s.id,l("float")),a=t.fieldZip([n.id,d],{kind:"opcode",opcode:h.Mul},l("float")),u=t.fieldBroadcast(o.id,l("float")),p=t.fieldZip([u,a],{kind:"opcode",opcode:h.Add},l("float")),f=t.sigConst(Math.PI*2,c("float")),m=t.fieldBroadcast(f,l("float")),g=t.fieldZip([p,m],{kind:"opcode",opcode:h.Mul},l("float")),y=t.fieldMap(g,{kind:"opcode",opcode:h.Sin},l("float")),I=t.fieldBroadcast(r.id,l("float")),F=t.fieldZip([y,I],{kind:"opcode",opcode:h.Mul},l("float")),v=t.fieldBroadcast(i.id,l("float"));return{value:{kind:"field",id:t.fieldZip([v,F],{kind:"opcode",opcode:h.Add},l("float")),type:l("float")}}};k({type:"FieldPulse",inputs:[{portId:"phase",type:c("phase")},{portId:"id01",type:l("float")},{portId:"base",type:c("float")},{portId:"amplitude",type:c("float")},{portId:"spread",type:c("float")}],outputs:[{portId:"value",type:l("float")}],lower:Ee});const xe=({b:t,inputsById:e,config:o})=>{const n=e.id01;if(!n||n.kind!=="field")throw new Error("FieldGoldenAngle requires id01 (field) input");const i=2.399963229728653,r=typeof o.turns=="number"?o.turns:50,s=t.sigConst(i*r,c("float")),d=t.fieldBroadcast(s,l("float"));return{angle:{kind:"field",id:t.fieldZip([n.id,d],{kind:"opcode",opcode:h.Mul},l("float")),type:l("float")}}};k({type:"FieldGoldenAngle",inputs:[{portId:"id01",type:l("float")}],outputs:[{portId:"angle",type:l("float")}],lower:xe});const Pe=({b:t,inputsById:e})=>{const o=e.phase,n=e.spin,i=e.id01;if(!o||o.kind!=="sig")throw new Error("FieldAngularOffset requires phase (signal) input");if(!n||n.kind!=="sig")throw new Error("FieldAngularOffset requires spin (signal) input");if(!i||i.kind!=="field")throw new Error("FieldAngularOffset requires id01 (field) input");const r=t.sigConst(2,c("float")),s=t.fieldBroadcast(r,l("float")),d=t.fieldZip([s,i.id],{kind:"opcode",opcode:h.Sub},l("float")),a=t.sigConst(Math.PI*2,c("float")),u=t.sigBinOp(o.id,a,h.Mul,c("float")),p=t.sigBinOp(u,n.id,h.Mul,c("float")),f=t.fieldBroadcast(p,l("float"));return{offset:{kind:"field",id:t.fieldZip([f,d],{kind:"opcode",opcode:h.Mul},l("float")),type:l("float")}}};k({type:"FieldAngularOffset",inputs:[{portId:"phase",type:c("phase")},{portId:"spin",type:c("float")},{portId:"id01",type:l("float")}],outputs:[{portId:"offset",type:l("float")}],lower:Pe});const Be=({b:t,inputsById:e})=>{const o=e.a,n=e.b;if(!o||o.kind!=="field")throw new Error("FieldAdd requires a (field) input");if(!n||n.kind!=="field")throw new Error("FieldAdd requires b (field) input");return{out:{kind:"field",id:t.fieldZip([o.id,n.id],{kind:"opcode",opcode:h.Add},l("float")),type:l("float")}}};k({type:"FieldAdd",inputs:[{portId:"a",type:l("float")},{portId:"b",type:l("float")}],outputs:[{portId:"out",type:l("float")}],lower:Be});const Ae=({b:t,inputsById:e})=>{const o=e.radius,n=e.id01;if(!o||o.kind!=="sig"&&o.kind!=="field")throw new Error("FieldRadiusSqrt requires radius (signal or field) input");if(!n||n.kind!=="field")throw new Error("FieldRadiusSqrt requires id01 (field) input");const i=t.fieldMap(n.id,{kind:"kernel",name:"sqrt"},l("float")),r=o.kind==="sig"?t.fieldBroadcast(o.id,l("float")):o.id;return{radius:{kind:"field",id:t.fieldZip([r,i],{kind:"opcode",opcode:h.Mul},l("float")),type:l("float")}}};k({type:"FieldRadiusSqrt",inputs:[{portId:"radius",type:l("float")},{portId:"id01",type:l("float")}],outputs:[{portId:"radius",type:l("float")}],lower:Ae});const $e=({b:t,inputsById:e})=>{const o=e.centerX,n=e.centerY,i=e.radius,r=e.angle;if(!o||o.kind!=="sig")throw new Error("FieldPolarToCartesian requires centerX (signal) input");if(!n||n.kind!=="sig")throw new Error("FieldPolarToCartesian requires centerY (signal) input");if(!i||i.kind!=="field")throw new Error("FieldPolarToCartesian requires radius (field) input");if(!r||r.kind!=="field")throw new Error("FieldPolarToCartesian requires angle (field) input");const s=t.fieldMap(r.id,{kind:"opcode",opcode:h.Cos},l("float")),d=t.fieldMap(r.id,{kind:"opcode",opcode:h.Sin},l("float")),a=t.fieldZip([i.id,s],{kind:"opcode",opcode:h.Mul},l("float")),u=t.fieldBroadcast(o.id,l("float")),p=t.fieldZip([u,a],{kind:"opcode",opcode:h.Add},l("float")),f=t.fieldZip([i.id,d],{kind:"opcode",opcode:h.Mul},l("float")),m=t.fieldBroadcast(n.id,l("float")),g=t.fieldZip([m,f],{kind:"opcode",opcode:h.Add},l("float"));return{pos:{kind:"field",id:t.fieldZip([p,g],{kind:"kernel",name:"makeVec2"},l("vec2")),type:l("vec2")}}};k({type:"FieldPolarToCartesian",inputs:[{portId:"centerX",type:c("float")},{portId:"centerY",type:c("float")},{portId:"radius",type:l("float")},{portId:"angle",type:l("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:$e});const Te=({b:t,inputsById:e})=>{const o=e.phase,n=e.id01;if(!o||o.kind!=="sig")throw new Error("FieldHueFromPhase requires phase (signal) input");if(!n||n.kind!=="field")throw new Error("FieldHueFromPhase requires id01 (field) input");const i=t.fieldBroadcast(o.id,l("float")),r=t.fieldZip([i,n.id],{kind:"opcode",opcode:h.Add},l("float"));return{hue:{kind:"field",id:t.fieldMap(r,{kind:"opcode",opcode:h.Wrap01},l("float")),type:l("float")}}};k({type:"FieldHueFromPhase",inputs:[{portId:"phase",type:c("phase")},{portId:"id01",type:l("float")}],outputs:[{portId:"hue",type:l("float")}],lower:Te});const qe=({b:t,inputsById:e})=>{const o=e.hue,n=e.sat,i=e.val;if(!o||o.kind!=="field")throw new Error("HsvToRgb requires hue (field) input");if(!n||n.kind!=="sig")throw new Error("HsvToRgb requires sat (signal) input");if(!i||i.kind!=="sig")throw new Error("HsvToRgb requires val (signal) input");const r=t.fieldBroadcast(n.id,l("float")),s=t.fieldBroadcast(i.id,l("float"));return{color:{kind:"field",id:t.fieldZip([o.id,r,s],{kind:"kernel",name:"hsvToRgb"},l("color")),type:l("color")}}};k({type:"HsvToRgb",inputs:[{portId:"hue",type:l("float")},{portId:"sat",type:c("float")},{portId:"val",type:c("float")}],outputs:[{portId:"color",type:l("color")}],lower:qe});const Re=({b:t,inputsById:e})=>{const o=e.domain,n=e.pos,i=e.color,r=e.size,s=e.opacity;if(!o||o.kind!=="domain")throw new Error("RenderInstances2D requires domain input");if(!n||n.kind!=="field")throw new Error("RenderInstances2D requires pos (field<vec2>) input");if(!i||i.kind!=="field")throw new Error("RenderInstances2D requires color (field<color>) input");let d;r&&(r.kind==="sig"||r.kind==="field")&&(d=r.id);let a;s&&s.kind==="sig"&&(a=s.id);let u=i.id;return a&&(u=t.fieldZipSig(i.id,[a],{kind:"kernel",name:"applyOpacity"},l("color"))),t.stepRender(o.id,n.id,u,d),{}};k({type:"RenderInstances2D",inputs:[{portId:"domain",type:{world:"scalar",domain:"float"}},{portId:"pos",type:l("vec2")},{portId:"color",type:l("color")},{portId:"size",type:l("float"),optional:!0},{portId:"opacity",type:c("float"),optional:!0}],outputs:[],lower:Re});const Ce=({b:t,inputsById:e})=>{const o=e.pos,n=e.rand,i=e.amountX,r=e.amountY;if(!o||o.kind!=="field")throw new Error("FieldJitter2D requires pos (field<vec2>) input");if(!n||n.kind!=="field")throw new Error("FieldJitter2D requires rand (field<float>) input");if(!i||i.kind!=="sig")throw new Error("FieldJitter2D requires amountX (signal) input");if(!r||r.kind!=="sig")throw new Error("FieldJitter2D requires amountY (signal) input");const s=t.fieldBroadcast(i.id,l("float")),d=t.fieldBroadcast(r.id,l("float"));return{pos:{kind:"field",id:t.fieldZip([o.id,n.id,s,d],{kind:"kernel",name:"jitter2d"},l("vec2")),type:l("vec2")}}};k({type:"FieldJitter2D",inputs:[{portId:"pos",type:l("vec2")},{portId:"rand",type:l("float")},{portId:"amountX",type:c("float")},{portId:"amountY",type:c("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:Ce});k({type:"FieldAttract2D",inputs:[{portId:"pos",type:l("vec2")},{portId:"targetX",type:c("float")},{portId:"targetY",type:c("float")},{portId:"phase",type:c("phase")},{portId:"strength",type:c("float")}],outputs:[{portId:"pos",type:l("vec2")}],lower:({b:t,inputsById:e})=>{const o=e.pos,n=e.targetX,i=e.targetY,r=e.phase,s=e.strength,d=t.fieldBroadcast(n.id,l("float")),a=t.fieldBroadcast(i.id,l("float")),u=t.fieldBroadcast(r.id,l("float")),p=t.fieldBroadcast(s.id,l("float"));return{pos:{kind:"field",id:t.fieldZip([o.id,d,a,u,p],{kind:"kernel",name:"attract2d"},l("vec2")),type:l("vec2")}}}});function ze(t,e){return t.world===e.world&&t.domain===e.domain?{kind:"direct"}:t.domain!==e.domain?null:t.world==="scalar"&&e.world==="signal"?{kind:"promote",from:"scalar",to:"signal"}:t.world==="signal"&&e.world==="field"?{kind:"broadcast"}:t.world==="scalar"&&e.world==="field"?{kind:"promote-broadcast"}:null}function De(t){const e=[];for(const o of t.edges){const n=t.blocks[o.fromBlock],i=t.blocks[o.toBlock],r=U(n.type),s=U(i.type);if(!r||!s)continue;const d=r.outputs.find(p=>p.portId===o.fromPort),a=s.inputs.find(p=>p.portId===o.toPort);if(!d){e.push({kind:"UnknownPort",message:`Source block '${n.type}' does not have output port '${o.fromPort}'`,blockId:n.id,portId:o.fromPort});continue}if(!a){e.push({kind:"UnknownPort",message:`Target block '${i.type}' does not have input port '${o.toPort}'`,blockId:i.id,portId:o.toPort});continue}ze(d.type,a.type)===null&&e.push({kind:"TypeMismatch",message:`Cannot connect ${d.type.world}:${d.type.domain} to ${a.type.world}:${a.type.domain} (${n.type}.${o.fromPort} â†’ ${i.type}.${o.toPort})`,blockId:n.id,portId:o.fromPort})}for(const o of t.blocks){const n=U(o.type);if(n)for(const i of n.inputs){if(i.optional)continue;!t.edges.some(s=>s.toBlock===t.blocks.indexOf(o)&&s.toPort===i.portId)&&!i.defaultValue&&e.push({kind:"MissingRequiredInput",message:`Block '${o.type}' is missing required input '${i.portId}'`,blockId:o.id,portId:i.portId})}}return e}function Ue(t){const e=[],o=pe(t);if(o.kind==="error")return{kind:"error",errors:o.errors.map(u=>({kind:u.kind,message:Oe(u)}))};const n=o.patch,i=Ze(n);i.kind==="error"&&e.push(...i.errors);const r=De(n);if(r.length>0&&e.push(...r),e.length>0)return{kind:"error",errors:e};const s=Xe(n),d=new ue,a=new Map;for(const u of s){const p=n.blocks[u],f=U(p.type);if(!f){e.push({kind:"UnknownBlockType",message:`Unknown block type: ${p.type}`,blockId:p.id});continue}const m=Ye(n,u,a);try{const g=f.lower({b:d,config:p.params,inputsById:m});a.set(u,g)}catch(g){e.push({kind:"LoweringError",message:g instanceof Error?g.message:String(g),blockId:p.id})}}return e.length>0?{kind:"error",errors:e}:{kind:"ok",program:d.build()}}function Oe(t){switch(t.kind){case"DanglingEdge":return"Edge references non-existent block";case"DuplicateBlockId":return"Duplicate block ID";default:return t.kind}}function Ze(t){const e=[];for(let o=0;o<t.blocks.length;o++){const n=t.blocks[o];(n.type==="InfiniteTimeRoot"||n.type==="FiniteTimeRoot"||n.type==="TimeRoot")&&e.push(o)}return e.length===0?{kind:"error",errors:[{kind:"NoTimeRoot",message:"No TimeRoot block found. Every patch needs exactly one."}]}:e.length>1?{kind:"error",errors:[{kind:"MultipleTimeRoots",message:`Found ${e.length} TimeRoot blocks. Only one allowed.`}]}:{kind:"ok",blockIdx:e[0]}}function Xe(t){const e=new Map,o=new Map;for(let r=0;r<t.blocks.length;r++)e.set(r,new Set),o.set(r,new Set);for(const r of t.edges)e.get(r.toBlock).add(r.fromBlock),o.get(r.fromBlock).add(r.toBlock);const n=[],i=[];for(let r=0;r<t.blocks.length;r++)e.get(r).size===0&&i.push(r);for(;i.length>0;){const r=i.shift();n.push(r);for(const s of o.get(r))e.get(s).delete(r),e.get(s).size===0&&i.push(s)}if(n.length!==t.blocks.length){const r=new Set;for(let d=0;d<t.blocks.length;d++)n.includes(d)||r.add(d);const s=[...r].map(d=>t.blocks[d].id);throw new Error(`Dependency cycle detected involving blocks: ${s.join(", ")}`)}return n}function Ye(t,e,o){const n={};for(const i of t.edges)if(i.toBlock===e){const r=o.get(i.fromBlock);if(r){const s=i.fromPort;n[i.toPort]=r[s]}}return n}function be(t){switch(t){case"float":case"int":case"phase":case"time":return"f32";case"vec2":return"vec2f32";case"color":return"rgba8";case"string":throw new Error("String domain cannot be materialized to typed array");default:{const e=t;throw new Error(`Unknown domain: ${String(e)}`)}}}class _e{constructor(){w(this,"pools",new Map);w(this,"inUse",new Map);w(this,"maxPoolSize",100)}alloc(e,o){const n=`${e}:${o}`;this.pools.size>this.maxPoolSize&&this.trimPools();const i=this.pools.get(n)??[];if(i.length>0){const s=i.pop();return this.trackInUse(n,s),s}const r=He(e,o);return this.trackInUse(n,r),r}releaseAll(){for(const[e,o]of this.inUse){const n=this.pools.get(e)??[];n.push(...o),this.pools.set(e,n)}this.inUse.clear()}trackInUse(e,o){const n=this.inUse.get(e)??[];n.push(o),this.inUse.set(e,n)}getStats(){let e=0;for(const n of this.pools.values())e+=n.length;let o=0;for(const n of this.inUse.values())o+=n.length;return{pooled:e,inUse:o,poolKeys:this.pools.size}}trimPools(){const e=new Set(this.inUse.keys());for(const[o,n]of this.pools)!e.has(o)&&n.length>0&&this.pools.delete(o)}clearUnusedPools(){for(const[e,o]of this.pools)this.inUse.has(e)||this.pools.delete(e)}}function He(t,e){switch(t){case"f32":return new Float32Array(e);case"vec2f32":return new Float32Array(e*2);case"rgba8":return new Uint8ClampedArray(e*4);default:{const o=t;throw new Error(`Unknown buffer format: ${String(o)}`)}}}function Ve(){return{prevTAbsMs:null,prevTModelMs:null,wrapCount:0}}function je(t,e,o){const n=o.prevTAbsMs!==null?t-o.prevTAbsMs:0;switch(o.prevTAbsMs=t,e.kind){case"finite":{const i=Math.max(0,Math.min(t,e.durationMs)),r=e.durationMs>0?i/e.durationMs:0;return{tAbsMs:t,tModelMs:i,dt:n,progress:r}}case"cyclic":{const i=e.periodMs,r=(t%i+i)%i,s=i>0?r/i:0;let d=0;o.prevTModelMs!==null&&r<o.prevTModelMs&&(d=1,o.wrapCount++),o.prevTModelMs=r;const a=o.wrapCount;return{tAbsMs:t,tModelMs:r,dt:n,phase:s,pulse:d,energy:a}}case"infinite":return{tAbsMs:t,tModelMs:t,dt:n};default:{const i=e;throw new Error(`Unknown time model: ${String(i)}`)}}}function Ge(t){return{f64:new Float64Array(t),objects:new Map}}function Le(t=1e3,e=1e3){return{frameId:0,sigValues:new Float64Array(t),sigStamps:new Uint32Array(t),fieldBuffers:new Map,fieldStamps:new Map}}function Je(){return{mouseX:.5,mouseY:.5,mouseOver:!1,smoothX:.5,smoothY:.5}}function We(t){return{values:Ge(t),cache:Le(),timeState:Ve(),time:null,external:Je()}}function O(t,e){return e.length===1?W(t,e[0]):Ke(t,e)}function W(t,e){switch(t){case"neg":return-e;case"abs":return Math.abs(e);case"sin":return Math.sin(e);case"cos":return Math.cos(e);case"tan":return Math.tan(e);case"wrap01":return(e%1+1)%1;default:throw new Error(`OpCode ${t} is not unary`)}}function Ke(t,e){switch(t){case"add":return e.reduce((o,n)=>o+n,0);case"sub":return e.length>=2?e[0]-e[1]:-e[0];case"mul":return e.reduce((o,n)=>o*n,1);case"div":return e.length>=2?e[0]/e[1]:1/e[0];case"mod":return e.length>=2?e[0]%e[1]:0;case"min":return Math.min(...e);case"max":return Math.max(...e);case"clamp":return e.length>=3?Math.max(e[1],Math.min(e[2],e[0])):e[0];case"lerp":return e.length>=3?e[0]*(1-e[2])+e[1]*e[2]:e[0];default:if(e.length===1)return W(t,e[0]);throw new Error(`OpCode ${t} not implemented for ${e.length} args`)}}function x(t,e,o){const n=o.cache.sigValues[t];if(o.cache.sigStamps[t]===o.cache.frameId)return n;const r=e.get(t);if(!r)throw new Error(`Signal expression ${t} not found`);const s=Ne(r,e,o);return o.cache.sigValues[t]=s,o.cache.sigStamps[t]=o.cache.frameId,s}function Ne(t,e,o){if(!o.time)throw new Error("Effective time not set");switch(t.kind){case"const":return typeof t.value=="number"?t.value:0;case"slot":return o.values.f64[t.slot];case"time":{const n=t;switch(n.which){case"t":return o.time.tModelMs;case"dt":return o.time.dt;case"phase":return o.time.phase??0;case"pulse":return o.time.pulse??0;case"energy":return o.time.energy??0;default:{const i=n.which;throw new Error(`Unknown time signal: ${String(i)}`)}}}case"external":{const n=t;if(n.which==="mouseX")return o.external.smoothX;if(n.which==="mouseY")return o.external.smoothY;if(n.which==="mouseOver")return o.external.mouseOver?1:0;throw new Error(`Unknown external signal: ${n.which}`)}case"map":{const n=x(t.input,e,o);return j(t.fn,[n])}case"zip":{const n=t.inputs.map(i=>x(i,e,o));return j(t.fn,n)}default:{const n=t;throw new Error(`Unknown signal expr kind: ${n.kind}`)}}}function j(t,e){if(t.kind==="opcode")return O(t.opcode,e);throw new Error(`PureFn kind ${t.kind} not implemented`)}function E(t,e,o,n,i,r,s){const d=`${t}:${e}`,a=r.cache.fieldBuffers.get(d),u=r.cache.fieldStamps.get(d);if(a&&u===r.cache.frameId)return a;const p=o.get(t);if(!p)throw new Error(`Field expression ${t} not found`);const f=i.get(e);if(!f)throw new Error(`Domain ${e} not found`);const m=be(p.type.domain),g=s.alloc(m,f.count);return Qe(p,g,f,o,n,i,r,s),r.cache.fieldBuffers.set(d,g),r.cache.fieldStamps.set(d,r.cache.frameId),g}function Qe(t,e,o,n,i,r,s,d){var u;const a=o.count;switch(t.kind){case"const":{const p=e,f=typeof t.value=="number"?t.value:0;if(t.type.domain==="color"){const m=e;for(let g=0;g<a;g++)m[g*4+0]=255,m[g*4+1]=255,m[g*4+2]=255,m[g*4+3]=255}else if(t.type.domain==="vec2"){const m=e;for(let g=0;g<a;g++)m[g*2+0]=f,m[g*2+1]=f}else for(let m=0;m<a;m++)p[m]=f;break}case"source":{et(t.sourceId,e,o);break}case"broadcast":{const p=x(t.signal,i,s),f=e;for(let m=0;m<a;m++)f[m]=p;break}case"map":{const p=E(t.input,o.id,n,i,r,s,d);tt(e,p,t.fn,a,t.type);break}case"zip":{const p=t.inputs.map(f=>E(f,o.id,n,i,r,s,d));ot(e,p,t.fn,a,t.type);break}case"zipSig":{const p=E(t.field,o.id,n,i,r,s,d),f=t.signals.map(m=>x(m,i,s));nt(e,p,f,t.fn,a,t.type);break}case"mapIndexed":{const p=((u=t.signals)==null?void 0:u.map(f=>x(f,i,s)))??[];it(e,t.fn,p,a,o,t.type);break}default:{const p=t;throw new Error(`Unknown field expr kind: ${p.kind}`)}}}function et(t,e,o){const n=o.count;switch(t){case"index":{const i=e;for(let r=0;r<n;r++)i[r]=r;break}case"normalizedIndex":{const i=e;for(let r=0;r<n;r++)i[r]=n>1?r/(n-1):0;break}case"pos0":{if(o.kind==="grid"){const i=o.params.rows||1,r=o.params.cols||1,s=e;for(let d=0;d<n;d++){const a=Math.floor(d/r),u=d%r;s[d*2+0]=r>1?u/(r-1):.5,s[d*2+1]=i>1?a/(i-1):.5}}else{const i=e;for(let r=0;r<n;r++)i[r*2+0]=0,i[r*2+1]=0}break}case"idRand":{const i=e;for(let r=0;r<n;r++){const s=o.elementIds[r]||String(r);i[r]=lt(s)}break}default:{const i=t;throw new Error(`Unknown source ID: ${String(i)}`)}}}function tt(t,e,o,n,i){const r=t,s=e;if(o.kind==="opcode"){const d=o.opcode;for(let a=0;a<n;a++)r[a]=O(d,[s[a]])}else if(o.kind==="kernel")switch(o.name){case"sqrt":for(let d=0;d<n;d++)r[d]=Math.sqrt(s[d]);break;case"floor":for(let d=0;d<n;d++)r[d]=Math.floor(s[d]);break;case"ceil":for(let d=0;d<n;d++)r[d]=Math.ceil(s[d]);break;case"round":for(let d=0;d<n;d++)r[d]=Math.round(s[d]);break;default:throw new Error(`Unknown map kernel: ${o.name}`)}else throw new Error(`Map function kind ${o.kind} not implemented`)}function ot(t,e,o,n,i){if(o.kind==="opcode"){const r=t,s=e.map(a=>a),d=o.opcode;for(let a=0;a<n;a++){const u=s.map(p=>p[a]);r[a]=O(d,u)}}else if(o.kind==="kernel")rt(t,e,o.name,n);else throw new Error(`Zip function kind ${o.kind} not implemented`)}function nt(t,e,o,n,i,r){const s=t,d=e;if(n.kind==="opcode"){const a=n.opcode;for(let u=0;u<i;u++){const p=[d[u],...o];s[u]=O(a,p)}}else if(n.kind==="kernel")st(t,e,o,n.name,i);else throw new Error(`ZipSig function kind ${n.kind} not implemented`)}function it(t,e,o,n,i,r){const s=t;if(e.kind==="kernel")if(e.name==="gridPos"){const d=i.params.rows||1,a=i.params.cols||1;for(let u=0;u<n;u++){const p=Math.floor(u/a),f=u%a;s[u*2+0]=a>1?f/(a-1):.5,s[u*2+1]=d>1?p/(d-1):.5}}else throw new Error(`Unknown kernel function: ${e.name}`);else throw new Error(`MapIndexed function kind ${e.kind} not implemented`)}function rt(t,e,o,n,i){if(o==="makeVec2"){if(e.length!==2)throw new Error("makeVec2 requires exactly 2 inputs");const r=t,s=e[0],d=e[1];for(let a=0;a<n;a++)r[a*2+0]=s[a],r[a*2+1]=d[a]}else if(o==="hsvToRgb"){if(e.length!==3)throw new Error("hsvToRgb requires exactly 3 inputs (h, s, v)");const r=t,s=e[0],d=e[1],a=e[2];for(let u=0;u<n;u++){const[p,f,m]=dt(s[u],d[u],a[u]);r[u*4+0]=p,r[u*4+1]=f,r[u*4+2]=m,r[u*4+3]=255}}else if(o==="jitter2d"){if(e.length!==4)throw new Error("jitter2d requires exactly 4 inputs (pos, rand, amountX, amountY)");const r=t,s=e[0],d=e[1],a=e[2],u=e[3];for(let p=0;p<n;p++){const f=d[p],m=Math.sin(f*12.9898+78.233)*43758.5453,g=Math.sin(f*93.9898+67.345)*24571.2341,y=((m-Math.floor(m))*2-1)*a[p],I=((g-Math.floor(g))*2-1)*u[p];r[p*2+0]=s[p*2+0]+y,r[p*2+1]=s[p*2+1]+I}}else if(o==="attract2d"){if(e.length!==5)throw new Error("attract2d requires 5 inputs (pos, targetX, targetY, phase, strength)");const r=t,s=e[0],d=e[1],a=e[2],u=e[3],p=e[4];for(let f=0;f<n;f++){const m=s[f*2+0],g=s[f*2+1],y=d[f],I=a[f],F=u[f],v=p[f],P=y-m,S=I-g,T=F*v;r[f*2+0]=m+P*T,r[f*2+1]=g+S*T}}else throw new Error(`Unknown kernel function: ${o}`)}function st(t,e,o,n,i,r){if(n==="applyOpacity"){if(o.length!==1)throw new Error("applyOpacity requires exactly 1 signal (opacity)");const s=t,d=e,a=Math.max(0,Math.min(1,o[0])),u=Math.round(a*255);for(let p=0;p<i;p++)s[p*4+0]=d[p*4+0],s[p*4+1]=d[p*4+1],s[p*4+2]=d[p*4+2],s[p*4+3]=u}else throw new Error(`Unknown zipSig kernel function: ${n}`)}function dt(t,e,o){t=(t%1+1)%1,e=Math.max(0,Math.min(1,e)),o=Math.max(0,Math.min(1,o));const n=o*e,i=n*(1-Math.abs(t*6%2-1)),r=o-n;let s,d,a;const u=t*6;return u<1?[s,d,a]=[n,i,0]:u<2?[s,d,a]=[i,n,0]:u<3?[s,d,a]=[0,n,i]:u<4?[s,d,a]=[0,i,n]:u<5?[s,d,a]=[i,0,n]:[s,d,a]=[n,0,i],[Math.round((s+r)*255),Math.round((d+r)*255),Math.round((a+r)*255)]}function lt(t){let e=0;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n)|0;e=Math.imul(e,1540483477),e^=e>>>15;const o=(e*12.9898+78.233)*43758.5453;return o-Math.floor(o)}function at(t,e,o,n){e.cache.frameId++;const i=je(n,t.timeModel,e.timeState);e.time=i;const r=[];for(const s of t.steps)switch(s.kind){case"evalSig":{const d=x(s.expr,t.signals,e);e.values.f64[s.target]=d,e.cache.sigValues[s.expr]=d,e.cache.sigStamps[s.expr]=e.cache.frameId;break}case"materialize":{const d=E(s.field,s.domain,t.fields,t.signals,t.domains,e,o);e.values.objects.set(s.target,d);break}case"render":{const d=t.domains.get(s.domain);if(!d)throw new Error(`Domain ${s.domain} not found`);const a=E(s.position,s.domain,t.fields,t.signals,t.domains,e,o),u=E(s.color,s.domain,t.fields,t.signals,t.domains,e,o);let p;if(s.size!==void 0){const f=t.signals.has(s.size);t.fields.has(s.size)?p=E(s.size,s.domain,t.fields,t.signals,t.domains,e,o):f?p=x(s.size,t.signals,e):p=10}else p=10;r.push({kind:"instances2d",count:d.count,position:a,color:u,size:p});break}default:{const d=s;throw new Error(`Unknown step kind: ${d.kind}`)}}return{version:1,passes:r}}function ct(t,e,o,n){t.fillStyle="#000000",t.fillRect(0,0,o,n);for(const i of e.passes)pt(t,i,o,n)}function pt(t,e,o,n){if(e.kind==="instances2d")ut(t,e,o,n);else throw new Error(`Unknown pass kind: ${e.kind}`)}function ut(t,e,o,n){const i=e.position,r=e.color,s=typeof e.size=="number"?null:e.size,d=typeof e.size=="number"?e.size:3;for(let a=0;a<e.count;a++){const u=i[a*2]*o,p=i[a*2+1]*n,f=s?s[a]:d;t.fillStyle=`rgba(${r[a*4]},${r[a*4+1]},${r[a*4+2]},${r[a*4+3]/255})`,t.fillRect(u-f/2,p-f/2,f,f)}}const X=document.getElementById("log"),ft=document.getElementById("stats");function M(t,e="info"){const o=document.createElement("div");o.className=`log-${e}`,o.textContent=`[${new Date().toISOString().slice(11,19)}] ${t}`,X.appendChild(o),X.scrollTop=X.scrollHeight,console.log(`[${e}] ${t}`)}let K=null,N=null;function Q(t){M(`Building patch with ${t} particles...`);const e=ce(i=>{const r=i.addBlock("InfiniteTimeRoot",{periodMs:16e3}),s=i.addBlock("DomainN",{n:t,seed:42}),d=i.addBlock("FieldFromDomainId",{}),a=i.addBlock("ConstFloat",{value:.5}),u=i.addBlock("ConstFloat",{value:.5}),p=i.addBlock("ConstFloat",{value:.35}),f=i.addBlock("ConstFloat",{value:.08}),m=i.addBlock("ConstFloat",{value:3}),g=i.addBlock("FieldPulse",{}),y=i.addBlock("ConstFloat",{value:2}),I=i.addBlock("FieldGoldenAngle",{turns:50}),F=i.addBlock("FieldAngularOffset",{}),v=i.addBlock("FieldAdd",{}),P=i.addBlock("FieldRadiusSqrt",{}),S=i.addBlock("FieldPolarToCartesian",{}),T=i.addBlock("ConstFloat",{value:.012}),te=i.addBlock("ConstFloat",{value:.012}),A=i.addBlock("FieldJitter2D",{}),oe=i.addBlock("ConstFloat",{value:.85}),ne=i.addBlock("ConstFloat",{value:.9}),Z=i.addBlock("FieldHueFromPhase",{}),q=i.addBlock("HsvToRgb",{}),ie=i.addBlock("ConstFloat",{value:3}),re=i.addBlock("ConstFloat",{value:2}),se=i.addBlock("ConstFloat",{value:1}),B=i.addBlock("FieldPulse",{}),R=i.addBlock("RenderInstances2D",{});i.wire(s,"domain",d,"domain"),i.wire(s,"domain",R,"domain"),i.wire(r,"phase",g,"phase"),i.wire(r,"phase",F,"phase"),i.wire(r,"phase",Z,"phase"),i.wire(d,"id01",g,"id01"),i.wire(p,"out",g,"base"),i.wire(f,"out",g,"amplitude"),i.wire(m,"out",g,"spread"),i.wire(d,"id01",I,"id01"),i.wire(d,"id01",F,"id01"),i.wire(d,"id01",Z,"id01"),i.wire(d,"id01",P,"id01"),i.wire(y,"out",F,"spin"),i.wire(I,"angle",v,"a"),i.wire(F,"offset",v,"b"),i.wire(a,"out",S,"centerX"),i.wire(u,"out",S,"centerY"),i.wire(g,"value",P,"radius"),i.wire(v,"out",S,"angle"),i.wire(P,"radius",S,"radius"),i.wire(S,"pos",A,"pos"),i.wire(s,"rand",A,"rand"),i.wire(T,"out",A,"amountX"),i.wire(te,"out",A,"amountY"),i.wire(Z,"hue",q,"hue"),i.wire(oe,"out",q,"sat"),i.wire(ne,"out",q,"val"),i.wire(r,"phase",B,"phase"),i.wire(d,"id01",B,"id01"),i.wire(ie,"out",B,"base"),i.wire(re,"out",B,"amplitude"),i.wire(se,"out",B,"spread"),i.wire(A,"pos",R,"pos"),i.wire(q,"color",R,"color"),i.wire(B,"value",R,"size")});M(`Patch built: ${e.blocks.size} blocks, ${e.edges.length} edges`);const o=Ue(e);if(o.kind!=="ok")throw M(`Compile failed: ${JSON.stringify(o.errors)}`,"error"),new Error("Compile failed");const n=o.program;M(`Compiled: ${n.signals.size} signals, ${n.fields.size} fields, ${n.steps.length} steps`),K=n,N=We(n.slotCount)}const V=document.getElementById("canvas"),ht=V.getContext("2d"),mt=new _e;Q(5e3);M("Runtime initialized");let C=0,Y=performance.now(),b=0,z=0,G=0,L=0,J=0,D=1/0,$=0,_=0;function ee(t){try{const e=performance.now(),o=performance.now(),n=at(K,N,mt,t);L=performance.now()-o;const i=performance.now();ct(ht,n,V.width,V.height),J=performance.now()-i,G=performance.now()-e,z=G,D=Math.min(D,z),$=Math.max($,z),_+=z,C++;const r=performance.now();if(r-Y>500){b=Math.round(C*1e3/(r-Y));const s=1e3/b,d=_/C,a=Math.max(0,Math.round((s-$)/s*100));ft.textContent=`FPS: ${b} | ${L.toFixed(1)}/${J.toFixed(1)}ms | Min/Max: ${D.toFixed(1)}/${$.toFixed(1)}ms`,C=0,Y=r,D=1/0,$=0,_=0}requestAnimationFrame(ee)}catch(e){M(`Runtime error: ${e}`,"error"),console.error(e)}}M("Starting animation loop...");requestAnimationFrame(ee);const gt=document.getElementById("particleSlider"),kt=document.getElementById("particleCount");gt.addEventListener("input",t=>{const e=parseInt(t.target.value);kt.textContent=e.toString(),Q(e),M(`Particle count changed to ${e}`)});
