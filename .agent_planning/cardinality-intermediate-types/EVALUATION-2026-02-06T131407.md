# Evaluation: Cardinality Intermediate Types Bug

## Verdict: CONTINUE

## Summary

Blocks that perform intermediate computations inside their `lower()` functions create expression types using `canonicalType(FLOAT)` or `canonicalSignal(FLOAT)`, which hardcode cardinality to `one`. When these blocks receive field-extent (many) inputs, the intermediate expressions get signal-extent types, violating the cardinality invariant.

## Root Cause (Confirmed via Diagnostic)

The cardinality solver correctly resolves port types (confirmed: Add block output gets `card=many` when field input connected). The resolved types flow correctly through passes 1-6 and into `ctx.outTypes`.

The bug is in **block lower() functions** that construct intermediate expression types from scratch instead of deriving them from `ctx.outTypes` or input types.

### Concrete Example (MakeColorHSL)

```
Expr[41] kernel/zip card=many   ← Add block output (correct: field)
Expr[42] kernel/map card=one    ← MakeColorHSL.wrap01(hInput) with hardcoded floatType
                                   ^^^ BUG: card=one but input is card=many
```

`make-color-hsl.ts:47`: `const floatType = canonicalType(FLOAT, unitTurns(), undefined, contractWrap01());`
This creates `card=one`. Used for all intermediate expressions at lines 55-58.

### Correct Pattern (NormalizeRange)

`normalize-range.ts:45-50` correctly:
1. Gets `outType = ctx.outTypes[0]` (resolved cardinality from solver)
2. Checks input cardinality: `const inCard = requireInst(input.type.extent.cardinality, 'cardinality')`
3. Preserves instance: `withInstance(outType, inCard.instance)`
4. Uses `withoutContract()` for intermediate types

## Affected Blocks

Confirmed with field-input violations:
- **MakeColorHSL** (`color/make-color-hsl.ts`) — creates `floatType` with `canonicalType(FLOAT, ...)`, uses for wrap/clamp intermediates
- **HueRainbow** (`color/hue-rainbow.ts`) — creates `outType` and `floatType` with `canonicalType()`
- **HueShift** (`color/hue-shift.ts`) — creates `floatType` with `canonicalType(FLOAT, unitScalar())`
- **MixColor** (`color/mix-color.ts`) — creates `floatType` with `canonicalType(FLOAT, unitScalar())`
- **DefaultSource** (`signal/default-source.ts`) — uses spread pattern `{ ...canonicalSignal(FLOAT), extent: outType.extent }`
- **Hash** (`signal/hash.ts`) — creates `seedType` with `canonicalSignal(FLOAT)`
- **Deadzone** (`lens/deadzone.ts`) — hardcodes zero constant type

Blocks that are signal-only (Phasor, Lag, SampleHold, Accumulator, Oscillator) have `cardinalityMode: 'signalOnly'` so their hardcoded types are currently correct but fragile.

## Impact

- Simple demo patch fails at runtime (`simple.test.ts`)
- Any patch with field inputs flowing through color/math blocks will fail
- 4 test failures currently: simple demo, cardinality invariants, deserialize, and FloatValueRenderer (last two unrelated)

## Approach Clarity

**HIGH confidence** — the fix pattern is well-established (NormalizeRange, DenormalizeRange, Deadzone already use it). Apply the same pattern to remaining blocks.
