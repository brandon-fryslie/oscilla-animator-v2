# Implementation Context: Stroke Rendering

**Generated**: 2026-01-22
**Bead ID**: oscilla-animator-v2-02h
**For**: RenderAssembler v2 and Canvas2DRenderer stroke implementation

---

## Architecture Overview

### The Rendering Pipeline (Phase 6 Target)

```
ScheduleExecutor.executeFrame()
  ↓
RenderAssembler.assemble()  ← oscilla-animator-v2-583 (DEPENDENCY)
  ↓
DrawPathInstancesOp[] (RenderFrameIR_Future)
  ↓
Canvas2DRenderer.renderFrame()  ← THIS WORK
  ↓
Canvas2D API calls (fill, stroke)
```

### Current State (Before This Work)

- **Renderer**: Fill-only path rendering in `renderPathAtParticle()`
- **RenderIR**: Uses legacy RenderPassIR (not DrawPathInstancesOp)
- **Style**: Only fillColor supported, no stroke properties
- **Coordinate Space**: Control points in normalized [0,1] world space, scaled by width/height

### Target State (After This Work)

- **Renderer**: Fill/stroke/fill+stroke modes via PathStyle
- **RenderIR**: Consumes DrawPathInstancesOp from RenderAssembler v2
- **Style**: Complete stroke control (color, width, join, cap, dash)
- **Coordinate Space**: Control points in local space, instance transforms applied

---

## Key Files

### Primary Implementation Files

1. **`src/render/future-types.ts`** (lines 46-61: PathStyle interface)
   - **Purpose**: Type definitions for future RenderIR
   - **Changes Needed**: Populate strokeColor, strokeWidth, lineJoin, lineCap, dashPattern, dashOffset
   - **Invariant**: All geometry in local space, transforms in world space
   - **Dependencies**: None (pure type definitions)

2. **`src/render/Canvas2DRenderer.ts`** (lines 180-259: renderPathAtParticle)
   - **Purpose**: Canvas2D rendering implementation
   - **Changes Needed**: Stroke style configuration, rendering mode dispatch, dash pattern support
   - **Invariant**: Renderer is pure sink, no shape interpretation
   - **Dependencies**: PathStyle from future-types.ts, topology from shapes/registry

### Supporting Files

3. **`src/runtime/RenderAssembler.ts`** (NEW in oscilla-animator-v2-583)
   - **Purpose**: Transform RenderPassIR → DrawPathInstancesOp
   - **Relevance**: Provides PathStyle values this work consumes
   - **Status**: IN PROGRESS (blocking dependency)
   - **Note**: Do NOT implement RenderAssembler here, only consume its output types

4. **`src/shapes/types.ts`** (PathTopologyDef, PathVerb enums)
   - **Purpose**: Topology and path verb definitions
   - **Relevance**: Used to interpret verbs array in path rendering
   - **Changes Needed**: None (read-only for this work)

5. **`.agent_planning/_future/9-renderer.md`** (Section 4: Explicit style controls)
   - **Purpose**: Specification for renderer future direction
   - **Relevance**: Defines stroke rendering contract
   - **Key Points**: Fill vs stroke separation, viewport scaling, dash pattern support

6. **`.agent_planning/_future/3-local-space-spec-deeper.md`** (Section 6: RenderAssembler algorithm)
   - **Purpose**: Specification for local-space geometry
   - **Relevance**: Explains coordinate space model (local vs world)
   - **Key Points**: Control points in local space, instance transforms in world space

---

## Core Concepts

### PathStyle Interface (Type Definition)

**Location**: `src/render/future-types.ts` lines 46-61

**Current State**:
```typescript
export interface PathStyle {
  readonly fillColor: Uint8ClampedArray;
  readonly strokeColor?: Uint8ClampedArray;       // TODO: implement
  readonly strokeWidth?: number | Float32Array;   // TODO: implement
  readonly fillRule?: 'nonzero' | 'evenodd';
  readonly globalAlpha?: number | Float32Array;
}
```

**Target State** (after this work):
```typescript
export interface PathStyle {
  readonly fillColor: Uint8ClampedArray;

  /** Stroke color: RGBA (uniform: 4 bytes, per-instance: count*4 bytes) */
  readonly strokeColor?: Uint8ClampedArray;

  /** Stroke width in world units (strokeWidthPx = strokeWidth × D, D = min(width, height)) */
  readonly strokeWidth?: number | Float32Array;

  /** Line join style (default: 'miter') */
  readonly lineJoin?: 'miter' | 'bevel' | 'round';

  /** Line cap style (default: 'butt') */
  readonly lineCap?: 'butt' | 'round' | 'square';

  /** Dash pattern in world units (scaled to pixels by D) */
  readonly dashPattern?: number[];

  /** Dash offset in world units (scaled to pixels by D) */
  readonly dashOffset?: number;

  readonly fillRule?: 'nonzero' | 'evenodd';
  readonly globalAlpha?: number | Float32Array;
}
```

**Key Design Decisions**:
- Optional fields maintain backward compatibility (fill-only still works)
- World units for strokeWidth ensure viewport-relative scaling
- Uniform vs per-instance via type union (number | Float32Array)
- Canvas2D API types reused directly (lineJoin, lineCap enums match Canvas API)

---

### Viewport Scaling Model

**Spec Reference**: `.agent_planning/_future/9-renderer.md` section 3 & 4

**Problem**: Stroke width must scale with viewport size to remain visible

**Solution**: D = min(width, height)

**Formula**: `strokeWidthPx = strokeWidth × D`

**Why min()?**
- Ensures isotropic scaling (no aspect ratio distortion)
- Matches instance `size` scaling behavior (consistent semantics)
- Prevents strokes becoming invisibly thin on narrow viewports

**Example**:
```typescript
// Viewport: 1920x1080
const D = Math.min(1920, 1080); // = 1080
const strokeWidth = 0.01; // world units
const strokeWidthPx = strokeWidth * D; // = 10.8 pixels

// Viewport: 800x600
const D2 = Math.min(800, 600); // = 600
const strokeWidthPx2 = strokeWidth * D2; // = 6 pixels (proportionally thinner)
```

**Implementation**:
```typescript
function calculateStrokeWidthPx(strokeWidth: number, width: number, height: number): number {
  const D = Math.min(width, height);
  return strokeWidth * D;
}
```

---

### Rendering Modes

**Spec Reference**: `.agent_planning/_future/9-renderer.md` section 4

**Three Modes**:

1. **Fill-only** (current behavior, preserve):
   - `fillColor` present, `strokeColor` absent
   - Call `ctx.fill()` only
   - Example: Solid shapes, no outline

2. **Stroke-only** (NEW):
   - `strokeColor` present, `fillColor` absent
   - Call `ctx.stroke()` only
   - Example: Wireframe shapes, outlines

3. **Fill+stroke** (NEW):
   - Both `fillColor` and `strokeColor` present
   - Call `ctx.fill()` THEN `ctx.stroke()`
   - Example: Shapes with borders

**Critical Ordering**: Fill before stroke
- Canvas2D stroke is centered on path (half inside, half outside)
- If stroke drawn first, fill would cover inner half
- Correct: fill interior, then stroke over it

**Implementation Pattern**:
```typescript
// Mode detection
const hasFill = style.fillColor !== undefined;
const hasStroke = style.strokeColor !== undefined;

if (!hasFill && !hasStroke) {
  console.warn('Path has no fill or stroke color, skipping render');
  return;
}

// Render
ctx.beginPath();
// ... build path from verbs/points ...

if (hasFill) {
  ctx.fillStyle = rgbaToCSS(style.fillColor, instanceIndex);
  ctx.fill();
}

if (hasStroke) {
  ctx.strokeStyle = rgbaToCSS(style.strokeColor, instanceIndex);
  ctx.lineWidth = calculateStrokeWidthPx(getStrokeWidth(style, instanceIndex), width, height);
  ctx.lineJoin = style.lineJoin ?? 'miter';
  ctx.lineCap = style.lineCap ?? 'butt';

  if (style.dashPattern) {
    const D = Math.min(width, height);
    ctx.setLineDash(style.dashPattern.map(v => v * D));
    ctx.lineDashOffset = (style.dashOffset ?? 0) * D;
  } else {
    ctx.setLineDash([]); // solid stroke
  }

  ctx.stroke();
}
```

---

### Dash Patterns

**Spec Reference**: `.agent_planning/_future/9-renderer.md` section 4

**Purpose**: Dashed or dotted strokes (e.g., selection outlines, animated paths)

**Canvas2D API**:
- `ctx.setLineDash(segments: number[])`: Alternating dash/gap lengths in PIXELS
- `ctx.lineDashOffset`: Offset into pattern in PIXELS

**Scaling Required**: Canvas2D expects pixels, PathStyle provides world units

**Algorithm**:
```typescript
const D = Math.min(width, height);
const dashPatternPx = style.dashPattern.map(length => length * D);
ctx.setLineDash(dashPatternPx);

if (style.dashOffset !== undefined) {
  ctx.lineDashOffset = style.dashOffset * D;
}
```

**Examples**:
```typescript
// Dashed line: 5 units dash, 3 units gap
dashPattern: [5, 3]

// Dotted line: 1 unit dot, 2 units gap
dashPattern: [1, 2]

// Dash-dot pattern: 5 dash, 2 gap, 1 dot, 2 gap
dashPattern: [5, 2, 1, 2]

// Solid line (no dash)
dashPattern: [] // or undefined
```

**Animation Pattern** (future):
```typescript
// Marching ants: animate dashOffset over time
dashOffset: (t % 8) // cycles through pattern
```

---

### Uniform vs Per-Instance Values

**Design Principle**: Support both for maximum flexibility

**Uniform Values** (single value for all instances):
- `strokeColor`: Uint8ClampedArray length 4 (single RGBA)
- `strokeWidth`: number (scalar)
- Benefits: Lower memory, faster rendering (set once per pass)

**Per-Instance Values** (unique per instance):
- `strokeColor`: Uint8ClampedArray length count*4 (RGBA per instance)
- `strokeWidth`: Float32Array length count (one per instance)
- Benefits: Expressive (each instance can differ), modulatable

**Detection**:
```typescript
function isUniformColor(color: Uint8ClampedArray, count: number): boolean {
  return color.length === 4; // uniform: single RGBA
}

function getInstanceColor(color: Uint8ClampedArray, instanceIndex: number): [number, number, number, number] {
  if (color.length === 4) {
    // Uniform: same color for all instances
    return [color[0], color[1], color[2], color[3]];
  } else {
    // Per-instance: index into array
    const offset = instanceIndex * 4;
    return [color[offset], color[offset + 1], color[offset + 2], color[offset + 3]];
  }
}

function getStrokeWidth(style: PathStyle, instanceIndex: number): number {
  if (style.strokeWidth === undefined) return 0;
  if (typeof style.strokeWidth === 'number') {
    return style.strokeWidth; // uniform
  } else {
    return style.strokeWidth[instanceIndex]; // per-instance
  }
}
```

---

### Canvas2D State Management

**Spec Reference**: Existing `Canvas2DRenderer.ts` patterns

**Principle**: Isolate instance rendering state

**Pattern** (already used):
```typescript
for (let i = 0; i < pass.count; i++) {
  ctx.save(); // Push state
  ctx.translate(x, y); // Instance transform

  // ... configure style, render path ...

  ctx.restore(); // Pop state (resets transforms, style)
}
```

**State to Manage**:
- `ctx.fillStyle` / `ctx.strokeStyle`: Per-instance colors
- `ctx.lineWidth`: Per-instance stroke width
- `ctx.lineJoin` / `ctx.lineCap`: Usually uniform, but could differ
- `ctx.setLineDash()` / `ctx.lineDashOffset`: Dash pattern

**Optimization Opportunity** (future):
- Batch instances by style hash to minimize state changes
- Not needed for initial implementation (premature optimization)
- Profile first, optimize if evidence of bottleneck

---

## Dependencies

### CRITICAL: oscilla-animator-v2-583 (RenderAssembler v2)

**Status**: IN PROGRESS
**Why Blocking**: This work consumes DrawPathInstancesOp that RenderAssembler produces

**What RenderAssembler Must Provide**:
1. PathStyle with populated stroke fields (strokeColor, strokeWidth)
2. PathGeometry in LOCAL SPACE (not normalized world space)
3. InstanceTransforms with explicit position/size/rotation
4. DrawPathInstancesOp structure conforming to future-types.ts

**Coordination Points**:
- RenderAssembler reads stroke properties from scalar banks
- Field kernels or material definitions expose stroke as modulatable fields
- Renderer (this work) assumes RenderAssembler has done all resolution

**If RenderAssembler Delayed**:
- Option 1: Block this work until dependency complete (PREFERRED)
- Option 2: Prototype stroke in CURRENT renderer as proof-of-concept (technical debt, must migrate later)
- Option 3: Focus on type definitions, tests, documentation (prep work)

---

## Implementation Checklist

### Phase 1: Type Definitions

- [ ] Edit `src/render/future-types.ts`
- [ ] Add strokeColor, strokeWidth, lineJoin, lineCap, dashPattern, dashOffset to PathStyle
- [ ] Write JSDoc comments explaining viewport scaling (D = min(width, height))
- [ ] Add usage examples in comments
- [ ] TypeScript compilation succeeds (no type errors)

### Phase 2: Stroke Width Calculation

- [ ] Create `calculateStrokeWidthPx()` utility function in Canvas2DRenderer.ts
- [ ] Implement: `D = Math.min(width, height); return strokeWidth * D;`
- [ ] Write unit tests:
  - [ ] Square viewport (width === height)
  - [ ] Wide viewport (width > height, expect D = height)
  - [ ] Tall viewport (height > width, expect D = width)
  - [ ] Zero width (edge case, expect 0 or error)
  - [ ] Negative width (validation, should error)
- [ ] Document why min() used (isotropic scaling)

### Phase 3: Rendering Mode Dispatch

- [ ] Modify `renderPathAtParticle()` in Canvas2DRenderer.ts
- [ ] Add mode detection: check fillColor, strokeColor presence
- [ ] Implement fill-only branch: `if (hasFill && !hasStroke) ctx.fill()`
- [ ] Implement stroke-only branch: `if (hasStroke && !hasFill) ctx.stroke()`
- [ ] Implement fill+stroke branch: `if (hasFill && hasStroke) { ctx.fill(); ctx.stroke(); }`
- [ ] Add no-op warning: `if (!hasFill && !hasStroke) console.warn(...)`
- [ ] Write unit tests:
  - [ ] Fill-only: verify ctx.fill() called, ctx.stroke() NOT called
  - [ ] Stroke-only: verify ctx.stroke() called, ctx.fill() NOT called
  - [ ] Fill+stroke: verify both called in correct order
  - [ ] No-op: verify warning logged

### Phase 4: Stroke Style Configuration

- [ ] Extract RGBA-to-CSS conversion as reusable utility `rgbaToCSS(color, instanceIndex)`
- [ ] Implement `getInstanceColor()` helper (uniform vs per-instance detection)
- [ ] Implement `getStrokeWidth()` helper (uniform vs per-instance detection)
- [ ] Apply stroke style before ctx.stroke():
  - [ ] ctx.strokeStyle = rgbaToCSS(style.strokeColor, i)
  - [ ] ctx.lineWidth = calculateStrokeWidthPx(getStrokeWidth(style, i), width, height)
  - [ ] ctx.lineJoin = style.lineJoin ?? 'miter'
  - [ ] ctx.lineCap = style.lineCap ?? 'butt'
- [ ] Write unit tests:
  - [ ] Uniform strokeColor: same CSS color for all instances
  - [ ] Per-instance strokeColor: different CSS colors per instance
  - [ ] Uniform strokeWidth: same pixel width for all instances
  - [ ] Per-instance strokeWidth: different pixel widths per instance
  - [ ] lineJoin applied (mock ctx, verify property set)
  - [ ] lineCap applied (mock ctx, verify property set)

### Phase 5: Dash Pattern Support

- [ ] Implement dash pattern scaling in stroke configuration:
  - [ ] Detect dashPattern presence
  - [ ] Scale to pixels: `dashPatternPx = style.dashPattern.map(v => v * D)`
  - [ ] Call `ctx.setLineDash(dashPatternPx)`
  - [ ] Apply dashOffset: `ctx.lineDashOffset = (style.dashOffset ?? 0) * D`
  - [ ] Reset when no dash: `ctx.setLineDash([])` if dashPattern absent
- [ ] Write unit tests:
  - [ ] Dash pattern scaled correctly (verify each segment)
  - [ ] Dash offset applied
  - [ ] Solid stroke when dashPattern undefined
  - [ ] Empty dashPattern treated as solid
  - [ ] Dash state doesn't leak between instances

### Phase 6: Integration & Testing

- [ ] Create integration test with mock DrawPathInstancesOp
- [ ] Visual regression test: render sample paths with stroke
- [ ] Performance test: 10k instances with per-instance stroke colors
- [ ] Verify ctx.save/restore prevents state leaks
- [ ] Update documentation in Canvas2DRenderer.ts
- [ ] Add example usage in code comments

---

## Testing Strategy

### Unit Tests (Isolated Logic)

**File**: `src/render/Canvas2DRenderer.test.ts` (create if doesn't exist)

**Approach**: Mock CanvasRenderingContext2D, verify API calls

**Key Tests**:
1. `calculateStrokeWidthPx()` correctness
2. Rendering mode dispatch (fill/stroke/both)
3. Uniform vs per-instance color indexing
4. Dash pattern scaling math
5. Style application (lineJoin, lineCap)

**Tools**: Vitest, mock canvas context

### Integration Tests (End-to-End)

**File**: `src/render/integration.test.ts` (new)

**Approach**: Full RenderAssembler → Renderer pipeline

**Requires**: oscilla-animator-v2-583 complete (RenderAssembler available)

**Key Tests**:
1. DrawPathInstancesOp → canvas calls (full pipeline)
2. Per-instance stroke colors render correctly
3. Dash patterns animate smoothly (dashOffset variation)
4. No memory leaks over 1000 frames

### Visual Regression Tests

**Approach**: Render to canvas, capture ImageData, compare pixels

**Key Tests**:
1. Fill-only pentagon (baseline, no regression)
2. Stroke-only pentagon (wireframe)
3. Fill+stroke pentagon (border)
4. Dashed stroke pentagon
5. Per-instance stroke colors (rainbow outline)

**Tools**: Canvas ImageData comparison, pixel diff tolerance

---

## Known Limitations & Future Work

### Out of Scope (Deferred)

1. **Gradient Strokes**: Requires gradient system (future Phase 7+)
2. **Stroke Alignment**: Inner/center/outer (Canvas2D limitation, center only)
3. **Per-Vertex Stroke Width**: Variable width along path (requires geometry shader, future GPU renderer)
4. **Miter Limit**: Advanced join control (use Canvas2D default for now)
5. **Stroke-to-Fill Conversion**: Vector export (future export system)

### Canvas2D API Limitations

- Stroke always centered on path (can't do inner/outer alignment)
- No built-in gradient strokes (would need custom shader or fill workaround)
- Performance degrades with many unique styles (state changes expensive)

### Performance Considerations

- Per-instance stroke colors: More state changes = slower
- Mitigation: Future batching by style hash (not in this sprint)
- Benchmark target: 10k instances @ 30fps (per-instance colors), 60fps (uniform)

---

## Symbols & Line Numbers

### `src/render/future-types.ts`

- **Line 46-61**: `PathStyle` interface (MODIFY)
- **Line 73-88**: `PathGeometry` interface (read-only reference)
- **Line 101-116**: `InstanceTransforms` interface (read-only reference)
- **Line 135-147**: `DrawPathInstancesOp` interface (read-only reference)

### `src/render/Canvas2DRenderer.ts`

- **Line 50-64**: `renderFrame()` (entry point, no changes)
- **Line 69-81**: `renderPass()` (dispatch, no changes)
- **Line 96-144**: `renderInstances2D()` (instance loop, minor changes for style)
- **Line 180-259**: `renderPathAtParticle()` (MAJOR CHANGES - stroke logic here)
- **Line 264**: `ShapeMode` type (context reference)
- **Line 275-282**: `convertResolvedShapeToMode()` (read-only reference)

### `src/shapes/types.ts`

- **Line ~20-30**: `PathVerb` enum (MOVE=0, LINE=1, CUBIC=2, QUAD=3, CLOSE=4)
- **Line ~50-60**: `PathTopologyDef` interface (verbs, render)

---

## Quick Reference: Canvas2D Stroke API

```typescript
// Stroke color
ctx.strokeStyle = 'rgba(255, 0, 0, 1.0)'; // red, fully opaque

// Stroke width (pixels)
ctx.lineWidth = 5;

// Line join (how corners connect)
ctx.lineJoin = 'miter'; // sharp corners
ctx.lineJoin = 'round'; // rounded corners
ctx.lineJoin = 'bevel'; // flattened corners

// Line cap (how ends terminate)
ctx.lineCap = 'butt';   // flat, flush with endpoints
ctx.lineCap = 'round';  // rounded
ctx.lineCap = 'square'; // flat, extends past endpoints

// Dash pattern (alternating dash/gap lengths, in pixels)
ctx.setLineDash([10, 5]); // 10px dash, 5px gap, repeat
ctx.setLineDash([]);      // solid (reset)

// Dash offset (offset into pattern, in pixels)
ctx.lineDashOffset = 0; // start at beginning of pattern
ctx.lineDashOffset = 5; // start 5px into pattern (animatable)

// Draw stroke
ctx.stroke(); // strokes the current path
```

---

## Contact & Questions

**Bead Owner**: bmf
**Related Beads**: oscilla-animator-v2-583 (RenderAssembler v2)
**Spec Questions**: See `.agent_planning/_future/9-renderer.md` section 4
**Implementation Questions**: Comment in bead or create sub-task

---

## Summary

This work adds complete stroke rendering to the Canvas2DRenderer by:

1. Extending PathStyle with stroke properties (color, width, join, cap, dash)
2. Implementing viewport-relative stroke width scaling (D = min(width, height))
3. Supporting three rendering modes: fill-only, stroke-only, fill+stroke
4. Configuring Canvas2D stroke appearance (lineJoin, lineCap)
5. Scaling and applying dash patterns for dashed/dotted strokes

The implementation is blocked on oscilla-animator-v2-583 (RenderAssembler v2) completing, as it consumes DrawPathInstancesOp structures that RenderAssembler produces.

Upon completion, Oscilla v2 will have full stroke rendering parity with modern vector graphics tools.
