# Sprint Breakdown: Stroke Rendering

**Generated**: 2026-01-22
**Bead ID**: oscilla-animator-v2-02h
**Estimated Duration**: 4 days (assumes RenderAssembler v2 complete)

---

## Sprint Structure

This sprint implements stroke rendering in DrawPathInstancesOp across 6 phases:

1. **Type Definitions** (4 hours) - Define PathStyle stroke fields
2. **Stroke Width Calculation** (4 hours) - Viewport scaling logic
3. **Rendering Mode Dispatch** (8 hours) - Fill/stroke/both logic
4. **Stroke Style Application** (10 hours) - Color, width, join, cap configuration
5. **Dash Pattern Support** (6 hours) - Dashed/dotted strokes
6. **Integration & Testing** (8 hours) - Visual tests, performance, docs

**Total**: ~40 hours (~5 working days, accounting for context switching)

---

## Day 1: Foundations (8 hours)

### Morning: Type Definitions (4 hours)

**Tasks**:
- [ ] Edit `src/render/future-types.ts` PathStyle interface
- [ ] Add `strokeColor?: Uint8ClampedArray` field
- [ ] Add `strokeWidth?: number | Float32Array` field
- [ ] Add `lineJoin?: 'miter' | 'bevel' | 'round'` field
- [ ] Add `lineCap?: 'butt' | 'round' | 'square'` field
- [ ] Add `dashPattern?: number[]` field
- [ ] Add `dashOffset?: number` field
- [ ] Write JSDoc comments explaining:
  - Viewport scaling: strokeWidthPx = strokeWidth × min(width, height)
  - Uniform vs per-instance value detection rules
  - World units vs pixel units
- [ ] Add usage example in interface comments
- [ ] Verify TypeScript compiles with no errors

**Deliverable**: Complete PathStyle type definition

**Acceptance**: TypeScript compilation succeeds, all fields documented

---

### Afternoon: Stroke Width Calculation (4 hours)

**Tasks**:
- [ ] Create `calculateStrokeWidthPx()` function in Canvas2DRenderer.ts
  ```typescript
  function calculateStrokeWidthPx(
    strokeWidth: number,
    width: number,
    height: number
  ): number {
    const D = Math.min(width, height);
    return strokeWidth * D;
  }
  ```
- [ ] Add JSDoc explaining D = min(width, height) rationale
- [ ] Create `src/render/Canvas2DRenderer.test.ts` (if doesn't exist)
- [ ] Write unit tests:
  - [ ] Square viewport: width=1000, height=1000, strokeWidth=0.01 → expect 10
  - [ ] Wide viewport: width=1920, height=1080, strokeWidth=0.01 → expect 10.8
  - [ ] Tall viewport: width=800, height=1200, strokeWidth=0.02 → expect 16
  - [ ] Zero stroke width: expect 0 (edge case)
  - [ ] Negative stroke width: expect error or 0 (validation)
- [ ] All tests pass

**Deliverable**: Tested stroke width calculation utility

**Acceptance**: 5 unit tests pass, function pure (no side effects)

---

## Day 2: Rendering Modes (8 hours)

### Morning & Afternoon: Mode Dispatch Logic (8 hours)

**Tasks**:
- [ ] Modify `renderPathAtParticle()` in Canvas2DRenderer.ts
- [ ] Add mode detection before path construction:
  ```typescript
  const hasFill = style.fillColor !== undefined;
  const hasStroke = style.strokeColor !== undefined;

  if (!hasFill && !hasStroke) {
    console.warn('[Canvas2DRenderer] Path has no fill or stroke, skipping');
    return;
  }
  ```
- [ ] Refactor existing fill-only code:
  - [ ] Move `ctx.fill()` into conditional: `if (hasFill) { ... }`
  - [ ] Preserve existing fillStyle logic
- [ ] Add stroke-only branch:
  ```typescript
  if (hasStroke) {
    ctx.strokeStyle = rgbaToCSS(style.strokeColor, instanceIndex);
    ctx.lineWidth = calculateStrokeWidthPx(
      getStrokeWidth(style, instanceIndex),
      width,
      height
    );
    ctx.stroke();
  }
  ```
- [ ] Ensure fill-before-stroke ordering (fill first, stroke second)
- [ ] Write mode dispatch tests:
  - [ ] Fill-only: Mock ctx, verify fill() called, stroke() NOT called
  - [ ] Stroke-only: Mock ctx, verify stroke() called, fill() NOT called
  - [ ] Fill+stroke: Mock ctx, verify fill() then stroke() in order
  - [ ] No-op: Mock console.warn, verify warning logged
- [ ] All tests pass

**Deliverable**: Three rendering modes working correctly

**Acceptance**: 4 mode tests pass, no regression in fill-only rendering

---

## Day 3: Stroke Style Configuration (10 hours)

### Morning: Color Utilities (3 hours)

**Tasks**:
- [ ] Extract existing RGBA-to-CSS conversion as reusable utility:
  ```typescript
  function rgbaToCSS(color: Uint8ClampedArray, instanceIndex: number): string {
    const [r, g, b, a] = getInstanceColor(color, instanceIndex);
    return `rgba(${r},${g},${b},${a / 255})`;
  }
  ```
- [ ] Implement `getInstanceColor()` helper:
  ```typescript
  function getInstanceColor(
    color: Uint8ClampedArray,
    instanceIndex: number
  ): [number, number, number, number] {
    if (color.length === 4) {
      // Uniform: same for all instances
      return [color[0], color[1], color[2], color[3]];
    } else {
      // Per-instance: index by instance
      const offset = instanceIndex * 4;
      return [color[offset], color[offset + 1], color[offset + 2], color[offset + 3]];
    }
  }
  ```
- [ ] Write color utility tests:
  - [ ] Uniform color: 4-byte array, all instances get same color
  - [ ] Per-instance color: n*4-byte array, each instance gets unique color
  - [ ] RGBA-to-CSS conversion: verify CSS string format
- [ ] Tests pass

**Deliverable**: Reusable color utilities with uniform/per-instance support

**Acceptance**: 3 tests pass, DRY principle satisfied

---

### Afternoon: Stroke Width & Style (4 hours)

**Tasks**:
- [ ] Implement `getStrokeWidth()` helper:
  ```typescript
  function getStrokeWidth(style: PathStyle, instanceIndex: number): number {
    if (style.strokeWidth === undefined) return 0;
    if (typeof style.strokeWidth === 'number') {
      return style.strokeWidth; // uniform
    } else {
      return style.strokeWidth[instanceIndex]; // per-instance
    }
  }
  ```
- [ ] Apply stroke style in stroke rendering branch:
  ```typescript
  if (hasStroke) {
    ctx.strokeStyle = rgbaToCSS(style.strokeColor!, instanceIndex);
    ctx.lineWidth = calculateStrokeWidthPx(
      getStrokeWidth(style, instanceIndex),
      width,
      height
    );
    ctx.lineJoin = style.lineJoin ?? 'miter';
    ctx.lineCap = style.lineCap ?? 'butt';
    ctx.stroke();
  }
  ```
- [ ] Write stroke width tests:
  - [ ] Uniform strokeWidth: number, all instances same pixel width
  - [ ] Per-instance strokeWidth: Float32Array, each instance different width
- [ ] Write lineJoin/lineCap tests:
  - [ ] Mock ctx, verify lineJoin property set
  - [ ] Mock ctx, verify lineCap property set
  - [ ] Verify defaults ('miter', 'butt') when undefined
- [ ] Tests pass

**Deliverable**: Complete stroke style configuration

**Acceptance**: 5 tests pass, stroke appearance configurable

---

### Late Afternoon: Integration Check (3 hours)

**Tasks**:
- [ ] Create mock DrawPathInstancesOp with stroke properties
- [ ] Test full renderPathAtParticle() flow:
  - [ ] Uniform strokeColor + uniform strokeWidth
  - [ ] Per-instance strokeColor + per-instance strokeWidth
  - [ ] Mix: uniform strokeColor + per-instance strokeWidth
- [ ] Verify ctx.save/restore prevents state leaks
- [ ] Visual inspection: render pentagon with stroke to actual canvas
- [ ] No errors or warnings in console

**Deliverable**: Stroke style rendering end-to-end

**Acceptance**: Visual test shows correct stroke color, width, join, cap

---

## Day 4: Dash Patterns & Testing (8 hours)

### Morning: Dash Pattern Implementation (3 hours)

**Tasks**:
- [ ] Add dash pattern logic to stroke rendering branch:
  ```typescript
  if (hasStroke) {
    // ... existing stroke style setup ...

    if (style.dashPattern && style.dashPattern.length > 0) {
      const D = Math.min(width, height);
      const dashPatternPx = style.dashPattern.map(length => length * D);
      ctx.setLineDash(dashPatternPx);

      if (style.dashOffset !== undefined) {
        ctx.lineDashOffset = style.dashOffset * D;
      }
    } else {
      ctx.setLineDash([]); // solid stroke
    }

    ctx.stroke();
  }
  ```
- [ ] Write dash pattern tests:
  - [ ] dashPattern scaling: verify each segment scaled by D
  - [ ] dashOffset applied correctly
  - [ ] Solid stroke when dashPattern undefined
  - [ ] Empty dashPattern `[]` treated as solid
  - [ ] Dash state reset between passes (no leak)
- [ ] Tests pass

**Deliverable**: Dashed/dotted stroke support

**Acceptance**: 5 tests pass, dash patterns render correctly

---

### Late Morning: Visual Regression Tests (2 hours)

**Tasks**:
- [ ] Create visual test harness (render to canvas, capture ImageData)
- [ ] Render test cases:
  1. **Fill-only pentagon**: Solid color, no stroke (baseline)
  2. **Stroke-only pentagon**: Wireframe outline, no fill
  3. **Fill+stroke pentagon**: Solid interior + border
  4. **Dashed stroke pentagon**: Dashed outline
  5. **Rainbow stroke**: Per-instance stroke colors (5 pentagons, 5 colors)
- [ ] Capture ImageData, save as reference images (or pixel hashes)
- [ ] Regression test: compare current render to reference
- [ ] Visual inspection: all test cases look correct

**Deliverable**: Visual regression test suite

**Acceptance**: 5 test images captured, no visual artifacts

---

### Afternoon: Performance & Documentation (3 hours)

**Tasks**:
- [ ] Performance benchmark:
  - [ ] 10,000 instances, uniform stroke color → measure frame time
  - [ ] 10,000 instances, per-instance stroke colors → measure frame time
  - [ ] Target: <16ms (uniform), <33ms (per-instance)
- [ ] Profile if performance target missed:
  - [ ] Identify bottleneck (style changes? color conversion?)
  - [ ] Document findings, defer optimization if non-critical
- [ ] Update Canvas2DRenderer.ts documentation:
  - [ ] Update file header comment with stroke rendering notes
  - [ ] Add example usage in renderPathAtParticle() JSDoc
  - [ ] Document known limitations (no gradient strokes, center alignment only)
- [ ] Update PathStyle interface JSDoc with complete usage example
- [ ] Final code review self-check:
  - [ ] No TODOs left uncommented
  - [ ] All tests passing
  - [ ] TypeScript strict mode happy
  - [ ] No console errors/warnings

**Deliverable**: Performance benchmarks, complete documentation

**Acceptance**: Benchmarks meet targets (or documented if not), docs complete

---

## Day 5: Contingency & Polish (8 hours)

*Reserve day for:*
- [ ] Fixing unexpected bugs discovered during testing
- [ ] Addressing RenderAssembler v2 integration issues (if dependency just completed)
- [ ] Performance optimization if benchmarks failed
- [ ] Additional edge case testing
- [ ] Code review feedback incorporation
- [ ] Documentation improvements

---

## Post-Sprint: Integration Verification

**Prerequisites**: oscilla-animator-v2-583 (RenderAssembler v2) complete

**Tasks**:
- [ ] RenderAssembler populates PathStyle stroke fields from scalar banks
- [ ] ScheduleExecutor → RenderAssembler → Canvas2DRenderer pipeline working
- [ ] Field kernels expose stroke properties (strokeColor, strokeWidth) as modulatable
- [ ] End-to-end test: Modulate stroke width over time (animation)
- [ ] End-to-end test: Per-instance stroke colors from field expression
- [ ] Visual confirmation in full application (not just unit tests)

**Deliverable**: Stroke rendering fully integrated with runtime

**Acceptance**: Modulated stroke properties animate smoothly, no integration errors

---

## Task Dependencies

```
Type Definitions
  ↓
Stroke Width Calculation
  ↓
Rendering Mode Dispatch ←┐
  ↓                       │
Stroke Style Application  │
  ↓                       │
Dash Pattern Support      │
  ↓                       │
Integration & Testing ────┘

RenderAssembler v2 (oscilla-animator-v2-583) → Integration Verification
```

---

## Daily Standup Format

**Yesterday**:
- Completed: [Phase X tasks]
- Tests: [N passed / M total]
- Blockers: [None | Issue description]

**Today**:
- Goal: [Phase Y]
- Tasks: [Top 3 priorities]
- Risk: [Any concerns]

**Tomorrow**:
- Next: [Phase Z preview]

---

## Definition of Done (Sprint-Level)

- [ ] All 6 phases complete
- [ ] All acceptance criteria in DOD-20260122.md met
- [ ] Test coverage >90% for new stroke code
- [ ] Performance benchmarks meet targets (or limitations documented)
- [ ] Visual regression tests pass
- [ ] Documentation complete (JSDoc, examples, limitations)
- [ ] TypeScript compilation: 0 errors
- [ ] Code review approved
- [ ] Integration with RenderAssembler v2 verified (post-dependency)

---

## Risk Mitigation

### Risk: RenderAssembler v2 Not Complete by Sprint Start

**Plan A**: Block sprint start, wait for dependency
**Plan B**: Prototype stroke in CURRENT renderer as proof-of-concept (discard after)
**Plan C**: Focus on type definitions, utilities, tests (prep work, no integration)

**Decision Point**: Day before sprint start (check oscilla-animator-v2-583 status)

### Risk: Performance Below Targets

**Threshold**: >33ms for 10k instances (30fps)
**Action**: Profile, identify bottleneck
**Options**:
1. Optimize color conversion (cache CSS strings)
2. Batch by style hash (minimize state changes)
3. Document as known limitation, defer optimization

**Decision Point**: Day 4 afternoon (during benchmarking)

### Risk: Visual Artifacts (Stroke Clipping, Aliasing)

**Detection**: Visual regression tests
**Root Cause**: Usually Canvas2D API quirks or coordinate rounding
**Mitigation**: Investigate Canvas2D docs, adjust rendering logic
**Contingency**: Document as browser limitation if unfixable

**Decision Point**: Day 4 late morning (during visual tests)

---

## Success Metrics

### Completion Criteria

- **Functional**: All 3 rendering modes work, stroke configurable
- **Quality**: >90% test coverage, 0 TS errors, visual tests pass
- **Performance**: 10k instances @ 30fps minimum (per-instance colors)
- **Documentation**: Complete JSDoc, usage examples, limitations noted

### User Value

- **Artists**: Can add outlines to shapes (visual clarity)
- **Designers**: Dashed strokes for selection, guides
- **Developers**: Stroke width modulatable (responsive designs)

### Technical Debt

- **None Expected**: This work aligns with Phase 6 spec
- **Future Cleanup**: When GPU renderer added, may refactor (but won't remove Canvas2D)

---

## Notes

- **Parallelization**: Days 1-2 could be done by 2 developers (types + calculation in parallel with mode dispatch), but Day 3-4 are sequential
- **Testing Philosophy**: Write tests incrementally (per phase), not all at end
- **Documentation**: Write JSDoc as you code, not as separate task
- **Visual Checks**: Render to actual canvas frequently (catch issues early)

---

## Sprint Retrospective (Post-Completion)

**What Went Well**:
- [To be filled after sprint]

**What Went Poorly**:
- [To be filled after sprint]

**Lessons Learned**:
- [To be filled after sprint]

**Process Improvements**:
- [To be filled after sprint]
