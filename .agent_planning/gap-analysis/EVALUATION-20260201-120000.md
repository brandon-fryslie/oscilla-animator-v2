# Evaluation: Gap Analysis (CanonicalType System Spec vs Implementation)
Timestamp: 2026-02-01-120000
Git Commit: a7178ed

## Executive Summary
Overall: 85% complete | Critical issues: 2 confirmed | Tests reliable: yes (with caveats)

The type system refactor is in strong shape. Build is clean, all 1815 tests pass, and the core type system (CanonicalType, ValueExpr unification, axis validation, legacy cleanup) is genuinely complete. The remaining work is concentrated in two areas that have been correctly identified but not yet fixed: (1) isTypeCompatible impurity and (2) backend type rewriting. Both are real violations, both are scoped, and both are fixable without cascading changes. The SUMMARY.md from the earlier analysis is accurate and current.

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| `npm run typecheck` | PASS | Zero errors |
| `npm run test` | PASS | 1815 passed, 23 skipped, 2 todo |
| Legacy type enforcement | PASS | 0 hits for SigExpr/FieldExpr/EventExpr in production |
| deriveKind enforcement | PASS | 0 hits in production code |
| Forbidden patterns | PASS | instanceId: 6 of 12 threshold (all on step types) |
| Backup file cleanup | NOT ENFORCED | 5 .bak/.backup2 files remain |

## Missing Checks

1. **isTypeCompatible purity test**: No enforcement test prevents block-name parameters from being used in type compatibility checks. Add a test that asserts isTypeCompatible signature has exactly 2 parameters (or does not reference block metadata).
2. **Backend read-only contract test**: No test verifies that backend passes (lower-blocks.ts) do not mutate or rewrite types. An enforcement test grepping for `withInstance` or type-rewriting patterns in `src/compiler/backend/` would catch this.
3. **Backup file cleanup test**: The 5 .bak/.backup2 files should be deleted or a CI check should prevent them from accumulating.

## Findings

### Core Types (CanonicalType, axes, payload, unit)
**Status**: COMPLETE
**Evidence**: `src/core/canonical-types.ts` is the single authority. `defaultUnitForPayload` used only in constructors (line 710). Axis validation gate at `src/compiler/frontend/axis-validate.ts` (297 lines, single enforcer). InferencePayloadType/InferenceCanonicalType properly separated in inference-types.ts.
**Issues**: None blocking.

### IR Expressions (ValueExpr unification)
**Status**: COMPLETE
**Evidence**: SigExpr/FieldExpr/EventExpr deleted. ValueExpr is the sole expression type. All 10 expression kinds carry `type: CanonicalType`. Enforcement tests passing. instanceId on expressions eliminated (only 6 references remain, all on Step types where they belong).
**Issues**: None blocking.

### Naming & Legacy Cleanup
**Status**: COMPLETE (with housekeeping debt)
**Evidence**: deriveKind deleted. Legacy ID aliases deleted. Enforcement tests cover all banned symbols.
**Issues**: 5 backup files remain: `src/compiler/ir/types.ts.bak`, `src/compiler/ir/types.ts.backup2`, `src/compiler/ir/__tests__/bridges.test.ts.bak`, `src/runtime/__tests__/PlacementBasis.test.ts.bak`, `src/runtime/__tests__/FieldKernels-placement.test.ts.bak`. These are harmless but should be deleted.

### Compiler Passes & Adapters
**Status**: PARTIAL -- 2 known violations remain
**Evidence**:
- **isTypeCompatible impurity** (`src/compiler/frontend/analyze-type-graph.ts:55-100`): Function takes `sourceBlockType?: string` and `targetBlockType?: string` params, uses them to query block cardinality metadata. Type compatibility must be a pure function of CanonicalType alone. This is a real violation of invariant #12 ("Kernel/Op Contracts Must Be Type-Driven") and #1 ("Single Authority"). The block-name lookup enables special-casing that will drift.
- **Backend type rewriting** (`src/compiler/backend/lower-blocks.ts:411-428`): Backend rewrites output types with inferred instance IDs using `withInstance()`. This violates the pipeline's read-only backend contract and the spec's requirement that instance resolution happens in the frontend type solver.
**Issues**: Both are P1 (no dependencies, can be fixed independently). Neither causes test failures today because the current block set happens to work with these violations. They are latent correctness risks.

### Runtime & Enforcement
**Status**: PARTIAL -- architectural gaps acknowledged, correctly deferred
**Evidence**:
- Schedule steps use hardcoded `evalSig`/`evalEvent` kinds (`src/compiler/ir/types.ts:252,353`, `src/runtime/ScheduleExecutor.ts:214,432`) rather than type-driven dispatch.
- No branch-scoped state (flat Float64Array storage).
- No explicit lane metadata tracking.
**Issues**: All correctly identified as P2/P5 work with dependencies on design decisions (#6 cardinality polymorphism, etc.). These are not regressions -- they are planned future work.

### Sprint 3 Consumer Errors (~45)
**Status**: RESOLVED
**Evidence**: `npm run typecheck` returns zero errors. The 45 consumer errors from Sprint 3 (type splits + unit restructure) have been fixed. No evidence of them in the current codebase.

## Ambiguities Found

| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| isTypeCompatible | Should cardinality-generic blocks use type-level polymorphism or runtime dispatch? | Current impl uses block-name lookup (runtime dispatch via metadata). Neither approach is wrong, but the block-name param violates type purity. | Medium -- fixable by encoding cardinality mode in CanonicalType extent or by using a separate cardinality-resolution pass before compatibility check. |
| Instance resolution | Should instance IDs be resolved in frontend (type solver) or backend (lowering)? | Backend does it now (lower-blocks.ts:415). Spec says frontend. | Medium -- moving to frontend is mechanical but requires touching type solver output. |
| instanceId on Steps | Is instanceId on StepMaterialize/StepRender correct or should it be in type? | Kept on steps. This seems correct -- steps need operational context beyond what type carries. | Low -- steps are operational instructions, not value expressions. The spec's "instance identity in type" applies to value-producing expressions, not execution steps. |

## SUMMARY.md Accuracy Assessment

The existing SUMMARY.md (updated 2026-02-01) is **accurate and current**. Specific checks:
- P1 items #1 and #2: Both confirmed still present at the exact lines cited.
- P2 items #3-5: All confirmed still present.
- "Resolved Since Last Run" section: All items verified complete.
- Priority ordering: Correct. P1 items have no dependencies, P2 items correctly flagged as blocked.
- Grade assessments: Core Types A+, IR A+, Naming A+, Compiler B+, Runtime B -- all match evidence.

## Old Sprint Plans (Jan 29-30) Relevance

- **Sprint 1 (P1 Independent Fixes)**: DONE. All 13 items complete. Plan is historical.
- **Sprint 2 (Validation Gate)**: DONE. All 6 items complete. Plan is historical.
- **Sprint 3 (Type Splits + Unit Restructure)**: DONE. Core complete, consumer errors resolved. Plan is historical.
- **Sprint 4 (ValueExpr unification)**: DONE. SigExpr/FieldExpr/EventExpr deleted. Plan is historical.

The old sprint plans are no longer actionable. The SUMMARY.md priority queue is the current work tracker.

## Test Quality Assessment

The enforcement tests are **real** (not theater):
- `no-legacy-types.test.ts`: Greps actual production source for banned patterns. Would catch regressions.
- `forbidden-patterns.test.ts`: Greps for `kind: 'var'` outside inference, AxisTag aliases, instanceId on expressions. Would catch regressions.
- The instanceId threshold (<=12) is generous (actual: 6), but the test correctly excludes comments and the remaining 6 are on Step types not expressions.

**One weakness**: The forbidden-patterns test for `instanceId` (line 89) has a comment saying "TODO: Change to expect(filtered).toEqual([]) after gap analysis Sprint 4 item #25". Sprint 4 #25 is DONE (instanceId removed from expressions), but the test was never tightened. The threshold should be lowered from 12 to match the actual 6, or better yet, the test should be rewritten to check only expression types and reject any instanceId there.

## Recommendations

1. **Fix isTypeCompatible purity** (P1 #1): Remove `sourceBlockType`/`targetBlockType` params. Encode cardinality mode in CanonicalType extent or resolve cardinality before compatibility check. Add enforcement test.
2. **Move instance resolution to frontend** (P1 #2): Move the type rewriting from `lower-blocks.ts:411-428` to the frontend type solver output. Add enforcement test for backend read-only contract.
3. **Tighten instanceId enforcement test**: Lower the threshold from 12 to actual count, or rewrite to check expression types specifically.
4. **Delete backup files**: Remove the 5 .bak/.backup2 files.
5. **Decide P3 items**: Items #6-13 (design decisions) are blocking P2 work. The most important is #6 (cardinality polymorphism strategy) which informs both P1 #1 and P2 #3.

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix

The two P1 critical items are well-scoped, have no dependencies, and the SUMMARY.md provides sufficient context and file references for implementation. The P2/P3 items are correctly deferred behind design decisions.

The only actionable question is: **Does the user want to fix P1 #1 and #2 now, or first resolve the P3 design decisions that would inform a more complete fix?** If P3 #6 (cardinality polymorphism strategy) is decided first, the isTypeCompatible fix can be done "right" the first time rather than potentially needing rework.
