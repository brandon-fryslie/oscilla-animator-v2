# Explore: Gap Analysis (CanonicalType System)
Timestamp: 2026-02-01-120000
Git Commit: a7178ed
Branch: bmf_type_system_refactor

## Build & Test State

### Typecheck
- `npm run typecheck` (tsc -b): CLEAN, zero errors

### Tests
- 121 passed, 7 skipped (128 total files)
- 1815 passed, 23 skipped, 2 todo (1840 total tests)
- Duration: 19.31s

## Critical Item #1: isTypeCompatible Purity

**Status: STILL PRESENT**

File: `src/compiler/frontend/analyze-type-graph.ts:55`
```typescript
function isTypeCompatible(from: CanonicalType, to: CanonicalType, sourceBlockType?: string, targetBlockType?: string): boolean {
```

Lines 79-97 use `targetBlockType` and `sourceBlockType` to look up block metadata (cardinality mode, broadcast policy). This violates the spec requirement that type compatibility is a pure function of CanonicalType only.

## Critical Item #2: Backend Type Rewriting

**Status: STILL PRESENT**

File: `src/compiler/backend/lower-blocks.ts:411-428`
```typescript
// Rewrite outTypes with actual instance ref for downstream blocks.
if (inferredInstance) {
  const instanceDecl = builder.getInstances().get(inferredInstance);
  if (instanceDecl) {
    const ref = makeInstanceRef(instanceDecl.domainType as string, inferredInstance as string);
    outTypes = outTypes.map(t => {
      const card = t.extent.cardinality;
      if (card.kind === 'inst' && card.value.kind === 'many') {
        return withInstance(t, ref);
      }
      return t;
    });
  }
}
```

Backend rewrites types with inferred instance IDs -- violates the read-only backend contract. Should move to frontend.

## P2 #3: Schedule Step Unification

**Status: STILL PRESENT**

File: `src/compiler/ir/types.ts:252,353`
- `StepEvalSig` with `kind: 'evalSig'` (line 252)
- `StepEvalEvent` with `kind: 'evalEvent'` (line 353)

File: `src/runtime/ScheduleExecutor.ts:214,432`
- `case 'evalSig':` (line 214)
- `case 'evalEvent':` (line 432)

These are hardcoded step kinds rather than type-driven dispatch.

## Enforcement Tests

### Forbidden Patterns (src/__tests__/forbidden-patterns.test.ts)
- Checks for AxisTag, payload var kind outside inference, legacy type aliases, instanceId on expressions
- instanceId threshold: <=12 allowed, actual: 6 (all on step types, not expressions) -- PASSING WITH MARGIN

### Legacy Type Enforcement (src/compiler/__tests__/no-legacy-types.test.ts)
- Checks SigExpr/FieldExpr/EventExpr type usage, SigExprId/FieldExprId/EventExprId aliases, deriveKind calls
- All 3 assertions PASSING

### Backup Files Still Present
- `src/compiler/ir/types.ts.bak`
- `src/compiler/ir/types.ts.backup2`
- `src/compiler/ir/__tests__/bridges.test.ts.bak`
- `src/runtime/__tests__/PlacementBasis.test.ts.bak`
- `src/runtime/__tests__/FieldKernels-placement.test.ts.bak`

## defaultUnitForPayload Usage

Only used in `src/core/canonical-types.ts:710` as a constructor default:
```typescript
unit: unit ?? defaultUnitForPayload(payload),
```
This is the allowed usage per spec -- constructors only, not type checking.

## Axis Validation Gate

File: `src/compiler/frontend/axis-validate.ts` (297 lines)
Single enforcement point as required by spec.

## instanceId on IR Types

6 non-comment occurrences in `src/compiler/ir/types.ts`:
- Line 56: IntrinsicPropertyName enum value (correct)
- Line 282: StepMaterialize.instanceId (step type, correct)
- Line 288: StepRender.instanceId (step type, correct)
- Line 329: StepContinuityMapBuild.instanceId (step type, correct)
- Line 340: StepContinuityApply.instanceId (step type, correct)
- Line 423: StepFieldStateWrite? (need to verify)

All remaining instanceId usages are on Step types, not ValueExpr types. This is architecturally correct -- steps need instance context for materialization/rendering, expressions carry it in their type's extent.

## Recent Commit History (30 commits)
Major themes:
- Legacy expression type deletion (SigExpr/FieldExpr/EventExpr)
- deriveKind deletion, replaced with direct extent checks
- Kernel decomposition to opcode sequences
- Enforcement tests added
- Math block extent/domain validation
