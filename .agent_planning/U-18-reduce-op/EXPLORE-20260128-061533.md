Perfect! Now I have comprehensive information. Let me compile the complete analysis:

## U-18: ReduceOp for Field→Scalar Aggregation — Complete Investigation

### 1. **CANONICAL SPECIFICATION**

**File**: `/Users/bmf/code/oscilla-animator-v2/design-docs/CANONICAL-oscilla-v2.5-20260109/topics/04-compilation.md`

#### IR Operation Definition (lines 382-410)
```typescript
type Op =
  // ...
  | { kind: 'reduce_field_to_scalar'; op: ReduceOp; field: FieldSlot; out: ScalarSlot }

type ReduceOp = 'min' | 'max' | 'sum' | 'avg';
```

#### Block System (Topic 02, line 362)
```
| **Reduce** | (future) Min, Max, Sum, Avg over field | Field → Signal aggregation |
```

**Spec Status**: Marked as **(future)** but fully specified in IR operations. The four operations are: `'min'`, `'max'`, `'sum'`, `'avg'`.

---

### 2. **EXPRESSION TYPE SYSTEM**

**File**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/types.ts`

#### Current Field Expression Types (lines 196-300)
```typescript
export type FieldExpr =
  | FieldExprConst
  | FieldExprIntrinsic
  | FieldExprBroadcast
  | FieldExprMap
  | FieldExprZip
  | FieldExprZipSig
  | FieldExprArray
  | FieldExprStateRead
  | FieldExprPathDerivative
  | FieldExprPlacement;
```

**KEY OBSERVATION**: No `FieldExprReduce` variant exists. The opposite operation **does exist**:

#### FieldExprBroadcast (lines 237-241)
```typescript
export interface FieldExprBroadcast {
  readonly kind: 'broadcast';
  readonly signal: SigExprId;
  readonly type: CanonicalType;
}
```

**Status**: Broadcast (scalar→field) is implemented; Reduce (field→scalar) is missing.

#### OpCode Enum (lines 359-401)
The `OpCode` enum includes binary operations like `Min` and `Max` but these are element-wise operations, not aggregations:
```typescript
enum OpCode {
  Min = 'min',   // Element-wise min(a[i], b[i])
  Max = 'max',   // Element-wise max(a[i], b[i])
  // ... etc
}
```

These **cannot** serve as ReduceOp because ReduceOp must aggregate across all lanes.

---

### 3. **TYPE SYSTEM: Field vs Scalar Distinction**

**File**: `/Users/bmf/code/oscilla-animator-v2/src/core/canonical-types.ts`

#### CanonicalType Structure (lines 1-150)
```typescript
export interface CanonicalType {
  readonly payload: PayloadType;     // What (float, vec2, color, etc.)
  readonly cardinality: Cardinality; // Where (zero, one, many(instance))
  readonly temporality: Temporality; // When (continuous, discrete)
  readonly unit: Unit;               // Semantic meaning
}
```

#### Cardinality Helpers (grep results)
```typescript
signalTypeSignal(payload, unit)    // one + continuous (Scalar)
signalTypeField(payload, instance, unit) // many(instance) + continuous (Field)
```

**Key Pattern**: The compiler uses cardinality to distinguish Field<T> (many) from Scalar<T> (one). ReduceOp must implement this transformation: `many → one`.

---

### 4. **MATERIALIZER ARCHITECTURE**

**File**: `/Users/bmf/code/oscilla-animator-v2/src/runtime/Materializer.ts`

#### Field Materialization Path (lines 185-266)
```typescript
export function materialize(
  fieldId: FieldExprId,
  instanceId: string,
  // ...
): ArrayBufferView {
  // Cache check, buffer allocation
  const format = getBufferFormat(expr.type.payload);
  const buffer = pool.alloc(format, count);
  fillBuffer(expr, buffer, ...);
  return buffer;
}
```

#### fillBuffer Switch Statement (lines 271-300+)
Handles all FieldExpr kinds:
```typescript
function fillBuffer(expr: FieldExpr, ...) {
  switch (expr.kind) {
    case 'const': // ... fill with constant
    case 'intrinsic': // ... per-element property
    case 'broadcast': // ... materialize signal into field
    case 'map': // ... apply kernel per-element
    case 'zip': // ... combine multiple fields
    // ... more cases
  }
}
```

**Status**: To add ReduceOp support, we'd need a **new expression type** in the IR and corresponding case in fillBuffer. However, **Reduce doesn't materialize into a buffer**—it aggregates one into a scalar slot.

**Key Insight**: ReduceOp belongs in **Step types** (execution schedule), not in FieldExpr. The IR already has `Step` union at line 481 but doesn't include a reduce step.

---

### 5. **CURRENT IR STEP TYPES**

**File**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/types.ts` (lines 481-597)

```typescript
export type Step =
  | StepEvalSig
  | StepSlotWriteStrided
  | StepMaterialize
  | StepRender
  | StepStateWrite
  | StepFieldStateWrite
  | StepContinuityMapBuild
  | StepContinuityApply
  | StepEvalEvent;
```

**Missing**: No `StepReduceFieldToScalar` or similar. The canonical spec shows `reduce_field_to_scalar` as an Op-level construct in the lowered operations table (04-compilation.md line 394).

---

### 6. **EXISTING PATTERNS: Broadcast vs Reduce**

### Broadcast (Implemented, lines 237-241)
```typescript
FieldExprBroadcast {
  kind: 'broadcast';
  signal: SigExprId;      // Source scalar
  type: CanonicalType;        // Result field type
}
```

**What it does**: Takes a signal value and replicates it per-lane.

### Reduce (NOT IMPLEMENTED)
Would be the inverse:
```typescript
FieldExprReduce {
  kind: 'reduce';
  field: FieldExprId;      // Source field
  op: ReduceOp;            // Aggregation: 'min'|'max'|'sum'|'avg'
  type: CanonicalType;        // Result signal type (cardinality = one)
}
```

---

### 7. **DOMAIN-TRANSFORM PLANNING DOCUMENTS**

**Files**: 
- `/Users/bmf/code/oscilla-animator-v2/.agent_planning/domain-transforms/SPRINT-1769356704-reduce-PLAN.md`
- `/Users/bmf/code/oscilla-animator-v2/.agent_planning/gap-analysis/unimplemented/topic-04-compilation.md`

#### Gap Analysis Entry (U-18):
```
### U-18: ReduceOp for field→scalar aggregation
Spec requirement: Combine step with ReduceOp to aggregate field values into scalar
Scope: new expression type + materializer support
Blocks: nothing — standalone
Evidence of absence: No "ReduceOp" or "reduce" operation in field expression types
```

#### Reduce Block Sprint Definition:
- **Block type**: 'Reduce'
- **Input**: Field<T> (polymorphic)
- **Parameter**: op ∈ {mean, sum, min, max, rms, any, all}
- **Output**: Scalar<T> (same payload, cardinality one)
- **Status**: READY FOR IMPLEMENTATION

---

### 8. **RUNTIME EVALUATION EXPECTATIONS**

From sprint plan (P1):
```typescript
// Pseudo-implementation required:
mean: sum all values / count
sum: accumulate all values
min/max: iterate finding extrema
rms: sqrt(mean(x²))
any: OR all values (for bool)
all: AND all values (for bool)
```

**Edge cases**:
- Empty field (0 lanes) → return 0
- Single lane → return that value

---

### 9. **TYPE CHECKING REQUIREMENTS**

From sprint plan (P2):
```typescript
// Must enforce:
Field<T> → Reduce → Scalar<T>
Input payload determines output payload
Operation parameter doesn't affect type signature
```

**Files involved**:
- `src/compiler/passes-v2/pass0-payload-resolution.ts` — Must recognize Reduce
- `src/expr/typecheck.ts` — Expression DSL may need to support reduce() function

---

## **SUMMARY: Implementation Gaps**

| Component | Location | Status | Gap |
|-----------|----------|--------|-----|
| **Spec** | 04-compilation.md:394 | ✓ Fully defined | `type ReduceOp = 'min'\|'max'\|'sum'\|'avg'` |
| **IR Field Expr** | types.ts:196-206 | ✗ Missing | No `FieldExprReduce` variant |
| **IR Step Types** | types.ts:481-597 | ✗ Missing | No `StepReduceFieldToScalar` |
| **Materializer** | Materializer.ts:271-300 | ✗ Missing | No case for reduce in fillBuffer |
| **Block Registry** | adapter-blocks.ts | ✗ Missing | No Reduce block registered |
| **Type Validation** | pass0-payload-resolution.ts | ✗ Missing | No Reduce handling |
| **Runtime Support** | (various) | ✗ Missing | Aggregation kernel not implemented |
| **Tests** | (no test files) | ✗ Missing | No test coverage |

All architectural patterns **already exist** (Broadcast as the dual pattern). Implementation should follow the sprint plan using existing infrastructure.
