# Evaluation: Units and Type Inference

Generated: 2026-01-24T18:05:00Z
Verdict: CONTINUE (with architectural conflict to resolve)

## Current State Summary

The system has **two competing mechanisms** for unit resolution that are causing the 16 test failures:

### What Exists

1. **Pass 0 (`pass0-polymorphic-types.ts`)**: Ad-hoc neighbor inference
   - Resolves `payloadType` AND `resolvedUnit` for generic blocks
   - Stores results in `block.params.payloadType` and `block.params.resolvedUnit`
   - Works by looking at connected ports' types

2. **Pass 1 (`pass1-type-constraints.ts`)**: Constraint solver (union-find)
   - Reads **raw definition types** (with `unitVar`) from block registry
   - Does NOT read `block.params.resolvedUnit`
   - Attempts to solve constraints from scratch
   - Has proper error handling (UnresolvedUnit, ConflictingUnits)

3. **Pass 2 (`pass2-types.ts`)**: Type validation
   - Uses `getPortType()` which checks resolved types from pass1
   - Falls back to definition types
   - Strict unit matching

### The Conflict

**Root cause**: Pass0 and Pass1 are doing the same job redundantly, and they don't coordinate.

Evidence from debug trace:
```
[9] b5: Const {"value":0,"payloadType":"float","resolvedUnit":"phase01"}  ← Pass0 resolved correctly!
[10] b6: Const {"value":0,"payloadType":"float","resolvedUnit":"scalar"}  ← Pass0 resolved for HsvToRgb.sat
```

But pass1TypeConstraints:
- Reads Const.out definition type: `float<unitVar('const_out')>`
- Tries to unify ALL Const blocks' outputs (they all share `const_out` var ID)
- Finds conflict: some need `phase01`, some need `scalar`
- Reports: `ConflictingUnits: scalar vs phase01`

**The spec says this is wrong architecture** (from `01-Units-and-Type-Inference.md`):
> pass0 should not be doing ad-hoc "infer from neighbor" logic. pass0 should only normalize structure. Then a dedicated type solve pass runs over the normalized graph and resolves units/payload.

### Options

**Option A: Make pass1 use pass0's resolved units**
- Change `getDefinitionPortType()` in pass1 to check `block.params.resolvedUnit` first
- Pros: Minimal change, leverages existing pass0 work
- Cons: Maintains redundant inference, ad-hoc before constraint solve

**Option B: Remove pass0 unit inference, let pass1 solve everything**
- Pass0 only sets `payloadType`, NOT `resolvedUnit`
- Pass1 constraint solver becomes the single source of truth for units
- Pros: Clean architecture per spec, single enforcer
- Cons: Larger change, need to fix the shared `unitVar` ID problem

**Option C: Give each generic block instance a unique unit variable**
- Instead of `unitVar('const_out')` (shared by all Const blocks), use `unitVar('const_out_${blockId}')`
- Pass1 can then solve each independently
- Pros: Keeps constraint solver, no shared variable conflicts
- Cons: Requires changes to block definition or lowering

## The Shared UnitVar Problem

All Const blocks share `unitVar('const_out')`. When multiple Const blocks exist:
- Const connecting to `phase` port needs `phase01`
- Const connecting to `sat` port needs `scalar`
- Constraint solver tries to unify both to the same variable → conflict

This is a fundamental design issue with how polymorphic types are defined.

## Recommended Path

Per the spec, **Option B + C hybrid**:

1. **Unique unit variables per block instance** during normalization
   - When creating a Const block (user or default source), assign unique `unitVar('const_out_${blockId}')`
   - OR: Replace `unitVar` with a per-block-instance constraint variable in pass1

2. **Pass0 should NOT set `resolvedUnit`**
   - Let pass1 be the single source of truth
   - Pass0 only handles payload type inference (which is separate)

3. **Pass1 constraint solver becomes authoritative**
   - Reads definition types with unique vars
   - Solves via union-find
   - Produces `resolvedPortTypes` map

4. **Pass2 reads from pass1's resolved map**
   - Already implemented correctly

## Immediate Fix (Option A)

To unblock tests NOW while proper architecture is designed:

1. In `pass1-type-constraints.ts`, modify `getDefinitionPortType()` to check `block.params.resolvedUnit` first
2. If found, return a concrete unit instead of `unitVar`
3. This makes pass1 a "validator" rather than "solver" when pass0 already resolved

This is a workaround, not the proper fix per spec.
