# Evaluation: Composite DSL Editor

## What Exists

### Composite System (Complete)
- `CompositeBlockDef` type with internal blocks, edges, exposed ports
- `CompositeEditorStore` MobX store with full CRUD
- `CompositeEditor.tsx` UI with visual graph editor + port exposure panel
- `CompositeStoreAdapter` bridges store to `GraphEditorCore`
- Builder API, JSON schema, persistence (localStorage), library composites
- Expansion pass (pass0) in compiler

### Patch DSL (Complete for Patches)
- HCL lexer → parser → AST → Patch pipeline
- Serializer: Patch → HCL with inline `outputs {}` syntax
- Deserializer: HCL → Patch with error recovery
- Parser already recognizes `composite` as header type (line 58 of patch-from-ast.ts)
- Full round-trip fidelity verified

### What's Missing
1. **No composite HCL syntax**: The DSL only handles `patch "Name" {}` — no way to express exposed ports, composite metadata, or the `composite` header semantics
2. **No DSL text panel in composite editor**: The CompositeEditor.tsx is visual-only
3. **No bidirectional sync**: No mechanism to convert CompositeEditorStore ↔ HCL text

## Architecture Assessment

### Key Insight: CompositeBlockDef ≠ Patch
A `CompositeBlockDef` has:
- `internalBlocks: Map<InternalBlockId, InternalBlockDef>` — similar to Patch.blocks but simpler (no ports, no roles)
- `internalEdges: InternalEdge[]` — simpler than Patch.edges (no roles, no enabled, no sortKey)
- `exposedInputs/exposedOutputs` — NO equivalent in Patch
- `metadata` (type, label, category, capability) — NO equivalent in Patch

### Two approaches:
1. **Extend patch-dsl to handle composite syntax** → serialize/deserialize to CompositeBlockDef directly
2. **Convert CompositeBlockDef ↔ Patch, reuse existing DSL** → lossy, exposed ports don't fit

Approach 1 is correct. The DSL should natively understand `composite "Name" {}` with `expose_input` / `expose_output` blocks.

### Data Flow
```
CompositeEditorStore ←→ CompositeBlockDef ←→ HCL text ←→ textarea
```
The store already has methods to produce/consume `CompositeBlockDef`. We need:
- `serializeCompositeToHCL(def: CompositeBlockDef): string`
- `deserializeCompositeFromHCL(hcl: string): { def: CompositeBlockDef, errors, warnings }`

## Verdict: CONTINUE
Clear path forward, no blockers.
