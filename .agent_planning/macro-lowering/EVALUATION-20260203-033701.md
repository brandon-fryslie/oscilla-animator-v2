# Evaluation: Pure Lowering Two-Result Model
Timestamp: 2026-02-03-033701
Git Commit: 9f0aaec

## Executive Summary
Overall: 35% complete | Critical issues: 4 | Tests reliable: no (zero test coverage of new code)

Sprint 1 delivered the skeleton: pure blocks exist (Add, DefaultSource, HueRainbow), LowerSandbox can invoke them, the orchestrator allocates slots for `slot: undefined` outputs. But the implementation diverges from the spec in fundamental ways. The two-result model (exprOutputs + LowerEffects) does not exist. Purity is enforced only by a TypeScript interface that is **never actually applied** -- LowerSandbox passes the full IRBuilder. DefaultSource uses direct IR emission instead of the specified DefaultPlan dispatch table. Zero tests cover any of the new code.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| `npx vitest run` | PASS (142/142) | 1 unrelated worker crash; no failures from new code |
| `npx tsc --noEmit` | PASS | Clean |
| DefaultSource block registered | YES | `src/blocks/signal/default-source.ts` registers it |
| HueRainbow block registered | YES | `src/blocks/color/hue-rainbow.ts` registers it |
| LowerSandbox class exists | YES | `src/compiler/ir/LowerSandbox.ts` |
| PureIRBuilder interface used | NO | Defined but never imported/consumed anywhere |
| loweringPurity on BlockDef | YES | 3 blocks tagged: Add, DefaultSource, HueRainbow |
| LowerEffects type exists | NO | Not implemented |
| DefaultPlan type exists | NO | Not implemented |
| Tests for new code | NONE | 0 test files reference LowerSandbox, PureIRBuilder, DefaultSource block, or HueRainbow |

## Missing Checks
1. **Unit test: DefaultSource compiles for each payload type** (float, int, bool, vec2, vec3, color, cameraProjection, discrete event)
2. **Unit test: DefaultSource with unresolved generic payload var throws**
3. **Unit test: LowerSandbox rejects non-pure blocks** (verify the purity gate works)
4. **Unit test: LowerSandbox macro output has slot: undefined** (orchestrator must allocate)
5. **Integration test: Full compile of graph with DefaultSource block** (end-to-end)
6. **Contract test: Pure blocks cannot call allocSlot at runtime through LowerSandbox** (currently they CAN)
7. **Invariant test: No `Axis.var` escapes into backend IR from DefaultSource path**

## Findings

### 1. PureIRBuilder: Dead Interface
**Status**: STUB
**Evidence**: `src/compiler/ir/PureIRBuilder.ts` defines the interface (44 methods). `grep -r 'PureIRBuilder' src/` finds it only in its own file and a comment in LowerSandbox.ts. It is never imported, never used as a type constraint, never passed to any function.
**Issues**:
- The spec says pure blocks get a constrained API. In reality, `LowerSandbox.ts:105` sets `b: this.builder` where `this.builder` is the full `IRBuilder`. Pure blocks can call `allocSlot()`, `stepSlotWriteStrided()`, `addRenderGlobal()`, etc.
- The PureIRBuilder interface includes `createInstance()` (line 121), which contradicts purity. The comment on line 119 says "may read instance context but not create new instances" but the method creates instances.
- This is **documentation theater** -- the interface suggests restriction but enforces nothing.

### 2. Two-Result Model (exprOutputs + LowerEffects)
**Status**: NOT_STARTED
**Evidence**: `src/blocks/registry.ts:88-104` defines `LowerResult` as `{ outputsById: Record<string, ValueRefExpr>, instanceContext?, stateSlot? }`. No `LowerEffects` type exists anywhere in the codebase.
**Issues**:
- The spec (line 106-110) requires lowerers to return `{ exprOutputs: Record<PortId, ValueExprId>, effects?: LowerEffects }` where effects include state cell requests, kernel registrations, slot requests.
- Current implementation: pure blocks return `LowerResult` with `slot: undefined` on each `ValueRefExpr`. The orchestrator detects `slot: undefined` and allocates inline.
- This is a **pragmatic shortcut** that works for the simple case (slot allocation as the only effect) but does not generalize to state cell requests, kernel registrations, or other effects.
- The inline slot allocation at `lower-blocks.ts:518-525` is a special case embedded in the orchestrator, not a general effects-processing stage.

### 3. DefaultSource Block: Works But Diverges From Spec
**Status**: PARTIAL
**Evidence**: `src/blocks/signal/default-source.ts` (174 lines) implements type-indexed dispatch via switch statement.
**Issues**:
- **No DefaultPlan type**: Spec defines `DefaultPlan = { kind: 'rail' | 'const' | 'construct' | 'error', ... }`. Implementation uses direct IR emission in switch branches. This means the dispatch table is not data-driven and cannot be inspected, tested, or overridden.
- **No DefaultKey type**: Spec defines `DefaultKey = { payload, unit?, temporality, cardinality }`. Implementation dispatches on `payload.kind` only, ignoring unit and cardinality.
- **No chooseDefault() function**: Spec shows `chooseDefault(profile, resolvedType)`. Implementation has no separate function -- dispatch is inline in `lower()`.
- **No profileId system**: Spec describes per-port profile overrides (e.g., `Render.opacity -> defaults to 1`). Not implemented. All defaults are global.
- **Float defaults to 1.0** (line 83): This matches spec ("identity for multiplication") but is a design choice that should be justified. Most systems default float to 0.0.
- **Color via HueRainbow works**: Line 132-155 uses LowerSandbox to invoke HueRainbow. This is the spec's primary use case and it works.

### 4. LowerSandbox: Functional But Leaky
**Status**: PARTIAL
**Evidence**: `src/compiler/ir/LowerSandbox.ts` (127 lines)
**Issues**:
- **Purity gate works**: Line 63 correctly rejects blocks without `loweringPurity: 'pure'`. This is a runtime check.
- **Full IRBuilder passed**: Line 105 `b: this.builder` passes the unrestricted builder. A "pure" block called through LowerSandbox can call ANY IRBuilder method, including allocSlot, stepSlotWriteStrided, etc.
- **Input type casting is unsafe**: Line 80 `const inputType = inputDef.type as CanonicalType` -- casts InferenceCanonicalType to CanonicalType. If the block definition uses type vars (which it should for generic blocks), this cast is incorrect and could produce wrong types.
- **Synthetic block index**: Line 95 uses `-1 as BlockIndex`. This is a magic number that could collide or cause issues in debugging/diagnostics.
- **No outType resolution**: Line 90-92 uses `outDef.type as CanonicalType` from the block definition, not the resolved output type. For DefaultSource (which has generic output type resolving via constraint propagation), the macro-expanded block's output type comes from the definition, not the calling context.

### 5. LoweringPurity Type: Incomplete
**Status**: PARTIAL
**Evidence**: `src/blocks/registry.ts:139` defines `export type LoweringPurity = 'pure';`
**Issues**:
- Spec (line 113-115) requires `'pure' | 'stateful' | 'impure'`. Only `'pure'` exists.
- The `BlockDef.loweringPurity` field is `LoweringPurity | undefined`, so existing blocks default to `undefined` (treated as impure). This is acceptable as a migration strategy.
- Missing `'stateful'` classification means blocks like UnitDelay, Phasor, Lag cannot be properly classified for macro expansion rules ("DefaultSource macro expansion may only call pure blocks, optionally stateful. Never impure." -- spec line 117).

### 6. Mechanical Purity Enforcement
**Status**: NOT_STARTED
**Evidence**: No determinism check, no deepFreeze, no ESLint rule, no record-and-replay.
**Issues**:
- Spec lines 119-131 describe four mechanical checks: determinism (run twice, compare), no mutation (deepFreeze + proxy), forbidden imports (ESLint rule), debug builds (record-and-replay).
- None are implemented.
- The purity "enforcement" is limited to: (1) a TypeScript interface that isn't used, (2) a runtime tag check in LowerSandbox that only verifies the tag exists, not that the function is actually pure.

### 7. Macro Trace Diagnostics
**Status**: NOT_STARTED
**Evidence**: No diagnostic trace in DefaultSource. Errors are thrown as plain `Error` objects.
**Issues**:
- Spec line 137-138: "DefaultSource diagnostics attribute back to the target input port with a macro trace: `{ producer: DefaultSource(anchor), expandedUsing: HueRainbow }`"
- Current: `throw new Error(...)` at lines 58-62, 161-163, 167-169. These are unstructured errors that lose context about which target port triggered the default, and which macro (if any) was expanded.

### 8. Slot Allocation: Inline vs. Separate Stage
**Status**: PARTIAL (pragmatic shortcut)
**Evidence**: `lower-blocks.ts:516-535` handles slot allocation inline during output processing.
**Issues**:
- Spec (line 110): "A separate compiler stage turns effects into slot allocations and schedule steps."
- Current: The orchestrator checks `slot === undefined` and allocates inline. This is functional but:
  - Not a separate stage (violates pipeline stage independence)
  - Only handles slot allocation (not state cells, kernel registrations, or other effects)
  - Duplicated between single-pass (line 516-535) and two-pass SCC (line 683-703) paths
- The duplication between single-pass and SCC paths is a code smell. If the effects were a separate stage, it would run once regardless of SCC structure.

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| PureIRBuilder usage | Should LowerSandbox use PureIRBuilder as ctx.b type instead of IRBuilder? | Created the interface but never wired it in. Full IRBuilder is passed. | HIGH: Purity is unenforced. Any "pure" block can call impure methods. |
| Two-result model scope | Is the two-result model required for Sprint 1, or is slot:undefined + inline allocation acceptable as interim? | Used inline allocation as pragmatic shortcut | MEDIUM: Works for current use cases but blocks future effects (state cells, kernel registrations) |
| DefaultPlan as data vs. inline dispatch | Should DefaultSource use a data-driven plan table (DefaultPlan) or is inline switch acceptable? | Used inline switch statement | LOW: Inline switch works. Data-driven table needed only when profiles are implemented. |
| Float default: 0 vs 1 | Spec says 1 (identity for multiplication). Is this correct? Most systems default to 0. | Followed spec (1.0) | MEDIUM: Could surprise users who expect 0.0 as default. |
| createInstance in PureIRBuilder | Should pure blocks be able to create instances? | Included createInstance in PureIRBuilder despite comment saying "not create new instances" | LOW: Currently unreachable since PureIRBuilder is dead code. |

## Recommendations

1. **Write tests for the new code (P0)**. Zero coverage means zero confidence. At minimum:
   - DefaultSource: one test per payload type (float/int/bool/vec2/vec3/color/cameraProjection/event)
   - DefaultSource: unresolved type produces error
   - LowerSandbox: rejects non-pure blocks
   - LowerSandbox: macro expansion produces valid IR
   - Integration: graph with DefaultSource compiles end-to-end

2. **Wire PureIRBuilder into LowerSandbox (P1)**. Currently dead code. Either:
   - Create a `PureIRBuilderProxy` class that wraps IRBuilder and throws on impure methods
   - Pass `PureIRBuilder` as `ctx.b` type in LowerSandbox's synthetic LowerCtx
   - Or delete PureIRBuilder if the decision is to not enforce purity at this level

3. **Remove createInstance from PureIRBuilder (P1)**. It contradicts the purity contract documented in the same file.

4. **Add `'stateful'` and `'impure'` to LoweringPurity union (P2)**. Needed for spec compliance and to support the macro expansion rule (only pure/stateful blocks can be macro-expanded).

5. **Defer two-result model, DefaultPlan, profiles, and mechanical enforcement to future sprints**. The current inline approach works for the implemented use cases. The spec's full design is a multi-sprint effort.

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix

The implementation is a valid first step that diverges from the spec's full design but handles the immediate use cases (DefaultSource type-indexed dispatch, HueRainbow macro expansion, slot allocation for pure blocks). The critical gap is zero test coverage and the PureIRBuilder being dead code. The former is a reliability risk; the latter is a purity enforcement gap that matters when more blocks are migrated to pure.

Sprint 1 delivered infrastructure. Sprint 2 should focus on: (1) tests, (2) wiring PureIRBuilder as actual enforcement, (3) expanding the set of pure blocks.
