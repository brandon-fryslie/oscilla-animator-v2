# Evaluation: Patch DSL (HCL-Based Serialization)
Timestamp: 2026-02-01-162800
Git Commit: 33c70c6

## Executive Summary
Overall: 0% complete (greenfield) | Critical issues: 0 | Tests reliable: N/A | Blockers: 0

**Status**: READY TO IMPLEMENT — Plan is complete, no ambiguities, clear reference patterns exist.

## Scope & Deliverables

**Target**: New `src/patch-dsl/` module providing bidirectional Patch ↔ HCL conversion.

**Plan location**: `~/.claude/plans/bubbly-seeking-parrot.md`

**Module structure** (from plan):
```
src/patch-dsl/
  index.ts              # Public API
  serialize.ts          # Patch → HCL
  deserialize.ts        # HCL → Patch
  lexer.ts              # Tokenizer
  parser.ts             # Recursive descent parser
  ast.ts                # HCL AST types
  patch-from-ast.ts     # AST → Patch conversion
  patch-to-hcl.ts       # Patch → AST → string
  errors.ts             # Error types with position info
  __tests__/            # Full test suite
```

**Integration points**:
- `src/services/PatchPersistence.ts` — Add HCL import/export alongside JSON
- `src/stores/PatchStore.ts` — Add loadFromHCL/exportToHCL methods

## Current State

### What Exists
1. **Reference lexer/parser pattern**: `src/expr/` provides excellent template
   - Clean token types (TokenKind enum)
   - Position tracking for errors
   - Hand-written recursive descent parser
   - Comprehensive test coverage
   - Error recovery pattern established

2. **Patch data model**: `src/graph/Patch.ts` fully defined
   - Block structure with ports, params, roles
   - Edge structure with endpoints, roles, sortKeys
   - VarargConnection support
   - LensAttachment support
   - PatchBuilder for programmatic construction

3. **Demo patches**: 13 demo patches in `src/demo/` provide round-trip test corpus
   - Simple patches (golden-spiral.ts: 8 blocks)
   - Complex patches (shape-kaleidoscope.ts, feedback-rotation.ts)
   - Edge cases (domain-test.ts, error-isolation-demo.ts)

4. **Canonical addressing**: `src/graph/addressing.ts` provides name normalization
   - `normalizeCanonicalName()` for display name → canonical name
   - `detectCanonicalNameCollisions()` for uniqueness checks
   - Shorthand resolution `blockName.portName`

5. **Block registry**: `src/blocks/registry.ts` defines all block types
   - Full metadata (inputs, outputs, params, cardinality, etc.)
   - Known block types for validation
   - Vararg support metadata

6. **Persistence layer**: `src/services/PatchPersistence.ts` handles JSON serialization
   - serializePatch() / deserializePatch()
   - localStorage integration
   - Clear integration pattern for HCL

### What Does NOT Exist
- No `src/patch-dsl/` directory — completely greenfield
- No HCL lexer/parser/AST
- No Patch → HCL serializer
- No HCL → Patch deserializer
- No round-trip tests
- No UI integration (deferred per plan)

## Plan Analysis

### Completeness: EXCELLENT

**Grammar** (plan lines 81-92):
```
document     := block*
block        := IDENT label* LBRACE body RBRACE
label        := STRING
body         := (attribute | block)*
attribute    := IDENT EQUALS value
value        := NUMBER | STRING | BOOL | reference | object | list
reference    := IDENT (DOT IDENT)*
object       := LBRACE (IDENT EQUALS value (COMMA? IDENT EQUALS value)*)? RBRACE
list         := LBRACKET (value (COMMA value)*)? RBRACKET
```

**Analysis**:
- Grammar is complete and unambiguous
- Directly maps to expr lexer pattern (same token types)
- Covers all Patch elements (blocks, edges, ports, lenses, varargs)
- Error recovery strategy documented (skip to `}` or newline)

**Token types** (plan lines 66-74):
```
IDENT, NUMBER, STRING, BOOL (true/false)
LBRACE, RBRACE, LBRACKET, RBRACKET
EQUALS, DOT, COMMA
COMMENT (#...)
NEWLINE (significant for attribute separation)
EOF
```

**Analysis**:
- Minimal, sufficient set
- Direct 1:1 mapping to expr lexer tokens (plus LBRACE, RBRACE, LBRACKET, RBRACKET, COMMENT, NEWLINE)
- Comment handling strategy clear
- Newline significance documented

**HCL AST** (plan lines 39-61):
```typescript
type HclValue = number | string | bool | reference | object | list
interface HclBlock {
  type: string
  labels: string[]
  attributes: Record<string, HclValue>
  children: HclBlock[]
  pos: Position
}
```

**Analysis**:
- AST is appropriately minimal
- No Patch types leak in (correct separation)
- Position tracking for error reporting
- Follows expr AST pattern (Position type reusable)

**Serialization algorithm** (plan lines 104-120):
1. Emit patch header
2. For each block → emit block definition with ports/params
3. For each edge → emit connect statement
4. Block name collision resolution (append `_2`, `_3`, etc.)

**Analysis**:
- Algorithm is deterministic and complete
- Name collision handling explicit
- Edge role filtering (skip derived edges)
- Handles all Patch features (varargs, lenses, params, roles)

**Deserialization algorithm** (plan lines 141-155):
1. Lex → parse → HclDocument
2. Extract patch header
3. Build block map (name → BlockId)
4. Process connect entries with reference resolution
5. Assemble Patch

**Analysis**:
- Two-phase (parse, then resolve) is correct
- Reference resolution strategy clear
- Error collection (not throwing) documented
- Partial patch support for malformed input

### Ambiguities: NONE FOUND

All potential ambiguities are resolved in the plan:

1. **Q: How are endpoint references represented?**
   - A: Bare traversals `blockName.portName` (plan line 9)

2. **Q: How are display name collisions handled?**
   - A: Append `_2`, `_3` etc. during serialization (plan line 121)

3. **Q: What happens with malformed HCL?**
   - A: Error recovery → partial AST → partial Patch + errors (plan line 94)

4. **Q: How are derived edges handled?**
   - A: Skip during serialization (role.kind !== 'user') (plan line 119)

5. **Q: How are varargs serialized?**
   - A: Nested `vararg "portId" { connect { ... } }` blocks (plan line 115)

6. **Q: How are lenses serialized?**
   - A: Nested `lens` blocks inside `connect` (plan line 117)

7. **Q: What about composite blocks?**
   - A: Deferred (plan line 164, line 230)

8. **Q: What about editor metadata (positions, viewport)?**
   - A: Deferred (plan line 233)

### Blockers: NONE

**Dependencies all satisfied**:
- ✅ Patch type stable (no ongoing refactors)
- ✅ Block registry stable
- ✅ Canonical addressing exists
- ✅ Reference pattern (expr DSL) exists
- ✅ Test framework (Vitest) available
- ✅ Demo patches for round-trip testing

**No architectural conflicts**:
- HCL DSL is orthogonal to JSON serialization (both can coexist)
- No circular dependencies (patch-dsl → graph, blocks; nothing depends back)
- No breaking changes to existing code
- Integration points clearly identified

**No missing requirements**:
- Plan specifies all inputs/outputs
- Error handling strategy defined
- Test strategy defined (unit + round-trip)
- Verification criteria explicit (plan lines 217-227)

## Risk Profile

### Low Risk Items
1. **Lexer** — Direct copy-adapt from `src/expr/lexer.ts`
   - Same token pattern, add LBRACE/RBRACE/LBRACKET/RBRACKET/COMMENT
   - ~150 lines, well-understood domain

2. **AST types** — Pure data structures
   - ~50 lines, no logic
   - Position type reusable from expr

3. **Parser** — Follows expr parser pattern
   - Simpler than expr (no precedence climbing, just blocks/attributes)
   - ~300 lines, recursive descent well-tested pattern
   - Error recovery pattern established

4. **Serialization (Patch → HCL)** — Straightforward traversal
   - Walk Patch, emit HCL text
   - Deterministic output (block order, edge order)
   - Name collision resolution simple (append suffix)

### Medium Risk Items
1. **Deserialization (HCL → Patch)** — Two-phase with resolution
   - Phase 1: Parse HCL → AST (low risk)
   - Phase 2: Resolve references → Patch (medium complexity)
   - **Risk**: Unresolvable references (mitigated: plan specifies collect error + skip)
   - **Risk**: Type mismatches for params (mitigated: use defaults + warning)

2. **Round-trip testing** — Verification complexity
   - Need structural equality check (not reference equality)
   - **Risk**: Patch has Maps/readonly arrays (need deep comparison)
   - **Mitigation**: Use JSON.stringify for comparison, or implement deep equality helper

3. **Error messages** — User-facing quality
   - **Risk**: Cryptic errors if position tracking breaks
   - **Mitigation**: Test error cases explicitly, copy expr pattern

### High Risk Items
**NONE** — This is a greenfield implementation with clear spec and reference pattern.

### Deferred Complexity (Explicitly Out of Scope)
Per plan lines 229-236:
- Composite block deserialization
- Editor metadata (positions, viewport)
- `format_version` / migration system
- Syntax highlighting / TextMate grammar
- UI integration (file picker, editor pane)

These are correctly deferred — they're not blockers for core DSL.

## Pattern Conformance

### Reference Pattern: `src/expr/`

**Lexer** (`src/expr/lexer.ts`, 286 lines):
- ✅ Token enum (TokenKind)
- ✅ Position tracking
- ✅ Error throwing with position
- ✅ Public API: `tokenize(input: string): Token[]`
- **Adapts cleanly**: Add 6 token types (LBRACE, RBRACE, LBRACKET, RBRACKET, COMMENT, NEWLINE)

**Parser** (`src/expr/parser.ts`, ~400 lines):
- ✅ ParseError class with position
- ✅ Recursive descent
- ✅ Lookahead helpers (peek, match, consume)
- ✅ Public API: `parse(tokens: Token[]): AstNode`
- **Adapts cleanly**: Simpler grammar (no precedence), same structure

**AST** (`src/expr/ast.ts`, 197 lines):
- ✅ Position interface
- ✅ Discriminated union (kind field)
- ✅ Immutable builder functions
- **Adapts cleanly**: Fewer node types (6 vs 1: HclBlock + HclValue variants)

**Tests** (`src/expr/__tests__/`):
- ✅ Unit tests for lexer (edge cases, errors)
- ✅ Unit tests for parser (grammar coverage)
- ✅ Integration tests (full parse + typecheck)
- **Adapts cleanly**: Same structure, simpler grammar

### Patch Conformance

**Patch type** (`src/graph/Patch.ts`):
```typescript
interface Patch {
  blocks: ReadonlyMap<BlockId, Block>;
  edges: readonly Edge[];
}
interface Block {
  id: BlockId;
  type: string;
  params: Record<string, unknown>;
  displayName: string;
  domainId: string | null;
  role: BlockRole;
  inputPorts: ReadonlyMap<string, InputPort>;
  outputPorts: ReadonlyMap<string, OutputPort>;
}
interface InputPort {
  id: string;
  defaultSource?: DefaultSource;
  combineMode: CombineMode;
  varargConnections?: readonly VarargConnection[];
  lenses?: readonly LensAttachment[];
}
interface Edge {
  id: string;
  from: Endpoint;
  to: Endpoint;
  enabled: boolean;
  sortKey: number;
  role: EdgeRole;
}
```

**All fields covered in plan**:
- ✅ Block type, displayName, params, domainId, role
- ✅ InputPort combineMode, defaultSource, varargConnections, lenses
- ✅ Edge from/to (as references), enabled, sortKey, role
- ✅ Edge role filtering (skip derived edges)

**No missing fields** — Plan is complete.

## Verification Strategy

### Unit Tests (per plan line 219)
1. **Lexer tests**: Token types, position tracking, errors
   - Pattern: `src/expr/__tests__/lexer.test.ts`
   - Coverage: All token types, edge cases (EOF, invalid chars)

2. **Parser tests**: Grammar coverage, error recovery
   - Pattern: `src/expr/__tests__/parser.test.ts`
   - Coverage: All productions, nested blocks, malformed input

3. **Serialize tests**: Patch → HCL
   - Input: PatchBuilder constructs
   - Output: HCL string
   - Assertions: String contains expected blocks/edges/params

4. **Deserialize tests**: HCL → Patch
   - Input: HCL strings
   - Output: Patch + errors
   - Assertions: Correct blocks, edges, error collection

### Round-Trip Tests (per plan line 221)
```typescript
describe('round-trip', () => {
  for (const [name, builder] of DEMO_PATCHES) {
    it(`round-trips ${name}`, () => {
      const patch1 = buildPatch(builder);
      const hcl = serializePatchToHCL(patch1);
      const result = deserializePatchFromHCL(hcl);
      expect(result.errors).toHaveLength(0);
      expect(patchesEqual(result.patch, patch1)).toBe(true);
    });
  }
});
```

**Verification criteria**:
- All 13 demo patches must round-trip without errors
- Structural equality (same blocks, edges, params, port overrides)
- Order-insensitive for maps (blocks, ports)
- Order-sensitive for arrays (edges sorted by sortKey)

**Deliberate error tests** (per plan line 223):
- Malformed HCL → partial patch + errors
- Unresolvable references → skip edge + error
- Duplicate block names → rename + warning
- Unknown block types → preserve as-is + warning
- Empty HCL → empty patch

### Integration Tests (per plan line 208)
```typescript
// In src/services/__tests__/PatchPersistence.test.ts
describe('HCL integration', () => {
  it('exports and imports patch via HCL', () => {
    const patch1 = buildPatch(b => { /* ... */ });
    const hcl = exportPatchAsHCL(patch1);
    const result = importPatchFromHCL(hcl);
    expect(result).not.toBeNull();
    expect(result!.errors).toHaveLength(0);
    expect(patchesEqual(result!.patch, patch1)).toBe(true);
  });
});
```

## Implementation Order (from plan)

**Phase-by-phase with clear gates**:

1. ✅ **Phase 1: AST types** (`ast.ts`)
   - Gate: File compiles, types export cleanly
   - Risk: None (pure types)
   - Estimate: 30 minutes

2. ✅ **Phase 2: Error types** (`errors.ts`)
   - Gate: Error types defined, Position type imported
   - Risk: None (pure types)
   - Estimate: 15 minutes

3. ✅ **Phase 3: Lexer** (`lexer.ts` + tests)
   - Gate: All tests pass, tokenize() works for sample HCL
   - Risk: Low (copy-adapt from expr)
   - Estimate: 2 hours

4. ✅ **Phase 4: Parser** (`parser.ts` + tests)
   - Gate: All tests pass, parse() works for sample HCL
   - Risk: Low (simpler than expr)
   - Estimate: 3 hours

5. ✅ **Phase 5: Serializer** (`patch-to-hcl.ts` + `serialize.ts` + tests)
   - Gate: Demo patches serialize to valid HCL
   - Risk: Low (straightforward traversal)
   - Estimate: 3 hours

6. ✅ **Phase 6: Deserializer** (`patch-from-ast.ts` + `deserialize.ts` + tests)
   - Gate: HCL deserializes to Patch, errors collected
   - Risk: Medium (reference resolution)
   - Estimate: 4 hours

7. ✅ **Phase 7: Round-trip tests** (`roundtrip.test.ts`)
   - Gate: All 13 demo patches round-trip successfully
   - Risk: Medium (verification complexity)
   - Estimate: 2 hours

8. ✅ **Phase 8: Integration** (`PatchPersistence.ts` + `PatchStore.ts`)
   - Gate: HCL export/import works via services
   - Risk: Low (thin wrapper)
   - Estimate: 1 hour

**Total estimate**: 15.75 hours (2 work days)

**Critical path**: Lexer → Parser → Deserializer → Round-trip tests

**Parallelizable**: Serializer can be built independently of Deserializer

## Missing Checks

**What should exist but doesn't**:
1. ❌ **HCL linter** — Validate HCL before parse (optional, can defer)
2. ❌ **Pretty-printer** — Format HCL with consistent indentation (can use simple indent logic)
3. ❌ **Canonical HCL order** — Deterministic block/edge ordering for diffs (can add sortBy displayName)

**None of these block implementation** — They're nice-to-haves.

## Findings

### No Blockers Found

**Codebase ready**:
- ✅ Patch type stable (no ongoing type system refactor affects structure)
- ✅ Block registry stable (no new block fields needed)
- ✅ Canonical addressing complete
- ✅ Reference pattern exists and works
- ✅ Test infrastructure ready

**Plan complete**:
- ✅ Grammar unambiguous
- ✅ Token set sufficient
- ✅ AST design sound
- ✅ Algorithm deterministic
- ✅ Error handling strategy clear
- ✅ Test strategy comprehensive
- ✅ Integration points identified

### No Ambiguities Requiring Clarification

All design decisions made:
- Endpoint syntax: `blockName.portName`
- Name collisions: Append suffix
- Malformed input: Error recovery + partial AST
- Derived edges: Skip during serialization
- Varargs: Nested vararg blocks
- Lenses: Nested lens blocks
- Composites: Deferred
- Editor metadata: Deferred

### No Design Conflicts

**Orthogonal to existing code**:
- JSON serialization continues to work
- HCL is additive (new format, not replacement)
- No changes to Patch type needed
- No changes to Block registry needed

**Clean dependency arrows**:
```
patch-dsl → graph (Patch type)
patch-dsl → blocks (registry for validation)
patch-dsl → core (canonical-name)
PatchPersistence → patch-dsl (uses API)
PatchStore → PatchPersistence (uses API)
```

No upward dependencies, no cycles.

## Pattern Gaps

**One minor pattern gap identified**:

**Issue**: Plan doesn't specify how to compare Patches for equality in round-trip tests.

**Problem**: Patch contains Maps and readonly arrays. Reference equality (`===`) won't work. JSON.stringify may have key ordering issues.

**Options**:
1. **JSON.stringify after sorting keys** — Simple, works for most cases
2. **Deep equality helper** — Custom function, handles Maps/arrays correctly
3. **Serialize both to HCL and compare strings** — Assumes serialization is deterministic

**Recommendation**: Option 2 (deep equality helper)
- Handles Maps correctly (compare entries, not references)
- Handles readonly arrays correctly (compare elements)
- Order-insensitive for blocks (Map), order-sensitive for edges (array sorted by sortKey)
- Reusable for other tests

**Add to plan**:
```typescript
// In __tests__/equality.ts
function patchesEqual(a: Patch, b: Patch): boolean {
  // Compare block counts
  if (a.blocks.size !== b.blocks.size) return false;
  // Compare blocks (order-insensitive)
  for (const [id, blockA] of a.blocks) {
    const blockB = b.blocks.get(id);
    if (!blockB || !blocksEqual(blockA, blockB)) return false;
  }
  // Compare edges (order-sensitive after sorting by sortKey)
  const edgesA = [...a.edges].sort((x, y) => x.sortKey - y.sortKey);
  const edgesB = [...b.edges].sort((x, y) => x.sortKey - y.sortKey);
  if (edgesA.length !== edgesB.length) return false;
  for (let i = 0; i < edgesA.length; i++) {
    if (!edgesEqual(edgesA[i], edgesB[i])) return false;
  }
  return true;
}
```

**Impact**: Low — Add 1 hour for equality helper implementation + tests.

## Recommendations

### 1. PROCEED WITH IMPLEMENTATION (Priority: CRITICAL)
**Rationale**: No blockers, plan complete, reference pattern exists, clear value.

**Order**:
1. Create `src/patch-dsl/` directory
2. Implement in plan order (ast → errors → lexer → parser → serialize → deserialize → round-trip)
3. Run tests continuously (TDD style)
4. Integrate with PatchPersistence after round-trip tests pass

### 2. Add Deep Equality Helper (Priority: HIGH)
**Rationale**: Required for round-trip tests, reusable for other tests.

**Action**: Create `src/patch-dsl/__tests__/equality.ts` with `patchesEqual()` function before Phase 7.

### 3. Deterministic Serialization (Priority: MEDIUM)
**Rationale**: HCL diffs are only useful if output is deterministic.

**Action**:
- Sort blocks by displayName (canonical name) during serialization
- Sort edges by sortKey (already in Patch)
- Emit params in sorted key order
- Emit ports in sorted key order

**Benefit**: Git diffs show actual changes, not reordering noise.

### 4. Pretty-Print with Indentation (Priority: LOW)
**Rationale**: Human readability matters for HCL.

**Action**: Add indentation logic to `patch-to-hcl.ts` (2 spaces per level).

**Deferrable**: Can start with minimal formatting, add later.

### 5. Example HCL in Plan (Priority: LOW)
**Rationale**: Helps implementer verify output format.

**Action**: Add example HCL to plan showing expected output for a simple patch.

**Deferrable**: Plan grammar is sufficient, examples are nice-to-have.

## Example Expected Output (Informational)

For the golden-spiral demo patch:
```hcl
patch "Golden Spiral" {
  block "InfiniteTimeRoot" "time" {
    periodAMs = 4000
    periodBMs = 120000
    role = "time_root"
  }

  block "Ellipse" "ellipse" {
    rx = 0.02
    ry = 0.02
  }

  block "Array" "array" {
    count = 5000
  }

  connect {
    from = ellipse.shape
    to = array.element
  }

  block "CircleLayoutUV" "circleLayout" {
    radius = 0.35
  }

  connect {
    from = array.elements
    to = circleLayout.elements
  }

  block "Const" "color" {
    value = { r = 0.9, g = 0.7, b = 0.5, a = 1.0 }
  }

  block "RenderInstances2D" "render" {}

  connect {
    from = circleLayout.position
    to = render.pos
  }

  connect {
    from = color.out
    to = render.color
  }

  connect {
    from = ellipse.shape
    to = render.shape
  }
}
```

**Note**: Actual format may vary (e.g., compact vs. expanded objects), but structure is correct.

## Verdict

- [x] **CONTINUE** — Issues clear (none), implementer can proceed immediately
- [ ] PAUSE — Ambiguities need clarification

**Next action**: Create `src/patch-dsl/ast.ts` and begin Phase 1.

**Confidence**: HIGH — This is a well-specified, low-risk greenfield implementation with clear patterns to follow.

**Estimated completion**: 2 work days (16 hours) assuming no interruptions.

---

## Appendix: Reference Files

**Must read before implementing**:
1. `~/.claude/plans/bubbly-seeking-parrot.md` — The plan
2. `src/expr/lexer.ts` — Lexer pattern
3. `src/expr/parser.ts` — Parser pattern
4. `src/expr/ast.ts` — AST pattern
5. `src/graph/Patch.ts` — Patch type definition
6. `src/graph/addressing.ts` — Canonical name handling
7. `src/demo/golden-spiral.ts` — Simplest demo patch for initial testing

**Optional context**:
- `src/blocks/registry.ts` — Block definitions (for validation)
- `src/services/PatchPersistence.ts` — Integration target
- `src/expr/__tests__/` — Test patterns

**Do NOT read** (not relevant):
- `src/compiler/` — Compilation is orthogonal to serialization
- `src/runtime/` — Runtime is orthogonal to serialization
- `src/ui/` — UI integration is deferred
