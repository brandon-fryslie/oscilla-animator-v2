# Feedback Loop Compiler Issue - Status Evaluation

Generated: 2026-01-27-141055
Topic: feedback-loops
Status: ISSUE IDENTIFIED - ROOT CAUSE UNDERSTOOD

## Executive Summary

Feedback loops with stateful blocks (UnitDelay, Lag, Phasor, SampleAndHold) fail during compilation because **input resolution in Pass 6 happens BEFORE the block's outputs are available**, even though pass5-scc correctly validates the cycle as legal.

The core issue is a **chicken-and-egg problem**: when processing blocks in topological order within an SCC (cycle), the first block processed cannot resolve its input because its dependency (the last block in the cycle) hasn't been lowered yet.

## Current Architecture

### Pass Pipeline

```
Pass 1: Type Constraints (unit/payload inference)
Pass 2: Type Graph (validation)
Pass 3: Time Topology (time model)
Pass 4: Dependency Graph (edges from NormalizedEdge array)
Pass 5: SCC Validation (Tarjan's algorithm - validates cycles have stateful blocks)
Pass 6: Block Lowering (lowers blocks to IR - FAILS HERE)
Pass 7: Schedule Construction
```

### How Pass 6 Processes Blocks

```typescript
// pass6-block-lowering.ts:535-536
const orderedSccs = [...validated.sccs].reverse();
for (const scc of orderedSccs) {
  for (const node of scc.nodes) {
    // ... lower block ...
  }
}
```

Blocks are processed in topological order of SCCs, then within each SCC in node order. For feedback loops (multi-node SCCs), there's no valid topological order - the cycle means every block depends on another.

### Where It Fails

In `resolveInputsWithMultiInput()` (pass6-block-lowering.ts:104-193):

```typescript
// For each input:
// 1. Enumerate writers via resolveWriters
// 2. If N=0: Error (should not happen after pass 0 materialization)
// 3. If N=1: Direct bind (looks up in blockOutputs)
// 4. If N>1: Validate combine policy, create combine node
```

When lowering block A in a cycle A -> B -> C -> A:
- A's input comes from C
- But C hasn't been lowered yet (it's later in the SCC)
- `blockOutputs.get(C)` returns undefined
- Error: "Wire source not found: C.out"

### The Stateful Block Semantic

UnitDelay and other stateful blocks have `isStateful: true` which means:
1. They read from **previous frame's state** (via `sigStateRead`)
2. They write **current frame's input** to state (via `stepStateWrite`)

This breaks the within-frame dependency:
- UnitDelay.out = state from previous frame (no input dependency)
- UnitDelay writes input to state for next frame (input dependency)

The **output does not depend on the input within the same frame** - it reads from state.

## Root Cause Analysis

### Why Pass 5 Works

Pass 5 (SCC validation) correctly identifies cycles and checks for stateful blocks:

```typescript
// pass5-scc.ts:109-118
const hasStateBoundary = sccNodes.some((node) => {
  if (node.kind === "BlockEval") {
    const block = blocks[node.blockIndex];
    const blockDef = getBlockDefinition(block.type);
    if (!blockDef) return false;
    return blockDef.isStateful === true;  // UnitDelay returns true
  }
  return false;
});
```

### Why Pass 6 Fails

Pass 6 doesn't know that stateful blocks break the within-frame dependency. It treats all edges as requiring the source block's output to exist before the target block can be lowered.

For UnitDelay in a cycle:
- Pass 6 tries to lower UnitDelay
- UnitDelay's input comes from a block later in the cycle
- That block's output doesn't exist in `blockOutputs` yet
- Error: "No writers for required input"

## Spec Reference

From `design-docs/CANONICAL-oscilla-v2.5-20260109/ESSENTIAL-SPEC.md`:

> **I7**: Cycles must cross stateful boundary (Tarjan's SCC + validation)

From `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/04-compilation.md`:

> **Validation Rule**: Every SCC must contain at least one stateful primitive: UnitDelay, Lag, Phasor, SampleAndHold

The spec REQUIRES feedback loops to work when they contain stateful primitives.

## Current Behavior (Bug)

**Expected**: Feedback loop with UnitDelay compiles successfully
**Actual**: "No writers for required input" or "Wire source not found" error during Pass 6

## Quantitative Impact

- **Blocked Feature**: Feedback loops are a core animation pattern
- **Test Impact**: Any test with feedback loops will fail
- **Demo Impact**: Phase accumulator demo fails to compile

## Existing Code Analysis

### UnitDelay Implementation (Correct)

```typescript
// signal-blocks.ts:376-401
lower: ({ ctx, inputsById, config }) => {
  const input = inputsById.in;
  // ...
  // Read previous state (this is the output - delayed by 1 frame)
  const outputId = ctx.b.sigStateRead(stateSlot, canonicalType(FLOAT));

  // Write current input to state for next frame
  ctx.b.stepStateWrite(stateSlot, input.id);

  return { outputsById: { out: ... } };
}
```

The UnitDelay lowering is correct - it reads from state for output, writes input to state. But it **still needs input resolved** to generate the state write step.

### The Two-Phase Execution Model

From CLAUDE.md:
> The runtime executes each frame in two phases: **Phase 1** evaluates all signals and reads from the previous frame's state, while **Phase 2** writes new state values for the next frame.

This is the key insight: at lowering time, we need to:
1. Generate the output (reads from state - no input dependency)
2. Generate the state write (needs input)

These are conceptually separate operations that should be lowerable in different orders.

## Solution Approaches

### Approach A: Two-Pass Lowering for SCCs

Split lowering into two phases for blocks in non-trivial SCCs:

**Phase A (Generate Outputs)**:
1. For stateful blocks: Generate state-read outputs (no input needed)
2. For non-stateful blocks: Skip (outputs depend on inputs)

**Phase B (Generate State Writes)**:
1. For stateful blocks: Generate state writes (inputs now available)
2. For non-stateful blocks: Full lowering (inputs now available from Phase A)

This matches the runtime's two-phase model.

### Approach B: Deferred Input Resolution

Modify input resolution to handle "not yet available" gracefully:
1. During lowering, if input source not found AND source block is stateful
2. Create a placeholder reference
3. After all blocks lowered, resolve placeholders

More complex, doesn't match semantic model as well.

### Approach C: Special SCC Ordering

For SCCs with stateful blocks:
1. Identify the stateful block(s)
2. Process stateful blocks FIRST (they don't need within-frame inputs)
3. Process remaining blocks in dependency order

Simpler but requires reordering within SCC.

## Recommended Approach

**Approach A (Two-Pass Lowering)** is recommended because:
1. Matches the runtime's two-phase execution model
2. Clear semantic separation (outputs vs state writes)
3. Works for any number of stateful blocks in a cycle
4. Minimal changes to existing lowering functions

## Files Affected

- `src/compiler/passes-v2/pass6-block-lowering.ts` - Main changes
- `src/blocks/registry.ts` - May need `LowerResult` to separate outputs from state writes
- `src/blocks/signal-blocks.ts` - May need to split UnitDelay/Lag lowering

## Test Coverage Needed

1. Simple feedback loop: UnitDelay in cycle
2. Complex feedback loop: Multiple blocks, one UnitDelay
3. Multiple stateful blocks in cycle
4. Nested cycles (SCC containing sub-SCCs)
5. Mixed stateful and non-stateful blocks in cycle
