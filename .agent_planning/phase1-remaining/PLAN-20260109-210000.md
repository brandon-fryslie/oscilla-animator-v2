# Sprint Plan: Phase 1 - Core Foundation (Unified)

**Generated**: 2026-01-09T21:00:00Z
**Spec Reference**: `design-docs/CANONICAL-oscilla-v2.5-20260109/`

---

## Sprint Goal

Complete all remaining Phase 1 work to achieve a fully functional compilation pipeline with slot-addressed runtime execution, proper time semantics, and working primitives catalog.

---

## Scope Overview

**In scope (this Phase 1 completion):**
- P0: IR-5-Axes implementation (approved plan already exists)
- P1: Type system IR integration
- P2: Time model completion
- P3: Compilation pipeline passes 5-10
- P4: Runtime offset-addressed execution
- P5: Buses and rails multi-writer semantics
- P6: Primitives catalog - Basic 12 + composites

**Explicitly out of scope (Phase 2+):**
- Editor UI integration
- Renderer implementation
- Phase matching/unwrap system
- Advanced transforms catalog
- Hot swap implementation

---

## Work Items

### P0: IR-5-Axes Implementation

**Reference**: `.agent_planning/ir-5-axes/PLAN-20260109-200000.md` (APPROVED)

This work is already planned and approved. Execute that plan which includes:
- CompiledProgramIR schema foundation
- SlotMeta with offsets + axes exposure
- Compiler passes 5-6 (lower to execution classes, build tables)
- Compiler passes 7-8 (schedule construction, slot planning)
- Runtime update (offset addressing)
- DebugIndexIR (passes 9-10)

**Estimated Sprints**: 3-4 (as per approved plan)

---

### P1: Type System IR Integration

**Goal**: Bridge SignalType/Extent to IR schema

#### P1.1: AxesDescIR Type
**File**: `src/compiler/ir/types.ts`

```typescript
interface AxesDescIR {
  readonly domain: "signal" | "field" | "event" | "value";
  readonly temporality: "static" | "discrete" | "continuous" | "instant";
  readonly perspective: "frame" | "sample" | "global";
  readonly branch: "single" | "branched";
  readonly identity:
    | { readonly kind: "none" }
    | { readonly kind: "keyed"; readonly keySpace: string };
}
```

#### P1.2: Bridge Functions
**File**: `src/compiler/ir/bridges.ts` (NEW)

- `bridgeExtentToAxesDescIR(extent: Extent): AxesDescIR`
- `bridgeCardinalityToIR(card: Cardinality): AxesDescIR['domain']`
- `bridgeTemporalityToIR(temp: Temporality): AxesDescIR['temporality']`

#### P1.3: SlotMetaEntry Integration
Update `SlotMetaEntry.type` to include AxesDescIR structure.

**Acceptance Criteria:**
- [ ] AxesDescIR interface matches spec
- [ ] All Extent variants map to IR correctly
- [ ] Bridge functions are pure (no side effects)
- [ ] SlotMetaEntry.type populated during compilation

---

### P2: Time Model Completion

**Goal**: Complete time semantics per spec

#### P2.1: TimeModel in IR
**File**: `src/compiler/ir/types.ts`

```typescript
type TimeModelIR =
  | { kind: 'infinite' }
  | { kind: 'finite'; durationMs: number }
  | { kind: 'cyclic'; periodMs: number };
```

Expose in CompiledProgramIR as `program.timeModel`.

#### P2.2: Time Unit Alignment
Update time blocks to use milliseconds (tMs) per spec:
- TimeRoot outputs `tMs` (int) not `t` (float seconds)
- All internal time calculations in milliseconds
- dt remains fractional for smoothness

#### P2.3: Phase Wrap System
**File**: `src/runtime/phase.ts` (NEW)

```typescript
function wrapPhase(value: number): number;
function phaseToFloat(phase: number): number;
function floatToPhase(f: number): number;
function phaseDistance(a: number, b: number): number;
```

**Acceptance Criteria:**
- [ ] TimeModelIR in CompiledProgramIR
- [ ] Time outputs use tMs (milliseconds)
- [ ] Phase wrap functions implemented
- [ ] Phase arithmetic follows spec rules

---

### P3: Compilation Pipeline Completion

**Goal**: Implement passes 5-10 fully

#### P3.1: Pass 5 - Execution Class Assignment
**File**: `src/compiler/passes-v2/pass5-execution-class.ts` (NEW)

Classify each node:
| Extent Pattern | Execution Class |
|----------------|-----------------|
| `one + continuous` | Scalar continuous |
| `many(domain) + continuous` | Field continuous |
| `one + discrete` | Scalar discrete |
| `many(domain) + discrete` | Field discrete |
| sinks | Render endpoints |

#### P3.2: Pass 6 - Build Execution Tables
**File**: `src/compiler/passes-v2/pass6-tables.ts` (NEW)

Create dense arrays:
- `signalExprs.nodes[]`
- `fieldExprs.nodes[]`
- `eventOps.nodes[]`
- `renderSinks[]`

#### P3.3: Pass 7 - Schedule Construction
**File**: `src/compiler/passes-v2/pass7-schedule.ts` (NEW)

Phase ordering:
1. Update rails/time inputs
2. Execute continuous scalars
3. Execute continuous fields (domain loops)
4. Apply discrete ops (events)
5. Sinks

#### P3.4: Pass 8 - Slot Planning
**File**: `src/compiler/passes-v2/pass8-slots.ts` (NEW)

Emit `slotMeta[]` with:
- slotId
- storage class (f64, f32, i32, object)
- offset (per-storage index)
- shape (scalar vs field)

#### P3.5: Pass 9-10 - Debug Index
**File**: `src/compiler/passes-v2/pass10-debug.ts` (NEW)

```typescript
interface DebugIndexIR {
  readonly stepToBlock: ReadonlyMap<StepId, BlockId>;
  readonly slotToBlock: ReadonlyMap<ValueSlot, BlockId>;
  readonly ports: readonly PortBindingIR[];
}
```

**Acceptance Criteria:**
- [ ] All nodes assigned to execution class
- [ ] Execution tables are dense arrays (no gaps)
- [ ] Schedule respects dependencies and phase ordering
- [ ] Slot offsets are per-storage class
- [ ] DebugIndexIR enables "click value → see port"

---

### P4: Runtime Offset-Addressed Execution

**Goal**: Runtime uses slotMeta.offset for all access

#### P4.1: Slot Access Functions
**File**: `src/runtime/slots.ts` (NEW)

```typescript
function readSlot(state: RuntimeState, meta: SlotMetaEntry): unknown {
  return state.stores[meta.storage][meta.offset];
}

function writeSlot(state: RuntimeState, meta: SlotMetaEntry, value: unknown): void {
  state.stores[meta.storage][meta.offset] = value;
}
```

#### P4.2: Schedule Executor Update
Update `ScheduleExecutor.ts` to:
- Execute schedule steps in order
- Use slot access functions
- No node tables or dynamic dispatch

#### P4.3: Performance Validation
- Runtime is O(work) with predictable loops
- No runtime type checks or inference
- Dense array access only

**Acceptance Criteria:**
- [ ] All slot access uses slotMeta.offset
- [ ] Runtime executes schedule (not nodes)
- [ ] No string lookups in hot loops
- [ ] Steel-thread test passes with new runtime

---

### P5: Buses and Rails

**Goal**: Multi-writer semantics and default sources

#### P5.1: Combine Block Insertion
**File**: `src/compiler/passes-v2/combine.ts` (NEW)

When input port has multiple writers:
1. Detect multi-writer during normalization
2. Insert combine block based on port's CombineMode
3. Route all writers through combine block

#### P5.2: CombineMode Implementation
For each combine mode, implement the operation:
- `sum`: Add all inputs
- `avg`: Average all inputs
- `max/min`: Select extremes
- `last/first`: Order-dependent selection
- `layer`: Z-ordered compositing

#### P5.3: Default Source Materialization
When input port has no writers:
1. Detect unconnected during normalization
2. Insert default source block based on PayloadType
3. Connect default source to port

#### P5.4: Rail System
Rails are immutable system buses:
- `time`, `phaseA`, `phaseB`, `pulse`, `palette`
- Always exist; can be overridden
- Derived blocks with role `{ kind: 'rail' }`

**Acceptance Criteria:**
- [ ] Multi-writer ports get combine blocks
- [ ] All combine modes implemented
- [ ] Unconnected ports get default sources
- [ ] Rails materialize as derived blocks
- [ ] Combine ordering is deterministic

---

### P6: Primitives Catalog

**Goal**: Complete Basic 12 and essential composites

#### P6.1: Complete Arithmetic Blocks
**Missing blocks:**
- `SubSignal`, `DivSignal`, `ModSignal`
- `Sin`, `Cos`, `Tan`, `Atan2`
- `Abs`, `Floor`, `Ceil`, `Round`
- `Min`, `Max`, `Clamp`
- `Step`, `Smoothstep`, `Mix`

#### P6.2: Stateful Primitives
Ensure all 4 MVP stateful blocks work:
- `UnitDelay` - `y(t) = x(t-1)`
- `Lag` - Smoothing filter
- `Phasor` - Phase accumulator
- `SampleAndHold` - Latch on trigger

#### P6.3: Basic 12 Completion
Verify all Basic 12 are implemented:
1. TimeRoot ✓
2. DomainN ✓
3. Id/U01 (FieldFromDomainId) ✓
4. Hash - Add if missing
5. Noise - Add if missing
6. Add ✓
7. Mul ✓
8. Length - Add if missing
9. Normalize - Add if missing
10. UnitDelay - Verify
11. HSV->RGB - Add if missing
12. RenderInstances2D ✓

#### P6.4: Essential Composites
Pre-built composite patterns:
- ColorCycle (phase → hue → RGB)
- SpiralLayout (golden angle positions)
- RadialGradient
- WavePattern

**Acceptance Criteria:**
- [ ] All arithmetic blocks implemented
- [ ] All 4 stateful primitives verified
- [ ] Basic 12 complete
- [ ] At least 4 composites available

---

## Sprint Allocation

### Sprint 1: Foundation (ir-5-axes P0-P1)
- Execute approved ir-5-axes plan P0 (schema)
- Execute approved ir-5-axes plan P1 (SlotMeta)
- Type system IR integration (P1 above)

### Sprint 2: Compilation (ir-5-axes P2-P4)
- Execute approved ir-5-axes P2 (passes 0-4)
- Execute approved ir-5-axes P3-P4 (passes 5-8)
- Time model completion (P2 above)

### Sprint 3: Runtime + Integration
- Runtime offset execution (P4)
- Execute ir-5-axes P5-P6 (runtime + debug)
- Buses and rails (P5)

### Sprint 4: Primitives + Polish
- Primitives catalog (P6)
- Integration testing
- Steel-thread validation

---

## Dependencies

External:
- Spec: `design-docs/CANONICAL-oscilla-v2.5-20260109/` (stable)

Internal:
- Type system foundation ✓ (90% complete)
- ir-5-axes plan ✓ (approved)
- Existing 25 blocks ✓ (working)
- 68 passing tests ✓

---

## Risks

1. **Schedule complexity** - Phase ordering with stateful blocks may reveal edge cases
   - Mitigation: Extensive ordering tests

2. **Dense table gaps** - Compilation may produce gaps in execution tables
   - Mitigation: Validation pass + assertions

3. **Runtime performance** - Offset addressing may not be faster initially
   - Mitigation: Benchmark before/after

4. **State migration** - Hot swap state continuity deferred but may surface issues
   - Mitigation: Design state IDs now, implement swap later

---

## Success Criteria

Phase 1 is complete when:
1. All 68+ tests pass
2. Steel-thread particle animation works with new pipeline
3. CompiledProgramIR matches spec exactly
4. Runtime uses slot offsets (no string lookups)
5. Basic 12 blocks all functional
6. At least one composite demonstrable

---

## Related Plans

- `.agent_planning/ir-5-axes/PLAN-20260109-200000.md` - Detailed ir-5-axes plan (APPROVED)
- `.agent_planning/ir-5-axes/DOD-20260109-200000.md` - ir-5-axes acceptance criteria
- `.agent_planning/ir-5-axes/CONTEXT-20260109-195500.md` - ir-5-axes context
