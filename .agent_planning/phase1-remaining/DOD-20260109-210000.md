# Definition of Done: Phase 1 - Core Foundation

**Generated**: 2026-01-09T21:00:00Z
**Plan Reference**: `PLAN-20260109-210000.md`

---

## Overview

Phase 1 is DONE when all acceptance criteria below are met.

---

## P0: IR-5-Axes (Approved Plan)

See `.agent_planning/ir-5-axes/DOD-20260109-200000.md` for detailed criteria.

Summary:
- [ ] CompiledProgramIR matches spec exactly
- [ ] `irVersion: 1` is literal type
- [ ] Execution tables are dense arrays
- [ ] `offset` is required on SlotMetaEntry
- [ ] All 5 axes defined in AxesDescIR
- [ ] Bridge functions handle all SignalType variants
- [ ] Schedule respects dependencies and phase ordering
- [ ] Slot offsets are per-storage class
- [ ] Runtime reads from `outputs[0].slot`
- [ ] All slot access uses `slotMeta.offset`
- [ ] Runtime is O(work) with predictable loops
- [ ] Debug index contains all slots
- [ ] Port bindings have accurate roles

---

## P1: Type System IR Integration

- [ ] `AxesDescIR` interface defined in `src/compiler/ir/types.ts`
- [ ] `AxesDescIR.domain` is one of: `"signal" | "field" | "event" | "value"`
- [ ] `AxesDescIR.temporality` is one of: `"static" | "discrete" | "continuous" | "instant"`
- [ ] `bridgeExtentToAxesDescIR()` function exists and is pure
- [ ] All `Cardinality` variants map correctly
- [ ] All `Temporality` variants map correctly
- [ ] `SlotMetaEntry.type.axes` populated during compilation
- [ ] Tests verify all axis combinations produce correct IR

---

## P2: Time Model Completion

- [ ] `TimeModelIR` type defined with `infinite | finite | cyclic` variants
- [ ] `CompiledProgramIR.timeModel` exists
- [ ] TimeRoot outputs `tMs` (int, milliseconds) not `t` (float, seconds)
- [ ] Time calculations internally use milliseconds
- [ ] `wrapPhase(value)` correctly wraps to [0, 1)
- [ ] `phaseDistance(a, b)` returns shortest signed distance
- [ ] Phase arithmetic rules enforced (phase + phase = ERROR)
- [ ] Tests verify time model variants produce expected schedules

---

## P3: Compilation Pipeline Completion

### Pass 5: Execution Class Assignment
- [ ] All nodes classified by execution class
- [ ] `one + continuous` → `ScalarContinuous`
- [ ] `many(domain) + continuous` → `FieldContinuous`
- [ ] `one + discrete` → `ScalarDiscrete`
- [ ] Sinks identified as render endpoints
- [ ] No unclassified nodes in output

### Pass 6: Build Execution Tables
- [ ] `signalExprs.nodes[]` is dense array
- [ ] `fieldExprs.nodes[]` is dense array
- [ ] `eventOps.nodes[]` is dense array
- [ ] No gaps in any execution table
- [ ] Tables ordered by slotId ascending

### Pass 7: Schedule Construction
- [ ] Schedule steps are explicit data
- [ ] Phase ordering: rails → scalars → fields → events → sinks
- [ ] Dependencies respected
- [ ] State reads before dependent computations
- [ ] State writes after computations
- [ ] Deterministic order (reproducible)

### Pass 8: Slot Planning
- [ ] All slots have assigned storage class
- [ ] Offsets are per-storage (not global)
- [ ] Offset assignment is stable (same input → same offsets)
- [ ] Shape includes domain reference for fields

### Pass 9-10: Debug Index
- [ ] `DebugIndexIR.stepToBlock` maps all steps
- [ ] `DebugIndexIR.slotToBlock` maps all slots
- [ ] Port bindings include direction and role
- [ ] Provenance enables "click value → see port"

---

## P4: Runtime Offset-Addressed Execution

- [ ] `readSlot()` function uses `meta.offset` not string lookup
- [ ] `writeSlot()` function uses `meta.offset`
- [ ] `ScheduleExecutor` executes schedule steps (not nodes)
- [ ] No dynamic dispatch in execution loop
- [ ] No `Map.get()` or `Record[key]` in hot paths
- [ ] Dense array access only for slot storage
- [ ] Steel-thread test passes with offset addressing
- [ ] Performance: No regression from current baseline

---

## P5: Buses and Rails

### Combine System
- [ ] Multi-writer detection works
- [ ] Combine blocks inserted during normalization
- [ ] `sum` mode: adds all inputs
- [ ] `avg` mode: averages all inputs
- [ ] `max`/`min` modes: select extremes
- [ ] `last`/`first` modes: order-dependent selection
- [ ] Combine ordering is deterministic

### Default Sources
- [ ] Unconnected port detection works
- [ ] Default source blocks inserted
- [ ] Default values match spec (phaseA for float, etc.)
- [ ] Every input has exactly one source (invariant I26)

### Rails
- [ ] `time` rail exists as derived block
- [ ] `phaseA` rail exists as derived block
- [ ] `phaseB` rail exists as derived block
- [ ] `pulse` rail exists as derived block
- [ ] `palette` rail exists as derived block
- [ ] Rails can be overridden (not read-only)

---

## P6: Primitives Catalog

### Arithmetic Blocks
- [ ] `SubSignal` implemented
- [ ] `DivSignal` implemented
- [ ] `Sin`, `Cos` implemented
- [ ] `Abs`, `Clamp` implemented
- [ ] `Min`, `Max` implemented

### Stateful Primitives
- [ ] `UnitDelay` works: `y(t) = x(t-1)`
- [ ] `Lag` works: smooth toward target
- [ ] `Phasor` works: 0..1 ramp with wrap
- [ ] `SampleAndHold` works: latch on trigger

### Basic 12 Complete
- [ ] TimeRoot ✓ (exists)
- [ ] DomainN ✓ (exists)
- [ ] Id/U01 ✓ (exists)
- [ ] Hash implemented
- [ ] Noise implemented
- [ ] Add ✓ (exists)
- [ ] Mul ✓ (exists)
- [ ] Length implemented
- [ ] Normalize implemented
- [ ] UnitDelay verified
- [ ] HSV→RGB implemented
- [ ] RenderInstances2D ✓ (exists)

### Composites
- [ ] At least 4 composites available
- [ ] ColorCycle composite works
- [ ] SpiralLayout composite works

---

## Integration Tests

- [ ] 68+ existing tests pass
- [ ] Steel-thread particle animation works end-to-end
- [ ] New tests for:
  - Dense table verification
  - Axes unification edge cases
  - Schedule determinism
  - Offset addressing correctness
  - Multi-writer combine
  - Default source generation

---

## Spec Compliance

- [ ] `CompiledProgramIR` has no forbidden fields:
  - No `program.nodes`
  - No `program.buses`
  - No `program.constPool` (only `constants.json`)
  - No `program.transforms`
  - No `program.meta` (except under debugIndex)
- [ ] Invariants I1-I27 not violated
- [ ] Type system matches `01-type-system.md`
- [ ] Runtime matches `05-runtime.md`
- [ ] Compilation matches `04-compilation.md`

---

## Final Validation

Phase 1 is **COMPLETE** when:

1. All checkboxes above are checked
2. All tests pass (`npm test` succeeds)
3. Steel-thread demonstration works
4. No known regressions
5. Code reviewed and merged

---

## Deferred to Phase 2

These items are NOT required for Phase 1 completion:

- Editor UI integration
- Renderer implementation (06-renderer.md)
- Hot swap implementation
- Phase matching system (10-phase-matching-system.md)
- Advanced transforms catalog
- Incremental compilation
- Performance optimization beyond baseline
