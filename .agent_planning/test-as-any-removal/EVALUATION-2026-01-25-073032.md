# Evaluation: Remove 'as any' casts from test files (oscilla-animator-v2-ar5)
Timestamp: 2026-01-25-073032
Git Commit: 25ae615

## Executive Summary
Overall: 25% complete | Critical issues: 0 | Tests reliable: yes

The beads issue states ~145 casts. Current count is 112. Recent commits (25ae615, 0d647ae) already removed ~33 casts. The remaining work is well-defined but involves 4-5 distinct patterns requiring different fixes.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| Typecheck | PASS | All tests pass with current 'as any' casts |
| Test suite | PASS | Tests functional, casts are type-level only |
| Count verification | PASS | 112 remaining casts across 20 files |

## Missing Checks
None required for this refactoring. This is pure type-level cleanup.

## Findings

### Category 1: Field kernel type params (30 instances)
**Status**: NOT_STARTED
**Evidence**: `src/runtime/__tests__/field-kernel-contracts.test.ts:30-500+`
**Pattern**:
```typescript
const type = { payload: 'vec2', cardinality: 'many' } as const;
applyFieldKernel(out, [x, y], 'makeVec2', 3, type as any);
```

**Root Cause**: Tests create partial type literals instead of proper `CanonicalType` objects. The kernel function expects `CanonicalType` (which has `payload`, `unit`, `extent` axes), but tests only provide `{ payload, cardinality }`.

**Fix**: Use `signalTypeField(payload, instanceId)` which produces proper CanonicalType. For tests that don't need instance tracking, can create a test helper:
```typescript
function testFieldType(payload: PayloadType): CanonicalType {
  return signalTypeField(payload, 'test-instance');
}
```

**Complexity**: LOW - Mechanical replacement across 30 call sites
**Risk**: LOW - Type-only change, runtime behavior unchanged

### Category 2: SigExprId branded type (6 instances)
**Status**: PARTIAL (some done in recent commits)
**Evidence**: `EventEvaluator.test.ts:133`, `event-blocks.test.ts:176,179`
**Pattern**:
```typescript
{ kind: 'wrap', signal: 0 as any }, // SigExprId = 0
```

**Fix**: Import `sigExprId` from types and use `sigExprId(0)`.
Already exists: `src/compiler/ir/Indices.ts:101`

**Complexity**: TRIVIAL - Direct replacement
**Risk**: NONE

### Category 3: Internal builder access (10 instances)
**Status**: NOT_STARTED
**Evidence**: `expression-blocks.test.ts:96-200`
**Pattern**:
```typescript
const sigId = (outputRef as any).id;
const sigExpr = builder['sigExprs'][sigId as any];
expect((sigExpr as any).value).toBe(0);
```

**Root Cause**: Tests verify IRBuilder internals but type definitions don't expose `id` property on `SigRef`. The `SigRef` type probably needs an `id: SigExprId` property, or tests need to use a different verification approach.

**Options**:
1. Add `id` property to `SigRef` type (proper fix)
2. Use typed test accessors (keeps internals private)
3. Create explicit test inspection API

**Complexity**: MEDIUM - Requires understanding `SigRef` design intent
**Risk**: LOW - Change is either type-only or adds read-only accessor

### Category 4: CompilationInspector output (9 instances)
**Status**: NOT_STARTED
**Evidence**: `CompilationInspectorService.test.ts:239-410`
**Pattern**:
```typescript
const output = snapshot?.passes[0].output as any;
expect(output.a).toBe(1);
```

**Root Cause**: Pass output typed as `unknown` since passes have heterogeneous outputs.

**Fix Options**:
1. Type-safe pass result accessors: `snapshot.getPassOutput<MyType>('passName')`
2. Runtime type guards with assertions
3. Accept `as unknown as T` pattern for test-only introspection (still uses cast but more explicit)

**Complexity**: MEDIUM - Architectural decision needed
**Risk**: LOW - Test-only code

### Category 5: Block definition mocking (9 instances)
**Status**: NOT_STARTED
**Evidence**: `exportFormats.test.ts:116-215`
**Pattern**:
```typescript
inputs: {
  count: { type: { payload: 'float' } as any, value: 100 },
},
```

**Root Cause**: Tests create mock block definitions with partial CanonicalType.

**Fix**: Use `canonicalType('float')` which returns complete CanonicalType with defaults:
```typescript
inputs: {
  count: { type: canonicalType('float'), value: 100 },
},
```

**Complexity**: LOW - Import and use existing factory
**Risk**: NONE

### Category 6: React props access (11 instances)
**Status**: NOT_STARTED
**Evidence**: `ValueRenderer.test.ts:36-104`
**Pattern**:
```typescript
expect((el.props as any)['data-renderer']).toBe('exact-float-phase');
```

**Root Cause**: JSX element props don't expose `data-*` attributes in type.

**Fix Options**:
1. Use `data-testid` with proper RTL queries
2. Create typed test helper: `getDataAttr(el, 'renderer')`
3. Cast only the attribute access: `(el.props as Record<string, unknown>)['data-renderer']`

**Complexity**: LOW - Mechanical change
**Risk**: NONE

### Category 7: Mock canvas context (4 instances)
**Status**: NOT_STARTED
**Evidence**: `continuity-integration.test.ts:386`, `stroke-rendering.test.ts:114`, `DebugMiniView.test.tsx:43`, `Sparkline.test.tsx:61`
**Pattern**:
```typescript
(ctx.fill as any).mockImplementation(() => calls.push('fill'));
HTMLCanvasElement.prototype.getContext = vi.fn(() => mockCtx) as any;
```

**Root Cause**: Vitest mock types don't chain properly with method implementations.

**Fix**: Create properly typed mock context helper:
```typescript
function createMockCanvas2DContext(): MockedContext2D {
  return {
    fill: vi.fn(),
    stroke: vi.fn(),
    // ... other needed methods
  } as unknown as MockedContext2D;
}
```

**Complexity**: LOW - One helper, reuse across tests
**Risk**: NONE

### Category 8: CanonicalType for local-space tests (6 instances)
**Status**: NOT_STARTED
**Evidence**: `local-space-sanity.test.ts:35-157`

Same fix as Category 1 - use `signalTypeField()`.

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| SigRef.id | Should SigRef expose id property? | Tests access via any cast | LOW - Can use bracket access if private by design |
| Pass output typing | Generic or discriminated union? | Tests use any | LOW - Test-only, either approach works |

## Recommendations

### Sprint 1: Trivial fixes (30 min)
1. Category 2: SigExprId branded types (6 instances)
2. Category 5: Block definition mocking (9 instances)
Total: 15 casts removed

### Sprint 2: Field kernel types (1 hour)
1. Category 1: field-kernel-contracts.test.ts (30 instances)
2. Category 8: local-space-sanity.test.ts (6 instances)
Total: 36 casts removed

### Sprint 3: React/Mock patterns (45 min)
1. Category 6: React props access (11 instances)
2. Category 7: Mock canvas context (4 instances)
Total: 15 casts removed

### Sprint 4: Requires design decision (1 hour)
1. Category 3: Internal builder access (10 instances)
2. Category 4: CompilationInspector output (9 instances)
Total: 19 casts removed

### Remaining (~17 casts in misc files)
- projection tests, compiler tests, stores tests
- Each file has 1-4 casts, fix opportunistically

## Dependencies
- Sprints 1-3 are independent and can be parallelized
- Sprint 4 may want brief design discussion before implementation
- No dependencies on other ongoing work

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix

Work is well-defined. All patterns have known fixes. No architectural blockers. Suggest doing Sprints 1-3 as one unit (96 casts, ~2 hours), then Sprint 4 separately if design input is wanted.

## Alternative: Single Sprint Approach
If the implementer prefers, all 112 casts can be addressed in a single focused session (~3 hours). The patterns are repetitive and the fixes are mechanical. The "design decisions" in Sprint 4 are minor - either approach (public accessor vs bracket access) works fine for tests.

---

## Final Output

```
project-evaluator complete
  Scope: test-as-any-removal | Completion: 25% | Gaps: 112 remaining casts
  Workflow: CONTINUE
  -> Implement in 2-4 sprints: trivial fixes, field types, react/mocks, builder access
```
