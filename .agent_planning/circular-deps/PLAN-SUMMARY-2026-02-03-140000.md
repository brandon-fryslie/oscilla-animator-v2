# Planning Summary: Circular Dependencies

**Topic**: Address circular dependencies between registry, compiler, and stores modules
**Generated**: 2026-02-03-140000
**Status**: Awaiting user approval

## Key Finding from Evaluation

**The circular dependency claim in the test skip comment is MISDIAGNOSED.**

- **What the comment claims**: `blocks/registry -> compiler modules -> stores` causes heap exhaustion
- **What actually exists**: `stores/` and `compiler/` have ZERO imports between each other -- no cycle exists involving stores
- **Real issue**: There IS a bidirectional dependency between `blocks/` and `compiler/ir/`, but it's not causing runtime failures

## Sprint Plan Overview

Total Sprints: **3**

### Sprint 1: test-reenable [HIGH CONFIDENCE - READY FOR IMPLEMENTATION]
**Status**: READY FOR IMPLEMENTATION
**Confidence**: HIGH: 3, MEDIUM: 0, LOW: 0

**Deliverables:**
- Remove `.skip` from 3 Store Integration tests in `composite-roundtrip.test.ts`
- Remove incorrect circular dependency comments (lines 524-526)
- Verify all tests pass

**Effort**: 2-line code change (delete 3 comment lines, change `describe.skip` to `describe`)

**Rationale**: The evaluation proves the circular dependency diagnosis is wrong. Similar store integration tests in `stores/__tests__/integration.test.ts` pass fine (11/11). The committed version (fa107a3) did NOT skip these tests.

**Files**:
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140000-test-reenable-PLAN.md`
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140000-test-reenable-DOD.md`
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140000-test-reenable-CONTEXT.md`

---

### Sprint 2: boundary-enforcement [PARTIALLY READY]
**Status**: PARTIALLY READY
**Confidence**: HIGH: 1, MEDIUM: 2, LOW: 0

**Deliverables:**
- Select and configure dependency boundary enforcement tool (eslint-plugin-boundaries or dependency-cruiser)
- Configure rules matching CLAUDE.md "ONE-WAY DEPENDENCIES" law
- Integrate into `npm run lint` pipeline
- Document intended module dependency architecture

**Research Needed:**
1. Does eslint-plugin-boundaries work with ESLint 9 flat config? (check npm page/docs)
2. Can dependency-cruiser allow known violations while flagging new ones? (check config)

**Rationale**: CLAUDE.md requires "Automated/Programmatic enforcement" of architectural constraints. Currently no tooling prevents new bidirectional import violations.

**Files**:
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140100-boundary-enforcement-PLAN.md`
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140100-boundary-enforcement-DOD.md`
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140100-boundary-enforcement-CONTEXT.md`

---

### Sprint 3: architecture-eval [RESEARCH REQUIRED]
**Status**: RESEARCH REQUIRED
**Confidence**: HIGH: 0, MEDIUM: 1, LOW: 2

**Deliverables:**
- Analysis of Option A (status quo), Option B (compiler owns lowering), Option C (shared IR primitives)
- Prototype of Option C if deemed viable
- User decision on preferred architecture
- Migration effort estimate

**Research Needed:**
1. Can LowerSandbox be extracted to shared layer without creating a NEW cycle?
2. Does moving OpCode violate "IRs have explicit ownership" guideline?
3. User preference: strict one-way enforcement vs pragmatic peer relationship?
4. Is the current cycle a real risk or purely theoretical?

**Rationale**: The bidirectional `blocks/` <-> `compiler/ir/` dependency violates CLAUDE.md "ONE-WAY DEPENDENCIES" law. However, it works in practice and is a deliberate design choice (blocks define their own lowering). User input needed on strictness of enforcement.

**Three Options Analyzed:**
- **Option A (status quo)**: Keep bidirectional dependency, works fine, good locality
- **Option B (compiler owns lowering)**: Move all lower() to compiler, breaks block self-containment
- **Option C (shared IR primitives)**: Extract OpCode/Indices to shared layer, least disruptive

**Files**:
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140200-architecture-eval-PLAN.md`
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140200-architecture-eval-DOD.md`
- `.agent_planning/circular-deps/SPRINT-2026-02-03-140200-architecture-eval-CONTEXT.md`

---

## Dependency Graph

All sprints are **independent** and can proceed in parallel:
- Sprint 1 (test-reenable) -- no dependencies, ready to implement
- Sprint 2 (boundary-enforcement) -- no dependencies, needs research first
- Sprint 3 (architecture-eval) -- no dependencies, needs research + user input

---

## Recommendation

**Immediate action**: Execute Sprint 1 (test-reenable) via `/do:it circular-deps`. This is a trivial change that fixes the incorrect diagnosis.

**Medium-term**: Execute Sprint 2 (boundary-enforcement) to prevent NEW architectural violations, regardless of Sprint 3 outcome.

**Long-term**: Sprint 3 is optional -- the bidirectional blocks/compiler dependency is not causing problems. Consider deferring until there's a clear architectural reason to change it.

---

## Files Created

**Evaluation**:
- `EVALUATION-2026-02-03-131723.md` - Full evaluation with dependency analysis
- `EXPLORE-2026-02-03-131723.md` - Exploration logs from evaluation

**Sprint Plans** (3 sprints Ã— 3 files each = 9 files):
- `SPRINT-*-test-reenable-{PLAN,DOD,CONTEXT}.md` [HIGH confidence]
- `SPRINT-*-boundary-enforcement-{PLAN,DOD,CONTEXT}.md` [MEDIUM confidence]
- `SPRINT-*-architecture-eval-{PLAN,DOD,CONTEXT}.md` [LOW confidence]

**This Summary**:
- `PLAN-SUMMARY-2026-02-03-140000.md` (this file)

All files in: `.agent_planning/circular-deps/`
