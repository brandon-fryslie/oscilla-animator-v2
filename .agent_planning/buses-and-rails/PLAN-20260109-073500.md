# Sprint Plan: Rails Foundation

**Timestamp**: 2026-01-09T07:35:00Z
**Topic**: buses-and-rails
**Sprint ID**: SPRINT-RAILS-001

---

## Sprint Goal

Establish the foundational type system for block/edge roles and implement 6 rail blocks that provide the global temporal modulation infrastructure (time, phaseA, phaseB, pulse, palette, energy).

---

## User Decisions Applied

1. **Palette**: Is a time-indexed color field `palette(t) = ColorCurve.evaluate(t)` - the chromatic reference frame
2. **Energy**: KEEP as a rail - audio-reactive level
3. **Scope**: Rails only this sprint - no BusBlock implementation

---

## In Scope

1. **P0 - BlockRole & DerivedBlockMeta types** (foundational)
   - Add discriminated union types to `src/types/index.ts`
   - No runtime changes - pure type definitions
   - EdgeRole types for completeness

2. **P1 - TimeRoot output corrections**
   - Rename outputs: `t` -> `tMs`, `phase` -> `phaseA`, add `phaseB`
   - Fix types: `tMs` should be `int`, not `float`
   - Add `palette` output (color rail sourced from TimeRoot)
   - Keep `energy` rail
   - Fix `eventType()` helper to use discrete temporality

3. **P2 - Rail blocks & normalization injection**
   - Create 6 rail block definitions (time, phaseA, phaseB, pulse, palette, energy)
   - Update `normalize.ts` to inject rails into every patch
   - Connect rails to TimeRoot outputs during normalization

---

## Out of Scope

- BusBlock implementation (user-created buses)
- Multi-writer combine logic for buses
- EdgeRole runtime enforcement
- UI filtering based on roles
- DefaultSource block creation
- Full graph normalization with default source injection

---

## Work Items

### P0: BlockRole & DerivedBlockMeta Types
**Priority**: P0 (Blocking)
**Estimated Size**: Small
**Location**: `src/types/index.ts`

**Deliverable**: Type definitions only, no runtime impact.

```typescript
// BlockRole discriminated union
type BlockRole =
  | { kind: "user" }
  | { kind: "derived"; meta: DerivedBlockMeta };

// DerivedBlockMeta discriminated union
type DerivedBlockMeta =
  | { kind: "defaultSource"; target: { kind: "port"; port: PortRef } }
  | { kind: "wireState";     target: { kind: "wire"; wire: WireId } }
  | { kind: "bus";           target: { kind: "bus"; busId: BusId } }
  | { kind: "rail";          target: { kind: "bus"; busId: BusId } }
  | { kind: "lens";          target: { kind: "node"; node: NodeRef } };

// EdgeRole discriminated union
type EdgeRole =
  | { kind: "user" }
  | { kind: "default"; meta: { defaultSourceBlockId: BlockId } }
  | { kind: "busTap";  meta: { busId: BusId } }
  | { kind: "auto";    meta: { reason: "portMoved" | "rehydrate" | "migrate" } };
```

**Acceptance Criteria**:
- [ ] Types compile without errors
- [ ] Types match spec in `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/02-block-system.md`
- [ ] All discriminators use `kind` property
- [ ] No optional fields - all meta types are explicit

---

### P1: TimeRoot Output Corrections
**Priority**: P1 (High)
**Estimated Size**: Medium
**Locations**:
- `src/compiler/blocks/time/InfiniteTimeRoot.ts`
- `src/compiler/blocks/time/FiniteTimeRoot.ts`
- `src/compiler/blocks/registry.ts` (fix eventType helper)

**Changes Required**:

1. **Rename outputs**:
   - `t` -> `tMs` (milliseconds, not generic time)
   - `phase` -> `phaseA` (primary phase)
   - Add `phaseB` (secondary phase, offset or different period)

2. **Fix signal types**:
   - `tMs`: `one + continuous + int` (currently using `float`)
   - `phaseA/phaseB`: `one + continuous + phase` (correct)
   - `pulse`: `one + discrete + unit` (needs discrete temporality)
   - `palette`: `one + continuous + color` (new output)
   - `energy`: `one + continuous + float` (keep as-is)

3. **Fix eventType() helper**:
   - Change from `signalTypeSignal()` to `signalTypeTrigger()` for discrete temporality

4. **Add palette output**:
   - For MVP, emit a simple color cycle: `hue = phaseA`, saturation = 1, lightness = 0.5
   - Creates HSV rainbow cycling with phase

5. **Add phaseB output**:
   - Default: phaseB period = phaseA period * 0.5 (or configurable via params)

**Acceptance Criteria**:
- [ ] Output names match spec (tMs, phaseA, phaseB, pulse, palette, energy, progress for finite)
- [ ] SignalType for tMs uses `int` payload
- [ ] `eventType()` helper uses `signalTypeTrigger()` for discrete temporality
- [ ] Palette output emits a color value (HSV rainbow)
- [ ] phaseB has configurable period ratio
- [ ] All existing tests pass (update wire references from `t` to `tMs`, `phase` to `phaseA`)

---

### P2: Rail Blocks & Normalization Injection
**Priority**: P2 (Medium)
**Estimated Size**: Large
**Locations**:
- New directory: `src/compiler/blocks/time/rails/`
- `src/graph/normalize.ts`

**Rail Block Definitions** (6 blocks):

| Rail ID | Block Type | Input Source | Output Type |
|---------|------------|--------------|-------------|
| `time` | `TimeRail` | TimeRoot.tMs | `one + continuous + int` |
| `phaseA` | `PhaseARail` | TimeRoot.phaseA | `one + continuous + phase` |
| `phaseB` | `PhaseBRail` | TimeRoot.phaseB | `one + continuous + phase` |
| `pulse` | `PulseRail` | TimeRoot.pulse | `one + discrete + unit` |
| `palette` | `PaletteRail` | TimeRoot.palette | `one + continuous + color` |
| `energy` | `EnergyRail` | TimeRoot.energy | `one + continuous + float` |

**Rail Block Structure**:
```typescript
// Each rail block is a pass-through with role metadata
registerBlock({
  type: 'TimeRail',
  inputs: [{ portId: portId('in'), type: sigType('int') }],
  outputs: [{ portId: portId('out'), type: sigType('int') }],
  lower: ({ inputsById }) => {
    const input = sig(inputsById, 'in');
    return { out: input }; // Pass-through
  }
});
```

**Normalization Changes**:
1. After normalizing blocks, inject TimeRoot if not present
2. Inject 6 rail blocks with `role: { kind: 'derived', meta: { kind: 'rail', ... } }`
3. Wire TimeRoot outputs to corresponding rail inputs

**Acceptance Criteria**:
- [ ] 6 rail block definitions registered
- [ ] Normalization injects rails into every patch
- [ ] Rails are wired to TimeRoot outputs
- [ ] Existing tests don't break (rails should be transparent pass-throughs)
- [ ] Rails have correct `role` metadata when Block type supports it

---

## Technical Notes

### Type System State
- Codebase has TWO parallel type systems: `TypeDesc` (old) and `SignalType` (new/canonical)
- TimeRoot blocks already use `SignalType` via `sigType()` helper
- Bridge functions exist in `src/compiler/ir/bridge.ts`
- **Action**: Use `SignalType` for all new code

### Block Registration Pattern
Follow the established pattern in `src/compiler/blocks/registry.ts`:
1. Import from registry: `registerBlock`, `portId`, `sigType`, etc.
2. Define `BlockLower` function
3. Call `registerBlock()` with type, inputs, outputs, lower function
4. Import in `index.ts` to trigger registration

### Signal Type Helpers
- `sigType('float')` -> one + continuous + float
- `sigType('int')` -> one + continuous + int
- `sigType('phase')` -> one + continuous + phase
- `sigType('color')` -> one + continuous + color
- `eventType('unit')` -> BROKEN - needs fix to use `signalTypeTrigger()`

### Normalization Architecture
Current `normalize.ts` only does:
- Block indexing (Map -> array)
- Edge validation (dangling edge detection)
- Edge normalization (to NormalizedEdge)

It does NOT:
- Inject TimeRoot
- Inject Rails
- Inject DefaultSources
- Assign roles

**Action**: Add rail injection as first step in normalization pipeline.

---

## Dependencies

1. **P0 -> P1**: TimeRoot needs to know about DerivedBlockMeta types (soft dependency - can stub for now)
2. **P0 -> P2**: Rail blocks need BlockRole types to set correct role metadata
3. **P1 -> P2**: Rails depend on correct TimeRoot outputs to wire to

**Critical Path**: P0 -> P1 -> P2

---

## Risks

### 1. Breaking Existing Tests
**Risk**: Tests wire to `phase` output, renaming to `phaseA` breaks them
**Mitigation**: Update test files to use new names (`tMs`, `phaseA`)

### 2. Type System Mismatch
**Risk**: Old TypeDesc vs new SignalType creates friction
**Mitigation**: Use SignalType exclusively in new code, bridge.ts handles conversion

### 3. Normalization Scope Creep
**Risk**: Rail injection opens door to full normalization implementation
**Mitigation**: Strict scope - only inject rails, don't implement DefaultSources

### 4. EventType is Broken
**Risk**: `eventType()` helper returns continuous, not discrete
**Mitigation**: Fix `eventType()` to use `signalTypeTrigger()` as part of P1
