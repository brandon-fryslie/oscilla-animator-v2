# Implementation Context: Graph Normalizer Pass Refactoring

**Date**: 2026-01-12
**Purpose**: Extract `src/graph/normalize.ts` into `src/graph/passes/`

---

## Directory Structure

```
src/graph/
├── normalize.ts              # Thin wrapper (re-exports)
├── passes/
│   ├── index.ts              # Orchestrator + exports
│   ├── pass0-polymorphic-types.ts
│   ├── pass1-default-sources.ts
│   ├── pass2-adapters.ts
│   └── pass3-indexing.ts
├── Patch.ts                  # (unchanged)
└── adapters.ts               # (unchanged)
```

---

## Line Extraction Map

From `src/graph/normalize.ts`:

| Pass | Lines to Extract | Functions |
|------|------------------|-----------|
| Pass 0 | 181-273 | `resolvePolymorphicTypes()` |
| Pass 1 | 73-164, 278-302 | `DefaultSourceInsertion`, `hasIncomingEdge()`, `generateDefaultSourceId()`, `analyzeDefaultSources()`, `applyDefaultSourceInsertions()` |
| Pass 2 | 308-496 | `AdapterInsertion`, `generateAdapterId()`, `getPortType()`, `analyzeAdapters()`, `applyAdapterInsertions()` |
| Pass 3 | 24-67, 517-580, 587-607 | Types + indexing logic + query helpers |

---

## Pass 0: Polymorphic Types

**File**: `src/graph/passes/pass0-polymorphic-types.ts`

```typescript
/**
 * Pass 0: Polymorphic Type Resolution
 *
 * Resolves '???' types by propagating concrete types bidirectionally.
 */

import type { BlockId } from '../../types';
import type { Block, Patch } from '../Patch';
import { getBlockDefinition } from '../../blocks/registry';

/**
 * Resolve '???' (polymorphic) types by propagating concrete types.
 *
 * @param patch - Raw patch
 * @returns Patch with resolved payloadType in block params
 */
export function pass0PolymorphicTypes(patch: Patch): Patch {
  // ... extract lines 182-272 from normalize.ts
}
```

---

## Pass 1: Default Sources

**File**: `src/graph/passes/pass1-default-sources.ts`

```typescript
/**
 * Pass 1: Default Source Materialization
 *
 * Inserts Const blocks for unconnected inputs with defaultSource.
 */

import type { BlockId, PortId, BlockRole, DefaultSource } from '../../types';
import type { Block, Edge, Patch } from '../Patch';
import { getBlockDefinition, type InputDef } from '../../blocks/registry';

interface DefaultSourceInsertion {
  block: Block;
  edge: Edge;
}

// ... extract helper functions

/**
 * Materialize default sources for unconnected inputs.
 *
 * @param patch - Patch from Pass 0
 * @returns Patch with Const blocks inserted
 */
export function pass1DefaultSources(patch: Patch): Patch {
  const insertions = analyzeDefaultSources(patch);
  return applyDefaultSourceInsertions(patch, insertions);
}
```

---

## Pass 2: Adapters

**File**: `src/graph/passes/pass2-adapters.ts`

```typescript
/**
 * Pass 2: Adapter Insertion
 *
 * Inserts adapter blocks for type-mismatched edges.
 */

import type { BlockId, PortId, BlockRole } from '../../types';
import type { CanonicalType } from '../../core/canonical-types';
import type { Block, Edge, Patch } from '../Patch';
import { getBlockDefinition } from '../../blocks/registry';
import { findAdapter, type AdapterSpec } from '../adapters';

// Error types
export type AdapterError =
  | { kind: 'UnknownPort'; blockId: BlockId; portId: string; direction: 'input' | 'output' }
  | { kind: 'NoAdapterFound'; edge: Edge; fromType: string; toType: string };

export interface Pass2Result {
  readonly kind: 'ok';
  readonly patch: Patch;
}

export interface Pass2Error {
  readonly kind: 'error';
  readonly errors: readonly AdapterError[];
}

// ... extract helper functions

/**
 * Insert adapters for type-mismatched edges.
 *
 * @param patch - Patch from Pass 1
 * @returns Patch with adapters, or errors
 */
export function pass2Adapters(patch: Patch): Pass2Result | Pass2Error {
  const errors: AdapterError[] = [];
  const insertions = analyzeAdapters(patch, errors);

  if (errors.length > 0) {
    return { kind: 'error', errors };
  }

  return { kind: 'ok', patch: applyAdapterInsertions(patch, insertions) };
}
```

---

## Pass 3: Indexing

**File**: `src/graph/passes/pass3-indexing.ts`

```typescript
/**
 * Pass 3: Block Indexing and Edge Normalization
 *
 * Builds dense block indices and normalizes edges.
 */

import type { BlockId, PortId } from '../../types';
import type { Block, Edge, Patch } from '../Patch';

// Type exports
export type BlockIndex = number & { readonly __brand: 'BlockIndex' };

export interface NormalizedPatch {
  readonly patch: Patch;
  readonly blockIndex: ReadonlyMap<BlockId, BlockIndex>;
  readonly blocks: readonly Block[];
  readonly edges: readonly NormalizedEdge[];
}

export interface NormalizedEdge {
  readonly fromBlock: BlockIndex;
  readonly fromPort: PortId;
  readonly toBlock: BlockIndex;
  readonly toPort: PortId;
}

// Error types
export type IndexingError =
  | { kind: 'DanglingEdge'; edge: Edge; missing: 'from' | 'to' }
  | { kind: 'DuplicateBlockId'; id: BlockId };

export interface Pass3Result {
  readonly kind: 'ok';
  readonly patch: NormalizedPatch;
}

export interface Pass3Error {
  readonly kind: 'error';
  readonly errors: readonly IndexingError[];
}

/**
 * Build block indices and normalize edges.
 *
 * @param patch - Patch from Pass 2
 * @returns NormalizedPatch with indices, or errors
 */
export function pass3Indexing(patch: Patch): Pass3Result | Pass3Error {
  // ... extract indexing logic from lines 517-566
}

// Query helpers
export function getInputEdges(
  patch: NormalizedPatch,
  blockIdx: BlockIndex,
  portId: PortId
): readonly NormalizedEdge[] {
  return patch.edges.filter(e => e.toBlock === blockIdx && e.toPort === portId);
}

export function getOutputEdges(
  patch: NormalizedPatch,
  blockIdx: BlockIndex,
  portId: PortId
): readonly NormalizedEdge[] {
  return patch.edges.filter(e => e.fromBlock === blockIdx && e.fromPort === portId);
}
```

---

## Orchestrator

**File**: `src/graph/passes/index.ts`

```typescript
/**
 * Graph Normalization Passes
 *
 * Orchestrates the normalization pipeline:
 * - Pass 0: Polymorphic type resolution
 * - Pass 1: Default source materialization
 * - Pass 2: Adapter insertion
 * - Pass 3: Block indexing
 */

import type { Patch } from '../Patch';
import { pass0PolymorphicTypes } from './pass0-polymorphic-types';
import { pass1DefaultSources } from './pass1-default-sources';
import { pass2Adapters, type AdapterError } from './pass2-adapters';
import { pass3Indexing, type IndexingError, type NormalizedPatch } from './pass3-indexing';

// Re-export types
export type { NormalizedPatch, NormalizedEdge, BlockIndex } from './pass3-indexing';
export type { AdapterError } from './pass2-adapters';
export type { IndexingError } from './pass3-indexing';

// Unified error type
export type NormError = AdapterError | IndexingError;

export interface NormalizeResult {
  readonly kind: 'ok';
  readonly patch: NormalizedPatch;
}

export interface NormalizeError {
  readonly kind: 'error';
  readonly errors: readonly NormError[];
}

/**
 * Run all normalization passes.
 */
export function runNormalizationPasses(patch: Patch): NormalizeResult | NormalizeError {
  // Pass 0: Polymorphic type resolution
  const p0 = pass0PolymorphicTypes(patch);

  // Pass 1: Default source materialization
  const p1 = pass1DefaultSources(p0);

  // Pass 2: Adapter insertion
  const p2Result = pass2Adapters(p1);
  if (p2Result.kind === 'error') {
    return { kind: 'error', errors: p2Result.errors };
  }

  // Pass 3: Block indexing
  const p3Result = pass3Indexing(p2Result.patch);
  if (p3Result.kind === 'error') {
    return { kind: 'error', errors: p3Result.errors };
  }

  return { kind: 'ok', patch: p3Result.patch };
}

// Re-export individual passes for testing
export { pass0PolymorphicTypes } from './pass0-polymorphic-types';
export { pass1DefaultSources } from './pass1-default-sources';
export { pass2Adapters } from './pass2-adapters';
export { pass3Indexing, getInputEdges, getOutputEdges } from './pass3-indexing';
```

---

## Updated normalize.ts

**File**: `src/graph/normalize.ts`

```typescript
/**
 * Graph Normalization
 *
 * This module re-exports the normalization pipeline from ./passes/
 * for backward compatibility.
 *
 * @see ./passes/ for implementation
 */

// Re-export the main function
export { runNormalizationPasses as normalize } from './passes';

// Re-export types
export type {
  NormalizedPatch,
  NormalizedEdge,
  BlockIndex,
  NormalizeResult,
  NormalizeError,
  NormError,
} from './passes';

// Re-export query helpers
export { getInputEdges, getOutputEdges } from './passes';
```

---

## Verification

```bash
# Type check
npm run typecheck

# Run tests
npm run test

# Build
npm run build

# Verify compiler still works
grep -r "from.*graph/normalize" src/compiler/
# Should show imports unchanged
```
