# Convert Topology IDs from String to Numeric

**Bead**: oscilla-animator-v2-4h6
**Status**: Planning
**Created**: 2026-01-22
**Priority**: P3 (Low - Performance optimization)
**Depends on**: oscilla-animator-v2-583 (RenderAssembler v2)

## Summary

Convert topology identification from string-based Map lookups to numeric array-indexed access for O(1) performance in the hot render path. This change affects the shape system's core type definitions, registry implementation, and all consumers across compiler, runtime, and renderer.

## Current State (String-Based)

**Type Definition** (`src/shapes/types.ts:16`):
```typescript
export type TopologyId = string;
```

**Registry Implementation** (`src/shapes/registry.ts:19-22`):
```typescript
const TOPOLOGY_REGISTRY: Map<TopologyId, TopologyDef> = new Map([
  [TOPOLOGY_ELLIPSE.id, TOPOLOGY_ELLIPSE],
  [TOPOLOGY_RECT.id, TOPOLOGY_RECT],
]);
```

**Lookup** (`src/shapes/registry.ts:31-37`):
```typescript
export function getTopology(id: TopologyId): TopologyDef {
  const topology = TOPOLOGY_REGISTRY.get(id);
  if (!topology) {
    throw new Error(`Unknown topology ID: ${id}`);
  }
  return topology;
}
```

**Built-in Topologies** (`src/shapes/topologies.ts`):
- `TOPOLOGY_ELLIPSE`: `id: 'ellipse'`
- `TOPOLOGY_RECT`: `id: 'rect'`

**Dynamic Registration** (`src/shapes/registry.ts:66-68`, `src/blocks/path-blocks.ts:54`):
- Path blocks create string IDs like `'polygon-5'`, `'polygon-7'`
- Registered during block lowering via `registerDynamicTopology()`

## Target State (Numeric-Based)

**Type Definition**:
```typescript
export type TopologyId = number;  // Array index, not string
```

**Registry Implementation**:
```typescript
const TOPOLOGY_REGISTRY: TopologyDef[] = [];
const TOPOLOGY_BY_NAME: Map<string, number> = new Map(); // For debugging/lookup only
```

**Lookup**:
```typescript
export function getTopology(id: TopologyId): TopologyDef {
  const topology = TOPOLOGY_REGISTRY[id];
  if (!topology) {
    throw new Error(`Unknown topology ID: ${id}`);
  }
  return topology;
}
```

**Numeric ID Assignment**:
- Built-in topologies: Reserve IDs 0-99
  - `TOPOLOGY_ELLIPSE`: 0
  - `TOPOLOGY_RECT`: 1
- Dynamic topologies: Auto-increment from 100
- ID assignment happens at registration time, returned to caller

## Gap Analysis

| Component | Current Behavior | Target Behavior | Change Required |
|-----------|------------------|-----------------|-----------------|
| **TopologyId type** | `string` | `number` | Type definition change |
| **Registry storage** | `Map<string, TopologyDef>` | `TopologyDef[]` | Data structure change |
| **Built-in IDs** | `'ellipse'`, `'rect'` | `0`, `1` | Constant assignment |
| **Dynamic IDs** | String generation (`'polygon-5'`) | Numeric auto-increment | Registration logic |
| **Lookup** | `Map.get(string)` O(log n) | Array index O(1) | Implementation change |
| **Registration** | `Map.set(id, def)` | `array.push(def)`, return index | API change |
| **Topology definitions** | `{ id: string, ... }` | `{ id: number, ... }` | Field type change |
| **Future-types.ts** | Already numeric (`topologyId: number`) | No change needed | Already correct ✓ |
| **Compiler IR** | `TopologyId` string refs | `TopologyId` number refs | Follow type change |
| **Block lowering** | Generates string IDs | Receives numeric IDs | Return value handling |
| **RenderAssembler** | Passes string to renderer | Passes number to renderer | Follow type change |
| **Renderer lookup** | `getTopology(string)` | `getTopology(number)` | Follow type change |

## Spec Justification

**From** `.agent_planning/_future/9-renderer.md:56-64`:

> **B. Topology lookup must be numeric + stable**
>
> Right now you do getTopology(shape.topologyId) where topologyId looks stringy. Change that.
> - Registry assigns numeric ids at init/compile time
> - topologyId in RenderIR is numeric
> - Renderer uses topologies[topologyId] array indexing
>
> No string lookups, no hash maps. This matches your slot-addressed philosophy.

**Design Principle**: The shape system should use the same O(1) array-indexing pattern as slot-based value addressing. String-based Map lookups violate the "slot-addressed philosophy" that governs the rest of the runtime.

## Implementation Plan

### Phase 1: Update Core Types and Registry (BREAKING CHANGE)

**P0 - Type System Changes**

**Work Item 1.1**: Change `TopologyId` type definition
- **File**: `src/shapes/types.ts:16`
- **Change**: `export type TopologyId = number;`
- **Impact**: Compilation errors across all consumers (desired - forces exhaustive update)

**Work Item 1.2**: Replace Map-based registry with array-based registry
- **File**: `src/shapes/registry.ts`
- **Changes**:
  ```typescript
  // Storage
  const TOPOLOGY_REGISTRY: TopologyDef[] = [];
  const TOPOLOGY_BY_NAME: Map<string, number> = new Map(); // Debug only

  // Reserve numeric IDs for built-ins
  const TOPOLOGY_ID_ELLIPSE = 0;
  const TOPOLOGY_ID_RECT = 1;
  const NEXT_DYNAMIC_ID_START = 100;
  let nextDynamicId = NEXT_DYNAMIC_ID_START;

  // Initialize built-ins at module load
  function initializeBuiltinTopologies() {
    // Pre-size array to reserve slots
    TOPOLOGY_REGISTRY[TOPOLOGY_ID_ELLIPSE] = createEllipseTopology();
    TOPOLOGY_REGISTRY[TOPOLOGY_ID_RECT] = createRectTopology();
    TOPOLOGY_BY_NAME.set('ellipse', TOPOLOGY_ID_ELLIPSE);
    TOPOLOGY_BY_NAME.set('rect', TOPOLOGY_ID_RECT);
  }
  ```

**Work Item 1.3**: Update `getTopology()` for array-indexed lookup
- **File**: `src/shapes/registry.ts:31-37`
- **Change**: Replace `TOPOLOGY_REGISTRY.get(id)` with `TOPOLOGY_REGISTRY[id]`
- **Bounds check**: Add assertion that `id >= 0 && id < TOPOLOGY_REGISTRY.length`

**Work Item 1.4**: Update `hasTopology()` for numeric check
- **File**: `src/shapes/registry.ts:45-47`
- **Change**: `return id >= 0 && id < TOPOLOGY_REGISTRY.length && TOPOLOGY_REGISTRY[id] !== undefined`

**Work Item 1.5**: Update `getAllTopologyIds()` for array iteration
- **File**: `src/shapes/registry.ts:54-56`
- **Change**:
  ```typescript
  return TOPOLOGY_REGISTRY
    .map((_, idx) => idx)
    .filter(idx => TOPOLOGY_REGISTRY[idx] !== undefined);
  ```

**Work Item 1.6**: Update `registerDynamicTopology()` to assign and return numeric ID
- **File**: `src/shapes/registry.ts:66-68`
- **Changes**:
  - Assign next available ID from counter
  - Store topology at that index
  - Return assigned ID to caller
  - Update caller signature: `(topology: Omit<TopologyDef, 'id'>) => TopologyId`
  ```typescript
  export function registerDynamicTopology(
    topology: Omit<TopologyDef, 'id'>,
    debugName?: string  // Optional for TOPOLOGY_BY_NAME
  ): TopologyId {
    const id = nextDynamicId++;
    const fullTopology: TopologyDef = { ...topology, id };
    TOPOLOGY_REGISTRY[id] = fullTopology;
    if (debugName) {
      TOPOLOGY_BY_NAME.set(debugName, id);
    }
    return id;
  }
  ```

**Work Item 1.7**: Add debug lookup by name (optional, non-critical)
- **File**: `src/shapes/registry.ts`
- **Function**: `export function getTopologyIdByName(name: string): TopologyId | undefined`
- **Purpose**: Debugging, error messages, testing
- **Implementation**: `return TOPOLOGY_BY_NAME.get(name);`

### Phase 2: Update Built-in Topologies

**P0 - Built-in Topology Definitions**

**Work Item 2.1**: Update `TOPOLOGY_ELLIPSE` definition
- **File**: `src/shapes/topologies.ts:20`
- **Change**: `id: 0` (use exported constant `TOPOLOGY_ID_ELLIPSE`)
- **Alternative**: Remove `id` field entirely, assign during registration

**Work Item 2.2**: Update `TOPOLOGY_RECT` definition
- **File**: `src/shapes/topologies.ts:48`
- **Change**: `id: 1` (use exported constant `TOPOLOGY_ID_RECT`)

**Work Item 2.3**: Export numeric ID constants
- **File**: `src/shapes/registry.ts`
- **Export**: `export { TOPOLOGY_ID_ELLIPSE, TOPOLOGY_ID_RECT }`
- **Purpose**: Allow direct numeric references in hot paths (avoid function call overhead)

### Phase 3: Update Dynamic Topology Registration (Blocks)

**P1 - Block System Updates**

**Work Item 3.1**: Update `createPolygonTopology()` to omit `id` field
- **File**: `src/blocks/path-blocks.ts:32-66`
- **Changes**:
  - Remove `id: 'polygon-${sides}'` from returned object
  - Topology ID will be assigned by `registerDynamicTopology()`
  - Keep `sides` parameter for internal use

**Work Item 3.2**: Update `ProceduralPolygon` block lowering to store numeric ID
- **File**: `src/blocks/path-blocks.ts:90-170` (estimated, need to find lowering logic)
- **Changes**:
  - Call `registerDynamicTopology(topology, `polygon-${sides}`)` → returns `TopologyId`
  - Store numeric ID in IR (likely in `ShapeRef` or compilation artifact)
  - Pass numeric ID to RenderAssembler

**Work Item 3.3**: Verify all other blocks using `registerDynamicTopology()`
- **Search**: `grep -r "registerDynamicTopology" src/blocks/`
- **Update**: Each call site to handle returned numeric ID
- **Expected**: Only path-blocks.ts (from earlier grep results)

### Phase 4: Update Compiler IR

**P1 - IR Type Updates**

**Work Item 4.1**: Update `ShapeRef` interface
- **File**: `src/shapes/types.ts:78-81`
- **Change**: `topologyId` field already uses `TopologyId` type → no change needed
- **Verify**: Type propagation works correctly

**Work Item 4.2**: Update compiler IR type imports
- **Files**: (from grep)
  - `src/compiler/ir/types.ts`
  - `src/compiler/ir/IRBuilderImpl.ts`
  - `src/compiler/ir/IRBuilder.ts`
  - `src/compiler/passes-v2/pass7-schedule.ts`
- **Change**: Imports of `TopologyId` type automatically pick up numeric change
- **Action**: Verify compilation, fix any type errors

**Work Item 4.3**: Update IR builder to handle numeric topology IDs
- **File**: `src/compiler/ir/IRBuilderImpl.ts`
- **Verify**: No hardcoded string ID logic
- **Expected**: Only passes through `TopologyId` values from blocks → no changes

### Phase 5: Update Runtime (RenderAssembler)

**P1 - Runtime Assembly Updates**

**Work Item 5.1**: Update `RenderAssembler.ts` topology resolution
- **File**: `src/runtime/RenderAssembler.ts`
- **Search**: All calls to `getTopology()`
- **Verify**: Accepts numeric `TopologyId` → type change sufficient
- **Test**: Ensure no string concatenation or manipulation of IDs

**Work Item 5.2**: Update `ResolvedShape` type if needed
- **File**: `src/runtime/ScheduleExecutor.ts:19` (type definition)
- **Check**: Does `ResolvedShape` embed `TopologyId`?
- **Action**: Type change propagates automatically if using `TopologyId` type

**Work Item 5.3**: Update `RuntimeState` if topology IDs are cached
- **File**: `src/runtime/RuntimeState.ts`
- **Search**: Any caching of topology lookups
- **Expected**: No caching (topologies are immutable, safe to look up each time)

### Phase 6: Update Renderer

**P1 - Renderer Updates**

**Work Item 6.1**: Update `Canvas2DRenderer.ts` topology dispatch
- **File**: `src/render/Canvas2DRenderer.ts`
- **Search**: All calls to `getTopology()`
- **Change**: Function signature already accepts numeric ID after registry update → no change
- **Verify**: No switch statements or if-chains on string topology IDs

**Work Item 6.2**: Verify future-types.ts alignment
- **File**: `src/render/future-types.ts:74-75`
- **Status**: Already defines `topologyId: number` ✓
- **Action**: No changes needed - validates our direction

### Phase 7: Update Tests

**P2 - Test Updates**

**Work Item 7.1**: Update RenderAssembler tests
- **File**: `src/runtime/__tests__/RenderAssembler.test.ts`
- **Changes**: Replace string topology IDs with numeric constants
- **Add**: Test for numeric ID assignment on dynamic registration

**Work Item 7.2**: Update shape system tests (if they exist)
- **Search**: `src/shapes/__tests__/` or `*.test.ts` near shape files
- **Changes**: Use numeric IDs in test fixtures

**Work Item 7.3**: Add topology registry tests
- **File**: `src/shapes/__tests__/registry.test.ts` (create if missing)
- **Tests**:
  - Built-in topologies have correct reserved IDs
  - Dynamic registration returns sequential IDs starting at 100
  - `getTopology()` throws on invalid ID
  - `hasTopology()` returns false for out-of-bounds ID
  - `getAllTopologyIds()` returns valid numeric array

### Phase 8: Performance Validation

**P3 - Verification**

**Work Item 8.1**: Measure lookup performance improvement
- **Benchmark**: 1M topology lookups before/after
- **Expected**: ~2-5x speedup (Map.get vs array index)
- **Tool**: `console.time()` around hot loop, or proper microbenchmark

**Work Item 8.2**: Verify renderer frame time improvement
- **Test**: Render 10k instances of polygon shapes
- **Metric**: Frame assembly + render time
- **Expected**: <5% improvement (lookup is not the only bottleneck)

## Acceptance Criteria

### Correctness (Required)

- [ ] `TopologyId` type is `number` throughout codebase
- [ ] Built-in topologies (ellipse, rect) assigned IDs 0 and 1
- [ ] Dynamic topologies assigned IDs starting at 100
- [ ] `getTopology(id: number)` performs array-indexed lookup O(1)
- [ ] `registerDynamicTopology()` returns assigned numeric ID
- [ ] All compilation passes successfully with no type errors
- [ ] All existing tests pass with numeric IDs
- [ ] Renderer correctly renders all shapes (ellipse, rect, polygons)

### Performance (Verification)

- [ ] Topology lookup microbenchmark shows measurable improvement
- [ ] No regression in frame render time for existing scenes

### Code Quality

- [ ] No string manipulation of topology IDs anywhere in codebase
- [ ] Debug helper `getTopologyIdByName()` available for error messages
- [ ] Numeric ID constants exported for zero-overhead hot path usage
- [ ] Registry bounds checking prevents undefined access

## Migration Notes

### Breaking Changes

This is a **BREAKING TYPE CHANGE** that forces exhaustive updates. The compiler will enforce correctness by rejecting any code that treats `TopologyId` as a string.

**API Changes**:
- `registerDynamicTopology(topology)` → `registerDynamicTopology(topology, debugName?): TopologyId`
  - Now returns assigned ID instead of void
  - Caller must store returned ID for later use

**ID Assignment Rules**:
- Reserved IDs 0-99: Built-in topologies
- Reserved IDs 100+: Dynamic topologies (auto-assigned)
- Gap from 2-99: Future built-ins without breaking existing IDs

### No Hot Swap Impact

Topology IDs are assigned at compile time (for built-ins) and block lowering time (for dynamic). Once assigned, they are immutable for the program lifetime. Hot swap preserves topology registry state, so numeric IDs remain stable across graph changes.

### Future Work (Out of Scope)

- **Topology serialization**: If saving/loading programs, map numeric IDs to stable names in serialization format
- **Multi-module topologies**: If allowing user-defined topologies from separate modules, need stable ID allocation strategy
- **Topology versioning**: If topology definitions change, need migration path for old numeric IDs

## Dependencies

**Blocks**:
- oscilla-animator-v2-583 (RenderAssembler v2) - IN PROGRESS
  - This work can proceed in parallel, but testing requires RenderAssembler v2 completion

**Blockers**:
- None (no external dependencies)

**Blocked By This**:
- Future renderer optimizations that assume O(1) topology dispatch

## Test Plan

### Unit Tests

**Registry Tests** (`src/shapes/__tests__/registry.test.ts`):
```typescript
describe('Topology Registry (Numeric IDs)', () => {
  test('built-in topologies have reserved IDs', () => {
    expect(TOPOLOGY_ID_ELLIPSE).toBe(0);
    expect(TOPOLOGY_ID_RECT).toBe(1);
    expect(getTopology(0).id).toBe(0); // Reflexive
  });

  test('dynamic registration assigns sequential IDs from 100', () => {
    const id1 = registerDynamicTopology({ params: [], render: () => {} }, 'test1');
    const id2 = registerDynamicTopology({ params: [], render: () => {} }, 'test2');
    expect(id1).toBeGreaterThanOrEqual(100);
    expect(id2).toBe(id1 + 1);
  });

  test('getTopology throws on invalid ID', () => {
    expect(() => getTopology(999)).toThrow('Unknown topology ID: 999');
    expect(() => getTopology(-1)).toThrow();
  });

  test('hasTopology returns false for unassigned IDs', () => {
    expect(hasTopology(0)).toBe(true);  // ellipse
    expect(hasTopology(50)).toBe(false); // unassigned
  });

  test('getTopologyIdByName returns correct numeric ID', () => {
    expect(getTopologyIdByName('ellipse')).toBe(0);
    expect(getTopologyIdByName('rect')).toBe(1);
    expect(getTopologyIdByName('nonexistent')).toBeUndefined();
  });
});
```

**Block Integration Tests** (`src/blocks/__tests__/path-blocks.test.ts`):
```typescript
test('ProceduralPolygon registration returns numeric topology ID', () => {
  // Create pentagon topology
  const topology = createPolygonTopology(5);
  const id = registerDynamicTopology(topology, 'polygon-5');

  expect(typeof id).toBe('number');
  expect(id).toBeGreaterThanOrEqual(100);
  expect(getTopology(id)).toBeDefined();
  expect(getTopology(id).verbs).toHaveLength(7); // MOVE + 4*LINE + CLOSE
});
```

**Renderer Integration Tests** (`src/render/__tests__/Canvas2DRenderer.test.ts`):
```typescript
test('renders shapes using numeric topology IDs', () => {
  const canvas = createTestCanvas();
  const renderer = new Canvas2DRenderer(canvas);

  const frame: RenderFrameIR = {
    passes: [{
      kind: 'instances2d',
      count: 1,
      position: new Float32Array([0.5, 0.5]),
      color: new Uint8ClampedArray([255, 0, 0, 255]),
      scale: 1.0,
      resolvedShape: {
        topologyId: TOPOLOGY_ID_ELLIPSE, // Numeric ID
        params: { rx: 0.1, ry: 0.1, rotation: 0 },
      },
    }],
  };

  expect(() => renderer.renderFrame(frame)).not.toThrow();
  // Verify canvas draw calls if possible
});
```

### Performance Tests

**Microbenchmark** (`src/shapes/__tests__/registry.bench.ts`):
```typescript
test('numeric lookup is faster than Map-based lookup', () => {
  const iterations = 1_000_000;

  // Warm up
  for (let i = 0; i < 1000; i++) getTopology(0);

  const start = performance.now();
  for (let i = 0; i < iterations; i++) {
    getTopology(i % 2); // Alternate between ellipse and rect
  }
  const duration = performance.now() - start;

  console.log(`${iterations} lookups in ${duration.toFixed(2)}ms`);
  expect(duration).toBeLessThan(100); // Baseline assertion
});
```

### Manual Testing

1. **Load example patch with polygons**: Verify correct rendering
2. **Hot swap**: Change polygon sides, verify new topology registered with new ID
3. **Dev tools inspection**: Log `TOPOLOGY_REGISTRY` to verify structure

## Files Modified

**Core Shape System** (6 files):
- `src/shapes/types.ts` - Type definition change
- `src/shapes/registry.ts` - Storage and lookup implementation
- `src/shapes/topologies.ts` - Built-in topology ID assignment
- `src/shapes/__tests__/registry.test.ts` - New test file

**Block System** (1 file):
- `src/blocks/path-blocks.ts` - Dynamic registration handling

**Compiler IR** (4 files):
- `src/compiler/ir/types.ts` - Type import update
- `src/compiler/ir/IRBuilderImpl.ts` - Verify type propagation
- `src/compiler/ir/IRBuilder.ts` - Verify type propagation
- `src/compiler/passes-v2/pass7-schedule.ts` - Verify type propagation

**Runtime** (3 files):
- `src/runtime/RenderAssembler.ts` - Topology resolution
- `src/runtime/ScheduleExecutor.ts` - Type verification
- `src/runtime/RuntimeState.ts` - Verify no ID caching

**Renderer** (1 file):
- `src/render/Canvas2DRenderer.ts` - Dispatch verification

**Tests** (2 files):
- `src/runtime/__tests__/RenderAssembler.test.ts` - Update fixtures
- `src/shapes/__tests__/registry.bench.ts` - New benchmark file

**Total**: 17 files modified/created

## Risks and Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| **Type system escape hatch** | Runtime errors if number treated as string | Low | TypeScript enforces type safety; no `as any` usage |
| **ID collision** | Multiple topologies assigned same ID | Very Low | Sequential assignment with counter, no external ID input |
| **Registry compaction assumption** | Code assumes IDs 0..N are contiguous | Low | Document that array may be sparse; use defined checks |
| **Serialization breaks** | Saved programs reference old string IDs | N/A | No serialization implemented yet; address in future work |
| **Debug experience degrades** | Numeric IDs harder to read in logs | Medium | Maintain `TOPOLOGY_BY_NAME` for debug output; add pretty-print helpers |
| **Performance gain negligible** | Optimization doesn't improve real-world perf | Medium | Acceptable - correctness and consistency with slot philosophy are primary goals |

## Timeline Estimate

- **Phase 1-2** (Core changes): 2 hours
- **Phase 3-4** (Blocks and IR): 1 hour
- **Phase 5-6** (Runtime and renderer): 1 hour
- **Phase 7** (Tests): 2 hours
- **Phase 8** (Performance validation): 1 hour

**Total**: ~7 hours (single sprint)

**Parallelization**: Phases 1-6 can be done in one commit (breaking change). Phase 7-8 can be separate commits.

## Implementation Order

1. Update types and registry (Phase 1-2) - **COMMIT POINT 1** (breaking)
2. Update all consumers (Phase 3-6) - **SAME COMMIT** (required for compilation)
3. Add/update tests (Phase 7) - **COMMIT POINT 2**
4. Performance validation (Phase 8) - **COMMIT POINT 3** (optional)

Single-commit strategy enforces atomic migration via type system.
