# Browser Console Errors - Status Evaluation

Generated: 2026-01-25T22:09:30
Source: Chrome DevTools MCP inspection of http://localhost:5174

## Executive Summary

The application produces **547+ console errors per page load**, all originating from a single root cause: **incorrect stride offset calculation in the compiler's slotMeta generation**. This causes a stride assertion failure on every animation frame (~60/sec).

## Error Analysis

### Error Type: assertF64Stride Failure

**Frequency**: ~60 errors/second (every animation frame)
**Severity**: CRITICAL - prevents proper runtime execution

**Stack Trace**:
```
at assertF64Stride (ScheduleExecutor.ts:41:11)
at executeFrame (ScheduleExecutor.ts:91:19)
at executeAnimationFrame (AnimationLoop.ts:39:17)
at animate (AnimationLoop.ts:102:7)
```

**Error Location**: `/src/runtime/ScheduleExecutor.ts` line 76-77:
```typescript
if (lookup.stride !== expectedStride) {
  throw new Error(`${what} must have stride=${expectedStride}, got ${lookup.stride}`);
}
```

**Trigger**: Line 164 calls `assertF64Stride(slotLookupMap, TIME_PALETTE_SLOT, 4, 'time.palette slot')` expecting stride=4 for the time.palette color slot, but the slot has stride=1.

## Root Cause Analysis

### The Bug: Incorrect Stride Offset Calculation in `compile.ts`

**Location**: `/src/compiler/compile.ts` lines 433-456 in `convertLinkedIRToProgram()`

**Problem Code**:
```typescript
const storageOffsets = {
  f64: 0,
  // ...
};

for (let slotId = 0; slotId < builder.getSlotCount?.() || 0; slotId++) {
  const slot = slotId as ValueSlot;
  const type = slotTypes.get(slot) || canonicalType('float');
  const storage = /* ... */;
  const offset = storageOffsets[storage]++;  // BUG: Always increments by 1
  const stride = storage === 'object' ? 1 : payloadStride(type.payload);

  slotMeta.push({ slot, storage, offset, stride, type });
}
```

**Issue**: The offset counter `storageOffsets[storage]++` increments by 1 for every slot, regardless of the slot's stride. When a slot has stride=4 (like color), it should consume offsets 0-3, and the next slot should start at offset 4. Instead:

| Slot | Type | Expected Offset | Actual Offset | Stride |
|------|------|----------------|---------------|--------|
| 0 | color | 0 | 0 | 4 |
| 1 | float | 4 | 1 | 1 |
| 2 | float | 5 | 2 | 1 |

This means slot 1 overlaps with slot 0's data (positions 1-3), corrupting memory layout.

### Why Slot 0 Has Wrong Stride at Runtime

The offset bug doesn't directly cause the stride error. Looking more closely:

1. `IRBuilderImpl` reserves slot 0 with `canonicalType('color')` (line 76)
2. The compile loop iterates slots and gets type from `slotTypes`
3. But `builder.getSlotCount()` may not account for reserved system slots properly

Wait - actually there's a second issue. Let me check if the slot counter starts at 1 (after the reserved slot 0):

In `IRBuilderImpl.ts` line 87-89:
```typescript
if (this.slotCounter <= slotId) {
  this.slotCounter = slotId + 1;
}
```

This ensures `slotCounter` is at least 1 after reserving slot 0. So `getSlotCount()` returns the total including reserved slots.

The actual issue is that while slot 0 is reserved with type `color`, the **stride calculation is correct** (`payloadStride('color')` returns 4), but the **offset increment** is wrong.

Actually wait - let me re-read the error. The runtime says "got ${lookup.stride}" - this means the stride IN slotMeta is wrong, not just the offset.

Re-checking line 447:
```typescript
const stride = storage === 'object' ? 1 : payloadStride(type.payload);
```

If `type` is correct (`color`), then `payloadStride('color')` should return 4. But what if slot 0 is not in `slotTypes`?

Line 435:
```typescript
const type = slotTypes.get(slot) || canonicalType('float'); // Default to float if no type info
```

If slot 0 is not in `slotTypes`, it defaults to `float` which has stride=1!

### Hypothesis: System Slot Type Not Registered

In `IRBuilderImpl.ts` constructor:
```typescript
constructor() {
  // Slot 0: time.palette (color, stride=4)
  this.reserveSystemSlot(0, canonicalType('color'));
}
```

And `reserveSystemSlot`:
```typescript
private reserveSystemSlot(slotId: number, type: CanonicalType): void {
  const slot = slotId as ValueSlot;
  this.slotTypes.set(slot, type);  // Should register the type
  if (this.slotCounter <= slotId) {
    this.slotCounter = slotId + 1;
  }
}
```

This looks correct. But `getSlotTypes()` returns `this.slotTypes`, so slot 0 should be in there.

Let me check if maybe there's a new IRBuilder created somewhere without the system slot reservation, or if the slotTypes map is being cleared/rebuilt somewhere.

Actually the most likely issue is that **a new IRBuilder is created for each compilation**, and the system slot reservation in the constructor should work. Let me verify this is the right IRBuilder being used.

In `pass6-block-lowering.ts`:
```typescript
import { createIRBuilder } from '../ir/IRBuilderImpl';
```

And `createIRBuilder()` returns `new IRBuilderImpl()` which calls the constructor with the reservation.

## Verified Root Cause

After careful analysis:

**PRIMARY BUG**: In `compile.ts` line 444, the offset calculation:
```typescript
const offset = storageOffsets[storage]++;
```
Should be:
```typescript
const offset = storageOffsets[storage];
storageOffsets[storage] += stride;
```

This causes slots to have overlapping offsets, but the slotMeta stride values themselves should be correct since they come from `payloadStride()`.

However, the runtime error specifically says the stride is wrong. Let me check if there's caching involved...

In `ScheduleExecutor.ts` line 38-56:
```typescript
const SLOT_LOOKUP_CACHE = new WeakMap<CompiledProgramIR, Map<ValueSlot, SlotLookup>>();

function getSlotLookupMap(program: CompiledProgramIR): Map<ValueSlot, SlotLookup> {
  const cached = SLOT_LOOKUP_CACHE.get(program);
  if (cached) return cached;
  const map = new Map<ValueSlot, SlotLookup>();
  for (const meta of program.slotMeta) {
    if (meta.stride == null) {
      throw new Error(`slotMeta missing required stride for slot ${meta.slot}`);
    }
    map.set(meta.slot, {
      storage: meta.storage,
      offset: meta.offset,
      stride: meta.stride,
      slot: meta.slot,
    });
  }
  SLOT_LOOKUP_CACHE.set(program, map);
  return map;
}
```

So the stride comes directly from `slotMeta[i].stride`. If that's wrong, the bug is definitely in compile.ts where slotMeta is built.

## Quantitative Metrics

- **Total errors captured**: 547 (in ~9 seconds)
- **Error rate**: ~60/second (matches animation frame rate)
- **Unique error types**: 1
- **Root causes identified**: 1 (offset calculation bug)

## Affected Components

1. `/src/compiler/compile.ts` - slotMeta generation (PRIMARY FIX LOCATION)
2. `/src/runtime/ScheduleExecutor.ts` - where error is thrown (SYMPTOM)
3. `/src/services/AnimationLoop.ts` - propagates error (SYMPTOM)

## Dependencies

None - this is a self-contained compiler bug.

## Risk Assessment

- **Fix Complexity**: LOW - single line change
- **Regression Risk**: MEDIUM - offset calculation affects all multi-component signals
- **Test Coverage**: Should add test for stride=4 slotMeta generation
