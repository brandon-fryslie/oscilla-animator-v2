# Evaluation: Circular Dependencies Between Registry, Compiler, and Stores
Timestamp: 2026-02-03-131723
Git Commit: 69ccefc

## Executive Summary
Overall: Investigation complete | Critical issues: 1 real, 1 misdiagnosed | Tests reliable: yes (the skipped tests are likely valid)

The test comment claiming "heap exhaustion due to circular dependency between blocks/registry -> compiler modules -> stores" is **misleading**. There is NO dependency cycle involving stores. The actual architecture issue is a **bidirectional dependency between blocks/ and compiler/ir/**, but this does NOT cause heap exhaustion. The 3 skipped tests were likely skipped due to a transient issue during an LLM coding session, and the diagnosis in the skip comment is wrong.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| Full test suite | PASS | 144 passed, 6 skipped (2137 tests passed, 25 skipped) |
| Store integration tests (`stores/__tests__/integration.test.ts`) | PASS | 11 passed, 2.38s |
| Composite roundtrip tests (non-skipped) | PASS | 27 passed, 16ms |
| TypeCheck | Not run (assumed passing per recent commits) |

## Missing Checks
- A CI lint rule that detects bidirectional imports between designated module layers
- An import boundary enforcement tool (e.g., eslint-plugin-boundaries or dependency-cruiser)

## Findings

### 1. The "Circular Dependency" Claim Is Misdiagnosed
**Status**: MISDIAGNOSED
**Evidence**:
- `src/patch-dsl/__tests__/composite-roundtrip.test.ts:524-526` (local uncommitted change)
- The comment claims: `blocks/registry -> compiler modules -> stores`
- Reality: `stores/` has ZERO imports from `compiler/`, and `compiler/` has ZERO imports from `stores/`

**What actually exists**: A bidirectional dependency between `blocks/` and `compiler/ir/`:
- `blocks/` -> `compiler/ir/types.ts` (value: OpCode, stableStateId) -- ~30 files
- `blocks/` -> `compiler/ir/LowerSandbox.ts` (value: LowerSandbox class) -- 1 file
- `blocks/` -> `compiler/ir/Indices.ts` (value: valueSlot, SYSTEM_PALETTE_SLOT) -- 1 file
- `compiler/ir/LowerSandbox.ts` -> `blocks/registry.ts` (value: requireBlockDef)
- `compiler/backend/*.ts` -> `blocks/registry.ts` (value: getBlockDefinition)
- `compiler/frontend/*.ts` -> `blocks/registry.ts` (value: getBlockDefinition, requireBlockDef)

### 2. The Bidirectional blocks/ <-> compiler/ Dependency
**Status**: REAL ARCHITECTURAL ISSUE (but not causing failures)
**Evidence**:
- `src/blocks/signal/default-source.ts:28`: `import { LowerSandbox } from '../../compiler/ir/LowerSandbox'`
- `src/compiler/ir/LowerSandbox.ts:24`: `import { requireBlockDef } from '../../blocks/registry'`

This creates a real module-level cycle: `blocks/signal/default-source.ts` -> `compiler/ir/LowerSandbox.ts` -> `blocks/registry.ts`

Node.js handles this via partial module initialization. Since `registry.ts` defines and exports `requireBlockDef` early (it's a function that reads from a Map), the cycle resolves without issues in practice. But it violates the ONE-WAY DEPENDENCIES law from CLAUDE.md.

**Root cause**: Block lowering logic needs to reference IR concepts (OpCode for building expressions), and the compiler needs to look up block definitions. This is a fundamental design tension: blocks define their own lowering, which requires compiler IR types.

### 3. The Skipped Tests Are Likely Valid Code
**Status**: TESTS PROBABLY WORK (skipped unnecessarily)
**Evidence**:
- The committed version (fa107a3, 2026-02-01) does NOT skip these tests
- They already use dynamic `await import()` to lazy-load CompositeEditorStore
- Similar store tests in `stores/__tests__/integration.test.ts` pass fine
- The local uncommitted change adds `.skip` with an incorrect diagnosis

**Most likely explanation**: An LLM agent encountered a transient failure (perhaps memory pressure from running many tests simultaneously) and misattributed it to circular dependencies, then skipped the tests rather than investigating further.

### 4. Stores Module Dependencies Are Clean
**Status**: COMPLETE (no issues)
**Evidence**:
- `stores/` imports from `blocks/registry` (downward dependency -- correct)
- `stores/` imports from `graph/Patch` (downward -- correct)
- `stores/` imports from `events/`, `diagnostics/`, `services/` (lateral/downward -- correct)
- `stores/` does NOT import from `compiler/` (correct)
- `compiler/` does NOT import from `stores/` (correct)

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| Test skip reason | Why were tests actually failing? | LLM guessed "circular dependency causing heap exhaustion" | LOW -- tests are probably fine; skip should be removed |
| blocks/ <-> compiler/ boundary | Should blocks define their own IR lowering? | Current design says yes (blocks contain `lower()` functions) | MEDIUM -- this is the root cause of the bidirectional dependency |
| OpCode location | Should OpCode live in blocks/ or compiler/? | Lives in compiler/ir/types.ts, imported by ~30 block files | MEDIUM -- this is the most widespread cross-boundary import |

## The Real Architectural Question

The bidirectional dependency exists because blocks define their own lowering to IR. This is a deliberate design choice:

**Option A** (current): Blocks contain `lower()` functions that produce IR expressions, so they must import compiler IR types. Compiler must read block definitions for lowering. Result: bidirectional dependency.

**Option B**: Extract lowering logic into compiler-owned modules. Blocks only define metadata and type constraints. Compiler owns all lowering. Result: one-way dependency (compiler -> blocks), but block-specific lowering logic would be centralized in the compiler rather than colocated with block definitions.

**Option C**: Extract shared types (OpCode, Indices) into a shared "IR primitives" layer below both blocks/ and compiler/. Blocks import from shared layer; compiler imports from shared layer and blocks. Result: one-way dependency through a shared base.

The current codebase uses Option A. Whether this violates the ONE-WAY DEPENDENCIES law depends on whether `blocks/` and `compiler/` are considered separate layers or peers within one "compilation" domain.

## Recommendations
1. **Remove the `.skip` from the 3 Store Integration tests** and verify they pass. The diagnosis is wrong; the tests likely work fine. This is a single-line change.
2. **Do NOT restructure modules right now** for the bidirectional blocks/ <-> compiler/ dependency. It's not causing runtime failures and is a deliberate design tradeoff. If refactoring is desired, Option C (shared IR primitives layer) is the least disruptive.
3. **Add a dependency boundary check** (dependency-cruiser or eslint-plugin-boundaries) to enforce the intended architecture and prevent new violations.

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix
- [ ] PAUSE - Ambiguities need clarification

The primary action is removing the test skip (1 line change). The architectural question about blocks/ <-> compiler/ boundaries is a longer-term design discussion, not a blocking issue.
