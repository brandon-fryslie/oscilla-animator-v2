# Pure Lowering Migration - Project Evaluation
Generated: 2026-02-06 14:30:00
Agent: project-evaluator (aedb97f)

## Verdict: PAUSE

3 questions need answers before proceeding with implementation.

---

## Key Findings Summary

### Critical Blocker: Runtime Does Not Support construct() in Signal Context

The design decision documented in `PURE-LOWERING-TODO.md` says "use construct() instead of stepSlotWriteStrided." But the runtime **explicitly throws** when evaluating `construct` expressions in signal context:

- `/Users/bmf/code/oscilla-animator-v2/src/runtime/ValueExprSignalEvaluator.ts:191-193` -- `case 'construct': { throw new Error('construct expressions are field-extent, not signal-extent'); }`
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/ScheduleExecutor.ts:249-250` -- `if (stride !== 1) { throw new Error(...) }` in the evalValue handler

The `construct` node only works today in the **field materializer** (`ValueExprMaterializer.ts:96-108`), not in the signal evaluator. Before any of the 4 blocked blocks can be migrated, the runtime needs changes. Two options exist:

**Option A**: Extend the signal evaluator to handle `construct` (evaluate components, write contiguously). This removes the need for `slotWriteStrided` as a step kind entirely.

**Option B**: Keep the signal evaluator scalar-only. Have the schedule builder automatically decompose `construct`-rooted slots into strided-write steps. Blocks return `construct()` purely; the orchestrator handles the rest.

### The TODO Document Overcounts

The claim "78/80 blocks migrated" conflates two things:
1. Having a `loweringPurity` annotation (78 files)
2. Actually performing pure lowering (fewer -- e.g., `default-source.ts` is tagged `'pure'` but uses `ctx.b.allocSlot()` and `ctx.b.registerSigSlot()` directly)

Additionally, `domain-index.ts` uses the effects pattern correctly but is missing its `loweringPurity` annotation entirely (not mentioned in the TODO).

### allocSlot() Calls Are Also Impure

The TODO doc only focuses on `stepSlotWriteStrided`, but `ctx.b.allocSlot()` calls in `lower()` are equally impure according to the design doc (`/Users/bmf/code/oscilla-animator-v2/design-docs/_new/pure-lowering-blocks/01-macro-lowering.md:103`). All 4 blocked blocks also use `allocSlot()` directly, which must be migrated to `effects.slotRequests`.

### No Enforcement Mechanism Exists

The planned ESLint rule to enforce pure lowering has not been written. There are currently **46 unresolved ESLint errors** in `src/blocks/`, demonstrating that existing rules are not gating anything.

---

## Questions Needing Answers

### 1. Runtime construct() Strategy

**Question**: How should the runtime handle `construct()` expressions for multi-component signals?

**Context**: The design doc says to use `construct()` instead of `stepSlotWriteStrided`, but the runtime currently throws an error when it encounters `construct` in signal context.

**Options**:

| Option | Approach | Pros | Cons |
|--------|----------|------|------|
| **A (Extend Evaluator)** | Add `construct` case to `ValueExprSignalEvaluator` that evaluates components and writes them contiguously | • Consistent with design doc<br>• `construct` works everywhere<br>• No special orchestrator logic | • Evaluator becomes more complex<br>• Need to handle stride>1 in evaluator |
| **B (Orchestrator Decomposition)** | Keep evaluator scalar-only. Schedule builder decomposes `construct`-rooted slots into separate scalar steps | • Evaluator stays simple<br>• Stride handling at compile time<br>• Maintains scalar/strided separation | • More orchestrator complexity<br>• Schedule gets more steps |

**Recommendation**: **Option A (Extend Evaluator)** - This is what the design doc intended. The evaluator should be able to handle all ValueExpr nodes uniformly. The restriction that "construct is field-only" appears to be a temporary limitation, not a design principle.

---

### 2. allocSlot() Scope

**Question**: Should `ctx.b.allocSlot()` calls in block `lower()` functions also be forbidden as part of pure lowering?

**Context**: The design doc states that pure blocks should not mutate the builder. `allocSlot()` is a builder mutation. All 4 blocked blocks use `allocSlot()` directly.

**Options**:

| Option | Approach | Pros | Cons |
|--------|----------|------|------|
| **A (Yes, Forbid)** | `allocSlot()` is impure. Blocks use `effects.slotRequests` instead | • Fully pure contract<br>• Consistent with design doc<br>• Slots allocated by orchestrator | • Larger migration scope<br>• More blocks affected |
| **B (No, Allow)** | `allocSlot()` is fine. Only forbid schedule mutations like `stepSlotWriteStrided` | • Smaller migration scope<br>• Pragmatic compromise | • Inconsistent purity<br>• Violates design doc |

**Recommendation**: **Option A (Yes, Forbid)** - The design doc is clear that blocks should return effects as data, not mutate the builder. This is the whole point of pure lowering. Accept the larger scope and migrate properly.

---

### 3. default-source.ts Honesty

**Question**: Should `default-source.ts` have its `loweringPurity: 'pure'` annotation corrected to `'impure'` given that it uses `ctx.b.allocSlot()` and `ctx.b.registerSigSlot()` directly?

**Context**: The block is marked as pure but performs imperative operations. The TODO mentions it "may be eliminated by normalization."

**Options**:

| Option | Approach | Pros | Cons |
|--------|----------|------|------|
| **A (Mark Impure)** | Change annotation to `'impure'` to reflect reality | • Honest labeling<br>• No confusion<br>• Can migrate later | • Admits defeat temporarily |
| **B (Keep Pure, Fix)** | Keep annotation but migrate to proper pure lowering | • Achieves goal immediately<br>• No intermediate step | • More work now |
| **C (Eliminate)** | Remove block entirely via normalization | • Best long-term solution<br>• Aligns with TODO note | • Unclear if normalization is ready |

**Recommendation**: **Option A (Mark Impure)** for now, with a plan to investigate Option C. The architectural review mentioned in the TODO should happen first. Don't let this block the other 3 migrations.

---

## Implementation Scope

Based on answers to the questions above, the migration includes:

### Core Changes (HIGH Confidence if Questions Resolved)
1. Extend `ValueExprSignalEvaluator` to support `construct()` (if Option A chosen)
2. Migrate 4 blocked blocks to use `construct()` and `effects.slotRequests`
3. Write ESLint rule to enforce pure lowering invariants
4. Fix `domain-index.ts` missing annotation

### Additional Work (MEDIUM Confidence)
5. Audit all blocks for `allocSlot()` calls and migrate to `effects.slotRequests`
6. Correct false-positive "pure" annotations (like `default-source.ts`)
7. Fix existing 46 ESLint errors in `src/blocks/`

### Future Work (LOW Confidence)
8. Architectural review of `default-source.ts` - can it be eliminated?
9. Remove `stepSlotWriteStrided` from IRBuilder API entirely
10. Update design docs to reflect final implementation

---

## Risks

1. **Runtime changes may break existing tests** - Need comprehensive test coverage (delete any failing tests and write new ones)
2. **ESLint enforcement may reveal more violations** - Could expand scope significantly (this is good!)
3. **default-source.ts normalization unclear** - May need to keep block longer than expected (provide clear context of problem and we will solve it)

---

## Dependencies

- Decision on runtime strategy (Question 1)
- Decision on allocSlot() scope (Question 2)
- Decision on default-source.ts handling (Question 3)

---

## Files Analyzed

- `PURE-LOWERING-TODO.md`
- `design-docs/_new/pure-lowering-blocks/01-macro-lowering.md`
- `src/blocks/signal/const.ts`
- `src/blocks/math/expression.ts`
- `src/blocks/signal/default-source.ts`
- `src/blocks/io/external-vec2.ts`
- `src/runtime/ValueExprSignalEvaluator.ts`
- `src/runtime/ScheduleExecutor.ts`
- `src/runtime/ValueExprMaterializer.ts`
- `src/compiler/ir/IRBuilder.ts`
- `src/compiler/ir/lowerTypes.ts`

===

Please implement this directly.  If you encounter any further complications, stop IMMEDIATELY and explain the situation in detail.  NO SHORTCUTS

1) Runtime construct() strategy for multi-component signals

Decision: Option A (extend the signal evaluator)

What to change
- ValueExprSignalEvaluator: implement case 'construct':
- Evaluate each component expression ID (which are scalar signals).
- Write the component values contiguously into the destination signal slot buffer at slotBase + i.
- Return “written stride” semantics consistent with how you currently handle scalar.
- ScheduleExecutor.evalValue stride guard: remove/relax if (stride !== 1) throw.
- The schedule step evalSig(expr, targetSlot) should be allowed to target stride > 1 slots.
- The evaluator (not the schedule) is responsible for writing stride lanes.

Why this is the right architecture
- It preserves a single universal rule: schedule evaluates expression roots into slots. No “special write step kinds.”
- It keeps multi-component values as a representation detail of ValueExpr evaluation, not a scheduling primitive.
- It aligns with your IR model: construct/extract are value-level operators, so they should be evaluable anywhere the value exists (signal or field), with the difference being “where the storage lives,” not “whether the op is legal.”
- It avoids creating a second semantics path where the orchestrator pattern-matches expression shapes and explodes them into schedule micro-steps.

Cost of ignoring:
- It pushes you toward orchestrator “lowering of lowering” logic: decomposing construct roots into strided writes, inventing ordering constraints, and increasing schedule size. That’s exactly the direction your effects-as-data work is trying to avoid.

So: implement construct in the signal evaluator and make stride>1 slots first-class in evalSig.

2) Whether allocSlot() is forbidden in pure lowering

Decision: Option A (forbid allocSlot() in block lower())

Rationale
- If purity means “lowering returns data, orchestrator mutates builder,” then allocSlot() is builder mutation and must move behind effects.slotRequests.
- Allowing allocSlot() but forbidding schedule mutations is a “purity half-measure” that leaks authority: some blocks decide storage layout while others don’t. You end up with two enforcement boundaries.

Cost to ignoring this:
- The cost is that it’s not actually pure: it couples block lowering order and builder state to storage allocation policy, and it makes a later real binding pass harder because you’ve blessed a mutation channel.

We want the strict version: blocks request slots; binder/orchestrator allocates them deterministically.

Concrete spec for the contract
- Pure lower() may:
- build expression IDs (pure graph construction),
- emit effects: slotRequests, stateDecls, stepRequests (where stepRequests are logical requests, not imperative schedule edits),
- reference ctx.outTypes.
- Pure lower() may not:
- allocate slots (allocSlot),
- register slots (registerSigSlot, etc.),
- emit schedule steps (stepSlotWriteStrided, stepStateWrite, etc. should be effects).

That implies your binder must handle:
- allocating slots for outputs requested by portId,
- allocating state slots keyed by StableStateId,
- patching expressions that refer to state (you already implemented this pattern successfully in SCC binding).

3) default-source.ts “pure” annotation honesty

Decision: Option B (keep it labeled pure, and make it actually pure now)

What to do
- Move allocSlot() to effects.slotRequests.
- Remove registerSigSlot() from the block. Slot registration should be a binder/orchestrator responsibility driven by slot allocation and resolved types.
- For multi-component outputs (vec2/vec3/color), return an expression root built from construct(...) (after you implement signal construct support).
- If default source selection varies by type/port, that should already be determined by normalization (port-aware policy); the block should simply lower whatever params/policy it was instantiated with.

Cost of ignoring:
- it creates exactly the enforcement hole you’re trying to close: “core block is exempt,” which makes it harder to build a real lint/type boundary later.

So: fix it to pure now, and if you later eliminate the block via normalization, that’s a separate simplification, not an excuse to violate the contract.

What this means for your sprint plan (practical adjustments)

Add a new WI-0 (must precede the blocked block migrations)

WI-0: Runtime stride support for signal slots
- Implement construct in ValueExprSignalEvaluator
- Allow stride>1 in the schedule eval path
- Add tests:
- Const color/vec2/vec3 signals evaluate correctly into contiguous slot storage
- Expression producing color/vec3 evaluates correctly
- Ensure no regression for scalar slots

This unblocks your “construct pattern” across signal context and eliminates the need for stepSlotWriteStrided.

Re-scope “blocked blocks”

Once WI-0 lands, the 4 blocked blocks migrate cleanly with the same pattern:
- outputs via effects.slotRequests
- multi-component values via construct
- no direct builder mutations

Enforcement should be type-level first, ESLint second

Relying on ESLint as the primary gate is brittle (as your 46-error situation shows). The robust mechanism is:
- Remove allocSlot, step*, and register* from the ctx.b interface completely.  <- HARD REQUIREMENT
- Then add ESLint as a belt-and-suspenders check, not the only wall.

This makes “pure means pure” enforceable even when linting is noisy.

Fix the project accounting (“78/80 migrated”)

Update the TODO to separate:
- “annotated” vs “actually pure under enforced interface”
- track progress by compiler-validated purity, not by a string field existing in files

Bottom line

Proceed, but with a hard ordering: first make the runtime capable of evaluating stride>1 signal expressions (including construct), then enforce the pure contract by removing builder mutation APIs from pure lowering, then migrate the remaining blocks and fix misannotations. This is the consistent path that doesn’t reintroduce schedule side effects through a different door.