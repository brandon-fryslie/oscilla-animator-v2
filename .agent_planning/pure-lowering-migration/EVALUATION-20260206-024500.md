# Evaluation: Pure Lowering Migration
Timestamp: 2026-02-06-024500
Git Commit: 3016f1a

## Executive Summary
Overall: ~75% complete | Critical issues: 2 | Tests reliable: yes (for what they cover)

The TODO document claims 78/80 blocks migrated (97.5%), but this figure is misleading. The migration has two distinct dimensions that are being conflated:

1. **Annotation migration** (adding `loweringPurity` tag): ~95% complete (3 blocks missing)
2. **Behavioral migration** (blocks actually returning declarative effects instead of calling imperative builder methods): significantly less complete -- many "pure" blocks still call `ctx.b.allocSlot()` directly

The headline blocker -- `stepSlotWriteStrided` for multi-component signals -- has a design decision documented (use `construct()` pattern), but the runtime does NOT support `construct()` in signal context. This is not a "just wire it up" task; it requires runtime changes to `ValueExprSignalEvaluator.ts` and `ScheduleExecutor.ts`.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| Tests (vitest run) | PASS (2 unrelated failures) | 147 passed, 2 failed, 6 skipped |
| ESLint (src/blocks/) | FAIL | 46 errors (mostly no-defaults-in-lower) |
| TypeScript (typecheck) | Not run | N/A |
| Pure lowering enforcement | MISSING | No ESLint rule exists |

## Missing Checks
1. **ESLint rule: no-imperative-builder-in-lower** -- The planned enforcement mechanism for pure lowering does not exist yet. The TODO doc and design doc both reference it. Without it, there is no automated gate preventing regression.
2. **Runtime test for signal-context construct()** -- No test exercises `construct()` in signal context because the runtime throws for it. Any migration to construct must add such tests.

## Findings

### 1. Runtime Does Not Support construct() in Signal Context
**Status**: BLOCKER -- NOT_STARTED
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/ValueExprSignalEvaluator.ts:191-193`: `case 'construct': { throw new Error('construct expressions are field-extent, not signal-extent'); }`
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/ScheduleExecutor.ts:249-250`: `if (stride !== 1) { throw new Error(...) }` in the evalValue handler
- `/Users/bmf/code/oscilla-animator-v2/src/compiler/backend/schedule-program.ts:673-678`: Schedule builder explicitly collects `slotWriteStrided` slots and skips them from evalValue generation

**Issues**: The design decision says "use construct() instead of stepSlotWriteStrided for multi-component signals." But construct() in signal context throws at runtime. The runtime has two separate evaluation paths:
  - **Signal evaluator** (`ValueExprSignalEvaluator.ts`): scalar values only, throws on construct
  - **Field materializer** (`ValueExprMaterializer.ts`): handles construct by interleaving component buffers

To migrate the 3 stepSlotWriteStrided blocks, one of these must change:
  - **Option A**: Make the signal evaluator support construct (evaluate components, write contiguously into f64 buffer). This is effectively reimplementing slotWriteStrided semantics but driven by expression evaluation instead of an explicit step.
  - **Option B**: Keep slotWriteStrided as a schedule step kind but generate it from a declarative effect (e.g., the binding pass emits slotWriteStrided steps when it sees a construct-typed output with stride > 1). The block itself returns construct expressions purely.

Option B is likely what the design decision intends ("Blocks only return expression IDs and effect requests. The orchestrator emits schedule steps"), but this requires changes to the schedule builder and binding pass, not just the blocks.

### 2. const.ts, expression.ts, external-vec2.ts (stepSlotWriteStrided)
**Status**: PARTIAL (blocked on runtime work above)
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/signal/const.ts:132,158`: `ctx.b.stepSlotWriteStrided(slot, components)`
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/math/expression.ts:175,188`: `ctx.b.stepSlotWriteStrided(slot, components)`
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/io/external-vec2.ts:55`: `ctx.b.stepSlotWriteStrided(slot, components)`

**Issues**: These blocks ALSO use `ctx.b.allocSlot()` directly (const.ts lines 86,98,110,127,151,166; expression.ts lines 84,161; external-vec2.ts line 54). Even after resolving the stepSlotWriteStrided issue, these allocSlot calls need to become effects-as-data (slotRequests). The TODO doc only calls out stepSlotWriteStrided but the allocSlot calls are equally impure.

### 3. default-source.ts
**Status**: PARTIAL (not blocked on stepSlotWriteStrided but has own issues)
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/signal/default-source.ts:190`: Already marked `loweringPurity: 'pure'`
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/signal/default-source.ts:252-257`: Uses `ctx.b.allocSlot()` and `ctx.b.registerSigSlot()` directly (imperative, not pure)
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/signal/default-source.ts:244,299`: Trips `no-block-type-check-in-lower` lint rule (accesses `ctx.blockType`)
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/signal/default-source.ts:49-55,231-233`: TODO comments about temporary cardinality workaround

**Issues**:
1. Block is LABELED `loweringPurity: 'pure'` but performs imperative operations (allocSlot, registerSigSlot). This is a false positive in the migration tracking.
2. The TODO document says this block "may be eliminated by normalization" but that's speculative. It currently has substantial lowering logic (field defaults with LowerSandbox macro expansion).
3. The cardinality TODO comments indicate this block's field-path code is temporary and will change when cardinality typevars are implemented -- but that's a separate, larger project.

### 4. domain-index.ts (Missing from TODO)
**Status**: PARTIAL (annotation missing, but functionally uses effects)
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/domain/domain-index.ts:50-55`: Uses `effects: { slotRequests: [...] }` pattern (pure-style)
- File has no `loweringPurity` annotation
- Not mentioned in PURE-LOWERING-TODO.md

**Issues**: Minor -- this block uses the effects pattern correctly but is missing the `loweringPurity` tag. Easy fix.

### 5. ESLint Enforcement
**Status**: NOT_STARTED
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/eslint-rules/`: 5 rules exist, none for pure lowering enforcement
- `/Users/bmf/code/oscilla-animator-v2/eslint.config.js`: Configured for existing rules only
- PURE-LOWERING-TODO.md step B (lines 251-256): "Write an eslint rule that enforces this behavior" -- not done

**Issues**: The design doc calls for ESLint rules forbidding imperative builder calls in lower(). This is step B in the remediation plan. Without it, any pure migration can silently regress.

### 6. Existing ESLint Violations
**Status**: PARTIAL (pre-existing debt)
**Evidence**: `npx eslint src/blocks/` returns 46 errors
- Mostly `no-defaults-in-lower` (using `??` in lower functions)
- 2x `no-block-type-check-in-lower` in default-source.ts
- 2x `no-default-source-in-lower` in ellipse.ts

**Issues**: These violations pre-date the current migration and are unrelated to stepSlotWriteStrided. However, they demonstrate that existing lint rules are not enforced in CI -- the project currently has 46 lint errors in the blocks directory.

### 7. TODO Document Accuracy
**Status**: PARTIAL (some claims are overcounted)
**Evidence**:
- Claims "78 blocks pure migrated" but default-source.ts (counted as pure) performs imperative operations
- Claims domain-index.ts is in "Domain: 2/2 COMPLETE" but it lacks loweringPurity annotation
- Does not account for allocSlot() calls in the 4 blocked blocks (only mentions stepSlotWriteStrided)

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| Runtime construct() support | Does the design decision to "use construct()" mean (a) the signal evaluator must support construct, or (b) the orchestrator translates construct outputs into slotWriteStrided steps? | The TODO doc says "use construct() pattern" without addressing the runtime gap. The design decision text says "the schedule should not care" which implies option (a), but the runtime explicitly throws. | HIGH -- determines whether the fix is "change runtime evaluator" or "change binding pass / schedule builder" |
| allocSlot() purity | Are direct allocSlot() calls in lower() considered impure? The TODO only mentions stepSlotWriteStrided. | The design doc says "slot allocation" is forbidden in pure lower(). The TODO ignores allocSlot() calls. | MEDIUM -- const.ts/expression.ts need allocSlot removed too, not just stepSlotWriteStrided |
| default-source.ts elimination | Will default-source.ts be eliminated by normalization (as the TODO suggests) or does it need full pure migration? | The TODO hedges: "may be eliminated by normalization." The block currently has substantial field-path logic with LowerSandbox. | LOW for now -- can defer this decision |
| Schedule step ownership | After pure migration, who emits the slotWriteStrided schedule step -- the binding pass, the schedule builder, or neither? | The TODO design section says "outputs are produced by eval steps, never by direct slot writes" which implies slotWriteStrided steps should also be generated by the orchestrator, not block lower(). But the schedule builder currently requires explicit slotWriteStrided steps. | HIGH -- determines the shape of the solution |

## Recommendations

1. **Resolve the runtime gap FIRST** (highest priority). The construct-in-signal-context question must be answered before any block migration can proceed. Two concrete options:
   - **Option A (signal evaluator change)**: Teach `ValueExprSignalEvaluator.ts` to handle `construct` by evaluating each component and writing them into the f64 buffer at `[offset, offset+1, ..., offset+stride-1]`. Also update `ScheduleExecutor.ts` evalValue handler to allow stride > 1 when the expression is a construct. Remove the `slotWriteStrided` step kind entirely.
   - **Option B (orchestrator generates steps)**: Keep the signal evaluator scalar-only. In the schedule builder, when a slot's root expression is a `construct`, automatically generate a `slotWriteStrided`-equivalent step that evaluates each component. The block's lower() returns `construct(...)` purely; the orchestrator decomposes it.

2. **Add loweringPurity to domain-index.ts** (trivial, do immediately).

3. **Write the ESLint rule** (`no-imperative-builder-in-lower`) before migrating the 4 blocks. The rule should flag:
   - `ctx.b.stepSlotWriteStrided` in lower()
   - `ctx.b.allocSlot` in lower() (for pure blocks)
   - `ctx.b.registerSigSlot` in lower()
   - Any other imperative builder mutation

4. **Fix allocSlot() calls** in const.ts, expression.ts, external-vec2.ts alongside the stepSlotWriteStrided migration. These are equally impure.

5. **Address existing 46 ESLint violations** or establish that they are known debt with a timeline.

6. **Fix default-source.ts purity** -- it claims `loweringPurity: 'pure'` but uses allocSlot/registerSigSlot. Either fix the imperative calls or change the annotation to 'impure'.

## Verdict
- [x] PAUSE - Ambiguities need clarification

**Reason for PAUSE**: The core design question -- how `construct()` should work for signal-context multi-component values at runtime -- is unresolved. The TODO document states the decision ("use construct pattern") but the runtime explicitly rejects this pattern. Proceeding with block migration before resolving this will produce code that compiles but throws at runtime.

**Questions needing answers**:

1. **Runtime construct() strategy**: Should the signal evaluator be extended to handle `construct` (Option A), or should the orchestrator/schedule-builder decompose construct outputs into strided writes (Option B)?

2. **allocSlot() in lower()**: Is `ctx.b.allocSlot()` also forbidden for pure blocks? (The design doc says yes, the TODO only mentions stepSlotWriteStrided.) If yes, the migration scope is larger than documented.

3. **default-source.ts**: Should this block's `loweringPurity: 'pure'` annotation be corrected to 'impure' given its imperative operations, or should its imperative operations be migrated? (This can be deferred but should be acknowledged.)
