# Plan: Port/Wire Type Checking in Node Editor

**Date:** 2026-01-19
**Status:** PENDING APPROVAL

---

## Goal

Add type checking when connecting ports in the ReactFlow node editor, preventing incompatible connections before they're created and providing visual feedback to users.

---

## Architecture Analysis

### Current State
- **No validation exists** - `createConnectHandler` in `sync.ts` accepts any connection
- **Compiler validates types** - Pass 2 in `pass2-types.ts` already has `isTypeCompatible()` logic
- **Block registry has types** - Every port declares its `SignalType` (payload + extent)
- **ReactFlow supports validation** - `isValidConnection` callback can prevent invalid connections

### Type Compatibility Rules (from Pass 2)
1. **Payload must match** - `float` → `float`, `color` → `color`, etc.
2. **Exception: `'???'`** - Polymorphic types unify with any concrete type
3. **Temporality must match** - `continuous` ≠ `discrete` (events vs. continuous signals)
4. **Cardinality must match** - `one` (signal) ≠ `many` (field)
5. **For `many` cardinality** - Instance (domainType + instanceId) must also match

---

## Implementation Plan

### Phase 1: Extract Type Validation Utility

**File:** `src/ui/reactFlowEditor/typeValidation.ts` (NEW)

Create a reusable module that:
- Exposes `isConnectionValid(sourceBlockId, sourcePort, targetBlockId, targetPort, patch)`
- Reuses logic from `pass2-types.ts`'s `isTypeCompatible()`
- Returns a result object with `valid: boolean` and `reason?: string`

This keeps validation logic in one place, usable by both UI and any future validation needs.

```typescript
export interface ConnectionValidationResult {
  valid: boolean;
  reason?: string;  // Human-readable explanation if invalid
}

export function validateConnection(
  sourceBlockId: string,
  sourcePortId: string,
  targetBlockId: string,
  targetPortId: string,
  patch: Patch
): ConnectionValidationResult;
```

### Phase 2: Integrate with ReactFlow

**File:** `src/ui/reactFlowEditor/ReactFlowEditor.tsx`

Add `isValidConnection` callback to ReactFlow component:

```typescript
const isValidConnection = useCallback((connection: Connection) => {
  if (!connection.source || !connection.target) return false;

  const result = validateConnection(
    connection.source,
    connection.sourceHandle || '',
    connection.target,
    connection.targetHandle || '',
    rootStore.patch.patch
  );

  return result.valid;
}, [/* dependencies */]);

<ReactFlow
  ...
  isValidConnection={isValidConnection}
/>
```

This **prevents invalid connections at the UI level** - ReactFlow won't even draw the connection line if invalid.

### Phase 3: Visual Feedback (Connection Line Styling)

**File:** `src/ui/reactFlowEditor/ReactFlowEditor.tsx` + CSS

ReactFlow's `isValidConnection` automatically:
- Shows a "can't connect" cursor when hovering over invalid targets
- Doesn't snap the connection line to invalid handles

For enhanced feedback, we can optionally add:
- Custom connection line component that shows red/green based on validity
- Tooltip showing why connection is invalid

**Minimal approach:** Just use `isValidConnection` - ReactFlow handles the UX automatically.

### Phase 4: Enhanced Feedback (Optional - Future)

For better UX, consider these enhancements in a future iteration:

1. **Color-coded handles** - Highlight compatible handles when dragging
2. **Tooltip on invalid attempt** - Show "Type mismatch: Signal<float> → Field<float>"
3. **Type badges on ports** - Show compact type info (S=signal, F=field, etc.)

---

## File Changes Summary

| File | Change |
|------|--------|
| `src/ui/reactFlowEditor/typeValidation.ts` | NEW - Type validation utility |
| `src/ui/reactFlowEditor/ReactFlowEditor.tsx` | Add `isValidConnection` callback |
| `src/ui/reactFlowEditor/sync.ts` | No changes needed (validation happens before onConnect) |

---

## Implementation Details

### typeValidation.ts

```typescript
/**
 * Type validation for ReactFlow connections.
 *
 * Validates port compatibility before connections are created.
 */

import type { Patch } from '../../types';
import type { SignalType } from '../../core/canonical-types';
import { getAxisValue, DEFAULTS_V0 } from '../../core/canonical-types';
import { getBlockDefinition } from '../../blocks/registry';

export interface ConnectionValidationResult {
  valid: boolean;
  reason?: string;
}

/**
 * Get port type from block in patch.
 */
function getPortType(
  patch: Patch,
  blockId: string,
  portId: string,
  direction: 'input' | 'output'
): SignalType | null {
  const block = patch.blocks.get(blockId);
  if (!block) return null;

  const blockDef = getBlockDefinition(block.type);
  if (!blockDef) return null;

  const slots = direction === 'input' ? blockDef.inputs : blockDef.outputs;
  const slot = slots.find(s => s.id === portId);
  return slot?.type ?? null;
}

/**
 * Check if two types are compatible.
 * Based on pass2-types.ts isTypeCompatible().
 */
function isTypeCompatible(from: SignalType, to: SignalType): boolean {
  const fromCard = getAxisValue(from.extent.cardinality, DEFAULTS_V0.cardinality);
  const fromTemp = getAxisValue(from.extent.temporality, DEFAULTS_V0.temporality);
  const toCard = getAxisValue(to.extent.cardinality, DEFAULTS_V0.cardinality);
  const toTemp = getAxisValue(to.extent.temporality, DEFAULTS_V0.temporality);

  // Payload must match (except '???' is polymorphic)
  if (from.payload !== to.payload) {
    if (from.payload !== '???' && to.payload !== '???') {
      return false;
    }
  }

  // Temporality must match
  if (fromTemp.kind !== toTemp.kind) {
    return false;
  }

  // Cardinality must match
  if (fromCard.kind !== toCard.kind) {
    return false;
  }

  // For 'many' cardinality, instance must match
  if (fromCard.kind === 'many' && toCard.kind === 'many') {
    const fromInstance = fromCard.instance;
    const toInstance = toCard.instance;
    if (!fromInstance || !toInstance) return false;
    return fromInstance.domainType === toInstance.domainType &&
           fromInstance.instanceId === toInstance.instanceId;
  }

  return true;
}

/**
 * Format type for display.
 */
function formatType(type: SignalType): string {
  const card = getAxisValue(type.extent.cardinality, DEFAULTS_V0.cardinality);
  const temp = getAxisValue(type.extent.temporality, DEFAULTS_V0.temporality);

  const cardStr = card.kind === 'zero' ? 'Const' : card.kind === 'one' ? 'Signal' : 'Field';
  const tempStr = temp.kind === 'continuous' ? '' : '[event]';

  return `${cardStr}<${type.payload}>${tempStr}`;
}

/**
 * Validate a connection between two ports.
 */
export function validateConnection(
  sourceBlockId: string,
  sourcePortId: string,
  targetBlockId: string,
  targetPortId: string,
  patch: Patch
): ConnectionValidationResult {
  // Get source type (output port)
  const sourceType = getPortType(patch, sourceBlockId, sourcePortId, 'output');
  if (!sourceType) {
    return { valid: false, reason: 'Unknown source port' };
  }

  // Get target type (input port)
  const targetType = getPortType(patch, targetBlockId, targetPortId, 'input');
  if (!targetType) {
    return { valid: false, reason: 'Unknown target port' };
  }

  // Check compatibility
  if (!isTypeCompatible(sourceType, targetType)) {
    return {
      valid: false,
      reason: `Type mismatch: ${formatType(sourceType)} → ${formatType(targetType)}`,
    };
  }

  return { valid: true };
}
```

---

## Verification

1. **Build passes:** `npm run typecheck && npm run build`
2. **Manual testing:**
   - Create two blocks with incompatible ports (e.g., Signal output → Field input)
   - Try to connect them - should be prevented
   - Create blocks with compatible ports - should connect normally
   - Test with polymorphic `???` types - should allow connection
3. **Edge cases:**
   - Self-connections (source = target block)
   - Multiple inputs to same port (ReactFlow handles this)
   - Deleted blocks during drag (handled by null checks)

---

## Out of Scope (Future Work)

- **Visual port coloring** - Color-code ports by type for visual feedback
- **Type inference display** - Show resolved types in tooltips
- **Adapter insertion** - Auto-insert type adapters for compatible but not identical types
- **Connection validation in PatchStore** - Defensive validation in store layer
- **Diagnostics integration** - Emit warnings to DiagnosticsStore for near-misses

---

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Performance with many nodes | Type lookup is O(1) via registry - no concern |
| Instance ID matching edge cases | Exact match semantics match compiler (no surprises) |
| Polymorphic type confusion | `???` is handled same as compiler - unifies with anything |

---

## Dependencies

- Existing type system in `canonical-types.ts` (no changes needed)
- Block registry in `registry.ts` (no changes needed)
- Pass 2 logic in `pass2-types.ts` (reference implementation)
