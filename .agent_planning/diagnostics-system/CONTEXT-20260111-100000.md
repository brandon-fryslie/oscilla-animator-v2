# Diagnostics System Sprint 2 - Implementation Context

**Generated**: 2026-01-11 10:00:00
**Sprint Goal**: Runtime health monitoring and bus validation warnings

---

## Sprint 1 Foundation (What Exists)

### Core Infrastructure
- **EventHub** (`src/events/EventHub.ts`): Type-safe event bus with 5-event contract
- **DiagnosticHub** (`src/diagnostics/DiagnosticHub.ts`): State manager with compile/authoring/runtime snapshots
- **Event Types** (`src/events/types.ts`): RuntimeHealthSnapshot event already defined (lines 197-216)
- **Diagnostic Types** (`src/diagnostics/types.ts`): TargetRef, Diagnostic, DiagnosticCode, Severity, Domain
- **DiagnosticConsole** (`src/ui/components/app/DiagnosticConsole.tsx`): UI for displaying diagnostics

### Integration Points
- **RootStore** (`src/stores/RootStore.ts`): EventHub instantiated at line 71, wired to DiagnosticHub
- **Compiler** (`src/compiler/compile.ts`): Emits CompileBegin (line 78), CompileEnd (lines 99, 248)
- **Animation Loop** (`src/main.ts`): Lines 211-267, calls `executeFrame()` and renders

### Test Coverage
- 303/303 tests passing
- EventHub: 100% coverage
- DiagnosticHub: 91.77% coverage
- authoringValidators: 100% coverage

---

## Deliverable 1: Runtime Health Monitoring

### Goal
Emit RuntimeHealthSnapshot events at 2-5 Hz with NaN detection and frame budget monitoring.

### Files to Create

#### 1. `/Users/bmf/code/oscilla-animator-v2/src/runtime/HealthMonitor.ts`

**Purpose**: Aggregate runtime metrics and generate diagnostics

**Key Functions**:
```typescript
// Record frame timing in ring buffer
export function recordFrameTime(state: RuntimeState, frameTimeMs: number): void

// Record NaN detection (batched in 100ms windows)
export function recordNaN(state: RuntimeState, blockId?: string | null): void

// Record Infinity detection (batched in 100ms windows)
export function recordInfinity(state: RuntimeState, blockId?: string | null): void

// Check if snapshot should be emitted (200ms throttle)
export function shouldEmitSnapshot(state: RuntimeState): boolean

// Generate and emit RuntimeHealthSnapshot event
export function emitHealthSnapshot(
  state: RuntimeState,
  events: EventHub,
  patchId: string,
  activePatchRevision: number,
  tMs: number
): void
```

**Constants**:
- `SNAPSHOT_INTERVAL_MS = 200` (5 Hz emission rate)
- `NAN_BATCH_WINDOW_MS = 100` (Aggregate NaN/Inf in 100ms batches)
- `FRAME_BUDGET_60FPS = 16.67` (ms per frame at 60 fps)
- `FRAME_BUDGET_WARN_THRESHOLD = 25` (Warn if frame > 25ms)

**Diagnostic Generation Logic**:
```typescript
// P_NAN_DETECTED
if (h.nanCount > 0 && h.lastNanBlockId) {
  raised.push(createDiagnostic({
    code: 'P_NAN_DETECTED',
    severity: 'warn',
    domain: 'perf',
    primaryTarget: { kind: 'block', blockId: h.lastNanBlockId },
    title: 'NaN value detected',
    message: `Block produced NaN during evaluation (${h.nanCount} batch(es) detected)`,
    patchRevision: activePatchRevision,
  }));
}

// P_FRAME_BUDGET_EXCEEDED
if (worstFrameMs > FRAME_BUDGET_WARN_THRESHOLD) {
  raised.push(createDiagnostic({
    code: 'P_FRAME_BUDGET_EXCEEDED',
    severity: 'warn',
    domain: 'perf',
    primaryTarget: { kind: 'graphSpan', blockIds: [] },
    title: 'Frame budget exceeded',
    message: `Frame took ${worstFrameMs.toFixed(1)}ms (threshold: ${FRAME_BUDGET_WARN_THRESHOLD}ms)`,
    patchRevision: activePatchRevision,
  }));
}
```

#### 2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/__tests__/runtimeDiagnostics.test.ts`

**Test Cases**:
- NaN batching: Multiple NaN in 100ms window → single count
- Frame timing ring buffer: Record 10 frames, verify avg/worst
- Snapshot throttling: Emit at 5 Hz max, not per-frame
- Health metrics reset: After snapshot, counters reset
- Integration: NaN → snapshot → diagnostic appears

### Files to Modify

#### 1. `/Users/bmf/code/oscilla-animator-v2/src/runtime/RuntimeState.ts`

**Location**: After line 119 (`export interface RuntimeState`)

**Add HealthMetrics interface**:
```typescript
export interface HealthMetrics {
  frameTimes: number[];           // Ring buffer (size 10)
  frameTimesIndex: number;        // Current write position
  nanCount: number;              // Batch count (not per-occurrence)
  infCount: number;
  lastNanBlockId: string | null;
  lastInfBlockId: string | null;
  materializationCount: number;
  heavyMaterializationBlocks: Map<string, number>;
  lastSnapshotTime: number;      // performance.now() of last snapshot
  samplingBatchStart: number;    // Start of current 100ms batch
  nanBatchCount: number;         // NaN occurrences in current batch
  infBatchCount: number;
}

export function createHealthMetrics(): HealthMetrics {
  return {
    frameTimes: new Array(10).fill(0),
    frameTimesIndex: 0,
    nanCount: 0,
    infCount: 0,
    lastNanBlockId: null,
    lastInfBlockId: null,
    materializationCount: 0,
    heavyMaterializationBlocks: new Map(),
    lastSnapshotTime: 0,
    samplingBatchStart: 0,
    nanBatchCount: 0,
    infBatchCount: 0,
  };
}
```

**Add field to RuntimeState**:
```typescript
export interface RuntimeState {
  // ... existing fields ...
  health: HealthMetrics;  // Add after line 135
}
```

**Update createRuntimeState**:
```typescript
export function createRuntimeState(pool: FieldPool): RuntimeState {
  return {
    // ... existing initialization ...
    health: createHealthMetrics(),
  };
}
```

#### 2. `/Users/bmf/code/oscilla-animator-v2/src/runtime/SignalEvaluator.ts`

**Location**: Lines 23-49 (`evaluateSignal()` function)

**Add NaN/Inf detection after evaluation** (before cache line):
```typescript
export function evaluateSignal(
  sigId: SigExprId,
  signals: readonly SigExpr[],
  state: RuntimeState
): number {
  // ... existing cache check ...

  // Evaluate based on kind
  const value = evaluateSigExpr(expr, signals, state);

  // NaN/Inf detection (batched)
  if (Number.isNaN(value)) {
    const now = performance.now();
    const h = state.health;

    // Start new batch if needed
    if (now - h.samplingBatchStart > 100) {
      if (h.nanBatchCount > 0) {
        h.nanCount++;
        h.lastNanBlockId = expr.sourceBlockId ?? null;
      }
      h.nanBatchCount = 0;
      h.samplingBatchStart = now;
    }
    h.nanBatchCount++;
  }

  if (!Number.isFinite(value) && !Number.isNaN(value)) {
    const now = performance.now();
    const h = state.health;

    // Start new batch if needed
    if (now - h.samplingBatchStart > 100) {
      if (h.infBatchCount > 0) {
        h.infCount++;
        h.lastInfBlockId = expr.sourceBlockId ?? null;
      }
      h.infBatchCount = 0;
      h.samplingBatchStart = now;
    }
    h.infBatchCount++;
  }

  // Cache result
  state.cache.sigValues[sigId as number] = value;
  state.cache.sigStamps[sigId as number] = state.cache.frameId;

  return value;
}
```

#### 3. `/Users/bmf/code/oscilla-animator-v2/src/main.ts`

**Location**: Lines 211-267 (`animate()` function)

**Add health monitoring after frame execution**:
```typescript
function animate(tMs: number) {
  if (!currentProgram || !currentState || !ctx || !canvas || !pool) {
    requestAnimationFrame(animate);
    return;
  }

  try {
    const frameStart = performance.now();

    // Execute frame
    const execStart = performance.now();
    const frame = executeFrame(currentProgram, currentState, pool, tMs);
    execTime = performance.now() - execStart;

    // Render to canvas
    const renderStart = performance.now();
    // ... existing render code ...
    renderTime = performance.now() - renderStart;

    // Calculate frame time
    const frameTime = performance.now() - frameStart;

    // Record health metrics
    if (currentState.health) {
      import { recordFrameTime, shouldEmitSnapshot, emitHealthSnapshot } from './runtime/HealthMonitor';

      recordFrameTime(currentState, frameTime);

      // Emit health snapshot if throttle interval elapsed
      if (shouldEmitSnapshot(currentState)) {
        emitHealthSnapshot(
          currentState,
          rootStore.events,
          'patch-0',
          rootStore.patch.revision,
          tMs
        );
      }
    }

    // ... existing FPS tracking code ...

    requestAnimationFrame(animate);
  } catch (err) {
    log(`Runtime error: ${err}`, 'error');
    console.error(err);
  }
}
```

#### 4. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts`

**Add new diagnostic codes** (after line 119, in DiagnosticCode type):
```typescript
// Performance diagnostics (runtime stream)
| 'P_NAN_DETECTED'              // NaN value produced during evaluation
| 'P_INFINITY_DETECTED'          // Infinity value produced
| 'P_FRAME_BUDGET_EXCEEDED'      // Frame eval exceeded time budget
```

---

## Deliverable 2: Bus Validation Warnings

### Goal
Generate W_BUS_EMPTY and W_BUS_NO_PUBLISHERS warnings after successful compilation.

### Files to Create

#### 1. `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes/busValidation.ts`

**Purpose**: Analyze bus usage and generate warnings

**Key Functions**:
```typescript
// Count publishers and listeners for each bus
function analyzeBusUsage(patch: NormalizedPatch): Map<string, {
  publishers: number;
  listeners: number;
  publisherBlockIds: string[];
}>

// Generate bus warnings for a normalized patch
export function generateBusWarnings(
  patch: NormalizedPatch,
  patchRevision: number
): Diagnostic[]
```

**Logic**:
```typescript
for (const [busId, { publishers, listeners }] of usage) {
  // W_BUS_EMPTY: Publishers but no listeners
  if (publishers > 0 && listeners === 0) {
    warnings.push(createDiagnostic({
      code: 'W_BUS_EMPTY',
      severity: 'warn',
      domain: 'compile',
      primaryTarget: { kind: 'bus', busId },
      title: 'Bus has no listeners',
      message: `Bus "${busId}" has ${publishers} publisher(s) but no listeners`,
      patchRevision,
    }));
  }

  // W_BUS_NO_PUBLISHERS: Listeners but no publishers
  if (publishers === 0 && listeners > 0) {
    warnings.push(createDiagnostic({
      code: 'W_BUS_NO_PUBLISHERS',
      severity: 'warn',
      domain: 'compile',
      primaryTarget: { kind: 'bus', busId },
      title: 'Bus has no publishers',
      message: `Bus "${busId}" has ${listeners} listener(s) but no publishers (will use silent value)`,
      patchRevision,
    }));
  }
}
```

#### 2. `/Users/bmf/code/oscilla-animator-v2/src/compiler/__tests__/busValidation.test.ts`

**Test Cases**:
- Empty bus: Publishers but no listeners → W_BUS_EMPTY
- No publishers: Listeners but no publishers → W_BUS_NO_PUBLISHERS
- Edge cases: Bus with no edges, self-publishing bus
- Coverage: Verify >80% for busValidation.ts

### Files to Modify

#### 1. `/Users/bmf/code/oscilla-animator-v2/src/compiler/compile.ts`

**Location**: Line 248 (before CompileEnd emission on success)

**Add bus validation**:
```typescript
// After successful compilation passes
const normResult = passes.normalize(patch);
// ... existing passes 2-10 ...

// Generate bus warnings (after successful compilation)
import { generateBusWarnings } from './passes/busValidation';
const busWarnings = generateBusWarnings(normResult.patch, options.patchRevision);

// Emit CompileEnd event (success)
if (options) {
  // Convert compile errors to diagnostics
  const compileEndDiags = convertCompileErrorsToDiagnostics(
    errors,
    options.patchRevision
  ).concat(busWarnings);  // Append bus warnings

  options.events.emit({
    type: 'CompileEnd',
    compileId,
    patchId: options.patchId,
    patchRevision: options.patchRevision,
    status: 'success',
    durationMs: performance.now() - startTime,
    diagnostics: compileEndDiags,
  });
}
```

**IMPORTANT**: Only generate bus warnings on successful compilation (status: 'success'). Do NOT generate on failure.

#### 2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts`

**Add new diagnostic codes** (after line 119):
```typescript
// Bus warnings (compile stream)
| 'W_BUS_EMPTY'                  // Bus has publishers but no listeners
| 'W_BUS_NO_PUBLISHERS'          // Bus has listeners but no publishers
```

---

## Deliverable 3 (Optional): Basic Quick Fix - createTimeRoot

### Goal
Implement "Create TimeRoot" action for E_TIME_ROOT_MISSING diagnostic.

### Files to Create

#### 1. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/actions/quickFixes.ts`

**Purpose**: Execute diagnostic actions

**Key Functions**:
```typescript
export function executeAction(
  action: DiagnosticAction,
  rootStore: RootStore
): boolean {
  switch (action.kind) {
    case 'createTimeRoot': {
      const timeRootKind = action.data?.timeRootKind ?? 'Infinite';
      const blockType = timeRootKind === 'Infinite' ? 'InfiniteTimeRoot' : 'FiniteTimeRoot';

      // Add TimeRoot block at center of viewport
      rootStore.patch.addBlock(blockType, {
        periodAMs: 8000,
        periodBMs: 16000,
      }, {
        role: { kind: 'timeRoot' },
        position: { x: 400, y: 300 },
      });

      return true;
    }

    case 'goToTarget': {
      console.log('Navigate to:', action.data?.target);
      return true;
    }

    default:
      return false;
  }
}
```

#### 2. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/diagnostics/DiagnosticActions.tsx`

**Purpose**: Render action buttons

**Component**:
```typescript
export const DiagnosticActions: React.FC<{ actions: DiagnosticAction[] }> = ({ actions }) => {
  const rootStore = useRootStore();

  const handleClick = (action: DiagnosticAction) => {
    const success = executeAction(action, rootStore);
    if (!success) {
      console.error(`Failed to execute action: ${action.id}`);
    }
  };

  return (
    <div className="diagnostic-actions">
      {actions.map(action => (
        <button
          key={action.id}
          onClick={() => handleClick(action)}
          className={action.isPrimary ? 'primary' : 'secondary'}
        >
          {action.label}
        </button>
      ))}
    </div>
  );
};
```

#### 3. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/__tests__/quickFixes.test.ts`

**Test Cases**:
- createTimeRoot action adds InfiniteTimeRoot block
- Action execution is idempotent (safe to replay)
- Action failure handling (invalid action kind)
- goToTarget action (logs to console)

### Files to Modify

#### 1. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts`

**Expand DiagnosticAction interface** (after line 149):
```typescript
export interface DiagnosticAction {
  readonly id: string;
  readonly kind: 'createTimeRoot' | 'goToTarget' | 'insertBlock' | 'removeBlock';
  readonly label: string;
  readonly isPrimary?: boolean;

  // Action-specific data
  readonly data?: {
    timeRootKind?: 'Infinite' | 'Finite' | 'Cycle';
    target?: TargetRef;
    blockType?: string;
    blockId?: string;
  };
}
```

#### 2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/validators/authoringValidators.ts`

**Add actions to E_TIME_ROOT_MISSING diagnostic** (lines 78-99):
```typescript
if (timeRoots.length === 0) {
  diags.push(createDiagnostic({
    code: 'E_TIME_ROOT_MISSING',
    severity: 'error',
    domain: 'authoring',
    primaryTarget: { kind: 'graphSpan', blockIds: [] },
    title: 'No TimeRoot',
    message: 'Patch must have exactly one TimeRoot block',
    patchRevision,
    actions: [
      {
        id: 'create-time-root-infinite',
        kind: 'createTimeRoot',
        label: 'Create Infinite TimeRoot',
        isPrimary: true,
        data: { timeRootKind: 'Infinite' },
      },
      {
        id: 'create-time-root-finite',
        kind: 'createTimeRoot',
        label: 'Create Finite TimeRoot',
        isPrimary: false,
        data: { timeRootKind: 'Finite' },
      },
    ],
  }));
}
```

#### 3. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/app/DiagnosticConsole.tsx`

**Integrate DiagnosticActions component** (in DiagnosticRow):
```typescript
<DiagnosticRow key={diag.id}>
  <SeverityIcon severity={diag.severity} />
  <Title>{diag.title}</Title>
  <Message>{diag.message}</Message>
  <Target>{formatTarget(diag.primaryTarget)}</Target>

  {/* Add action buttons if actions exist */}
  {diag.actions && diag.actions.length > 0 && (
    <DiagnosticActions actions={diag.actions} />
  )}
</DiagnosticRow>
```

---

## Key Concepts

### NaN Detection Batching Strategy

**Problem**: Per-occurrence NaN detection would spam diagnostics (e.g., 600 NaN/sec at 60fps).

**Solution**: Batch NaN occurrences in 100ms windows:
1. Track `nanBatchCount` (occurrences in current batch)
2. When batch window expires (100ms), commit batch: `nanCount++`
3. Reset `nanBatchCount = 0` for next batch

**Result**: Multiple NaN in 100ms → single diagnostic occurrence count

### Runtime Health Snapshot Throttling

**Problem**: Per-frame snapshots (60 Hz) would overwhelm event system.

**Solution**: Throttle to 5 Hz (200ms interval):
1. Track `lastSnapshotTime` (performance.now())
2. Emit only if `now - lastSnapshotTime >= 200`
3. Reset `lastSnapshotTime` after emission

**Result**: Max 5 snapshots/sec, regardless of frame rate

### Bus Usage Analysis

**Data sources**:
- **Buses**: From `NormalizedPatch.buses` (all buses in patch)
- **Publishers**: Count edges where `edge.target.kind === 'bus'`
- **Listeners**: Count edges where `edge.source.kind === 'bus'`

**Warning conditions**:
- `publishers > 0 && listeners === 0` → W_BUS_EMPTY
- `publishers === 0 && listeners > 0` → W_BUS_NO_PUBLISHERS

---

## Integration Dependencies

### Runtime Diagnostics
- **Requires**: RuntimeState with HealthMetrics field
- **Depends on**: EventHub (already exists), RuntimeHealthSnapshot event (already defined)
- **Integration point**: main.ts animation loop (lines 211-267)

### Bus Warnings
- **Requires**: NormalizedPatch from compiler (already exists)
- **Depends on**: compile.ts CompileEnd emission (already exists)
- **Integration point**: After successful compilation (line 248)

### Quick Fixes
- **Requires**: PatchStore.addBlock() (already exists)
- **Depends on**: Diagnostic.actions array (already defined in Sprint 1)
- **Integration point**: DiagnosticConsole UI (already exists)

---

## Testing Approach

### Unit Tests
- HealthMonitor: NaN batching, frame timing, snapshot throttling
- busValidation: Empty bus, no publishers, edge cases
- quickFixes: createTimeRoot execution, action idempotency

### Integration Tests
- Runtime flow: NaN → snapshot → diagnostic → UI
- Bus warning flow: Compile → warnings → UI
- Quick fix flow: Click action → block added → diagnostic clears

### Performance Tests
- Health snapshot overhead: <1ms per snapshot
- NaN detection overhead: <0.01ms per signal evaluation
- Bus validation overhead: <5ms for 100-bus patch

---

## Spec References

- **Canonical spec**: `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/07-diagnostics-system.md`
- **Runtime diagnostics**: Lines 411-491 (NaN detection, frame budget)
- **Bus warnings**: Lines 617-644 (W_BUS_EMPTY, W_BUS_NO_PUBLISHERS)
- **Quick fixes**: Lines 368-379 (DiagnosticAction interface)
- **RuntimeHealthSnapshot event**: Lines 197-216 in `src/events/types.ts`

---

## Critical Implementation Notes

1. **NaN detection must be batched** - Do NOT increment nanCount on every occurrence
2. **Health snapshots throttled to 5 Hz** - Do NOT emit per-frame
3. **Bus warnings only on success** - Do NOT generate on compilation failure
4. **Performance overhead <1%** - Health monitoring must not impact frame rate
5. **Runtime diagnostics merge** - DiagnosticHub already handles RuntimeHealthSnapshot (Sprint 1)
6. **Test coverage >80%** - All new code must be well-tested

---

## File Summary

**New files (7)**:
1. `src/runtime/HealthMonitor.ts` - Health snapshot generation
2. `src/compiler/passes/busValidation.ts` - Bus warning generation
3. `src/diagnostics/actions/quickFixes.ts` - Quick fix executors
4. `src/ui/components/diagnostics/DiagnosticActions.tsx` - Action UI
5. `src/diagnostics/__tests__/runtimeDiagnostics.test.ts` - Runtime tests
6. `src/compiler/__tests__/busValidation.test.ts` - Bus validation tests
7. `src/diagnostics/__tests__/quickFixes.test.ts` - Quick fix tests

**Modified files (6)**:
1. `src/main.ts` - Integrate health monitoring in animation loop
2. `src/runtime/RuntimeState.ts` - Add HealthMetrics interface and field
3. `src/runtime/SignalEvaluator.ts` - Add NaN/Inf detection
4. `src/compiler/compile.ts` - Integrate bus validation
5. `src/diagnostics/types.ts` - Add diagnostic codes (P_*, W_*) and expand DiagnosticAction
6. `src/diagnostics/validators/authoringValidators.ts` - Add actions to E_TIME_ROOT_MISSING

---

## Estimated Effort

**Deliverable 1** (Runtime Health): 16-20 hours
**Deliverable 2** (Bus Warnings): 8-12 hours
**Deliverable 3** (Quick Fix): 6-8 hours (optional)

**Total Sprint 2**: 24-32 hours (P0+P1), 30-40 hours (P0+P1+P2)
