# Diagnostics System - Sprint 2 Implementation Plan

**Generated**: 2026-01-11 10:00:00
**Sprint Goal**: Enable runtime health monitoring (NaN/performance) and bus validation warnings with user-configurable settings
**Scope**: P0 Runtime diagnostics + P1 Settings panel + P2 Bus warnings (+ Optional P3 createTimeRoot quick fix)

---

## Sprint 2 Deliverables

### Deliverable 1: Runtime Health Monitoring (P0)

**Estimated Effort**: 16-20 hours

**Objective**: Emit RuntimeHealthSnapshot events from animation loop with NaN detection and frame budget monitoring

**Files to Create**:
1. `/Users/bmf/code/oscilla-animator-v2/src/runtime/HealthMonitor.ts` - Health snapshot generation
2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/__tests__/runtimeDiagnostics.test.ts` - Runtime diagnostic tests

**Files to Modify**:
1. `/Users/bmf/code/oscilla-animator-v2/src/main.ts` (lines 211-267) - Integrate health monitoring in animation loop
2. `/Users/bmf/code/oscilla-animator-v2/src/runtime/RuntimeState.ts` (after line 119) - Add HealthMetrics interface
3. `/Users/bmf/code/oscilla-animator-v2/src/runtime/SignalEvaluator.ts` (lines 23-49) - Add NaN/Inf detection
4. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts` - Add P_NAN_DETECTED, P_INFINITY_DETECTED, P_FRAME_BUDGET_EXCEEDED codes

**Implementation Steps**:

#### Step 1.1: Add Health Tracking to RuntimeState

**Location**: `src/runtime/RuntimeState.ts` after line 119

Add HealthMetrics interface:
```typescript
export interface HealthMetrics {
  // Frame timing window (last 10 frames)
  frameTimes: number[];        // Ring buffer
  frameTimesIndex: number;     // Current write position

  // NaN/Inf detection (batched, not per-occurrence)
  nanCount: number;           // Batch count (not per-occurrence)
  infCount: number;
  lastNanBlockId: string | null;
  lastInfBlockId: string | null;

  // Field materialization tracking
  materializationCount: number;
  heavyMaterializationBlocks: Map<string, number>;

  // Sampling state
  lastSnapshotTime: number;   // performance.now() of last snapshot
  samplingBatchStart: number; // Start of current 100ms batch
  nanBatchCount: number;      // NaN occurrences in current batch
  infBatchCount: number;
}

export function createHealthMetrics(): HealthMetrics {
  return {
    frameTimes: new Array(10).fill(0),
    frameTimesIndex: 0,
    nanCount: 0,
    infCount: 0,
    lastNanBlockId: null,
    lastInfBlockId: null,
    materializationCount: 0,
    heavyMaterializationBlocks: new Map(),
    lastSnapshotTime: 0,
    samplingBatchStart: 0,
    nanBatchCount: 0,
    infBatchCount: 0,
  };
}
```

Add `health: HealthMetrics` field to RuntimeState interface.
Update `createRuntimeState()` to initialize health metrics.

#### Step 1.2: Create HealthMonitor

**New File**: `src/runtime/HealthMonitor.ts`

**Constants**:
- `SNAPSHOT_INTERVAL_MS = 200` (5 Hz emission rate)
- `NAN_BATCH_WINDOW_MS = 100` (Aggregate NaN/Inf in 100ms batches)
- `FRAME_BUDGET_WARN_THRESHOLD = 25` (Warn if frame > 25ms)

**Functions**:
```typescript
// Record frame timing in ring buffer
export function recordFrameTime(state: RuntimeState, frameTimeMs: number): void

// Record NaN detection (batched in 100ms windows)
export function recordNaN(state: RuntimeState, blockId?: string | null): void

// Record Infinity detection (batched in 100ms windows)
export function recordInfinity(state: RuntimeState, blockId?: string | null): void

// Check if snapshot should be emitted (200ms throttle)
export function shouldEmitSnapshot(state: RuntimeState): boolean

// Generate and emit RuntimeHealthSnapshot event
export function emitHealthSnapshot(
  state: RuntimeState,
  events: EventHub,
  patchId: string,
  activePatchRevision: number,
  tMs: number
): void
```

**Diagnostic Generation**:
- P_NAN_DETECTED: When `nanCount > 0`
- P_INFINITY_DETECTED: When `infCount > 0`
- P_FRAME_BUDGET_EXCEEDED: When `worstFrameMs > 25`

See CONTEXT-20260111-100000.md for full implementation details.

#### Step 1.3: Instrument Signal Evaluator for NaN Detection

**Location**: `src/runtime/SignalEvaluator.ts` lines 23-49

Add NaN/Inf detection after `evaluateSigExpr()` call:
```typescript
const value = evaluateSigExpr(expr, signals, state);

// NaN/Inf detection (batched)
if (Number.isNaN(value)) {
  const now = performance.now();
  const h = state.health;

  // Start new batch if needed
  if (now - h.samplingBatchStart > 100) {
    if (h.nanBatchCount > 0) {
      h.nanCount++;
      h.lastNanBlockId = expr.sourceBlockId ?? null;
    }
    h.nanBatchCount = 0;
    h.samplingBatchStart = now;
  }
  h.nanBatchCount++;
}

// Similar for Infinity
if (!Number.isFinite(value) && !Number.isNaN(value)) {
  // ... same batching logic for Infinity
}
```

#### Step 1.4: Integrate into Animation Loop

**Location**: `src/main.ts` lines 211-267

After frame execution and rendering:
```typescript
const frameTime = performance.now() - frameStart;

// Record health metrics
if (currentState.health) {
  recordFrameTime(currentState, frameTime);

  // Emit health snapshot if throttle interval elapsed
  if (shouldEmitSnapshot(currentState)) {
    emitHealthSnapshot(
      currentState,
      rootStore.events,
      'patch-0',
      rootStore.patch.revision,
      tMs
    );
  }
}
```

**Acceptance Criteria**:
1. RuntimeHealthSnapshot events emit at 2-5 Hz (not per-frame)
2. NaN detection is batched: Multiple NaN in 100ms → single occurrence count
3. Frame budget diagnostic appears when worst frame > 25ms
4. DiagnosticHub receives runtime diagnostics via RuntimeHealthSnapshot
5. Runtime diagnostics show in DiagnosticConsole

---

### Deliverable 2: Diagnostics Settings Panel (P1)

**Estimated Effort**: 8-12 hours

**Objective**: Create user-configurable settings panel for diagnostics system preferences

**Files to Create**:
1. `/Users/bmf/code/oscilla-animator-v2/src/stores/DiagnosticsSettingsStore.ts` - MobX store for diagnostics settings
2. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/settings/DiagnosticsSettingsPanel.tsx` - Settings UI panel
3. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/__tests__/DiagnosticsSettingsStore.test.ts` - Settings tests

**Files to Modify**:
1. `/Users/bmf/code/oscilla-animator-v2/src/stores/RootStore.ts` - Add DiagnosticsSettingsStore
2. `/Users/bmf/code/oscilla-animator-v2/src/runtime/HealthMonitor.ts` - Read settings from store
3. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/app/App.tsx` - Add settings panel to UI

**Implementation Steps**:

#### Step 2.1: Create DiagnosticsSettingsStore

**New File**: `src/stores/DiagnosticsSettingsStore.ts`

```typescript
import { makeAutoObservable } from 'mobx';

export interface DiagnosticsSettings {
  // Runtime health monitoring
  runtimeHealthEnabled: boolean;
  healthSnapshotIntervalMs: number;  // 5 Hz = 200ms, 2 Hz = 500ms
  nanBatchWindowMs: number;          // Aggregate NaN in this window

  // Frame budget thresholds (configurable per target FPS)
  frameBudgetThresholdMs: number;    // Warn if frame > this value
  targetFPS: number;                 // 30, 60, 120

  // NaN/Inf detection
  nanDetectionEnabled: boolean;
  infDetectionEnabled: boolean;

  // Bus warnings
  busWarningsEnabled: boolean;
  warnEmptyBuses: boolean;           // W_BUS_EMPTY
  warnNoPub lishers: boolean;          // W_BUS_NO_PUBLISHERS

  // Performance monitoring
  perfMonitoringEnabled: boolean;
  frameBudgetWarningsEnabled: boolean;
}

export const DEFAULT_DIAGNOSTICS_SETTINGS: DiagnosticsSettings = {
  runtimeHealthEnabled: true,
  healthSnapshotIntervalMs: 200,  // 5 Hz
  nanBatchWindowMs: 100,
  frameBudgetThresholdMs: 25,
  targetFPS: 60,
  nanDetectionEnabled: true,
  infDetectionEnabled: true,
  busWarningsEnabled: true,
  warnEmptyBuses: true,
  warnNoPublishers: true,
  perfMonitoringEnabled: true,
  frameBudgetWarningsEnabled: true,
};

export class DiagnosticsSettingsStore {
  settings: DiagnosticsSettings;

  constructor() {
    // Load from localStorage or use defaults
    const saved = localStorage.getItem('diagnosticsSettings');
    this.settings = saved
      ? { ...DEFAULT_DIAGNOSTICS_SETTINGS, ...JSON.parse(saved) }
      : DEFAULT_DIAGNOSTICS_SETTINGS;

    makeAutoObservable(this);
  }

  // Update individual settings
  setRuntimeHealthEnabled(enabled: boolean) {
    this.settings.runtimeHealthEnabled = enabled;
    this.persist();
  }

  setHealthSnapshotInterval(intervalMs: number) {
    this.settings.healthSnapshotIntervalMs = intervalMs;
    this.persist();
  }

  setFrameBudgetThreshold(thresholdMs: number) {
    this.settings.frameBudgetThresholdMs = thresholdMs;
    this.persist();
  }

  setTargetFPS(fps: number) {
    this.settings.targetFPS = fps;
    // Auto-adjust frame budget threshold based on target FPS
    this.settings.frameBudgetThresholdMs = Math.round((1000 / fps) * 1.5);
    this.persist();
  }

  setNanDetectionEnabled(enabled: boolean) {
    this.settings.nanDetectionEnabled = enabled;
    this.persist();
  }

  setBusWarningsEnabled(enabled: boolean) {
    this.settings.busWarningsEnabled = enabled;
    this.persist();
  }

  // Reset to defaults
  resetToDefaults() {
    this.settings = { ...DEFAULT_DIAGNOSTICS_SETTINGS };
    this.persist();
  }

  // Persist to localStorage
  private persist() {
    localStorage.setItem('diagnosticsSettings', JSON.stringify(this.settings));
  }
}
```

#### Step 2.2: Create Settings Panel UI

**New File**: `src/ui/components/settings/DiagnosticsSettingsPanel.tsx`

```typescript
import React from 'react';
import { observer } from 'mobx-react-lite';
import { useRootStore } from '../../hooks/useRootStore';
import {
  Box,
  Switch,
  Slider,
  FormControlLabel,
  Typography,
  Divider,
  Button,
  Select,
  MenuItem,
} from '@mui/material';

export const DiagnosticsSettingsPanel: React.FC = observer(() => {
  const { diagnosticsSettings } = useRootStore();
  const s = diagnosticsSettings.settings;

  return (
    <Box sx={{ p: 2, maxWidth: 600 }}>
      <Typography variant="h6">Diagnostics Settings</Typography>

      {/* Runtime Health Monitoring */}
      <Box sx={{ mt: 2 }}>
        <Typography variant="subtitle1">Runtime Health Monitoring</Typography>
        <FormControlLabel
          control={
            <Switch
              checked={s.runtimeHealthEnabled}
              onChange={(e) => diagnosticsSettings.setRuntimeHealthEnabled(e.target.checked)}
            />
          }
          label="Enable runtime health monitoring"
        />

        {s.runtimeHealthEnabled && (
          <>
            <Typography gutterBottom>
              Health Snapshot Interval: {s.healthSnapshotIntervalMs}ms ({Math.round(1000 / s.healthSnapshotIntervalMs)} Hz)
            </Typography>
            <Slider
              value={s.healthSnapshotIntervalMs}
              onChange={(_, val) => diagnosticsSettings.setHealthSnapshotInterval(val as number)}
              min={100}
              max={1000}
              step={50}
              marks={[
                { value: 100, label: '10 Hz' },
                { value: 200, label: '5 Hz' },
                { value: 500, label: '2 Hz' },
                { value: 1000, label: '1 Hz' },
              ]}
            />

            <FormControlLabel
              control={
                <Switch
                  checked={s.nanDetectionEnabled}
                  onChange={(e) => diagnosticsSettings.setNanDetectionEnabled(e.target.checked)}
                />
              }
              label="Detect NaN values"
            />

            <FormControlLabel
              control={
                <Switch
                  checked={s.infDetectionEnabled}
                  onChange={(e) => diagnosticsSettings.settings.infDetectionEnabled = e.target.checked}
                />
              }
              label="Detect Infinity values"
            />
          </>
        )}
      </Box>

      <Divider sx={{ my: 2 }} />

      {/* Frame Budget */}
      <Box sx={{ mt: 2 }}>
        <Typography variant="subtitle1">Frame Budget</Typography>
        <FormControlLabel
          control={
            <Switch
              checked={s.frameBudgetWarningsEnabled}
              onChange={(e) => diagnosticsSettings.settings.frameBudgetWarningsEnabled = e.target.checked}
            />
          }
          label="Warn when frame budget exceeded"
        />

        {s.frameBudgetWarningsEnabled && (
          <>
            <Typography gutterBottom>Target FPS</Typography>
            <Select
              value={s.targetFPS}
              onChange={(e) => diagnosticsSettings.setTargetFPS(e.target.value as number)}
            >
              <MenuItem value={30}>30 FPS</MenuItem>
              <MenuItem value={60}>60 FPS (default)</MenuItem>
              <MenuItem value={120}>120 FPS</MenuItem>
            </Select>

            <Typography gutterBottom sx={{ mt: 2 }}>
              Frame Budget Threshold: {s.frameBudgetThresholdMs}ms
            </Typography>
            <Slider
              value={s.frameBudgetThresholdMs}
              onChange={(_, val) => diagnosticsSettings.setFrameBudgetThreshold(val as number)}
              min={8}
              max={100}
              step={1}
              marks={[
                { value: 8, label: '8ms' },
                { value: 16, label: '16ms' },
                { value: 33, label: '33ms' },
              ]}
            />
          </>
        )}
      </Box>

      <Divider sx={{ my: 2 }} />

      {/* Bus Warnings */}
      <Box sx={{ mt: 2 }}>
        <Typography variant="subtitle1">Bus Warnings</Typography>
        <FormControlLabel
          control={
            <Switch
              checked={s.busWarningsEnabled}
              onChange={(e) => diagnosticsSettings.setBusWarningsEnabled(e.target.checked)}
            />
          }
          label="Enable bus validation warnings"
        />

        {s.busWarningsEnabled && (
          <>
            <FormControlLabel
              control={
                <Switch
                  checked={s.warnEmptyBuses}
                  onChange={(e) => diagnosticsSettings.settings.warnEmptyBuses = e.target.checked}
                />
              }
              label="Warn on empty buses (publishers but no listeners)"
            />

            <FormControlLabel
              control={
                <Switch
                  checked={s.warnNoPublishers}
                  onChange={(e) => diagnosticsSettings.settings.warnNoPublishers = e.target.checked}
                />
              }
              label="Warn on buses with no publishers"
            />
          </>
        )}
      </Box>

      <Divider sx={{ my: 2 }} />

      {/* Reset to defaults */}
      <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end' }}>
        <Button
          variant="outlined"
          onClick={() => diagnosticsSettings.resetToDefaults()}
        >
          Reset to Defaults
        </Button>
      </Box>
    </Box>
  );
});
```

#### Step 2.3: Integrate Settings into RootStore

**Location**: `src/stores/RootStore.ts`

Add DiagnosticsSettingsStore field:
```typescript
import { DiagnosticsSettingsStore } from './DiagnosticsSettingsStore';

export class RootStore {
  // ... existing stores ...
  diagnosticsSettings: DiagnosticsSettingsStore;

  constructor() {
    // ... existing initialization ...
    this.diagnosticsSettings = new DiagnosticsSettingsStore();
  }
}
```

#### Step 2.4: Update HealthMonitor to Read Settings

**Location**: `src/runtime/HealthMonitor.ts`

Replace hardcoded constants with settings reads:
```typescript
import type { DiagnosticsSettingsStore } from '../stores/DiagnosticsSettingsStore';

export function shouldEmitSnapshot(
  state: RuntimeState,
  settings: DiagnosticsSettingsStore
): boolean {
  if (!settings.settings.runtimeHealthEnabled) return false;

  const now = performance.now();
  const interval = settings.settings.healthSnapshotIntervalMs;
  return now - state.health.lastSnapshotTime >= interval;
}

export function emitHealthSnapshot(
  state: RuntimeState,
  events: EventHub,
  patchId: string,
  activePatchRevision: number,
  tMs: number,
  settings: DiagnosticsSettingsStore
): void {
  const h = state.health;
  const s = settings.settings;
  const now = performance.now();

  // ... frame metrics calculation ...

  // Generate diagnostics based on settings
  const raised: Diagnostic[] = [];

  // P_NAN_DETECTED (only if enabled)
  if (s.nanDetectionEnabled && h.nanCount > 0 && h.lastNanBlockId) {
    raised.push(/* ... */);
  }

  // P_INFINITY_DETECTED (only if enabled)
  if (s.infDetectionEnabled && h.infCount > 0 && h.lastInfBlockId) {
    raised.push(/* ... */);
  }

  // P_FRAME_BUDGET_EXCEEDED (only if enabled, use configurable threshold)
  if (s.frameBudgetWarningsEnabled && worstFrameMs > s.frameBudgetThresholdMs) {
    raised.push(/* ... */);
  }

  // ... emit event ...
}
```

#### Step 2.5: Update SignalEvaluator to Respect Settings

**Location**: `src/runtime/SignalEvaluator.ts`

Check settings before recording NaN/Inf:
```typescript
// NaN detection (only if enabled in settings)
if (Number.isNaN(value) && state.settings?.nanDetectionEnabled) {
  // ... batching logic ...
}

if (!Number.isFinite(value) && !Number.isNaN(value) && state.settings?.infDetectionEnabled) {
  // ... batching logic ...
}
```

**Note**: Pass settings through RuntimeState or as parameter from main.ts.

#### Step 2.6: Update Bus Validation to Respect Settings

**Location**: `src/compiler/compile.ts`

```typescript
// Generate bus warnings (only if enabled in settings)
let busWarnings: Diagnostic[] = [];
if (rootStore.diagnosticsSettings.settings.busWarningsEnabled) {
  busWarnings = generateBusWarnings(
    normResult.patch,
    options.patchRevision,
    rootStore.diagnosticsSettings.settings
  );
}
```

**Location**: `src/compiler/passes/busValidation.ts`

```typescript
export function generateBusWarnings(
  patch: NormalizedPatch,
  patchRevision: number,
  settings: { warnEmptyBuses: boolean; warnNoPublishers: boolean }
): Diagnostic[] {
  const warnings: Diagnostic[] = [];
  const usage = analyzeBusUsage(patch);

  for (const [busId, { publishers, listeners }] of usage) {
    // W_BUS_EMPTY (only if enabled)
    if (settings.warnEmptyBuses && publishers > 0 && listeners === 0) {
      warnings.push(/* ... */);
    }

    // W_BUS_NO_PUBLISHERS (only if enabled)
    if (settings.warnNoPublishers && publishers === 0 && listeners > 0) {
      warnings.push(/* ... */);
    }
  }

  return warnings;
}
```

**Acceptance Criteria**:
1. DiagnosticsSettingsStore persists settings to localStorage
2. Settings panel UI displays all configurable options
3. Runtime health monitoring respects `runtimeHealthEnabled` toggle
4. Health snapshot interval is configurable (100ms-1000ms slider)
5. Frame budget threshold is configurable (8ms-100ms slider)
6. Target FPS selector auto-adjusts frame budget threshold
7. NaN/Inf detection can be individually toggled
8. Bus warnings can be enabled/disabled
9. Individual bus warning types (empty buses, no publishers) can be toggled
10. "Reset to Defaults" button restores default settings
11. Settings changes apply immediately (MobX reactivity)

---

### Deliverable 3: Bus Validation Warnings (P2)

**Estimated Effort**: 8-12 hours

**Objective**: Generate bus warnings during compilation for empty buses and buses with no publishers

**Files to Create**:
1. `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes/busValidation.ts` - Bus warning generator
2. `/Users/bmf/code/oscilla-animator-v2/src/compiler/__tests__/busValidation.test.ts` - Bus validation tests

**Files to Modify**:
1. `/Users/bmf/code/oscilla-animator-v2/src/compiler/compile.ts` (line 248) - Add bus validation pass
2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts` - Add W_BUS_EMPTY, W_BUS_NO_PUBLISHERS codes

**Implementation Steps**:

#### Step 2.1: Create Bus Validation Pass

**New File**: `src/compiler/passes/busValidation.ts`

**Functions**:
```typescript
// Count publishers and listeners for each bus
function analyzeBusUsage(patch: NormalizedPatch): Map<string, {
  publishers: number;
  listeners: number;
  publisherBlockIds: string[];
}>

// Generate bus warnings for a normalized patch
export function generateBusWarnings(
  patch: NormalizedPatch,
  patchRevision: number
): Diagnostic[]
```

**Logic**:
- Iterate through all buses in `patch.buses`
- Count publishers: edges where `edge.target.kind === 'bus'`
- Count listeners: edges where `edge.source.kind === 'bus'`
- Generate warnings:
  - W_BUS_EMPTY: `publishers > 0 && listeners === 0`
  - W_BUS_NO_PUBLISHERS: `publishers === 0 && listeners > 0`

See CONTEXT-20260111-100000.md for full implementation.

#### Step 2.2: Integrate Bus Validation into Compiler

**Location**: `src/compiler/compile.ts` line 248

After successful compilation (before CompileEnd emission):
```typescript
// Generate bus warnings (after successful compilation)
const busWarnings = generateBusWarnings(normResult.patch, options.patchRevision);

// Emit CompileEnd event (success)
const compileEndDiags = convertCompileErrorsToDiagnostics(
  errors,
  options.patchRevision
).concat(busWarnings);  // Append bus warnings

options.events.emit({
  type: 'CompileEnd',
  // ...
  diagnostics: compileEndDiags,
});
```

**IMPORTANT**: Only generate bus warnings on successful compilation (not on failure).

**Acceptance Criteria**:
1. W_BUS_EMPTY diagnostic appears when bus has publishers but no listeners
2. W_BUS_NO_PUBLISHERS diagnostic appears when bus has listeners but no publishers
3. Bus warnings appear in DiagnosticConsole after successful compilation
4. Bus warnings do NOT appear on compilation failure
5. Test coverage >80% for bus validation logic

---

### Deliverable 4 (Optional): Basic Quick Fix - createTimeRoot (P3)

**Estimated Effort**: 6-8 hours

**Objective**: Implement "Create TimeRoot" quick fix action for E_TIME_ROOT_MISSING diagnostic

**Files to Create**:
1. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/actions/quickFixes.ts` - Quick fix executors
2. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/diagnostics/DiagnosticActions.tsx` - Action UI
3. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/__tests__/quickFixes.test.ts` - Quick fix tests

**Files to Modify**:
1. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts` (line 149) - Expand DiagnosticAction interface
2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/validators/authoringValidators.ts` (lines 78-99) - Add actions to E_TIME_ROOT_MISSING
3. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/app/DiagnosticConsole.tsx` - Integrate DiagnosticActions component

**Implementation Steps**:

#### Step 3.1: Expand DiagnosticAction Type

**Location**: `src/diagnostics/types.ts` line 149

```typescript
export interface DiagnosticAction {
  readonly id: string;
  readonly kind: 'createTimeRoot' | 'goToTarget' | 'insertBlock' | 'removeBlock';
  readonly label: string;
  readonly isPrimary?: boolean;

  readonly data?: {
    timeRootKind?: 'Infinite' | 'Finite' | 'Cycle';
    target?: TargetRef;
    blockType?: string;
    blockId?: string;
  };
}
```

#### Step 3.2: Create Quick Fix Executor

**New File**: `src/diagnostics/actions/quickFixes.ts`

```typescript
export function executeAction(
  action: DiagnosticAction,
  rootStore: RootStore
): boolean {
  switch (action.kind) {
    case 'createTimeRoot': {
      const timeRootKind = action.data?.timeRootKind ?? 'Infinite';
      const blockType = timeRootKind === 'Infinite' ? 'InfiniteTimeRoot' : 'FiniteTimeRoot';

      rootStore.patch.addBlock(blockType, {
        periodAMs: 8000,
        periodBMs: 16000,
      }, {
        role: { kind: 'timeRoot' },
        position: { x: 400, y: 300 },
      });

      return true;
    }

    case 'goToTarget':
      console.log('Navigate to:', action.data?.target);
      return true;

    default:
      return false;
  }
}
```

#### Step 3.3: Add Action to E_TIME_ROOT_MISSING Diagnostic

**Location**: `src/diagnostics/validators/authoringValidators.ts` lines 78-99

```typescript
if (timeRoots.length === 0) {
  diags.push(createDiagnostic({
    code: 'E_TIME_ROOT_MISSING',
    severity: 'error',
    domain: 'authoring',
    primaryTarget: { kind: 'graphSpan', blockIds: [] },
    title: 'No TimeRoot',
    message: 'Patch must have exactly one TimeRoot block',
    patchRevision,
    actions: [
      {
        id: 'create-time-root-infinite',
        kind: 'createTimeRoot',
        label: 'Create Infinite TimeRoot',
        isPrimary: true,
        data: { timeRootKind: 'Infinite' },
      },
      {
        id: 'create-time-root-finite',
        kind: 'createTimeRoot',
        label: 'Create Finite TimeRoot',
        isPrimary: false,
        data: { timeRootKind: 'Finite' },
      },
    ],
  }));
}
```

#### Step 3.4: UI for Actions

**New File**: `src/ui/components/diagnostics/DiagnosticActions.tsx`

```typescript
export const DiagnosticActions: React.FC<{ actions: DiagnosticAction[] }> = ({ actions }) => {
  const rootStore = useRootStore();

  const handleClick = (action: DiagnosticAction) => {
    const success = executeAction(action, rootStore);
    if (!success) {
      console.error(`Failed to execute action: ${action.id}`);
    }
  };

  return (
    <div className="diagnostic-actions">
      {actions.map(action => (
        <button
          key={action.id}
          onClick={() => handleClick(action)}
          className={action.isPrimary ? 'primary' : 'secondary'}
        >
          {action.label}
        </button>
      ))}
    </div>
  );
};
```

**Integrate in DiagnosticConsole**:
```typescript
{diag.actions && diag.actions.length > 0 && (
  <DiagnosticActions actions={diag.actions} />
)}
```

**Acceptance Criteria**:
1. E_TIME_ROOT_MISSING diagnostic includes "Create TimeRoot" action
2. Clicking action button adds InfiniteTimeRoot block to patch
3. After action executes, diagnostic disappears (authoring validators re-run)
4. Action execution is logged and can be undone
5. UI shows action buttons inline with diagnostic message

---

## Integration Points

### Files Modified (6)
1. `src/main.ts` - Integrate health monitoring in animation loop
2. `src/runtime/RuntimeState.ts` - Add HealthMetrics interface
3. `src/runtime/SignalEvaluator.ts` - NaN/Inf detection
4. `src/compiler/compile.ts` - Bus validation integration
5. `src/diagnostics/types.ts` - Expand diagnostic codes, actions
6. `src/diagnostics/validators/authoringValidators.ts` - Add actions to diagnostics

### New Files (7)
1. `src/runtime/HealthMonitor.ts` - Health snapshot generation
2. `src/compiler/passes/busValidation.ts` - Bus warning generation
3. `src/diagnostics/actions/quickFixes.ts` - Quick fix executors
4. `src/ui/components/diagnostics/DiagnosticActions.tsx` - Action UI
5. `src/diagnostics/__tests__/runtimeDiagnostics.test.ts` - Runtime tests
6. `src/compiler/__tests__/busValidation.test.ts` - Bus validation tests
7. `src/diagnostics/__tests__/quickFixes.test.ts` - Quick fix tests

---

## Diagnostic Codes Added

**Performance Diagnostics**:
- `P_NAN_DETECTED` - NaN value produced during evaluation
- `P_INFINITY_DETECTED` - Infinity value produced
- `P_FRAME_BUDGET_EXCEEDED` - Frame eval exceeded time budget

**Bus Warnings**:
- `W_BUS_EMPTY` - Bus has publishers but no listeners
- `W_BUS_NO_PUBLISHERS` - Bus has listeners but no publishers

---

## Dependencies on Sprint 1

- EventHub supports RuntimeHealthSnapshot event (already defined)
- DiagnosticHub handles RuntimeHealthSnapshot (already subscribed)
- RuntimeState exists and is accessible in main.ts
- DiagnosticCode enum can be extended
- Diagnostic interface accepts optional actions array

---

## Ambiguities Resolved

1. **NaN detection frequency**: Batched in 100ms windows (not per-occurrence)
2. **Performance thresholds**: 25ms frame budget threshold
3. **Bus warnings timing**: Only after successful compilation
4. **Health snapshot rate**: 5 Hz (200ms interval)
5. **Quick fix scope**: createTimeRoot only for Sprint 2 MVP
6. **Runtime diagnostic expiry**: No TTL for Sprint 2 (persist until resolved)

---

## Testing Strategy

### Unit Tests
- HealthMonitor: NaN batching, frame timing, snapshot throttling
- busValidation: Empty bus, no publishers detection
- quickFixes: createTimeRoot execution, idempotency

### Integration Tests
- Runtime flow: NaN → snapshot → diagnostic → UI
- Bus warning flow: Compile → warnings → UI
- Quick fix flow: Click action → block added → diagnostic clears

### Performance Tests
- Health snapshot overhead: <1ms per snapshot
- NaN detection overhead: <0.01ms per signal evaluation
- Bus validation overhead: <5ms for 100-bus patch

---

## Out of Scope (Sprint 2)

Deferred to Sprint 3+:
- Advanced quick fixes (addAdapter, removeBlock, muteDiagnostic)
- UI badges on blocks/ports/buses
- Diagnostic grouping
- Muting persistence
- Field materialization tracking diagnostics
- Combine mode conflict detection
- Performance profiling (block-level timing)

---

## Success Criteria

Sprint 2 is complete when:
1. RuntimeHealthSnapshot events emit at 5 Hz during animation
2. P_NAN_DETECTED diagnostic appears when NaN occurs (batched)
3. P_FRAME_BUDGET_EXCEEDED appears when frame > 25ms
4. W_BUS_EMPTY and W_BUS_NO_PUBLISHERS appear after successful compilation
5. Optional: "Create TimeRoot" action adds block and resolves diagnostic
6. All new code has >80% test coverage
7. All existing tests pass (303/303 baseline)
8. Integration tests pass for runtime and bus warning flows
9. No regressions in animation loop performance (<1% overhead)

---

## Implementation Order

1. **Day 1-2**: Runtime health infrastructure (HealthMetrics, HealthMonitor)
2. **Day 2-3**: NaN/Inf detection in SignalEvaluator
3. **Day 3-4**: Animation loop integration, snapshot emission
4. **Day 4-5**: Bus validation pass (analyzeBusUsage, generateBusWarnings)
5. **Day 5-6**: Compiler integration for bus warnings
6. **Day 6-7**: Quick fix infrastructure (optional)
7. **Day 7-8**: Testing, polish, documentation

**Total Estimated Effort**: 24-32 hours (P0+P1), 30-40 hours (P0+P1+P2)
