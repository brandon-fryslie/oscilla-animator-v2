# Diagnostics System - Sprint 2 Implementation Plan

**Generated**: 2026-01-11 10:00:00
**Sprint Goal**: Enable runtime health monitoring (NaN/performance) and bus validation warnings
**Scope**: P0 Runtime diagnostics + P1 Bus warnings (+ Optional P2 createTimeRoot quick fix)

---

## Sprint 2 Deliverables

### Deliverable 1: Runtime Health Monitoring (P0)

**Estimated Effort**: 16-20 hours

**Objective**: Emit RuntimeHealthSnapshot events from animation loop with NaN detection and frame budget monitoring

**Files to Create**:
1. `/Users/bmf/code/oscilla-animator-v2/src/runtime/HealthMonitor.ts` - Health snapshot generation
2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/__tests__/runtimeDiagnostics.test.ts` - Runtime diagnostic tests

**Files to Modify**:
1. `/Users/bmf/code/oscilla-animator-v2/src/main.ts` (lines 211-267) - Integrate health monitoring in animation loop
2. `/Users/bmf/code/oscilla-animator-v2/src/runtime/RuntimeState.ts` (after line 119) - Add HealthMetrics interface
3. `/Users/bmf/code/oscilla-animator-v2/src/runtime/SignalEvaluator.ts` (lines 23-49) - Add NaN/Inf detection
4. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts` - Add P_NAN_DETECTED, P_INFINITY_DETECTED, P_FRAME_BUDGET_EXCEEDED codes

**Implementation Steps**:

#### Step 1.1: Add Health Tracking to RuntimeState

**Location**: `src/runtime/RuntimeState.ts` after line 119

Add HealthMetrics interface:
```typescript
export interface HealthMetrics {
  // Frame timing window (last 10 frames)
  frameTimes: number[];        // Ring buffer
  frameTimesIndex: number;     // Current write position

  // NaN/Inf detection (batched, not per-occurrence)
  nanCount: number;           // Batch count (not per-occurrence)
  infCount: number;
  lastNanBlockId: string | null;
  lastInfBlockId: string | null;

  // Field materialization tracking
  materializationCount: number;
  heavyMaterializationBlocks: Map<string, number>;

  // Sampling state
  lastSnapshotTime: number;   // performance.now() of last snapshot
  samplingBatchStart: number; // Start of current 100ms batch
  nanBatchCount: number;      // NaN occurrences in current batch
  infBatchCount: number;
}

export function createHealthMetrics(): HealthMetrics {
  return {
    frameTimes: new Array(10).fill(0),
    frameTimesIndex: 0,
    nanCount: 0,
    infCount: 0,
    lastNanBlockId: null,
    lastInfBlockId: null,
    materializationCount: 0,
    heavyMaterializationBlocks: new Map(),
    lastSnapshotTime: 0,
    samplingBatchStart: 0,
    nanBatchCount: 0,
    infBatchCount: 0,
  };
}
```

Add `health: HealthMetrics` field to RuntimeState interface.
Update `createRuntimeState()` to initialize health metrics.

#### Step 1.2: Create HealthMonitor

**New File**: `src/runtime/HealthMonitor.ts`

**Constants**:
- `SNAPSHOT_INTERVAL_MS = 200` (5 Hz emission rate)
- `NAN_BATCH_WINDOW_MS = 100` (Aggregate NaN/Inf in 100ms batches)
- `FRAME_BUDGET_WARN_THRESHOLD = 25` (Warn if frame > 25ms)

**Functions**:
```typescript
// Record frame timing in ring buffer
export function recordFrameTime(state: RuntimeState, frameTimeMs: number): void

// Record NaN detection (batched in 100ms windows)
export function recordNaN(state: RuntimeState, blockId?: string | null): void

// Record Infinity detection (batched in 100ms windows)
export function recordInfinity(state: RuntimeState, blockId?: string | null): void

// Check if snapshot should be emitted (200ms throttle)
export function shouldEmitSnapshot(state: RuntimeState): boolean

// Generate and emit RuntimeHealthSnapshot event
export function emitHealthSnapshot(
  state: RuntimeState,
  events: EventHub,
  patchId: string,
  activePatchRevision: number,
  tMs: number
): void
```

**Diagnostic Generation**:
- P_NAN_DETECTED: When `nanCount > 0`
- P_INFINITY_DETECTED: When `infCount > 0`
- P_FRAME_BUDGET_EXCEEDED: When `worstFrameMs > 25`

See CONTEXT-20260111-100000.md for full implementation details.

#### Step 1.3: Instrument Signal Evaluator for NaN Detection

**Location**: `src/runtime/SignalEvaluator.ts` lines 23-49

Add NaN/Inf detection after `evaluateSigExpr()` call:
```typescript
const value = evaluateSigExpr(expr, signals, state);

// NaN/Inf detection (batched)
if (Number.isNaN(value)) {
  const now = performance.now();
  const h = state.health;

  // Start new batch if needed
  if (now - h.samplingBatchStart > 100) {
    if (h.nanBatchCount > 0) {
      h.nanCount++;
      h.lastNanBlockId = expr.sourceBlockId ?? null;
    }
    h.nanBatchCount = 0;
    h.samplingBatchStart = now;
  }
  h.nanBatchCount++;
}

// Similar for Infinity
if (!Number.isFinite(value) && !Number.isNaN(value)) {
  // ... same batching logic for Infinity
}
```

#### Step 1.4: Integrate into Animation Loop

**Location**: `src/main.ts` lines 211-267

After frame execution and rendering:
```typescript
const frameTime = performance.now() - frameStart;

// Record health metrics
if (currentState.health) {
  recordFrameTime(currentState, frameTime);

  // Emit health snapshot if throttle interval elapsed
  if (shouldEmitSnapshot(currentState)) {
    emitHealthSnapshot(
      currentState,
      rootStore.events,
      'patch-0',
      rootStore.patch.revision,
      tMs
    );
  }
}
```

**Acceptance Criteria**:
1. RuntimeHealthSnapshot events emit at 2-5 Hz (not per-frame)
2. NaN detection is batched: Multiple NaN in 100ms → single occurrence count
3. Frame budget diagnostic appears when worst frame > 25ms
4. DiagnosticHub receives runtime diagnostics via RuntimeHealthSnapshot
5. Runtime diagnostics show in DiagnosticConsole

---

### Deliverable 2: Bus Validation Warnings (P1)

**Estimated Effort**: 8-12 hours

**Objective**: Generate bus warnings during compilation for empty buses and buses with no publishers

**Files to Create**:
1. `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes/busValidation.ts` - Bus warning generator
2. `/Users/bmf/code/oscilla-animator-v2/src/compiler/__tests__/busValidation.test.ts` - Bus validation tests

**Files to Modify**:
1. `/Users/bmf/code/oscilla-animator-v2/src/compiler/compile.ts` (line 248) - Add bus validation pass
2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts` - Add W_BUS_EMPTY, W_BUS_NO_PUBLISHERS codes

**Implementation Steps**:

#### Step 2.1: Create Bus Validation Pass

**New File**: `src/compiler/passes/busValidation.ts`

**Functions**:
```typescript
// Count publishers and listeners for each bus
function analyzeBusUsage(patch: NormalizedPatch): Map<string, {
  publishers: number;
  listeners: number;
  publisherBlockIds: string[];
}>

// Generate bus warnings for a normalized patch
export function generateBusWarnings(
  patch: NormalizedPatch,
  patchRevision: number
): Diagnostic[]
```

**Logic**:
- Iterate through all buses in `patch.buses`
- Count publishers: edges where `edge.target.kind === 'bus'`
- Count listeners: edges where `edge.source.kind === 'bus'`
- Generate warnings:
  - W_BUS_EMPTY: `publishers > 0 && listeners === 0`
  - W_BUS_NO_PUBLISHERS: `publishers === 0 && listeners > 0`

See CONTEXT-20260111-100000.md for full implementation.

#### Step 2.2: Integrate Bus Validation into Compiler

**Location**: `src/compiler/compile.ts` line 248

After successful compilation (before CompileEnd emission):
```typescript
// Generate bus warnings (after successful compilation)
const busWarnings = generateBusWarnings(normResult.patch, options.patchRevision);

// Emit CompileEnd event (success)
const compileEndDiags = convertCompileErrorsToDiagnostics(
  errors,
  options.patchRevision
).concat(busWarnings);  // Append bus warnings

options.events.emit({
  type: 'CompileEnd',
  // ...
  diagnostics: compileEndDiags,
});
```

**IMPORTANT**: Only generate bus warnings on successful compilation (not on failure).

**Acceptance Criteria**:
1. W_BUS_EMPTY diagnostic appears when bus has publishers but no listeners
2. W_BUS_NO_PUBLISHERS diagnostic appears when bus has listeners but no publishers
3. Bus warnings appear in DiagnosticConsole after successful compilation
4. Bus warnings do NOT appear on compilation failure
5. Test coverage >80% for bus validation logic

---

### Deliverable 3 (Optional): Basic Quick Fix - createTimeRoot (P2)

**Estimated Effort**: 6-8 hours

**Objective**: Implement "Create TimeRoot" quick fix action for E_TIME_ROOT_MISSING diagnostic

**Files to Create**:
1. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/actions/quickFixes.ts` - Quick fix executors
2. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/diagnostics/DiagnosticActions.tsx` - Action UI
3. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/__tests__/quickFixes.test.ts` - Quick fix tests

**Files to Modify**:
1. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts` (line 149) - Expand DiagnosticAction interface
2. `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/validators/authoringValidators.ts` (lines 78-99) - Add actions to E_TIME_ROOT_MISSING
3. `/Users/bmf/code/oscilla-animator-v2/src/ui/components/app/DiagnosticConsole.tsx` - Integrate DiagnosticActions component

**Implementation Steps**:

#### Step 3.1: Expand DiagnosticAction Type

**Location**: `src/diagnostics/types.ts` line 149

```typescript
export interface DiagnosticAction {
  readonly id: string;
  readonly kind: 'createTimeRoot' | 'goToTarget' | 'insertBlock' | 'removeBlock';
  readonly label: string;
  readonly isPrimary?: boolean;

  readonly data?: {
    timeRootKind?: 'Infinite' | 'Finite' | 'Cycle';
    target?: TargetRef;
    blockType?: string;
    blockId?: string;
  };
}
```

#### Step 3.2: Create Quick Fix Executor

**New File**: `src/diagnostics/actions/quickFixes.ts`

```typescript
export function executeAction(
  action: DiagnosticAction,
  rootStore: RootStore
): boolean {
  switch (action.kind) {
    case 'createTimeRoot': {
      const timeRootKind = action.data?.timeRootKind ?? 'Infinite';
      const blockType = timeRootKind === 'Infinite' ? 'InfiniteTimeRoot' : 'FiniteTimeRoot';

      rootStore.patch.addBlock(blockType, {
        periodAMs: 8000,
        periodBMs: 16000,
      }, {
        role: { kind: 'timeRoot' },
        position: { x: 400, y: 300 },
      });

      return true;
    }

    case 'goToTarget':
      console.log('Navigate to:', action.data?.target);
      return true;

    default:
      return false;
  }
}
```

#### Step 3.3: Add Action to E_TIME_ROOT_MISSING Diagnostic

**Location**: `src/diagnostics/validators/authoringValidators.ts` lines 78-99

```typescript
if (timeRoots.length === 0) {
  diags.push(createDiagnostic({
    code: 'E_TIME_ROOT_MISSING',
    severity: 'error',
    domain: 'authoring',
    primaryTarget: { kind: 'graphSpan', blockIds: [] },
    title: 'No TimeRoot',
    message: 'Patch must have exactly one TimeRoot block',
    patchRevision,
    actions: [
      {
        id: 'create-time-root-infinite',
        kind: 'createTimeRoot',
        label: 'Create Infinite TimeRoot',
        isPrimary: true,
        data: { timeRootKind: 'Infinite' },
      },
      {
        id: 'create-time-root-finite',
        kind: 'createTimeRoot',
        label: 'Create Finite TimeRoot',
        isPrimary: false,
        data: { timeRootKind: 'Finite' },
      },
    ],
  }));
}
```

#### Step 3.4: UI for Actions

**New File**: `src/ui/components/diagnostics/DiagnosticActions.tsx`

```typescript
export const DiagnosticActions: React.FC<{ actions: DiagnosticAction[] }> = ({ actions }) => {
  const rootStore = useRootStore();

  const handleClick = (action: DiagnosticAction) => {
    const success = executeAction(action, rootStore);
    if (!success) {
      console.error(`Failed to execute action: ${action.id}`);
    }
  };

  return (
    <div className="diagnostic-actions">
      {actions.map(action => (
        <button
          key={action.id}
          onClick={() => handleClick(action)}
          className={action.isPrimary ? 'primary' : 'secondary'}
        >
          {action.label}
        </button>
      ))}
    </div>
  );
};
```

**Integrate in DiagnosticConsole**:
```typescript
{diag.actions && diag.actions.length > 0 && (
  <DiagnosticActions actions={diag.actions} />
)}
```

**Acceptance Criteria**:
1. E_TIME_ROOT_MISSING diagnostic includes "Create TimeRoot" action
2. Clicking action button adds InfiniteTimeRoot block to patch
3. After action executes, diagnostic disappears (authoring validators re-run)
4. Action execution is logged and can be undone
5. UI shows action buttons inline with diagnostic message

---

## Integration Points

### Files Modified (6)
1. `src/main.ts` - Integrate health monitoring in animation loop
2. `src/runtime/RuntimeState.ts` - Add HealthMetrics interface
3. `src/runtime/SignalEvaluator.ts` - NaN/Inf detection
4. `src/compiler/compile.ts` - Bus validation integration
5. `src/diagnostics/types.ts` - Expand diagnostic codes, actions
6. `src/diagnostics/validators/authoringValidators.ts` - Add actions to diagnostics

### New Files (7)
1. `src/runtime/HealthMonitor.ts` - Health snapshot generation
2. `src/compiler/passes/busValidation.ts` - Bus warning generation
3. `src/diagnostics/actions/quickFixes.ts` - Quick fix executors
4. `src/ui/components/diagnostics/DiagnosticActions.tsx` - Action UI
5. `src/diagnostics/__tests__/runtimeDiagnostics.test.ts` - Runtime tests
6. `src/compiler/__tests__/busValidation.test.ts` - Bus validation tests
7. `src/diagnostics/__tests__/quickFixes.test.ts` - Quick fix tests

---

## Diagnostic Codes Added

**Performance Diagnostics**:
- `P_NAN_DETECTED` - NaN value produced during evaluation
- `P_INFINITY_DETECTED` - Infinity value produced
- `P_FRAME_BUDGET_EXCEEDED` - Frame eval exceeded time budget

**Bus Warnings**:
- `W_BUS_EMPTY` - Bus has publishers but no listeners
- `W_BUS_NO_PUBLISHERS` - Bus has listeners but no publishers

---

## Dependencies on Sprint 1

- EventHub supports RuntimeHealthSnapshot event (already defined)
- DiagnosticHub handles RuntimeHealthSnapshot (already subscribed)
- RuntimeState exists and is accessible in main.ts
- DiagnosticCode enum can be extended
- Diagnostic interface accepts optional actions array

---

## Ambiguities Resolved

1. **NaN detection frequency**: Batched in 100ms windows (not per-occurrence)
2. **Performance thresholds**: 25ms frame budget threshold
3. **Bus warnings timing**: Only after successful compilation
4. **Health snapshot rate**: 5 Hz (200ms interval)
5. **Quick fix scope**: createTimeRoot only for Sprint 2 MVP
6. **Runtime diagnostic expiry**: No TTL for Sprint 2 (persist until resolved)

---

## Testing Strategy

### Unit Tests
- HealthMonitor: NaN batching, frame timing, snapshot throttling
- busValidation: Empty bus, no publishers detection
- quickFixes: createTimeRoot execution, idempotency

### Integration Tests
- Runtime flow: NaN → snapshot → diagnostic → UI
- Bus warning flow: Compile → warnings → UI
- Quick fix flow: Click action → block added → diagnostic clears

### Performance Tests
- Health snapshot overhead: <1ms per snapshot
- NaN detection overhead: <0.01ms per signal evaluation
- Bus validation overhead: <5ms for 100-bus patch

---

## Out of Scope (Sprint 2)

Deferred to Sprint 3+:
- Advanced quick fixes (addAdapter, removeBlock, muteDiagnostic)
- UI badges on blocks/ports/buses
- Diagnostic grouping
- Muting persistence
- Field materialization tracking diagnostics
- Combine mode conflict detection
- Performance profiling (block-level timing)

---

## Success Criteria

Sprint 2 is complete when:
1. RuntimeHealthSnapshot events emit at 5 Hz during animation
2. P_NAN_DETECTED diagnostic appears when NaN occurs (batched)
3. P_FRAME_BUDGET_EXCEEDED appears when frame > 25ms
4. W_BUS_EMPTY and W_BUS_NO_PUBLISHERS appear after successful compilation
5. Optional: "Create TimeRoot" action adds block and resolves diagnostic
6. All new code has >80% test coverage
7. All existing tests pass (303/303 baseline)
8. Integration tests pass for runtime and bus warning flows
9. No regressions in animation loop performance (<1% overhead)

---

## Implementation Order

1. **Day 1-2**: Runtime health infrastructure (HealthMetrics, HealthMonitor)
2. **Day 2-3**: NaN/Inf detection in SignalEvaluator
3. **Day 3-4**: Animation loop integration, snapshot emission
4. **Day 4-5**: Bus validation pass (analyzeBusUsage, generateBusWarnings)
5. **Day 5-6**: Compiler integration for bus warnings
6. **Day 6-7**: Quick fix infrastructure (optional)
7. **Day 7-8**: Testing, polish, documentation

**Total Estimated Effort**: 24-32 hours (P0+P1), 30-40 hours (P0+P1+P2)
