# Diagnostics System Evaluation

## Executive Summary

The Diagnostics System is **partially implemented** with significant gaps between specification and reality:

| Component | Status | Completeness |
|-----------|--------|--------------|
| **DiagnosticsStore** | BASIC | ~20% - Only basic error/warning/log tracking, no spec structure |
| **DiagnosticHub (Event Integration)** | MISSING | 0% - No event subscription mechanism |
| **EventHub** | MISSING | 0% - No centralized event bus exists |
| **Diagnostic Codes (30+ codes)** | MISSING | 0% - Not defined anywhere |
| **TargetRef (Discriminated Union)** | MISSING | 0% - No target addressing system |
| **Compiler Integration** | PARTIAL | ~30% - CompileError exists but doesn't map to Diagnostics |
| **Runtime Diagnostics** | MISSING | 0% - No NaN/performance monitoring |
| **Authoring Validators** | MISSING | 0% - No fast synchronous validators |
| **UI Components** | MINIMAL | ~10% - LogPanel only, no diagnostic console |
| **Muting/Lifecycle** | MISSING | 0% - No diagnostic lifecycle management |

---

## What Exists Currently

### 1. DiagnosticsStore (`src/stores/DiagnosticsStore.ts`)
- Simple error/warning/log tracking with sequential IDs
- **Critical Issues**:
  - No `code`, `severity`, or `domain` fields
  - No `primaryTarget` or `TargetRef` system
  - No `scope` (patchRevision, compileId, runtimeSessionId)
  - No `metadata` (occurrence count, firstSeenAt, lastSeenAt)
  - No deduplication, muting, or lifecycle management
  - Conflates diagnostics with logs

### 2. Compiler Error System (`src/compiler/types.ts`)
- Has `CompileError` interface and basic error codes
- **Issues**:
  - No conversion to `Diagnostic` structure
  - Error codes don't match spec (e.g., `TypeMismatch` vs `E_TYPE_MISMATCH`)
  - No bus warning generation after compilation
  - Not wired to event emissions

### 3. Event System
- **Completely absent**: No EventHub, no event types, no coordination mechanism
- MobX reactions exist in stores but no centralized event spine

### 4. Type System
- `BlockId`, `PortId` branded types exist
- **Missing**: `TargetRef` discriminated union (required by spec with 7 kinds)
- **Missing**: `BusId` branded type

---

## Critical Gaps

### Gap 1: Diagnostic Codes (30+ required by spec)
Not defined anywhere. Spec requires codes organized as:
- **E_** (errors): `E_TIME_ROOT_MISSING`, `E_TYPE_MISMATCH`, `E_CYCLE_DETECTED`, etc.
- **W_** (warnings): `W_BUS_EMPTY`, `W_GRAPH_DISCONNECTED_BLOCK`, etc.
- **I_** (info): `I_SILENT_VALUE_USED`, `I_DEPRECATED_PRIMITIVE`, etc.
- **P_** (performance): `P_NAN_DETECTED`, `P_FRAME_BUDGET_EXCEEDED`, etc.

### Gap 2: DiagnosticHub (State Manager)
Missing entire class required by spec:
```typescript
class DiagnosticHub {
  private compileSnapshots = new Map<number, Diagnostic[]>();
  private authoringSnapshot: Diagnostic[] = [];
  private runtimeDiagnostics: Map<string, Diagnostic> = new Map();
  private activeRevision: number = 0;
  private pendingCompileRevision: number | null = null;
  private mutedDiagnostics: Set<string> = new Set();
  // Plus 10+ query methods
}
```

**Impact**: Cannot maintain separate compile/authoring/runtime scopes, cannot deduplicate, cannot implement muting.

### Gap 3: EventHub (Event Bus)
Completely absent. Spec requires typed discriminated-union event bus for coordination:
- No `EventHub` class with `on<E>()` / `emit<E>()`
- No `EditorEvent` union type
- No event definitions for: `GraphCommitted`, `CompileBegin`, `CompileEnd`, `ProgramSwapped`, `RuntimeHealthSnapshot`

**Impact**: No coordination between stores, no event-driven architecture, DiagnosticHub cannot listen to compilation/runtime.

### Gap 4: TargetRef Discriminated Union
Required by spec with 7 kinds:
```typescript
type TargetRef =
  | { kind: 'block'; blockId: string }
  | { kind: 'port'; blockId: string; portId: string }
  | { kind: 'bus'; busId: string }
  | { kind: 'binding'; bindingId: string; busId: string; blockId: string; direction: 'publish' | 'subscribe' }
  | { kind: 'timeRoot'; blockId: string }
  | { kind: 'graphSpan'; blockIds: string[]; spanKind?: 'cycle' | 'island' | 'subgraph' }
  | { kind: 'composite'; compositeDefId: string; instanceId?: string };
```

**Currently**: Completely missing. No way to address targets in diagnostics.

### Gap 5: Stable Diagnostic ID Generation
Spec requires hash-based stable IDs:
```typescript
function generateDiagnosticId(
  code: DiagnosticCode,
  primaryTarget: TargetRef,
  patchRevision: number,
  signature?: string
): string {
  const targetStr = serializeTargetRef(primaryTarget);
  return `${code}:${targetStr}:rev${patchRevision}${signature ? `:${signature}` : ''}`;
}
```

**Currently**: Simple sequential counter (`error-0`, `error-1`). Deduplication impossible.

### Gap 6: Five-Event Integration Contract
DiagnosticHub must subscribe to exactly five events:

| Event | Action |
|-------|--------|
| `GraphCommitted` | Run authoring validators, update authoring snapshot |
| `CompileBegin` | Mark revision as "pending compile" |
| `CompileEnd` | **Replace** compile snapshot (full replacement, not merge) |
| `ProgramSwapped` | Set active revision pointer for runtime diagnostics |
| `RuntimeHealthSnapshot` | Update/merge runtime diagnostics |

**Currently**: Completely missing. No event subscriptions, no validator triggering.

### Gap 7: Authoring Validators
Required fast, synchronous validators on `GraphCommitted` event:
- Missing TimeRoot
- Multiple TimeRoots
- Disconnected blocks (no path to TimeRoot)
- Empty buses (publishers but no listeners)
- Unbound inputs using silent values

**Currently**: Zero authoring feedback except console errors. No real-time validation.

### Gap 8: Runtime Diagnostics
Runtime should emit `RuntimeHealthSnapshot` events (2-5 Hz) with:
- NaN/Infinity detection
- Field materialization tracking
- Frame budget metrics (fps, avg/worst frame time)
- Diagnostic deltas (raised/resolved)

**Currently**: Runtime exists but doesn't emit these events, no performance monitoring, no NaN detection.

### Gap 9: UI Components
Spec requires:
- **Diagnostic Console** - list view of all active diagnostics
- **Block Inspector badges** - diagnostics targeting selected block
- **Port Badges** - inline type mismatch icons
- **Bus Board warnings** - aggregated per-row badges
- **Time Console** - TimeRoot health and clock status
- **Patch Health summary** - Clean / Warnings / Errors header

**Currently**: Only LogPanel exists. No diagnostic console, no badges, no integration.

---

## Critical Ambiguities & Open Questions

### 1. Diagnostic ID Stability After Edits
**Ambiguity**: When user edits patch and same error re-occurs, should it be same diagnostic ID?

Spec says (line 366): "If a patch is edited and the same error re-appears, that's a NEW diagnostic instance."

**Resolution needed**: How does this interact with muting? Should mutes clear on edit?

### 2. Compile Snapshot Replacement vs Merge
**Ambiguity**: When `CompileEnd` arrives, should compile diagnostics be replaced or merged?

Spec says (lines 107-115): "This is a **snapshot replacement**, not incremental updates... even if the previous compile had 10"

**Resolution needed**: What if user edits during compilation? Do we have multiple pending compiles per revision?

### 3. Runtime Diagnostic Expiry Window
**Ambiguity**: Spec says "time window (e.g., 10 seconds)" but exact behavior undefined.

**Resolution needed**:
- Exactly 10 seconds or configurable?
- Oldest-first or last-occurrence-first expiry?
- Does expiry trigger UI update?

### 4. Authoring Validator Performance
**Ambiguity**: Spec says "< 10ms for typical patches" but:
- What's a "typical patch" size?
- Debounced or on every keystroke?
- Fallback if validation slow?

**Resolution needed**: Define performance budget and debounce strategy.

### 5. Dual Addressing (Hard + Semantic)
**Ambiguity**: Spec mentions semantic pathRefs for resilience but implementation unclear.

**Resolution needed**:
- Is pathRef required or optional in TargetRef?
- How is path resolution implemented?
- Performance implications?

### 6. Diagnostic Grouping in UI
**Ambiguity**: Spec mentions groupKey but doesn't specify full contract.

Spec shows example: `groupKey = '${code}:${busId}'`

**Resolution needed**:
- Should DiagnosticHub compute groupKey?
- UI collapsible groups or tabs?

### 7. Muting Persistence
**Ambiguity**: Should muted diagnostics persist across sessions?

Spec says (lines 569-580): "Mute is per-diagnostic-id and per-patch"

**Resolution needed**:
- Stored in patch file or local preference?
- How is "edited the bus" detected to clear mute?
- Cross-patch broadcast of muting?

### 8. Multiple Patch Instances
**Ambiguity**: How do diagnostics work with multiple patches open?

Spec says (line 73): "EventHub owned by top-level store, not global singleton"

**Resolution needed**:
- Each patch has own DiagnosticHub?
- Cross-patch diagnostics possible?
- Active revision tracking per patch?

### 9. Action Determinism & Idempotency
**Ambiguity**: Actions must be "deterministic" but error handling unclear.

**Resolution needed**:
- What if InsertBlock action replayed but block exists?
- Should actions be idempotent?
- Undo/redo interaction model?

### 10. Diagnostic Payload Extensibility
**Ambiguity**: Spec defines 5 payload kinds but extension strategy unclear.

**Resolution needed**:
- Union intentionally closed or allow generic fallback?
- How do new diagnostic types add payload?

---

## What Needs Changes (By Component)

### Types & Enums
- **CREATE**: `TargetRef` discriminated union (7 kinds)
- **CREATE**: `DiagnosticCode` enum (30+ codes)
- **CREATE**: `Severity` enum (hint/info/warn/error/fatal)
- **CREATE**: `Domain` enum (authoring/compile/runtime/perf)
- **CREATE**: Full `Diagnostic` interface (per spec lines 297-333)
- **CREATE**: `DiagnosticAction` union type
- **CREATE**: `DiagnosticPayload` union type
- **CREATE**: `serializeTargetRef()` function

### Event System (NEW)
- **CREATE**: `src/events/EventHub.ts` - Typed event bus
- **CREATE**: `src/events/EditorEvent.ts` - 25+ event types
- **CREATE**: Event interfaces for: `GraphCommitted`, `CompileBegin`, `CompileEnd`, `ProgramSwapped`, `RuntimeHealthSnapshot`
- **WIRE**: EventHub into RootStore

### Compiler Integration
- **MODIFY**: `src/compiler/compile.ts` - Emit CompileBegin/CompileEnd
- **CREATE**: `src/compiler/DiagnosticConverter.ts` - Error→Diagnostic conversion
- **CREATE**: Bus warning generator after successful compilation

### DiagnosticsStore → DiagnosticHub
- **REWRITE**: Separate from logs
- **IMPLEMENT**: Three snapshot maps (compile/authoring/runtime)
- **IMPLEMENT**: Muting state
- **IMPLEMENT**: Subscribe to five core events
- **IMPLEMENT**: Query methods per spec

### Authoring Validators
- **CREATE**: Fast synchronous validators for graph validation
- **WIRE**: To `GraphCommitted` event

### Runtime Integration
- **MODIFY**: Signal evaluator - Add NaN/Infinity detection
- **MODIFY**: Materializer - Track field materialization counts
- **MODIFY**: ScheduleExecutor - Track frame budget
- **CREATE**: HealthMonitor - Emit RuntimeHealthSnapshot (2-5 Hz)

### UI Components
- **REWRITE**: LogPanel → DiagnosticConsole with filtering
- **CREATE**: DiagnosticRow component
- **CREATE**: DiagnosticActions component
- **MODIFY**: BlockInspector - Add diagnostic badges
- **MODIFY**: TableView - Add bus board warnings

---

## Dependencies & Critical Path

1. **EventHub first** (blocks all downstream)
2. **TargetRef + DiagnosticCode types**
3. **DiagnosticHub state manager**
4. **Compiler integration** (error→diagnostic conversion)
5. **Authoring validators** (immediate feedback)
6. **Runtime integration** (performance monitoring)
7. **UI components** (user-facing elements)
8. **Polish** (muting, grouping, actions)

---

## Risks

| Risk | Severity | Description | Mitigation |
|------|----------|-------------|-----------|
| EventHub reentrancy | HIGH | Handlers mutating state → circular emissions | Enforce handlers only queue state changes |
| Compile diagnostic races | HIGH | Edit during compilation → which revision? | Use compileId + patchRevision to disambiguate |
| Runtime snapshot rate | MEDIUM | Slow runtimes miss snapshots; diagnostics expire | Configurable window; log misses |
| Authoring validator perf | MEDIUM | Large patches exceed 10ms budget | Profile; async-defer if needed |
| Muting state loss | LOW | Preferences lost on reload | Persist to patch metadata or preference file |

---

## Test Coverage Requirements

1. **Diagnostic ID Stability** - Same error → same ID; different patch → different ID
2. **Compile Snapshot Replacement** - CompileEnd replaces (not merges); removed diags disappear
3. **Authoring Validator Timing** - Runs < 10ms; synchronous; on GraphCommitted
4. **Runtime Aggregation** - NaN count increments; occurrence updates; expiry works
5. **Muting** - Muted diags hidden; per ID; clears on edit
6. **Event Ordering** - GraphCommitted→validators; CompileBegin→pending; CompileEnd→replace; etc.

---

## Summary: Spec Compliance

| Feature | Spec | Impl | Priority |
|---------|------|------|----------|
| Diagnostic Codes | YES | NO | P0 |
| TargetRef | YES | NO | P0 |
| DiagnosticHub | YES | NO | P0 |
| EventHub | YES | NO | P0 |
| Five-Event Integration | YES | NO | P0 |
| Stable IDs | YES | NO | P0 |
| Compiler Error→Diag | YES | NO | P1 |
| Authoring Validators | YES | NO | P1 |
| Runtime Diagnostics | YES | NO | P1 |
| Bus Warnings | YES | NO | P1 |
| UI Console | YES | PARTIAL | P2 |
| Muting | YES | NO | P2 |
| Port Badges | YES | NO | P2 |
| Diagnostic Grouping | YES | NO | P2 |

**Estimated effort**: 80-120 engineering hours for full implementation across all P0-P2 priorities.
