# Diagnostics System: Gap Analysis & Ambiguity Resolutions

## Ambiguity Resolutions

### 1. Muting Behavior
**Decision**: **Remove muting for errors entirely**
- Errors are errors and must be shown in the console
- Only warnings/hints might be dismissible (deferred to future work)
- Simplifies implementation significantly

### 2. Compile Race Conditions
**Decision**: **Whichever is simplest to implement** (user is not concerned)
- Recommendation: Queue next compile (let current finish, then start new one)
- Avoids mid-compile cancellation complexity
- Brief display of stale diagnostics is acceptable

### 3. Runtime Diagnostic Expiry
**Decision**: **Configurable time/count-based, no expiry by default**
- Add `expiryMode: 'time' | 'count' | 'none'` config
- When `time`: configurable window (default 10s)
- When `count`: configurable max occurrences (default 100)
- When `none`: diagnostics persist until resolved
- Default to `none` for initial implementation

### 4. Authoring Validator Timing
**Decision**: **Immediate, no debounce**
- Run validators synchronously on every `GraphCommitted` event
- Spec requires <10ms budget for typical patches
- Instant feedback is priority

### 5. TargetRef Dual Addressing
**Decision**: **Hard IDs only, no semantic paths**
- All identities (blockId, portId, busId) must remain stable across graph rewrites
- Instability of references will be treated as a core bug
- No need for optional semantic pathRefs
- Simplifies implementation

### 6. Multiple Patches Open
**Decision**: **One DiagnosticHub per RootStore**
- Each patch gets its own DiagnosticHub and EventHub
- Clean isolation between patches
- Simpler reasoning about scope and lifecycle

### 7. Diagnostic Action Idempotency
**Decision**: **Yes, actions must be idempotent**
- Replaying an action is safe (e.g., 'insert adapter' checks if already exists)
- Enables undo/redo and safe retry
- Better error recovery

## Simplified Scope for Sprint 1

Based on resolutions, we can defer:
- **Muting UI/state** - Not needed for errors
- **Semantic path resolution** - IDs are stable
- **Multi-patch coordination** - Each store independent
- **Complex expiry logic** - Default to no expiry

This significantly reduces Sprint 1 complexity.

## Priority Adjustments

### Must Have (P0) - Sprint 1
1. Core types (TargetRef, Diagnostic, DiagnosticCode, Severity, Domain)
2. EventHub foundation (5 core events)
3. DiagnosticHub with compile/authoring/runtime snapshot management
4. Stable ID generation
5. Compiler integration (CompileBegin/CompileEnd events, error→diagnostic conversion)

### Should Have (P1) - Sprint 1 if time permits
6. Basic authoring validators (TimeRoot missing, disconnected blocks)
7. Diagnostic console UI (list view with filtering)
8. CompileError→Diagnostic conversion

### Nice to Have (P2) - Sprint 2+
9. Runtime diagnostics (NaN detection, performance monitoring)
10. Bus warnings (empty buses, no publishers)
11. Diagnostic actions/quick fixes
12. UI badges (block inspector, port badges, bus board)
13. Grouping and advanced UI features

## Core Architectural Decisions

### EventHub Design
- Typed event bus with discriminated union of all event types
- Single hub per RootStore (not global singleton)
- Type-safe `on<E>()` and `emit<E>()` methods
- No reentrancy protection needed initially (handlers are simple state updates)

### DiagnosticHub State Model
```typescript
class DiagnosticHub {
  // Three separate snapshot stores
  private compileSnapshots = new Map<number, Diagnostic[]>();
  private authoringSnapshot: Diagnostic[] = [];
  private runtimeDiagnostics: Map<string, Diagnostic> = new Map();

  // Active revision tracking
  private activeRevision: number = 0;
  private pendingCompileRevision: number | null = null;

  // No muting state needed (removed from scope)

  // Query methods
  getAll(filters?: DiagnosticFilter): Diagnostic[]
  getByRevision(rev: number): Diagnostic[]
  getActive(): Diagnostic[]
  // ...
}
```

### Diagnostic ID Stability
```typescript
// Format: CODE:targetStr:revN
// Example: E_TYPE_MISMATCH:port-b1:p2:rev42
function generateDiagnosticId(
  code: DiagnosticCode,
  primaryTarget: TargetRef,
  patchRevision: number
): string {
  const targetStr = serializeTargetRef(primaryTarget);
  return `${code}:${targetStr}:rev${patchRevision}`;
}
```

### Five-Event Contract
| Event | DiagnosticHub Action |
|-------|---------------------|
| `GraphCommitted` | Run authoring validators → update authoringSnapshot |
| `CompileBegin` | Set pendingCompileRevision |
| `CompileEnd` | **Replace** compile snapshot for that revision |
| `ProgramSwapped` | Set activeRevision pointer |
| `RuntimeHealthSnapshot` | Merge runtime diagnostics (update counts) |

## Implementation Sequence

### Phase 1: Foundation (Must have for compilation diagnostics)
1. Create type definitions (`TargetRef`, `Diagnostic`, codes, etc.)
2. Implement EventHub with 5 core event types
3. Create DiagnosticHub with snapshot management
4. Wire EventHub into RootStore

### Phase 2: Compiler Integration (Makes diagnostics visible)
5. Add CompileBegin/CompileEnd emission to compiler
6. Implement CompileError→Diagnostic conversion
7. Wire compiler to emit events

### Phase 3: UI Display (User-visible feedback)
8. Create basic DiagnosticConsole component
9. Wire DiagnosticHub to MobX observable
10. Display active diagnostics in UI

### Phase 4: Authoring Validators (Immediate feedback)
11. Implement fast graph validators
12. Wire validators to GraphCommitted event
13. Add authoring diagnostics to UI

### Phase 5: Polish (Future)
- Runtime diagnostics
- Bus warnings
- Quick fix actions
- UI badges and grouping

## Files to Create

### Core Types
- `src/diagnostics/types.ts` - TargetRef, Diagnostic, codes, enums
- `src/diagnostics/diagnosticId.ts` - Stable ID generation

### Event System
- `src/events/EventHub.ts` - Event bus implementation
- `src/events/EditorEvent.ts` - Event type definitions

### Diagnostic Management
- `src/diagnostics/DiagnosticHub.ts` - State manager
- `src/diagnostics/DiagnosticStore.ts` - MobX wrapper (or replace existing)

### Compiler Integration
- `src/compiler/diagnosticConversion.ts` - Error→Diagnostic converter
- Modify `src/compiler/compile.ts` - Add event emissions

### Validators
- `src/diagnostics/validators/authoringValidators.ts` - Fast graph checks

### UI
- `src/ui/react/DiagnosticConsole.tsx` - Main console component
- `src/ui/react/DiagnosticRow.tsx` - Single diagnostic display
- `src/ui/react/DiagnosticFilters.tsx` - Filtering controls

## Success Criteria

Sprint 1 is successful if:
1. ✅ Compiler errors appear as structured diagnostics
2. ✅ Diagnostics have stable IDs and proper targets
3. ✅ UI shows diagnostic console with severity filtering
4. ✅ GraphCommitted events trigger authoring validation
5. ✅ Each event in five-event contract is emitted correctly
6. ✅ Diagnostics survive across compilations (via snapshot replacement)
7. ✅ Type safety: impossible to create invalid TargetRef or Diagnostic

## Out of Scope (Sprint 1)

Explicitly deferred:
- Runtime diagnostics (NaN detection, performance monitoring)
- Bus warnings
- Diagnostic actions/quick fixes
- UI badges on blocks/ports/buses
- Diagnostic grouping
- Export-specific diagnostics
- Muting (removed from spec based on user input)
- Semantic path resolution (IDs are stable)
- Cross-patch diagnostic coordination
