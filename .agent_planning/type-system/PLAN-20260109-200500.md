# Sprint Plan: Type System P4 - Runtime Migration

**Generated**: 2026-01-09T20:05:00Z
**Topic**: type-system
**Evaluation**: EVALUATION-20260109-200000.md

---

## Sprint Goal

Integrate SignalType metadata into runtime infrastructure, enabling type-safe slot addressing and preparing for P5 constraint solving.

---

## Scope

**In scope (this sprint):**
1. SlotMeta population with SignalType axes
2. Runtime type assertions (debug mode)
3. TypeDesc ↔ SignalType adapter function

**Explicitly out of scope (future sprints):**
- P5: Cardinality inference algorithm
- P5: Temporality compatibility checking
- P5: Domain alignment validation
- P6: Bus system migration
- P6: Combine mode validation
- Performance optimization of hot paths

---

## Work Items

### P0: TypeDesc ↔ SignalType Adapter

**Acceptance Criteria:**
- [ ] Create `typeDescToSignalType()` function in `src/core/types.ts`
- [ ] Create `signalTypeToTypeDesc()` function for backward compatibility
- [ ] Map: `world='signal'` → `cardinality=one, temporality=continuous`
- [ ] Map: `world='field'` → `cardinality=many(domain), temporality=continuous`
- [ ] Map: `world='event'` → `cardinality=one/many, temporality=discrete`
- [ ] Map: `world='scalar'/'config'` → `cardinality=zero, temporality=continuous`
- [ ] Unit tests for all world→axes mappings

**Technical Notes:**
- Use existing `worldToAxes()` in canonical-types.ts as reference
- Adapter allows gradual migration; both systems work during transition
- Preserve domain information during conversion

### P1: SlotMeta Type Metadata

**Acceptance Criteria:**
- [ ] Extend `SlotMetaEntry` interface to include `type: SignalType`
- [ ] IR builder populates slotMeta with axes from expression types
- [ ] All SigExpr/FieldExpr in IR have complete type info
- [ ] Slot metadata accessible at runtime via index lookup
- [ ] No string-keyed lookups in hot path

**Technical Notes:**
- Modify `src/compiler/ir/program.ts` (CompiledProgramIR)
- Modify `src/compiler/ir/builder.ts` (IRBuilder)
- Cache slot→type mapping in RuntimeState during initialization

### P2: Runtime Type Assertions

**Acceptance Criteria:**
- [ ] Add `DEBUG_TYPE_CHECK` flag for assertion mode
- [ ] Assert payload type matches buffer format during allocation
- [ ] Assert cardinality consistency at combine points (debug only)
- [ ] Assertions compile out in production builds
- [ ] Clear error messages with slot ID and expected vs actual type

**Technical Notes:**
- Modify `src/runtime/SignalEvaluator.ts`
- Modify `src/runtime/Materializer.ts`
- Use `process.env.NODE_ENV` or build-time flag
- Performance: Zero overhead when assertions disabled

---

## Dependencies

- P0-P3 canonical-types.ts (EXISTS, complete)
- 25 blocks already use SignalType (migration complete)
- 68 existing tests must continue passing

---

## Risks

| Risk | Mitigation |
|------|------------|
| TypeDesc→SignalType lossy mapping | Document edge cases; throw on unmappable types |
| Runtime performance regression | Assertions disabled in prod; profile before/after |
| Backward compatibility break | Keep both systems; test all 68 existing tests |
| slotMeta size increase | Measure; consider lazy population if significant |

---

## Verification

```bash
# Must pass before sprint complete
npm run typecheck        # 0 errors
npm run test             # 68+ tests pass
npm run build            # Clean build
```

### New Tests Required
- `src/core/__tests__/type-adapter.test.ts` - Adapter function tests
- `src/compiler/ir/__tests__/slotMeta.test.ts` - SlotMeta population tests
- `src/runtime/__tests__/type-assertions.test.ts` - Runtime assertion tests

---

## Exit Criteria

Sprint is complete when:
1. All acceptance criteria marked complete
2. 68+ existing tests pass
3. New tests for adapter, slotMeta, and assertions pass
4. Typecheck clean
5. No regression in steel-thread demo (visual output unchanged)
