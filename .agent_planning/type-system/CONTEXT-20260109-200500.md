# Implementation Context: Type System P4 - Runtime Migration

**Generated**: 2026-01-09T20:05:00Z
**Purpose**: Complete context for write-only agent implementation

---

## Key Files

### Primary Source of Truth
- **Spec**: `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/01-type-system.md`
- **Canonical Types**: `src/core/canonical-types.ts` (583 lines, complete)

### Files to Modify

#### `src/core/types.ts` (P0: Adapter)
Current state: Contains old TypeDesc definition
```typescript
// Lines ~10-30 - TypeDesc interface
export interface TypeDesc {
  world: 'signal' | 'event' | 'field' | 'scalar' | 'config';
  domain: string;
  category: 'render' | 'sound' | 'control';
  busEligible?: boolean;
  lanes?: number;
}
```
Add after TypeDesc:
```typescript
import { CanonicalType, signalTypeSignal, signalTypeField, signalTypeTrigger, signalTypeStatic, domainRef, axisInstantiated, cardinalityMany, cardinalityOne, cardinalityZero, temporalityContinuous, temporalityDiscrete, extent } from './canonical-types';

export function typeDescToSignalType(td: TypeDesc): CanonicalType {
  switch (td.world) {
    case 'signal':
      return signalTypeSignal(td.domain as PayloadType);
    case 'field':
      // td.domain contains both payload AND domain ID in old system
      // Need to parse or use default domain
      return signalTypeField(td.domain as PayloadType, 'default');
    case 'event':
      return signalTypeTrigger(td.domain as PayloadType);
    case 'scalar':
    case 'config':
      return signalTypeStatic(td.domain as PayloadType);
  }
}

export function signalTypeToTypeDesc(st: CanonicalType): TypeDesc {
  const card = st.extent.cardinality;
  const temp = st.extent.temporality;

  // Determine world from axes
  let world: TypeDesc['world'];
  if (card.kind === 'instantiated' && card.value.kind === 'zero') {
    world = 'scalar';
  } else if (card.kind === 'instantiated' && card.value.kind === 'many') {
    world = 'field';
  } else if (temp.kind === 'instantiated' && temp.value.kind === 'discrete') {
    world = 'event';
  } else {
    world = 'signal';
  }

  return {
    world,
    domain: st.payload,
    category: 'render', // default; could be inferred from context
  };
}
```

#### `src/compiler/ir/program.ts` (P1: SlotMeta)
Current state: SlotMetaEntry exists but may lack type
```typescript
// Find interface SlotMetaEntry (around line 50-70)
export interface SlotMetaEntry {
  slot: ValueSlot;
  storage: 'f64' | 'f32' | 'i32' | 'u32' | 'object';
  offset: number;
  // ADD THIS:
  type: CanonicalType;  // NEW: full 5-axis type coordinate
}
```
Import at top:
```typescript
import { CanonicalType } from '../../core/canonical-types';
```

#### `src/compiler/ir/builder.ts` (P1: Populate slotMeta)
Current state: IRBuilder creates expressions but may not populate slotMeta.type

Find where slotMeta entries are created (search for `slotMeta.push` or similar).
Add type population:
```typescript
// When creating a slot entry:
slotMeta.push({
  slot: newSlot,
  storage: storageForPayload(expr.type.payload),
  offset: currentOffset,
  type: expr.type,  // NEW: preserve full CanonicalType
});
```

#### `src/runtime/RuntimeState.ts` (P1: Cache type lookup)
Current state: RuntimeState manages value slots
```typescript
// Add type cache for O(1) lookup
export class RuntimeState {
  // Existing fields...
  private slotTypes: CanonicalType[] = [];  // NEW: indexed by slot number

  initFromProgram(program: CompiledProgramIR): void {
    // Existing init...

    // NEW: Cache slot types
    this.slotTypes = program.slotMeta.map(entry => entry.type);
  }

  getSlotType(slot: ValueSlot): CanonicalType {
    return this.slotTypes[slot];
  }
}
```

#### `src/runtime/SignalEvaluator.ts` (P2: Assertions)
Current state: evaluateSignal() returns number without type checking
```typescript
// At top of file
const DEBUG_TYPE_CHECK = process.env.NODE_ENV !== 'production';

// In evaluateSigExpr or similar:
if (DEBUG_TYPE_CHECK) {
  assertTypeConsistency(expr, result, state);
}

function assertTypeConsistency(
  expr: SigExpr,
  result: number,
  state: RuntimeState
): void {
  const expected = expr.type;
  // Validate payload type makes sense for result
  // Validate cardinality matches evaluation context
  if (expected.extent.cardinality.kind === 'instantiated') {
    const card = expected.extent.cardinality.value;
    if (card.kind === 'many') {
      throw new Error(
        `Type assertion failed: expected many(${card.domain.id}) ` +
        `but evaluated as single value for expr ${JSON.stringify(expr)}`
      );
    }
  }
}
```

#### `src/runtime/Materializer.ts` (P2: Buffer assertions)
Current state: materialize() creates typed arrays
```typescript
// In materialize() or fillBuffer():
if (DEBUG_TYPE_CHECK) {
  const expectedFormat = payloadToBufferFormat(expr.type.payload);
  if (buffer.format !== expectedFormat) {
    throw new Error(
      `Buffer format mismatch: expected ${expectedFormat} ` +
      `for payload ${expr.type.payload}, got ${buffer.format}`
    );
  }
}

function payloadToBufferFormat(payload: PayloadType): BufferFormat {
  switch (payload) {
    case 'float':
    case 'phase':
    case 'unit':
      return 'f32';
    case 'int':
      return 'i32';
    case 'vec2':
      return 'f32'; // 2 elements
    case 'color':
      return 'f32'; // 4 elements
    case 'bool':
      return 'u8';
  }
}
```

---

## World â†’ Axes Mapping Reference

From `canonical-types.ts` line 498-528:
```typescript
export function worldToAxes(
  world: 'static' | 'scalar' | 'signal' | 'field' | 'event',
  domainId?: DomainId
): { cardinality: Cardinality; temporality: Temporality } {
  switch (world) {
    case 'static':
    case 'scalar':
      return {
        cardinality: cardinalityZero(),
        temporality: temporalityContinuous(),
      };
    case 'signal':
      return {
        cardinality: cardinalityOne(),
        temporality: temporalityContinuous(),
      };
    case 'field':
      if (!domainId) throw new Error('field world requires domainId');
      return {
        cardinality: cardinalityMany(domainRef(domainId)),
        temporality: temporalityContinuous(),
      };
    case 'event':
      return {
        cardinality: domainId ? cardinalityMany(domainRef(domainId)) : cardinalityOne(),
        temporality: temporalityDiscrete(),
      };
  }
}
```

---

## Test File Templates

### `src/core/__tests__/type-adapter.test.ts`
```typescript
import { describe, it, expect } from 'vitest';
import { typeDescToSignalType, signalTypeToTypeDesc, TypeDesc } from '../types';
import { PayloadType } from '../canonical-types';

describe('typeDescToSignalType', () => {
  it('maps signal world to one+continuous', () => {
    const td: TypeDesc = { world: 'signal', domain: 'float', category: 'render' };
    const st = typeDescToSignalType(td);
    expect(st.payload).toBe('float');
    expect(st.extent.cardinality).toEqual({ kind: 'instantiated', value: { kind: 'one' } });
    expect(st.extent.temporality).toEqual({ kind: 'instantiated', value: { kind: 'continuous' } });
  });

  it('maps field world to many+continuous', () => {
    const td: TypeDesc = { world: 'field', domain: 'float', category: 'render' };
    const st = typeDescToSignalType(td);
    expect(st.extent.cardinality.kind).toBe('instantiated');
    // cardinality.value.kind should be 'many'
  });

  it('maps event world to discrete temporality', () => {
    const td: TypeDesc = { world: 'event', domain: 'float', category: 'render' };
    const st = typeDescToSignalType(td);
    expect(st.extent.temporality).toEqual({ kind: 'instantiated', value: { kind: 'discrete' } });
  });

  it('maps scalar world to zero cardinality', () => {
    const td: TypeDesc = { world: 'scalar', domain: 'float', category: 'render' };
    const st = typeDescToSignalType(td);
    expect(st.extent.cardinality).toEqual({ kind: 'instantiated', value: { kind: 'zero' } });
  });
});

describe('signalTypeToTypeDesc', () => {
  it('round-trips signal world', () => {
    const td: TypeDesc = { world: 'signal', domain: 'float', category: 'render' };
    const st = typeDescToSignalType(td);
    const back = signalTypeToTypeDesc(st);
    expect(back.world).toBe('signal');
    expect(back.domain).toBe('float');
  });
});
```

### `src/compiler/ir/__tests__/slotMeta.test.ts`
```typescript
import { describe, it, expect } from 'vitest';
import { IRBuilder } from '../builder';
import { signalTypeSignal } from '../../../core/canonical-types';

describe('SlotMeta type population', () => {
  it('populates type from expression', () => {
    const builder = new IRBuilder();
    const expr = builder.constant(1.0, signalTypeSignal('float'));
    const program = builder.build();

    const slotEntry = program.slotMeta.find(e => e.slot === expr.slot);
    expect(slotEntry).toBeDefined();
    expect(slotEntry!.type.payload).toBe('float');
  });
});
```

---

## Invariants to Preserve

From `design-docs/CANONICAL-oscilla-v2.5-20260109/INVARIANTS.md`:
- **I8**: Slot-addressed execution - no runtime lookups by string
- **I10**: Editor declares bus type - types come from declarations
- **I22**: Safe modulation ranges - type checking at compile time

---

## Success Verification

```bash
# Run these after implementation:
npm run typecheck        # Must exit 0
npm run test             # Must show 68+ tests pass
npm run build            # Must succeed
npm run dev              # Visual verification: particles render at 60 FPS
```
