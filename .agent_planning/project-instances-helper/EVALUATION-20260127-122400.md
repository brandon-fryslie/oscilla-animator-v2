# Evaluation: Extract projectInstances + depthSortAndCompact Pattern into Reusable Helper

**Date:** 2026-01-27 12:24:00  
**Status:** Analysis Complete  
**Duplications Found:** Medium (2 production sites + 3 test sites)  
**Extraction Feasibility:** High  
**Risk Level:** Low-Medium  

---

## Executive Summary

The `projectInstances` + `depthSortAndCompact` pattern appears in **5 distinct locations**:

1. **2 Production Sites (RenderAssembler.ts)**
   - `assemblePerInstanceShapes()` - Line 780, then line 826 (compact)
   - `assembleDrawPathInstancesOp()` - Line 1200, then line 1203 (compact)

2. **3 Test Sites** (level6/7/9 tests)
   - Direct usage of both functions with manual memory management

The pattern is **repeated enough to warrant extraction**, but with important caveats about API design and memory contract clarity.

---

## Section 1: Pattern Instances Found

### 1.1 Production: assemblePerInstanceShapes (Lines 780-846)

**Location:** `/Users/bmf/code/oscilla-animator-v2/src/runtime/RenderAssembler.ts:780-846`

```typescript
// Line 780
const projection = projectInstances(fullPosition, scale, count, resolved, pool);

// ... for each group ...
// Lines 803-823: Slice projection output for group
const groupProjection: ProjectionOutput = { ... };

// Lines 826-832
const compacted = depthSortAndCompact(
  groupProjection,
  group.instanceIndices.length,
  color,
  rotation,
  scale2
);

// Lines 838-846: CRITICAL - Copy compacted buffers
const compactedCopy = {
  count: compacted.count,
  screenPosition: new Float32Array(compacted.screenPosition),
  screenRadius: new Float32Array(compacted.screenRadius),
  depth: new Float32Array(compacted.depth),
  color: new Uint8ClampedArray(compacted.color),
  rotation: compacted.rotation ? new Float32Array(compacted.rotation) : undefined,
  scale2: compacted.scale2 ? new Float32Array(compacted.scale2) : undefined,
};
```

**Pattern Characteristics:**
- Calls `projectInstances()` once for full batch
- Calls `depthSortAndCompact()` for **each group** (multiple times per frame)
- **Always copies** results to avoid pooled buffer reuse issues
- Optional `rotation` and `scale2` parameters

**Context:** This is the "multi-group" path where instances are grouped by topology and each group is compacted separately.

---

### 1.2 Production: assembleDrawPathInstancesOp (Lines 1200-1218)

**Location:** `/Users/bmf/code/oscilla-animator-v2/src/runtime/RenderAssembler.ts:1200-1218`

```typescript
// Line 1200
const projection = projectInstances(positionBuffer, scale, count, context.resolvedCamera, pool);

// Line 1203
const compacted = depthSortAndCompact(projection, count, colorBuffer, rotation, scale2);

// Lines 1210-1218: Copy compacted buffers
const compactedCopy = {
  count: compacted.count,
  screenPosition: new Float32Array(compacted.screenPosition),
  screenRadius: new Float32Array(compacted.screenRadius),
  depth: new Float32Array(compacted.depth),
  color: new Uint8ClampedArray(compacted.color),
  rotation: compacted.rotation ? new Float32Array(compacted.rotation) : undefined,
  scale2: compacted.scale2 ? new Float32Array(compacted.scale2) : undefined,
};
```

**Pattern Characteristics:**
- Same as production site 1, but called **once per step** (not repeated in loop)
- "Uniform shape" path (no per-instance topology variation)
- Identical copy strategy

**Context:** This is the "single group" path for uniform shapes.

---

### 1.3-1.5 Test Sites

**level6-mode-toggle.test.ts (Lines 70, 78, 100, 106, 112)**
- Calls `projectInstances()` only (no compaction)
- Used to test projection mode consistency
- **No copy pattern needed** (test scope)

**level7-depth-culling.test.ts (Lines 66, 119, 150, 202, 229, 251, 253, 285, 315, 362, 376, 383)**
- Calls both `projectInstances()` and `depthSortAndCompact()` 
- **Varies the pattern**: sometimes projects for full batch, sometimes for subset
- **Example at line 202:**
  ```typescript
  const projection = projectInstances(positions, 0.03, N, orthoCam);
  const result = depthSortAndCompact(projection, N, color);
  ```
  No copy (test assertion scope, safe)

**level9-continuity-decoupling.test.ts (Line 281, 304)**
- Calls both functions
- No copy pattern (test scope)

---

## Section 2: Common Calling Patterns

### Pattern A: Project → Compact → Copy (Production, Most Common)

```
1. Call projectInstances(positions, radius, count, camera, pool)
   → Returns: { screenPosition, screenRadius, depth, visible }

2. Call depthSortAndCompact(projection, count, color, rotation?, scale2?)
   → Returns: compacted views into pooled buffers

3. **ALWAYS** copy all returned buffers:
   screenPosition = new Float32Array(compacted.screenPosition)
   screenRadius = new Float32Array(compacted.screenRadius)
   depth = new Float32Array(compacted.depth)
   color = new Uint8ClampedArray(compacted.color)
   rotation = compacted.rotation ? new Float32Array(...) : undefined
   scale2 = compacted.scale2 ? new Float32Array(...) : undefined
```

**Frequency:** 2x in production (lines 826-832 and 1203 in RenderAssembler)

**Risk:** If copy is forgotten, next frame corrupts data (pooled buffers are reused)

---

### Pattern B: Project → Compact → Use (Tests)

```
1. Call projectInstances(positions, radius, count, camera)
   → No pool parameter (falls back to direct allocation)

2. Call depthSortAndCompact(projection, count, color, rotation?, scale2?)
   → Returns views safe within test scope

3. Consume immediately (assert/verify) — no storage beyond assertion
```

**Frequency:** 3x in tests

**Safety:** Fine for tests, but different memory semantics than production

---

## Section 3: Duplication Analysis

### Duplication Metrics

| Metric | Value | Assessment |
|--------|-------|-----------|
| Call sites | 5 (2 prod, 3 test) | **Medium** |
| Pattern repetition | 100% identical copy logic | **High** |
| Lines of duplicated code | 8-10 lines (copy block) | **Low-Medium** |
| Lines of setup/teardown | 3-5 lines (projection call) | **Low** |
| **Total per-site duplication** | ~12 lines | **Moderate** |

### Duplication Level: **MEDIUM**

**Justification:**
- The core 8-10 line **copy block is repeated identically** in 2 production sites
- The setup pattern (call → result handling) is repeated
- However, **context differs** (single group vs. multi-group iteration)
- Tests use simplified versions (no pool, no copy)

**Risk if not extracted:** 
- Future bug fixes to copy logic require 2 edits in production
- Memory contract confusion: why do tests not copy but production does?
- Maintenance burden for new features (rotation/scale2 additions)

---

## Section 4: Current Architecture

### 4.1 projectInstances

**Definition:** `src/runtime/RenderAssembler.ts:297-348`

**Signature:**
```typescript
export function projectInstances(
  worldPositions: Float32Array,      // READ-ONLY input
  worldRadius: number,                // Uniform radius
  count: number,
  resolved: ResolvedCameraParams,    // Camera params (ortho/persp)
  pool?: BufferPool,
): ProjectionOutput
```

**Memory Contract:**
- Allocates output buffers from `pool` if provided
- Falls back to direct allocation if no pool (test mode)
- **Returns owned buffers** (pool or direct)
- Input `worldPositions` is READ-ONLY, never mutated

**Output:**
```typescript
interface ProjectionOutput {
  screenPosition: Float32Array;    // stride 2, [0,1] normalized
  screenRadius: Float32Array;       // per-instance
  depth: Float32Array;              // for sorting
  visible: Uint8Array;              // 1=visible, 0=culled
}
```

---

### 4.2 depthSortAndCompact

**Definition:** `src/runtime/RenderAssembler.ts:163-282`

**Signature:**
```typescript
export function depthSortAndCompact(
  projection: ProjectionOutput,
  count: number,
  color: Uint8ClampedArray,
  rotation?: Float32Array,
  scale2?: Float32Array,
): {
  count: number;
  screenPosition: Float32Array;
  screenRadius: Float32Array;
  depth: Float32Array;
  color: Uint8ClampedArray;
  rotation?: Float32Array;
  scale2?: Float32Array;
}
```

**Memory Contract (CRITICAL):**
- **Returns VIEWS into module-level pooled buffers** (lines 50-85)
- Valid **only until** next frame or next call to `depthSortAndCompact`
- **Callers MUST copy** for persistent storage
- Comment at lines 145-154 explicitly warns:
  ```
  // ⚠️ MEMORY CONTRACT - CRITICAL:
  // Returned buffers are VIEWS into module-level pooled storage. They are valid ONLY until:
  // - The next call to depthSortAndCompact (overwrites pooled buffers)
  // - The next frame (pooled buffers are reused)
  //
  // Callers MUST copy the returned data before storing in any persistent structure.
  ```

**Key Operations:**
1. Build visibility index (lines 184-189)
2. Check if already sorted (fast-path, lines 191-205)
3. Sort if needed (lines 208-221)
4. Compact all buffers to pooled storage (lines 223-262)
5. Return subarray views (lines 265-281)

---

### 4.3 Pooled Buffers

**Definition:** Lines 56-85 (module-level state)

```typescript
let pooledIndices: Uint32Array = new Uint32Array(INITIAL_POOL_CAPACITY);
let pooledScreenPos: Float32Array = new Float32Array(INITIAL_POOL_CAPACITY * 2);
let pooledRadius: Float32Array = new Float32Array(INITIAL_POOL_CAPACITY);
let pooledDepth: Float32Array = new Float32Array(INITIAL_POOL_CAPACITY);
let pooledColor: Uint8ClampedArray = new Uint8ClampedArray(INITIAL_POOL_CAPACITY * 4);
let pooledRotation: Float32Array = new Float32Array(INITIAL_POOL_CAPACITY);
let pooledScale2: Float32Array = new Float32Array(INITIAL_POOL_CAPACITY * 2);
```

**Lifecycle:**
- Preallocated at module load (capacity 256)
- Grow 2x when capacity exceeded (line 76)
- Reused every frame without clearing
- **Never shrink** (conservative memory strategy)

**Why pooled:** Avoid per-frame allocations in hot loop

---

### 4.4 BufferPool

**Reference:** `src/runtime/BufferPool.ts` (not examined in detail)

**Used by:** `projectInstances()` to allocate `screenPosition`, `screenRadius`, `depth` buffers

**Contract with projectInstances:**
- Optional parameter
- If provided: allocations come from pool
- If not provided: fallback to direct allocation
- Enables test compatibility (tests pass undefined)

---

## Section 5: Extraction Considerations

### 5.1 What Should the Helper Return?

**Option A: Return compacted data with automatic copy (Recommended)**

```typescript
export function projectAndCompact(
  worldPositions: Float32Array,
  worldRadius: number,
  count: number,
  color: Uint8ClampedArray,
  camera: ResolvedCameraParams,
  rotation?: Float32Array,
  scale2?: Float32Array,
  pool?: BufferPool,
): {
  count: number;
  screenPosition: Float32Array;      // OWNED copies
  screenRadius: Float32Array;        // OWNED copies
  depth: Float32Array;               // OWNED copies
  color: Uint8ClampedArray;          // OWNED copies
  rotation?: Float32Array;           // OWNED copies (if provided)
  scale2?: Float32Array;             // OWNED copies (if provided)
} {
  // 1. Project
  const projection = projectInstances(worldPositions, worldRadius, count, camera, pool);
  
  // 2. Compact & sort
  const compacted = depthSortAndCompact(projection, count, color, rotation, scale2);
  
  // 3. Copy all buffers (AUTOMATIC - caller doesn't need to remember)
  return {
    count: compacted.count,
    screenPosition: new Float32Array(compacted.screenPosition),
    screenRadius: new Float32Array(compacted.screenRadius),
    depth: new Float32Array(compacted.depth),
    color: new Uint8ClampedArray(compacted.color),
    rotation: compacted.rotation ? new Float32Array(compacted.rotation) : undefined,
    scale2: compacted.scale2 ? new Float32Array(compacted.scale2) : undefined,
  };
}
```

**Advantages:**
- **Memory safety:** Copy is automatic, eliminates common error (forgetting to copy)
- **Cleaner call sites:** Single call replaces 2 calls + copy block
- **Clear ownership:** Return values are owned by caller
- **Test-friendly:** Same semantics with or without pool

**Disadvantages:**
- Adds allocation overhead (creates 6 typed arrays per call)
- **Can't be used if caller wants pool views** (but that's a danger anyway)

---

**Option B: Return projection + compact separately (Current pattern)**

Keep both functions separate, but provide a **wrapper for common pattern**:

```typescript
export interface ProjectAndCompactInput {
  worldPositions: Float32Array;
  worldRadius: number;
  count: number;
  color: Uint8ClampedArray;
  camera: ResolvedCameraParams;
  rotation?: Float32Array;
  scale2?: Float32Array;
  pool?: BufferPool;
}

export interface ProjectAndCompactOutput {
  projection: ProjectionOutput;
  compacted: ReturnType<typeof depthSortAndCompact>;  // Views (caller must copy)
}

export function projectAndGetCompacted(input: ProjectAndCompactInput): ProjectAndCompactOutput {
  const projection = projectInstances(...);
  const compacted = depthSortAndCompact(...);
  return { projection, compacted };
}
```

**Advantages:**
- Minimal wrapping
- Caller retains control over copy strategy
- Allows projection-only use cases

**Disadvantages:**
- Doesn't solve the memory safety problem
- More wordy than Option A
- Less value-add

---

**RECOMMENDATION: Option A (Auto-copy)**

**Rationale:**
1. **Memory safety is critical** — forgetting to copy is a subtle bug
2. **Allocation cost is acceptable** — RenderAssembler is not hot-loop (called once/frame per group)
3. **Simplifies call sites** — reduces 12+ lines to 1
4. **Clear ownership semantics** — returned buffers are always owned by caller
5. **Consistent with spec** — SINGLE ENFORCER: memory safety at one boundary

---

### 5.2 Where Should the Helper Live?

**Option A: RenderAssembler.ts (same file)**
- Pro: Logical grouping with related functions
- Pro: Private helper (not exported)
- Con: RenderAssembler is already large (1294 lines)

**Option B: New file src/projection/project-and-compact.ts**
- Pro: Follows modular structure
- Pro: Clearer separation of concerns
- Con: Might be overkill for a small utility
- Con: New module for 40 lines of code

**Option C: New file src/runtime/ProjectionCompact.ts**
- Pro: Groups projection + compaction (related concepts)
- Pro: Discoverable name
- Pro: Test helpers can import from here
- Con: Another module

**RECOMMENDATION: Option A (RenderAssembler.ts, private)**

**Rationale:**
1. Helper is **internal to render assembly** — no need to export
2. Avoids micro-module explosion
3. Easy to move later if needed
4. No new public API surface to maintain

---

### 5.3 What Should It Be Named?

**Candidates:**
1. `projectAndCompact()` — Clear, concise, descriptive
2. `projectInstancesAndCompact()` — More explicit
3. `projectAndDepthSort()` — Emphasizes sorting aspect
4. `projectCompactAndSort()` — Complete description

**RECOMMENDATION: `projectAndCompact()`**

Reasoning:
- `depthSortAndCompact` already exists with "sort" in name
- This helper wraps both, so leading with `project` is most natural
- Mirrors naming of underlying functions

---

### 5.4 Export Strategy

**Current exports from RenderAssembler:**
- `projectInstances` (exported)
- `depthSortAndCompact` (exported)
- Various helper functions (exported)
- Type: `ProjectionOutput`, `ProjectionMode`, etc. (exported)

**For new helper:**
- **Export it** (callers may benefit from using it outside RenderAssembler)
- Add to `src/runtime/index.ts` if testing uses it
- Document memory contract clearly (auto-copy means no pooled views)

---

## Section 6: Risks & Mitigations

### Risk 1: Allocation Performance

**Issue:** Helper adds allocation overhead (6 typed arrays per call vs. 0 with pool views)

**Impact:** RenderAssembler hot loop could slow down

**Current Reality:**
- `assemblePerInstanceShapes` calls helper **per topology group** (already allocates)
- `assembleDrawPathInstancesOp` calls **once per frame** (not hot)
- Existing code **already copies** (so allocation is not new)

**Verdict:** No net performance change — existing code already copies

**Mitigation:** None needed; existing pattern already incurs cost

---

### Risk 2: Breaking Changes

**Issue:** Changing `depthSortAndCompact` contract (auto-copy) breaks test code

**Current Test Usage:**
```typescript
const result = depthSortAndCompact(projection, count, color);
// Tests use immediately, no storage — safe with views
```

**If we create helper:**
- Keep `depthSortAndCompact()` unchanged (returns views)
- New helper `projectAndCompact()` returns copies
- Tests can use either, no breaking change

**Verdict:** Can be non-breaking with careful design

**Mitigation:**
1. Keep original functions exported
2. New helper is additive, not replacement
3. Gradual migration of call sites

---

### Risk 3: API Design Confusion

**Issue:** Two paths for same operation:
- `projectInstances()` + `depthSortAndCompact()` (returns views, needs copy)
- `projectAndCompact()` (returns copies, automatic)

Users might be confused about which to use.

**Mitigation:**
1. Document clearly: helper is **preferred** for typical use
2. Original functions are **low-level API** for advanced use
3. Add comments explaining when each is appropriate

---

### Risk 4: Test Coverage

**Issue:** New helper needs test coverage

**Options:**
1. Test within RenderAssembler tests
2. Create dedicated test file
3. Rely on existing integration tests

**Recommended:** Option 3 (leverage existing tests)
- Existing tests in level6/7/9 already exercise projection + compaction
- If helper is correct, existing tests pass
- No new test surface area

---

## Section 7: Recommended Approach

### 7.1 Implementation Plan (Priority: LOW)

**Why LOW priority?** 
- Current code works correctly
- No bugs or performance issues
- Refactoring is pure code quality improvement

**Steps:**

1. **Create helper in RenderAssembler.ts**
   - Function name: `projectAndCompact()`
   - Signature includes world-space inputs, camera, color, optional rotation/scale2
   - Returns owned copies of all buffers
   - Mark `@internal` if not intending public API

2. **Update production call sites**
   - Replace lines 780-832 (assemblePerInstanceShapes)
   - Replace lines 1200-1218 (assembleDrawPathInstancesOp)

3. **Verify existing tests pass**
   - No test changes needed
   - Integration tests verify correctness

4. **Optional: Export and document**
   - Add to `src/runtime/index.ts` exports if helper has value beyond RenderAssembler
   - Add JSDoc with clear memory contract

5. **Code review checklist**
   - Verify copy logic is identical to original
   - Check that all buffer types are copied (including optional rotation/scale2)
   - Ensure tests still pass

---

### 7.2 Code Sketch

**Location:** Insert after `depthSortAndCompact()` definition (~line 283)

```typescript
/**
 * Project world-space instances and depth-sort/compact in one step.
 *
 * This is the high-level API combining projectInstances() + depthSortAndCompact().
 * Returns OWNED copies of all buffers (safe for persistent storage).
 *
 * Preferred over manual projection + compaction for typical rendering use.
 *
 * @param worldPositions - World-space positions (vec3 stride, READ-ONLY)
 * @param worldRadius - Uniform world-space radius
 * @param count - Instance count
 * @param color - Per-instance RGBA colors
 * @param camera - Resolved camera parameters (determines projection mode)
 * @param rotation - Optional per-instance rotations (will be copied)
 * @param scale2 - Optional per-instance anisotropic scale (will be copied)
 * @param pool - Buffer pool for intermediate allocation (optional, for memory management)
 * @returns All buffers as OWNED copies (safe for immediate storage in DrawOp)
 */
export function projectAndCompact(
  worldPositions: Float32Array,
  worldRadius: number,
  count: number,
  color: Uint8ClampedArray,
  camera: ResolvedCameraParams,
  rotation?: Float32Array,
  scale2?: Float32Array,
  pool?: BufferPool,
): {
  count: number;
  screenPosition: Float32Array;
  screenRadius: Float32Array;
  depth: Float32Array;
  color: Uint8ClampedArray;
  rotation?: Float32Array;
  scale2?: Float32Array;
} {
  // Project
  const projection = projectInstances(worldPositions, worldRadius, count, camera, pool);

  // Compact & sort
  const compacted = depthSortAndCompact(projection, count, color, rotation, scale2);

  // Copy all buffers to ensure ownership (caller doesn't need to remember to copy)
  return {
    count: compacted.count,
    screenPosition: new Float32Array(compacted.screenPosition),
    screenRadius: new Float32Array(compacted.screenRadius),
    depth: new Float32Array(compacted.depth),
    color: new Uint8ClampedArray(compacted.color),
    rotation: compacted.rotation ? new Float32Array(compacted.rotation) : undefined,
    scale2: compacted.scale2 ? new Float32Array(compacted.scale2) : undefined,
  };
}
```

---

### 7.3 Updated Call Sites

**Before (assemblePerInstanceShapes, line 826-832):**
```typescript
const compacted = depthSortAndCompact(
  groupProjection,
  group.instanceIndices.length,
  color,
  rotation,
  scale2
);

const compactedCopy = {
  count: compacted.count,
  screenPosition: new Float32Array(compacted.screenPosition),
  // ... 5 more copy lines
};
```

**After:**
```typescript
// Change: use grouped projection as input
const compactedCopy = projectAndCompact(
  groupScreenPos,        // group-sliced position
  scale,                 // world radius
  group.instanceIndices.length,
  color,                 // group-sliced color
  groupDepth,            // camera for projection
  rotation,              // optional
  scale2                 // optional
  // pool passed in context
);
```

**Wait — this won't work directly!** The `assemblePerInstanceShapes` case is tricky because it projects the **full batch once**, then uses per-group slices of that projection. The helper assumes projection is the first step, but here we've already projected.

**Revised recommendation:** Helper is **useful for `assembleDrawPathInstancesOp` only** (single uniform shape case). The multi-group case is more complex because projection happens once, compaction happens per-group.

---

## Section 8: Ambiguities Requiring User Clarification

### Question 1: Scope of Extraction

**Current finding:** Only 1 clear candidate for extraction (`assembleDrawPathInstancesOp`).

**The multi-group case is problematic:**
- Projects once (full batch)
- Compacts per-group (multiple times)
- Helper would need to separate projection from compaction to be useful

**Ask user:** 
- Should we extract only the "single group" case?
- Or refactor multi-group to use helper by restructuring projection flow?
- Or extract both separately (helper not as valuable)?

**Recommendation:** Start with single-group only. Leaves door open for multi-group refactoring later.

---

### Question 2: Export vs. Internal

**Should `projectAndCompact()` be exported?**

**Pro (export):**
- Useful for other rendering backends
- Signals "recommended API" to callers
- Tests can use it

**Con (export):**
- Adds public API surface
- Commits to memory semantics (auto-copy is now API contract)

**Recommendation:** Export. The auto-copy contract is safe and desirable.

---

### Question 3: BufferPool Integration

**Current helper signature includes `pool?: BufferPool`.**

**Question:** Do we pass pool through, or handle internally?

**Current state:** `projectInstances()` accepts pool, uses for intermediate allocation. Helper would pass through to `projectInstances()`.

**Decision needed:**
- Is pool management the caller's responsibility? (Yes)
- Should helper be aware of pool at all? (Yes, it's a parameter of underlying functions)

**Recommendation:** Keep pool parameter. Preserve caller's control over memory management.

---

### Question 4: Test API

**Should tests migrate to `projectAndCompact()`?**

**Current:** Tests use raw functions + manual copy (or no copy in test scope)

**Options:**
1. Leave tests as-is (tests document the low-level API)
2. Migrate tests to helper (tests verify helper works)

**Recommendation:** Option 2 (selected level-7 test can use helper to verify it). Proves helper works correctly.

---

## Section 9: Summary Matrix

| Aspect | Finding | Note |
|--------|---------|------|
| **Pattern instances** | 5 total (2 prod, 3 test) | 2 production sites repeat identical copy logic |
| **Duplication level** | Medium | ~10 lines repeated identically |
| **Extraction value** | Medium-High | Improves memory safety, simplifies API |
| **Feasibility** | High | Straightforward wrapping of existing functions |
| **Risk** | Low | Non-breaking, can be phased in |
| **Performance impact** | Neutral | Existing code already allocates copies |
| **API design clarity** | Improved | Clear distinction: low-level vs. high-level |
| **Test compatibility** | Maintained | Original functions remain unchanged |
| **Recommended priority** | Low | Quality-of-life improvement, not urgent |

---

## Section 10: Decision Matrix

**For extraction (Y/N by dimension):**

| Dimension | Recommendation | Confidence |
|-----------|----------------|-----------|
| Extract as new helper? | YES | HIGH |
| Auto-copy in helper? | YES | HIGH |
| Place in RenderAssembler? | YES | MEDIUM-HIGH |
| Export from module? | YES | MEDIUM |
| Apply to single-group only? | YES (initially) | HIGH |
| Include in tests? | YES (verify) | MEDIUM-HIGH |

---

## Final Recommendation

**PROCEED with extraction of `projectAndCompact()` helper:**

1. **Scope:** Single-group case first (`assembleDrawPathInstancesOp`)
2. **Design:** Auto-copy, owned buffers returned
3. **Location:** RenderAssembler.ts (private, but exported via module)
4. **Priority:** Low (quality-of-life improvement)
5. **Risk:** Low (non-breaking, can rollback easily)
6. **Value:** Medium (cleaner API, improves memory safety)

**Next step:** User decision on whether to proceed and in what order (see ambiguities section).

