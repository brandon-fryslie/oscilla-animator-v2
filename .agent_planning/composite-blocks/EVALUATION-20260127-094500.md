# Evaluation: Composite Blocks System

Timestamp: 2026-01-27-094500
Git Commit: 4a5ba37

## Executive Summary

Overall: **0% complete** | Critical issues: **4 specification gaps** | Tests reliable: N/A (no implementation)

This is a greenfield feature evaluation. The codebase has anticipatory scaffolding (type placeholders, diagnostic targets) but zero actual implementation. The primary blockers are **specification ambiguities** that must be resolved before implementation can begin.

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| Build | PASS | `npm run build` succeeds |
| Tests | PASS | `npm run test` passes |
| Macro form usage | NONE | grep for `form: 'macro'` returns 0 results |
| Composite expansion pass | NONE | No pass exists |
| Composite definition format | NONE | No types/interfaces exist |

## Missing Checks

1. **No composite definition validator** - Cannot validate that a composite definition is well-formed
2. **No circular composite detector** - Cannot detect A-contains-B-contains-A
3. **No port mapping validator** - Cannot verify exposed ports map to internal ports correctly
4. **No expansion ID collision test** - Cannot verify expanded block IDs don't collide

## Findings

### 1. Block Registry Architecture
**Status**: READY (extension point exists)
**Evidence**: `/Users/bmf/code/oscilla-animator-v2/src/blocks/registry.ts:90`
```typescript
export type BlockForm = 'primitive' | 'macro';
```
**Issues**:
- 'macro' form is defined but has NO special handling anywhere
- No blocks use `form: 'macro'` (grep returns 0 results across entire codebase)
- Registry does not distinguish between primitive and macro at registration time
- `lower()` function is REQUIRED on BlockDef - how would a composite lower?

### 2. Graph Normalization Pipeline
**Status**: REQUIRES EXTENSION
**Evidence**: `/Users/bmf/code/oscilla-animator-v2/src/graph/passes/index.ts:61-84`
**Issues**:
- Current pass order: default-sources -> adapters -> varargs -> indexing
- Composite expansion MUST happen BEFORE default-sources (so expanded blocks get their defaults)
- But also AFTER user graph is loaded (so composites exist to expand)
- **Open question**: Should composites be expanded in normalization or BEFORE normalization?

### 3. Composite Definition Storage
**Status**: NOT STARTED
**Evidence**: No composite definition types exist anywhere in codebase
**Issues**:
- Where do composite definitions live? Options:
  - A) In registry (like blocks) - but blocks have `lower()` function
  - B) In patch metadata - but Patch contract forbids derived artifacts
  - C) In separate store - new architectural component
- Definition format is unspecified:
  - Internal blocks: BlockId mapping to block definitions
  - Internal edges: Edge list
  - Exposed ports: PortId -> internal port reference
  - Parameters: How do params flow to internal blocks?

### 4. Port Mapping System
**Status**: NOT STARTED
**Evidence**: No port mapping types or logic exist
**Issues**:
- How to express "expose internal block B's output port 'value' as composite output 'result'"?
- How to express "composite input 'speed' maps to internal blocks [A.rate, B.multiplier]"?
- One-to-one vs one-to-many port mappings?
- Type constraints: exposed port type must match internal port type

### 5. ID Generation for Expanded Blocks
**Status**: PATTERN EXISTS
**Evidence**: `/Users/bmf/code/oscilla-animator-v2/src/graph/passes/pass1-default-sources.ts:79-81`
```typescript
function generateDefaultSourceId(blockId: BlockId, portId: string): BlockId {
    return `_ds_${blockId}_${portId}` as BlockId;
}
```
**Issues**:
- Pattern works for default sources: `_ds_${blockId}_${portId}`
- Suggested pattern for composites: `_comp_${compositeInstanceId}_${internalBlockId}`
- **Risk**: Deeply nested composites create very long IDs
- Must be deterministic for hot-swap state continuity

### 6. State Migration / Hot-Swap
**Status**: REQUIRES ANALYSIS
**Evidence**: `/Users/bmf/code/oscilla-animator-v2/src/runtime/StateMigration.ts` (not read, but referenced in CLAUDE.md)
**Issues**:
- When a composite is edited, its instances must re-expand
- All internal blocks get new IDs (based on instance ID)
- State keying by StateId must survive re-expansion
- **Critical question**: How to key state for stateful blocks inside composites?

### 7. Diagnostics Integration
**Status**: PARTIALLY READY
**Evidence**: `/Users/bmf/code/oscilla-animator-v2/src/diagnostics/types.ts:48`
```typescript
| { kind: 'composite'; compositeDefId: string; instanceId?: string };
```
**Issues**:
- TargetRef type is ready
- Serialization in diagnosticId.ts handles composite
- No actual composite diagnostics exist
- **Open question**: When an error occurs in expanded block, how to trace back to composite definition?

### 8. UI/Editor System
**Status**: NOT STARTED
**Evidence**: `/Users/bmf/code/oscilla-animator-v2/src/ui/components/BlockLibrary.tsx` shows 'P' vs 'M' badge
**Issues**:
- How to CREATE a composite from selected blocks?
- How to EDIT a composite definition?
- How to VIEW a composite's internal structure?
- How to expose/hide internal ports?
- How to handle composite-within-composite recursion?

## Ambiguities Found

| Area | Question | How LLM Would Guess | Impact |
|------|----------|---------------------|--------|
| **Definition Storage** | Where do composite definitions live? | Probably separate CompositeRegistry | CRITICAL - affects entire architecture |
| **Expansion Timing** | Before or during normalization? | New pass0 before pass1 | HIGH - affects pass ordering |
| **Lowering** | Does composite have lower() or rely on expansion? | Expansion-only, no lower() | HIGH - affects registry type |
| **Port Mapping** | One-to-one or one-to-many? | One-to-one only for MVP | MEDIUM - affects complexity |
| **State Keying** | How to key state inside composites? | Composite instance + internal state ID | HIGH - affects hot-swap |
| **Nesting Depth** | Max nesting depth? | Arbitrary, error on cycle | MEDIUM - performance |
| **Editing** | Edit composite in-place or open separate editor? | Separate editor panel | MEDIUM - UX decision |

## Recommendations

1. **FIRST: Resolve definition storage location**
   - Option A: CompositeRegistry separate from BlockRegistry
   - Option B: Unified registry with discriminated union (Primitive | Composite)
   - My recommendation: Option B for consistency

2. **SECOND: Define CompositeDefinition type**
   ```typescript
   interface CompositeDefinition {
     id: string;
     label: string;
     category: string;
     // Internal graph (not a full Patch - no TimeRoot)
     internalBlocks: Map<LocalBlockId, BlockInstance>;
     internalEdges: Edge[];
     // Port exposure
     exposedInputs: Map<PortId, InternalPortRef>;
     exposedOutputs: Map<PortId, InternalPortRef>;
     // Parameters that flow to internal blocks
     paramBindings: ParamBinding[];
   }
   ```

3. **THIRD: Implement expansion pass (pass0)**
   - Run before default-sources
   - Recursively expand nested composites
   - Generate deterministic IDs
   - Track expansion provenance for debugging

4. **FOURTH: State key format for composites**
   - Proposed: `state:${compositeInstanceId}:${internalBlockId}:${stateSlot}`
   - Must survive re-expansion of same composite

5. **Defer editor UI to after runtime works**
   - Can test composites via JSON fixtures first
   - Editor is complex but not architecturally blocking

## Verdict

- [x] **PAUSE** - Ambiguities need clarification

### Critical Questions Requiring Answers

1. **Definition Storage**: Should composites live in BlockRegistry (unified) or a separate CompositeRegistry?

2. **Expansion vs Lowering**: Should `BlockForm = 'macro'` blocks have a `lower()` function, or rely purely on expansion to primitive blocks?

3. **Port Mapping Cardinality**: Can one composite input map to MULTIPLE internal ports, or only one-to-one?

4. **Editor Model**: When editing a composite, does the user see it as a single block with an "edit contents" action, or as a collapsible group in the main canvas?

5. **Library Composites**: Are premade library composites shipped as JSON definitions, or as code (like current blocks)?

### What Happens If We Guess Wrong

| If We Guess | And It's Wrong | Consequence |
|-------------|----------------|-------------|
| Separate CompositeRegistry | Spec wants unified | Major refactor of registry architecture |
| Expansion in pass0 | Spec wants normalization-time | Rewrite pass ordering |
| One-to-one port mapping | Users need one-to-many | Major type system extension |
| Composite has lower() | Should be expansion-only | Confusing dual mechanism |

---

## Final Output

```
project-evaluator complete
  Scope: composite-blocks | Completion: 0% | Gaps: 4 critical spec questions
  Workflow: PAUSE (4 questions need answers first)
  -> Resolve definition storage, expansion timing, port mapping, and editor model before implementation
```
