# Evaluation: Composite Block System
Generated: 2026-01-27T15:00:00Z
Topic: composite-blocks

## Executive Summary

**Verdict: CONTINUE**

The composite block system is a greenfield feature with clear architectural fit. All critical design decisions have been resolved through user consultation. The existing codebase has anticipatory scaffolding that supports this feature.

## Feature Overview

A composite block system that allows:
- Combining multiple standard blocks into a reusable unit
- Internal blocks wired together like a mini-graph
- Explicit port mapping to expose internal ports
- User-created composites via in-app editor
- Library/premade composites (code + JSON hybrid)
- Graph normalizer expansion into normal blocks
- Stateful blocks inside composites with stable state keys

## Key Design Decisions (User-Confirmed)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Storage | Unified Block Registry with `form='composite'` | Single source of truth. Macros are different concept. |
| Expansion | Graph normalization pass (pass0) | Reuses existing infrastructure, clean separation |
| Editor | Separate tab in main center area | Clear mode separation, same canvas pattern |
| Library Format | Hybrid (code + JSON) | Core composites in code, user-created in JSON |
| Port Mapping | Explicit mapping | Full control over naming and exposed ports |
| Internal State | Yes, with stable state keys | Full functionality, state keys include composite instance ID |

## Existing Infrastructure Assessment

### Already Exists (Can Reuse)
1. **`BlockForm`** type at `src/blocks/registry.ts:90` - add 'composite' form
2. **TargetRef** includes `{ kind: 'composite' }` in diagnostics - ready to use
3. **Derived block role** system with `meta.kind` - add 'compositeExpansion'
4. **Deterministic ID patterns** - `_ds_`, `_adapter_` patterns for derived blocks
5. **Normalization pass pipeline** - extensible, can add pass0
6. **PatchBuilder** - programmatic graph construction for expansion
7. **GraphCommitted reasons** include 'compositeSave' in spec

### Must Build (New)
1. **CompositeBlockDef type** - extends BlockDef with internal graph + port mapping
2. **Composite expansion pass** - new pass0 in normalization pipeline
3. **Port mapping types** - ExposedPort, PortMapping interfaces
4. **Composite editor UI** - new tab component with graph editing
5. **Composite library loader** - JSON parsing + validation
6. **State key generation** - composite-aware state ID format

## Architecture Alignment

### Fits Existing Patterns
- Composites compile through same pipeline as primitives (after expansion)
- No special-casing in type inference, scheduling, or runtime
- Derived blocks already used for default sources and adapters
- Diagnostics can trace back to composite definitions

### Invariants Respected
- **Single source of truth**: One registry for all block types
- **No back-edges**: Expansion happens in pass0, before other passes
- **Deterministic IDs**: `_comp_{compositeInstanceId}_{internalBlockId}`
- **One-way dependencies**: Composite editor reads from registry, writes to PatchStore

## Risk Assessment

| Risk | Severity | Mitigation |
|------|----------|------------|
| Circular composite definitions | High | Detect cycles during composite validation |
| Deep nesting performance | Medium | Limit nesting depth (e.g., 5 levels max) |
| Debugging expanded blocks | Medium | Maintain source mapping for diagnostics |
| State migration complexity | Medium | Clear state key format with composite path |

## Completion Status

- **Existing infrastructure**: 15% (scaffolding only)
- **Composite system**: 0%
- **Editor UI**: 0%
- **Library system**: 0%

## Recommended Approach

1. **Sprint 1 (Core)**: Type definitions, composite registry integration, expansion pass
2. **Sprint 2 (Editor)**: Composite editor UI, create/edit workflow
3. **Sprint 3 (Library)**: JSON loader, premade composites, library panel integration

## Files to Modify/Create

### Core Changes
- `src/blocks/registry.ts` - Add 'composite' form, CompositeBlockDef type
- `src/blocks/composite-types.ts` - NEW: Composite-specific types
- `src/graph/passes/pass0-composite-expansion.ts` - NEW: Expansion pass
- `src/graph/passes/index.ts` - Add pass0 to pipeline
- `src/types/index.ts` - Export new types

### Editor Changes
- `src/ui/components/CompositeEditor.tsx` - NEW: Main editor component
- `src/ui/dockview/panels/CompositeEditorPanel.tsx` - NEW: Dockview wrapper
- `src/stores/CompositeEditorStore.ts` - NEW: Editor state management

### Library Changes
- `src/blocks/composites/index.ts` - NEW: Library loader
- `src/blocks/composites/*.json` - NEW: Library definitions
- `src/ui/components/BlockLibrary.tsx` - Add composite section

## Questions Resolved

All critical specification questions have been answered:
- Where do definitions live? → Unified registry with form='composite'
- How does expansion work? → Graph normalization pass0
- How do ports get exposed? → Explicit port mapping
- Can composites have state? → Yes, with stable state keys
- What's the editor UX? → Separate tab in main area
- How are library composites distributed? → Code + JSON hybrid
