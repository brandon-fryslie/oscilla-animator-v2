# Exploration: Composite Blocks Feature

Timestamp: 2026-01-27-094500
Topic: composite-blocks

## Raw Facts Gathered

### 1. Existing Block System Architecture

**Block Registry (`src/blocks/registry.ts`):**
- `BlockForm = 'primitive' | 'macro'` - exists but 'macro' is NOT used anywhere in codebase
- All current blocks use `form: 'primitive'`
- `BlockDef` interface includes: type, label, category, description, form, capability, inputs, outputs, lower
- `registerBlock()` validates port uniqueness and vararg constraints
- Registry is a simple Map<string, BlockDef>

**Key observation**: The 'macro' form exists in the type system but has no implementation. This is a placeholder that was anticipated but never built.

### 2. Graph Model (`src/graph/Patch.ts`)

**Patch structure:**
- `Patch = { blocks: Map<BlockId, Block>, edges: Edge[] }`
- `Block` has: id, type, params, label, displayName, domainId, role, inputPorts, outputPorts
- `BlockRole` types: 'user', 'derived', 'bus', 'domain'
- `DerivedBlockMeta` includes: 'defaultSource', 'adapter' kinds

**Contract (from file header):**
- Patch is the authoritative, undoable user intent
- Must NOT contain: inferred types, resolved payloads, resolved units, constraint-solver artifacts, compiler-only derived structure, runtime caches
- Normalization/compilation may derive additional artifacts but they must NOT be written back into Patch

### 3. Normalization Pipeline (`src/graph/passes/`)

**Pass order:**
1. `pass1DefaultSources` - Materializes default sources as derived blocks
2. `pass2Adapters` - Inserts type adapter blocks
3. `pass4Varargs` - Validates vararg connections
4. `pass3Indexing` - Creates dense block indices

**Key insight**: Default sources and adapters are EXPANDED into the patch as derived blocks with explicit role metadata. The compiler sees a flat graph with no special cases.

**ID generation pattern:**
- Default source IDs: `_ds_${blockId}_${portId}`
- Adapter IDs: `_adapter_${edgeId}`
- Deterministic, derived from source block/edge

### 4. Compiler Pipeline (`src/compiler/compile.ts`)

**Full pipeline:**
1. Normalization
2. Pass 1: Type constraints
3. Pass 2: Type graph
4. Pass 3: Time topology
5. Pass 4: Dependency graph
6. Pass 5: Cycle validation (SCC)
7. Pass 6: Block lowering
8. Pass 7: Schedule construction

**Block lowering (`pass6-block-lowering.ts`):**
- Uses `BLOCK_DEFS_BY_TYPE` to look up each block
- Calls `blockDef.lower()` function per block
- Tracks instance context propagation between blocks
- Returns `UnlinkedIRFragments` with outputs per block

### 5. Diagnostics System (`src/diagnostics/types.ts`)

**TargetRef already includes composite:**
```typescript
| { kind: 'composite'; compositeDefId: string; instanceId?: string }
```

**This is forward-looking** - the type exists but is only used in serialization tests. No actual composite diagnostics exist.

**GraphCommitted reasons include:**
- `'macroExpand'` and `'compositeSave'` - anticipated but not implemented

### 6. Spec Documentation

**From `02-block-system.md`:**
- "Everything is a block or wire at compile time"
- "Buses, default sources, and lenses are all derived blocks"
- Block roles: 'user' vs 'derived' - both compile the same way
- "The Compiler Ignores Roles" - roles are for editor, not compiler

**Macros mentioned in spec:**
- GraphCommitted reason includes 'macroExpand'
- EventHub spec mentions MacroExpanded event
- Spec talks about "dropping a macro" triggering expansion
- No actual macro/composite DEFINITION format is specified

### 7. UI Components

**BlockLibrary.tsx:**
- Reads from registry via `getBlockCategories()` and `getBlockTypesByCategory()`
- Shows badge for primitive vs macro: `form === 'primitive' ? 'P' : 'M'`
- Double-click adds block via `patch.addBlock()`

**PatchStore.ts:**
- `addBlock()` creates block with ports from registry definition
- `loadPatch()` handles deserialization
- No macro/composite expansion logic exists

### 8. Rules from `.claude/rules/graph/blocks.md`

**Critical rule:**
> "Macros: 'presets' that expand into blocks when they're added to a patch. Not true Blocks, they are never added to a patch and graph normalization never sees them."

This describes macros as EXPANSION-TIME sugar, not runtime entities.

## Key Findings Summary

1. **'macro' form exists but is UNUSED** - placeholder in type system only
2. **No composite DEFINITION format exists** - how to define a composite's internal graph?
3. **No expansion pass exists** - where would composites be unpacked?
4. **Diagnostics TargetRef is forward-compatible** - `kind: 'composite'` ready
5. **Spec describes macros as expansion-time sugar** - not persistent in patch
6. **ID generation patterns established** - deterministic derived IDs
7. **Derived block role system is extensible** - can add new meta.kind
