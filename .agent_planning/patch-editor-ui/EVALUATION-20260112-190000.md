# EVALUATION: patch-editor-ui (Rete.js Integration)

**Date:** 2026-01-12 19:00
**Topic:** patch-editor-ui
**Approach:** Rete.js integration for visual node editor

---

## Executive Summary

This evaluation explores integrating **Rete.js v2** as the visual node editor layer for Oscilla. Rete provides built-in socket validation, undo/redo (History plugin), and auto-layout - features we'd otherwise need to build ourselves.

**Key insight:** Rete handles the UI/UX layer; our existing compiler pipeline remains unchanged. Rete validates at authoring time; the compiler validates at compile time.

---

## 1. What Rete.js Provides (For Free)

### 1.1 Socket Type Validation
```typescript
class SignalFloatSocket extends ClassicPreset.Socket {
  isCompatibleWith(socket: Socket) {
    return socket instanceof SignalFloatSocket
        || socket instanceof AnySocket;
  }
}
```
- Prevents invalid connections before they're created
- Visual feedback (green/red port highlighting)
- Maps directly to our CanonicalType system

### 1.2 History Plugin (Undo/Redo)
- Built-in command pattern
- Tracks node add/remove, connection add/remove, node position
- Keyboard shortcuts (Ctrl+Z, Ctrl+Y)
- No custom implementation needed

### 1.3 Auto-Arrange Plugin
- Automatic node layout (dagre-based)
- Can be triggered on demand or auto
- Respects node sizes and connection directions

### 1.4 Additional Plugins
- **Minimap** - overview of large graphs
- **Context Menu** - right-click actions
- **Readonly** - view-only mode
- **Connection Path** - custom edge routing

---

## 2. Architecture: Rete as UI Layer

```
┌─────────────────────────────────────────────────────────────┐
│                     RETE.JS LAYER                           │
│  • NodeEditor (graph state)                                 │
│  • React rendering plugin                                   │
│  • Socket validation (isCompatibleWith)                     │
│  • History plugin (undo/redo)                               │
│  • Auto-arrange plugin (layout)                             │
│  • Area plugin (pan/zoom)                                   │
└─────────────────────────────────────────────────────────────┘
                           │
                           │ Bidirectional sync
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                   PATCHSTORE (Source of Truth)              │
│  • Canonical block/edge representation                      │
│  • MobX observables for reactive UI                         │
│  • Mutation actions (addBlock, removeBlock, etc.)           │
└─────────────────────────────────────────────────────────────┘
                           │
                           │ On change → recompile
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                   COMPILER PIPELINE                         │
│  • Pass 2: Type graph (validates types again)               │
│  • Pass 3-8: Time, deps, SCC, lowering, schedule, link      │
│  • Diagnostics emitted to DiagnosticsStore                  │
└─────────────────────────────────────────────────────────────┘
```

### Key Design Decision: PatchStore Remains Source of Truth

Rete has its own NodeEditor state. We need to decide:

**Option A: Rete is source of truth, PatchStore derives from it**
- Pros: Simple, Rete controls everything
- Cons: Tight coupling, hard to use PatchStore without Rete

**Option B: PatchStore is source of truth, Rete syncs to it** ✅ RECOMMENDED
- Pros: Rete is optional UI layer, PatchStore works standalone
- Cons: Need bidirectional sync logic

**Why Option B:**
1. PatchStore already works with TableView, ConnectionMatrix
2. Compiler reads from PatchStore, not Rete
3. Can swap Rete for different editor later
4. Headless operation (tests, CLI) doesn't need Rete

---

## 3. Integration Points

### 3.1 Socket Types → CanonicalType Mapping

Our CanonicalType system has axes: PayloadType, Cardinality, Temporality, Binding, Extent

For Rete sockets, we simplify to connection-compatible groups:

```typescript
// Core socket types for visual editor
const SOCKET_TYPES = {
  // Signals (scalar, time-varying)
  signal_float: new SignalSocket('float'),
  signal_int: new SignalSocket('int'),
  signal_phase: new SignalSocket('phase'),
  signal_color: new SignalSocket('color'),

  // Fields (per-element, domain-bound)
  field_float: new FieldSocket('float'),
  field_int: new FieldSocket('int'),
  field_vec2: new FieldSocket('vec2'),
  field_color: new FieldSocket('color'),

  // Domain reference
  domain: new DomainSocket(),

  // Control flow (buses, rails)
  bus: new BusSocket(),
};

// Compatibility rules
class SignalSocket extends ClassicPreset.Socket {
  isCompatibleWith(socket: Socket) {
    // Signals connect to signals of same payload type
    // OR to field inputs (broadcast)
    return (socket instanceof SignalSocket && socket.payloadType === this.payloadType)
        || (socket instanceof FieldSocket && socket.payloadType === this.payloadType);
  }
}
```

### 3.2 Block → Rete Node Mapping

Each Oscilla Block becomes a Rete Node:

```typescript
class OscillaNode extends ClassicPreset.Node {
  constructor(
    public blockType: string,
    public blockId: BlockId,
    public displayName: string,
    inputs: InputDef[],
    outputs: OutputDef[]
  ) {
    super(displayName || blockType);

    // Add input sockets from block definition
    for (const input of inputs) {
      this.addInput(input.id, new ClassicPreset.Input(
        getSocketForType(input.canonicalType),
        input.label,
        input.optional // multipleConnections
      ));
    }

    // Add output sockets
    for (const output of outputs) {
      this.addOutput(output.id, new ClassicPreset.Output(
        getSocketForType(output.canonicalType),
        output.label
      ));
    }
  }
}
```

### 3.3 Sync Strategy: PatchStore ↔ Rete

**PatchStore → Rete (Initial load & external changes):**
```typescript
function syncPatchToRete(patch: Patch, editor: NodeEditor) {
  // Clear Rete state
  await editor.clear();

  // Add nodes
  for (const block of patch.blocks.values()) {
    const node = createReteNode(block);
    await editor.addNode(node);
  }

  // Add connections
  for (const edge of patch.edges) {
    const conn = createReteConnection(edge, editor);
    await editor.addConnection(conn);
  }
}
```

**Rete → PatchStore (User edits):**
```typescript
// Listen to Rete events
editor.addPipe(context => {
  if (context.type === 'nodecreated') {
    patchStore.addBlock(context.data.blockType, {}, {
      // Use Rete's generated ID or map it
    });
  }
  if (context.type === 'connectioncreated') {
    patchStore.addEdge(
      { blockId: context.data.source, slotId: context.data.sourceOutput },
      { blockId: context.data.target, slotId: context.data.targetInput }
    );
  }
  // ... noderemoved, connectionremoved
  return context;
});
```

### 3.4 History Plugin Integration

Rete's History plugin tracks its own undo/redo. We need to:

1. Let Rete handle undo/redo for graph structure
2. Sync changes back to PatchStore after undo/redo
3. Don't duplicate history in PatchStore

```typescript
import { HistoryPlugin, HistoryActions } from 'rete-history-plugin';

const history = new HistoryPlugin<Schemes>();
area.use(history);

// Undo/redo buttons call history
function handleUndo() {
  history.undo();
}
function handleRedo() {
  history.redo();
}
```

---

## 4. What We Build vs What Rete Provides

| Feature | Build Ourselves | Rete Provides |
|---------|-----------------|---------------|
| Node rendering | Custom React components | Plugin framework |
| Port/socket types | Type definitions | Validation + UI |
| Connection drag | Nothing | Built-in |
| Pan/zoom | Nothing | Area plugin |
| Undo/redo | Nothing | History plugin |
| Auto-layout | Nothing | Auto-arrange plugin |
| Minimap | Nothing | Minimap plugin |
| Context menu | Menu items only | Menu framework |
| Sync to PatchStore | Bidirectional sync | Nothing |
| Block library UI | Keep existing | Nothing |
| Inspector UI | Keep existing | Nothing |

---

## 5. Dependencies & Bundle Impact

### NPM Packages Required
```json
{
  "rete": "^2.0.0",
  "rete-react-plugin": "^2.0.0",
  "rete-area-plugin": "^2.0.0",
  "rete-connection-plugin": "^2.0.0",
  "rete-history-plugin": "^2.0.0",
  "rete-auto-arrange-plugin": "^2.0.0",
  "rete-minimap-plugin": "^2.0.0",
  "rete-context-menu-plugin": "^2.0.0"
}
```

### Estimated Bundle Impact
- Core rete: ~15KB gzipped
- Plugins: ~20-30KB total gzipped
- **Total: ~35-45KB gzipped**

### Dependency Isolation

To limit coupling, wrap Rete in an abstraction layer:

```typescript
// src/ui/editor/ReteEditor.tsx
// All Rete imports contained here

export interface NodeEditorProps {
  patch: Patch;
  onPatchChange: (patch: Patch) => void;
  selection: SelectionStore;
}

export function NodeEditor({ patch, onPatchChange, selection }: NodeEditorProps) {
  // Rete setup contained within this component
}
```

---

## 6. Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Rete state diverges from PatchStore | Medium | High | Single direction of truth, careful sync |
| Rete API changes in future versions | Low | Medium | Pin versions, wrap in abstraction |
| Performance with large graphs | Low | Medium | Rete handles 100s of nodes |
| Learning curve | Medium | Low | Good docs, examples available |
| React version conflicts | Low | Low | Rete supports React 18+ |

---

## 7. Recommended Sprint Scope

### Sprint 1: Foundation (This Sprint)
1. **P0:** Install Rete packages, basic editor rendering
2. **P1:** Socket type definitions mapped to CanonicalType
3. **P2:** Bidirectional sync: PatchStore ↔ Rete
4. **P3:** Add block from Library (double-click → add to Rete → sync to PatchStore)
5. **P4:** Delete block (context menu → remove from Rete → sync to PatchStore)

### Sprint 2: Polish
- History plugin (undo/redo)
- Auto-arrange plugin (layout)
- Minimap
- Parameter editing integration

### Explicitly Deferred
- Custom node rendering (use Rete defaults first)
- Advanced edge routing
- Subgraphs

---

## 8. Success Criteria

1. Rete editor renders current PatchStore state
2. User can add block via Library → appears in Rete editor
3. User can delete block via context menu
4. User can create connection by dragging between ports
5. Invalid connections prevented (socket type mismatch)
6. Changes sync to PatchStore → compiler runs → diagnostics update
7. Existing TableView/Matrix continue to work (read from same PatchStore)

---

## Verdict: CONTINUE

Rete.js integration is viable and provides significant value (undo/redo, layout, validation) for reasonable cost (~40KB bundle, abstraction layer). Proceed with planning.
