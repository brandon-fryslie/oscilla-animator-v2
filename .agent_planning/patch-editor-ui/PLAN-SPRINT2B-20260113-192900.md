# Sprint 2B Implementation Plan - Advanced Editor Features

**Date:** 2026-01-13 19:29
**Topic:** patch-editor-ui Sprint 2B
**Reference:** EVALUATION-SPRINT2B-20260113-192722.md, DOD-SPRINT2B-20260113-192900.md

---

## Executive Summary

Sprint 2B adds 5 advanced features to the Rete.js editor, building on the stable Sprint 2A foundation. Features are implemented in dependency order: Auto-layout → Minimap → Custom Rendering → Parameter UI → E2E Tests.

---

## Phase 1: Auto-layout (Feature 1)

### Step 1.1: Install Dependencies
```bash
npm install rete-auto-arrange-plugin
```

### Step 1.2: Integrate Auto-layout Plugin
**File:** `src/ui/editor/ReteEditor.tsx`

```typescript
import { AutoArrangePlugin, Presets as ArrangePresets } from 'rete-auto-arrange-plugin';

// In editor initialization
const arrange = new AutoArrangePlugin<Schemes>();
arrange.addPreset(ArrangePresets.classic.setup());
area.use(arrange);
```

### Step 1.3: Add Toolbar Button
**File:** `src/ui/editor/ReteEditor.tsx`

Add "Auto Arrange" button next to existing toolbar buttons:
- Click handler calls `await arrange.layout()`
- After layout, trigger zoom-to-fit with `area.emit('fit')`

### Step 1.4: Configure Layout Options
- Direction: Left-to-right ('LR')
- Spacing: [100, 80] (horizontal, vertical)
- Use elk layout engine if available

### Verification
- Button visible in toolbar
- Clicking arranges nodes with no overlap
- Zoom-to-fit shows all nodes after layout

---

## Phase 2: Minimap (Feature 2)

### Step 2.1: Install Dependencies
```bash
npm install rete-minimap-plugin
```

### Step 2.2: Integrate Minimap Plugin
**File:** `src/ui/editor/ReteEditor.tsx`

```typescript
import { MinimapPlugin } from 'rete-minimap-plugin';

// In editor initialization
const minimap = new MinimapPlugin<Schemes>({
  size: { width: 180, height: 120 }
});
area.use(minimap);
```

### Step 2.3: Style Minimap
**File:** `src/ui/editor/ReteEditor.css` or inline styles

Position in top-right corner:
```css
.rete-minimap {
  position: absolute;
  top: 8px;
  right: 8px;
  border: 1px solid #444;
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.8);
}
```

### Verification
- Minimap visible in top-right corner
- Shows all nodes
- Viewport rectangle visible
- Click-to-navigate works

---

## Phase 3: Custom Node Rendering (Feature 3)

### Step 3.1: Create Custom Node Component
**File:** `src/ui/editor/components/OscillaNodeComponent.tsx`

```typescript
import { ClassicScheme, Presets } from 'rete-react-plugin';

export function OscillaNodeComponent(props: { data: OscillaNode }) {
  const { data } = props;

  return (
    <div className="oscilla-node">
      <div className="node-header">
        <span className="node-label">{data.label}</span>
        <span className="node-type">{data.blockType}</span>
      </div>
      <div className="node-body">
        {/* Inputs */}
        <div className="node-inputs">
          {Object.entries(data.inputs).map(([key, input]) => (
            <div key={key} className="socket-row input">
              <Presets.classic.Socket {...input.socket} />
              <span className="socket-label">{input.label || key}</span>
            </div>
          ))}
        </div>
        {/* Outputs */}
        <div className="node-outputs">
          {Object.entries(data.outputs).map(([key, output]) => (
            <div key={key} className="socket-row output">
              <span className="socket-label">{output.label || key}</span>
              <Presets.classic.Socket {...output.socket} />
            </div>
          ))}
        </div>
      </div>
      {/* Parameter controls placeholder (Phase 4) */}
      <div className="node-controls" />
    </div>
  );
}
```

### Step 3.2: Register Custom Renderer
**File:** `src/ui/editor/ReteEditor.tsx`

```typescript
render.addPreset(Presets.classic.setup({
  customize: {
    node() {
      return OscillaNodeComponent;
    }
  }
}));
```

### Step 3.3: Add Node Styling
**File:** `src/ui/editor/components/OscillaNode.css`

- Header styling with gradient
- Socket colors per type
- Compact layout
- Selection highlight

### Verification
- Nodes display with custom styling
- All socket interactions work
- Selection and dragging work
- Performance smooth with 50+ nodes

---

## Phase 4: Parameter Control UI (Feature 4)

### Step 4.1: Create Parameter Controls
**File:** `src/ui/editor/components/ParameterControl.tsx`

```typescript
export function FloatControl({ param, onChange }) {
  return (
    <div className="param-control float">
      <label>{param.label}</label>
      <input
        type="range"
        min={param.min}
        max={param.max}
        step={param.step ?? 0.1}
        value={param.value}
        onChange={(e) => onChange(parseFloat(e.target.value))}
      />
      <span className="value">{param.value.toFixed(2)}</span>
    </div>
  );
}

export function BoolControl({ param, onChange }) {
  return (
    <div className="param-control bool">
      <label>{param.label}</label>
      <input
        type="checkbox"
        checked={param.value}
        onChange={(e) => onChange(e.target.checked)}
      />
    </div>
  );
}

export function EnumControl({ param, onChange }) {
  return (
    <div className="param-control enum">
      <label>{param.label}</label>
      <select value={param.value} onChange={(e) => onChange(e.target.value)}>
        {param.options.map(opt => (
          <option key={opt} value={opt}>{opt}</option>
        ))}
      </select>
    </div>
  );
}
```

### Step 4.2: Extend OscillaNode with Parameters
**File:** `src/ui/editor/OscillaNode.ts`

Add controls map for parameters:
```typescript
class OscillaNode extends ClassicPreset.Node {
  // ... existing fields

  constructor(blockDef, blockId) {
    super(blockDef.label);
    // ... existing setup

    // Add parameter controls
    for (const param of blockDef.parameters ?? []) {
      this.addControl(param.id, new ParameterControl(param, blockId));
    }
  }
}
```

### Step 4.3: Implement Parameter Sync
**File:** `src/ui/editor/sync.ts`

```typescript
// Debounced parameter update
const parameterUpdateQueue = new Map<string, NodeJS.Timeout>();

export function updateParameter(blockId: BlockId, paramId: string, value: any) {
  const key = `${blockId}:${paramId}`;

  // Clear existing timeout
  if (parameterUpdateQueue.has(key)) {
    clearTimeout(parameterUpdateQueue.get(key)!);
  }

  // Debounce: update after 100ms of no changes
  parameterUpdateQueue.set(key, setTimeout(() => {
    patchStore.updateBlockParameter(blockId, paramId, value);
    parameterUpdateQueue.delete(key);
  }, 100));
}
```

### Step 4.4: Integrate Controls in Custom Node
Update `OscillaNodeComponent.tsx` to render controls in node-controls div.

### Verification
- Float sliders work with real-time update
- Bool checkboxes toggle correctly
- Enum dropdowns show options
- Changes sync to PatchStore
- BlockInspector stays in sync

---

## Phase 5: E2E Testing (Feature 5)

### Step 5.1: Auto-layout Tests
**File:** `tests/e2e/editor-auto-layout.test.ts`

- Test button exists
- Test layout produces no overlap
- Test zoom-to-fit after layout

### Step 5.2: Minimap Tests
**File:** `tests/e2e/editor-minimap.test.ts`

- Test minimap visible
- Test click-to-navigate

### Step 5.3: Custom Rendering Tests
**File:** `tests/e2e/editor-custom-nodes.test.ts`

- Test custom styling applied
- Test socket interactions preserved

### Step 5.4: Parameter Tests
**File:** `tests/e2e/editor-parameters.test.ts`

- Test parameter edit syncs to store
- Test bidirectional sync

### Step 5.5: Regression Suite
Verify all Sprint 2A tests still pass.

---

## Technical Notes

### Dependencies to Install
```bash
npm install rete-auto-arrange-plugin rete-minimap-plugin
```

### Files to Modify
1. `src/ui/editor/ReteEditor.tsx` - Plugin integration
2. `src/ui/editor/OscillaNode.ts` - Parameter support
3. `src/ui/editor/sync.ts` - Parameter sync logic

### Files to Create
1. `src/ui/editor/components/OscillaNodeComponent.tsx`
2. `src/ui/editor/components/OscillaNode.css`
3. `src/ui/editor/components/ParameterControl.tsx`
4. E2E test files

### Risk Mitigation
- **Custom rendering breaks interactions:** Test each interaction incrementally
- **Parameter sync loops:** Use isSyncing guard like existing sync
- **Performance issues:** Apply React.memo, test with 50+ nodes early

---

## Acceptance Criteria Summary

**Auto-layout:** Button visible, no overlap after layout, zoom-to-fit
**Minimap:** Visible top-right, click-to-navigate works
**Custom Rendering:** Styled nodes, all interactions work
**Parameter UI:** Controls visible, editable, sync to PatchStore
**E2E Tests:** All features tested, all tests pass

---

## Next Steps

1. Implement Phase 1 (Auto-layout) first
2. Verify each phase before moving to next
3. Run tests after each phase
4. Complete all 5 phases for Sprint 2B
