# Sprint Plan: patch-editor-ui (Rete.js Integration)

**Date:** 2026-01-12 19:00
**Topic:** patch-editor-ui
**Approach:** Rete.js v2 integration
**Reference:** EVALUATION-20260112-190000.md

---

## Sprint Goal

Integrate Rete.js as the visual node editor, enabling users to add/delete blocks and create connections with type-safe socket validation. Establish bidirectional sync with PatchStore as source of truth.

---

## Scope

**In scope (this sprint):**
1. Rete.js installation and basic editor setup
2. Socket type system mapped to Oscilla SignalTypes
3. Bidirectional sync between Rete and PatchStore
4. Add block from Library
5. Delete block via context menu
6. Create/delete connections via drag

**Explicitly out of scope (deferred):**
- Undo/redo (History plugin) - Sprint 2
- Auto-layout (Auto-arrange plugin) - Sprint 2
- Minimap - Sprint 2
- Parameter editing in nodes - Sprint 2
- Custom node rendering - Sprint 2
- Subgraphs - Future

---

## Work Items

### P0: Rete.js Setup & Basic Rendering

**Goal:** Get Rete editor rendering in the UI with pan/zoom working.

**Acceptance Criteria:**
- [ ] Rete packages installed (rete, rete-react-plugin, rete-area-plugin, rete-connection-plugin)
- [ ] ReteEditor component created at `src/ui/editor/ReteEditor.tsx`
- [ ] Editor renders in center panel (new tab alongside Blocks/Matrix/Preview)
- [ ] Pan and zoom work via mouse/trackpad
- [ ] Empty editor shows placeholder or grid background
- [ ] No console errors

**Technical Notes:**

Install packages:
```bash
npm install rete rete-react-plugin rete-area-plugin rete-connection-plugin
```

Basic setup:
```typescript
import { createRoot } from 'react-dom/client';
import { NodeEditor, GetSchemes, ClassicPreset } from 'rete';
import { AreaPlugin, AreaExtensions } from 'rete-area-plugin';
import { ReactPlugin, Presets } from 'rete-react-plugin';
import { ConnectionPlugin, Presets as ConnectionPresets } from 'rete-connection-plugin';

type Schemes = GetSchemes<ClassicPreset.Node, ClassicPreset.Connection<ClassicPreset.Node>>;

async function createEditor(container: HTMLElement) {
  const editor = new NodeEditor<Schemes>();
  const area = new AreaPlugin<Schemes>(container);
  const connection = new ConnectionPlugin<Schemes>();
  const reactPlugin = new ReactPlugin<Schemes>({ createRoot });

  editor.use(area);
  area.use(connection);
  area.use(reactPlugin);

  AreaExtensions.selectableNodes(area, AreaExtensions.selector(), {
    accumulating: AreaExtensions.accumulateOnCtrl()
  });

  return { editor, area };
}
```

**Files:**
- `src/ui/editor/ReteEditor.tsx` (new)
- `src/ui/editor/index.ts` (new)
- `src/ui/components/app/App.tsx` (add Editor tab)
- `package.json` (add dependencies)

---

### P1: Socket Type System

**Goal:** Define socket types that map to Oscilla's CanonicalType system and enforce connection compatibility.

**Acceptance Criteria:**
- [ ] Socket classes defined for: signal_float, signal_int, signal_phase, field_float, field_int, field_vec2, domain
- [ ] `isCompatibleWith()` implemented for each socket type
- [ ] Signal sockets connect to matching signal sockets
- [ ] Signal sockets can connect to field inputs (broadcast semantics)
- [ ] Field sockets only connect to field sockets of same payload type
- [ ] Domain sockets only connect to domain sockets
- [ ] Incompatible connection attempts show visual rejection (no connection created)

**Technical Notes:**

Socket hierarchy:
```typescript
// src/ui/editor/sockets.ts

import { ClassicPreset } from 'rete';

export class OscillaSocket extends ClassicPreset.Socket {
  constructor(
    name: string,
    public readonly cardinality: 'signal' | 'field',
    public readonly payloadType: string
  ) {
    super(name);
  }

  isCompatibleWith(socket: ClassicPreset.Socket): boolean {
    if (!(socket instanceof OscillaSocket)) return false;

    // Same cardinality and payload → compatible
    if (this.cardinality === socket.cardinality &&
        this.payloadType === socket.payloadType) {
      return true;
    }

    // Signal → Field broadcast (same payload)
    if (this.cardinality === 'signal' &&
        socket.cardinality === 'field' &&
        this.payloadType === socket.payloadType) {
      return true;
    }

    return false;
  }
}

// Singleton instances
export const Sockets = {
  signal_float: new OscillaSocket('Signal<float>', 'signal', 'float'),
  signal_int: new OscillaSocket('Signal<int>', 'signal', 'int'),
  signal_phase: new OscillaSocket('Signal<phase>', 'signal', 'phase'),
  field_float: new OscillaSocket('Field<float>', 'field', 'float'),
  field_int: new OscillaSocket('Field<int>', 'field', 'int'),
  field_vec2: new OscillaSocket('Field<vec2>', 'field', 'vec2'),
  domain: new OscillaSocket('Domain', 'signal', 'domain'),
};

// Map from CanonicalType to Socket
export function getSocketForSignalType(canonicalType: CanonicalType): OscillaSocket {
  const key = `${canonicalType.cardinality}_${canonicalType.payloadType}`;
  return Sockets[key] ?? Sockets.signal_float; // fallback
}
```

**Files:**
- `src/ui/editor/sockets.ts` (new)

---

### P2: OscillaNode Class & Block Mapping

**Goal:** Create Rete node class that represents an Oscilla block with proper inputs/outputs.

**Acceptance Criteria:**
- [ ] OscillaNode class extends ClassicPreset.Node
- [ ] Constructor takes BlockDef and creates inputs/outputs with correct sockets
- [ ] Node displays block type name and displayName
- [ ] Factory function `createNodeFromBlock(block: Block)` exists
- [ ] Factory function `createNodeFromBlockDef(def: BlockDef)` exists (for new blocks)

**Technical Notes:**

```typescript
// src/ui/editor/nodes.ts

import { ClassicPreset } from 'rete';
import { getSocketForSignalType, OscillaSocket } from './sockets';
import type { Block, BlockId } from '../../types';
import type { BlockDef } from '../../blocks/registry';

export class OscillaNode extends ClassicPreset.Node {
  public readonly blockId: BlockId;
  public readonly blockType: string;

  constructor(blockDef: BlockDef, blockId: BlockId, displayName?: string | null) {
    super(displayName || blockDef.label);
    this.blockId = blockId;
    this.blockType = blockDef.type;

    // Add inputs
    for (const input of blockDef.inputs) {
      const socket = getSocketForSignalType(input.canonicalType);
      this.addInput(input.id, new ClassicPreset.Input(
        socket,
        input.label,
        !input.optional // singleConnection = required inputs only accept one
      ));
    }

    // Add outputs
    for (const output of blockDef.outputs) {
      const socket = getSocketForSignalType(output.canonicalType);
      this.addOutput(output.id, new ClassicPreset.Output(socket, output.label));
    }
  }
}

export function createNodeFromBlock(block: Block, blockDef: BlockDef): OscillaNode {
  return new OscillaNode(blockDef, block.id, block.displayName);
}

export function createNodeFromBlockDef(blockDef: BlockDef, blockId: BlockId): OscillaNode {
  return new OscillaNode(blockDef, blockId);
}
```

**Files:**
- `src/ui/editor/nodes.ts` (new)

---

### P3: Bidirectional Sync (PatchStore ↔ Rete)

**Goal:** Keep Rete editor state synchronized with PatchStore. PatchStore is source of truth.

**Acceptance Criteria:**
- [ ] `syncPatchToEditor(patch, editor)` loads PatchStore state into Rete
- [ ] Editor updates when PatchStore changes (MobX reaction)
- [ ] Rete events (nodecreated, noderemoved, connectioncreated, connectionremoved) sync back to PatchStore
- [ ] No infinite loops (guard against sync cycles)
- [ ] Node positions stored in Rete Area, not in PatchStore (positions are editor-only state)

**Technical Notes:**

```typescript
// src/ui/editor/sync.ts

import { reaction } from 'mobx';

// Flag to prevent sync loops
let isSyncing = false;

// PatchStore → Rete (initial load and external changes)
export async function syncPatchToEditor(
  patch: Patch,
  editor: NodeEditor<Schemes>,
  area: AreaPlugin<Schemes>
) {
  if (isSyncing) return;
  isSyncing = true;

  try {
    // Clear existing
    for (const node of editor.getNodes()) {
      await editor.removeNode(node.id);
    }

    // Add nodes
    const nodeMap = new Map<BlockId, OscillaNode>();
    for (const block of patch.blocks.values()) {
      const def = getBlockDefinition(block.type);
      if (!def) continue;

      const node = createNodeFromBlock(block, def);
      await editor.addNode(node);
      nodeMap.set(block.id, node);

      // Position nodes (simple grid for now)
      // TODO: Use auto-arrange plugin or stored positions
    }

    // Add connections
    for (const edge of patch.edges) {
      const sourceNode = nodeMap.get(edge.from.blockId as BlockId);
      const targetNode = nodeMap.get(edge.to.blockId as BlockId);
      if (sourceNode && targetNode) {
        const conn = new ClassicPreset.Connection(
          sourceNode, edge.from.slotId,
          targetNode, edge.to.slotId
        );
        await editor.addConnection(conn);
      }
    }
  } finally {
    isSyncing = false;
  }
}

// Rete → PatchStore (user edits)
export function setupEditorToPatchSync(
  editor: NodeEditor<Schemes>,
  patchStore: PatchStore
) {
  editor.addPipe(context => {
    if (isSyncing) return context;

    if (context.type === 'nodecreated') {
      const node = context.data as OscillaNode;
      // Don't add to PatchStore here - we add first, then Rete syncs
      // This event fires after our addBlock, not before
    }

    if (context.type === 'noderemoved') {
      const node = context.data as OscillaNode;
      isSyncing = true;
      patchStore.removeBlock(node.blockId);
      isSyncing = false;
    }

    if (context.type === 'connectioncreated') {
      const conn = context.data;
      const sourceNode = editor.getNode(conn.source) as OscillaNode;
      const targetNode = editor.getNode(conn.target) as OscillaNode;

      isSyncing = true;
      patchStore.addEdge(
        { kind: 'port', blockId: sourceNode.blockId, slotId: conn.sourceOutput },
        { kind: 'port', blockId: targetNode.blockId, slotId: conn.targetInput }
      );
      isSyncing = false;
    }

    if (context.type === 'connectionremoved') {
      const conn = context.data;
      // Find and remove corresponding edge in PatchStore
      const edge = patchStore.edges.find(e =>
        e.from.slotId === conn.sourceOutput &&
        e.to.slotId === conn.targetInput
      );
      if (edge) {
        isSyncing = true;
        patchStore.removeEdge(edge.id);
        isSyncing = false;
      }
    }

    return context;
  });
}
```

**Files:**
- `src/ui/editor/sync.ts` (new)

---

### P4: Add Block from Library

**Goal:** Double-clicking a block type in Library adds it to the Rete editor.

**Acceptance Criteria:**
- [ ] Double-click block type in BlockLibrary → block appears in editor
- [ ] New block added to PatchStore first, then synced to Rete
- [ ] New block positioned at center of current viewport
- [ ] New block selected after creation
- [ ] Diagnostics update (GraphCommitted fires)

**Technical Notes:**

Modify BlockLibrary.tsx:
```typescript
const handleBlockDoubleClick = useCallback((type: BlockTypeInfo) => {
  // Add to PatchStore (source of truth)
  const blockId = rootStore.patch.addBlock(type.type, {}, {
    displayName: type.label
  });

  // Get editor reference and add node
  if (editorRef.current) {
    const { editor, area } = editorRef.current;
    const def = getBlockDefinition(type.type);
    if (def) {
      const node = createNodeFromBlockDef(def, blockId);
      editor.addNode(node).then(() => {
        // Position at viewport center
        const { x, y } = area.area.pointer; // or calculate center
        area.translate(node.id, { x, y });

        // Select the new node
        rootStore.selection.selectBlock(blockId);
      });
    }
  }
}, []);
```

Need to expose editor instance to BlockLibrary via context or ref.

**Files:**
- `src/ui/components/BlockLibrary.tsx` (modify)
- `src/ui/editor/EditorContext.tsx` (new - React context for editor access)

---

### P5: Delete Block via Context Menu

**Goal:** Right-click block in editor shows context menu with Delete option.

**Acceptance Criteria:**
- [ ] Right-click node in Rete editor shows context menu
- [ ] Context menu has "Delete" option
- [ ] Clicking Delete removes node from Rete
- [ ] Node removal syncs to PatchStore (via P3 sync)
- [ ] Connected edges also removed
- [ ] Selection cleared if deleted node was selected

**Technical Notes:**

Use rete-context-menu-plugin:
```bash
npm install rete-context-menu-plugin
```

```typescript
import { ContextMenuPlugin, Presets } from 'rete-context-menu-plugin';

const contextMenu = new ContextMenuPlugin<Schemes>({
  items(context) {
    if (context === 'root') {
      // Background context menu
      return {
        searchBar: false,
        list: [] // Could add "Add Block" submenu here
      };
    }

    // Node context menu
    return {
      searchBar: false,
      list: [
        {
          label: 'Delete',
          key: 'delete',
          handler: async () => {
            const node = context as OscillaNode;
            await editor.removeNode(node.id);
            // Sync handles PatchStore update
          }
        }
      ]
    };
  }
});

area.use(contextMenu);
```

**Files:**
- `src/ui/editor/ReteEditor.tsx` (add context menu plugin)
- `package.json` (add rete-context-menu-plugin)

---

## Dependencies

### NPM Packages (New)
```json
{
  "rete": "^2.0.0",
  "rete-react-plugin": "^2.0.0",
  "rete-area-plugin": "^2.0.0",
  "rete-connection-plugin": "^2.0.0",
  "rete-context-menu-plugin": "^2.0.0"
}
```

### Internal Dependencies
- PatchStore (exists)
- SelectionStore (exists)
- Block registry (exists)
- BlockLibrary component (exists, modify)

---

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Sync loops between Rete/PatchStore | Medium | High | isSyncing guard flag |
| Rete TypeScript types complexity | Medium | Low | Use type assertions where needed |
| Socket validation too strict/lenient | Low | Medium | Start permissive, tighten later |
| Node positioning issues | Medium | Low | Use auto-arrange in Sprint 2 |

---

## Verification

### Automated
- [ ] TypeScript compiles without errors
- [ ] All existing tests pass
- [ ] New tests for socket compatibility

### Manual Runtime
- [ ] Open app, see "Editor" tab in center panel
- [ ] Editor shows empty canvas with grid
- [ ] Can pan (drag background) and zoom (scroll)
- [ ] Double-click block in Library → node appears in editor
- [ ] Drag from output port to input port → connection created
- [ ] Drag incompatible ports → connection rejected (visual feedback)
- [ ] Right-click node → Delete → node removed
- [ ] Changes reflect in Blocks table and Connection Matrix
- [ ] Diagnostics console updates on changes
