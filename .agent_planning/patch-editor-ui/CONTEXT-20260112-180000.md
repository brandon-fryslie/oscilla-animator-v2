# Implementation Context: patch-editor-ui

**Date:** 2026-01-12
**Topic:** patch-editor-ui

---

## Key Codebase Insights

### 1. Store Architecture

The application uses MobX stores with a RootStore pattern:

```
RootStore
  ├── patch: PatchStore      # THE source of truth for blocks/edges
  ├── selection: SelectionStore  # UI selection state (IDs only)
  ├── viewport: ViewportStore    # Camera/zoom state
  ├── playback: PlaybackStore    # Animation playback
  ├── diagnostics: DiagnosticsStore
  └── events: EventHub           # Type-safe event bus
```

**Critical invariant:** SelectionStore only stores IDs, derives actual Block/Edge objects via computed getters from PatchStore.

### 2. PatchStore Mutations

All mutation methods exist and are already MobX actions:

```typescript
// src/stores/PatchStore.ts
addBlock(type, params, options): BlockId
removeBlock(id): void  // Also removes connected edges
updateBlockParams(id, params): void
updateBlockDisplayName(id, displayName): void
addEdge(from, to, options): string
removeEdge(id): void
updateEdge(id, updates): void
loadPatch(patch): void
clear(): void
```

### 3. GraphCommitted Events

RootStore already wires PatchStore mutations to emit `GraphCommitted` events:

```typescript
// src/stores/RootStore.ts line 74-95
reaction(
  () => ({ blockCount, edgeCount }),
  () => {
    this.events.emit({ type: 'GraphCommitted', ... });
  }
);
```

This means diagnostics will update automatically when commands mutate the patch.

### 4. Block Registry

Block definitions live in `src/blocks/registry.ts`:

```typescript
getBlockDefinition(blockType: string): BlockDef | undefined
getAllBlockDefs(): BlockDef[]
getBlockTypesByCategory(category: string): BlockDef[]
```

Each `BlockDef` includes:
- `type`, `label`, `category`, `description`
- `inputs: InputDef[]` with `id`, `label`, `type`, `optional`, `defaultSource`, `uiHint`
- `outputs: OutputDef[]`
- `form`, `capability`

### 5. BlockLibrary TODO Location

The TODO is at line 111-114:

```typescript
const handleBlockDoubleClick = useCallback((type: BlockTypeInfo) => {
  // TODO: Add block to canvas
  console.log('Add block:', type.type);
}, []);
```

### 6. BlockInspector Parameter Display

Currently displays parameters as read-only JSON (line 313-330):

```typescript
{block.params && Object.keys(block.params).length > 0 && (
  <pre>
    {JSON.stringify(block.params, null, 2)}
  </pre>
)}
```

Needs replacement with editable form inputs.

### 7. TableView Row Click Handler

Each block row click already selects the block (line 57-59):

```typescript
const handleRowClick = (blockId: BlockId) => {
  rootStore.selection.selectBlock(blockId);
};
```

Add `onContextMenu` handler to `BlockRow` for delete menu.

---

## Type References

### BlockId (branded string)

```typescript
// src/types/index.ts
declare const BlockIdBrand: unique symbol;
export type BlockId = string & { readonly [BlockIdBrand]: never };
export function blockId(s: string): BlockId { return s as BlockId; }
```

### Block Interface

```typescript
// src/graph/Patch.ts
interface Block {
  readonly id: BlockId;
  readonly type: BlockType;
  readonly params: Readonly<Record<string, unknown>>;
  readonly label?: string;
  readonly displayName: string | null;
  readonly domainId: string | null;
  readonly role: BlockRole;
}
```

### Edge Interface

```typescript
// src/graph/Patch.ts
interface Edge {
  readonly id: string;
  readonly from: Endpoint;
  readonly to: Endpoint;
  readonly enabled?: boolean;
  readonly sortKey?: number;
}

interface Endpoint {
  readonly kind: 'port';
  readonly blockId: string;
  readonly slotId: string;
}
```

---

## Implementation Patterns

### MobX Observer Pattern

All components that read from stores use `observer`:

```typescript
import { observer } from 'mobx-react-lite';

export const MyComponent = observer(function MyComponent() {
  // Access rootStore.patch.blocks - will re-render on changes
});
```

### Store Access

Components import the singleton rootStore:

```typescript
import { rootStore } from '../../stores';
```

### Command Pattern (to implement)

Each command:
1. Captures pre-execution state in constructor or execute()
2. Calls PatchStore action in execute()
3. Reverses with stored state in undo()

---

## Edge Cases to Handle

### 1. Block ID Restoration

When restoring a deleted block, we need the **same ID** to restore edges correctly.

**Solution:** Add `restoreBlock(block: Block)` that inserts with existing ID.

### 2. Edge Dependency on Blocks

Edges reference blockIds. If we try to restore an edge before its block, it will reference a non-existent block.

**Solution:** In `RemoveBlockCommand.undo()`, restore block first, then edges.

### 3. Redo Stack Clearing

When user does undo then performs a new action, the redo stack must be cleared.

**Solution:** In `CommandStore.execute()`, truncate history to current index before pushing.

### 4. Selection After Delete

If the deleted block was selected, selection becomes invalid.

**Solution:** Clear selection in `RemoveBlockCommand.execute()` if deleting selected block.

---

## Critical Files

| File | Purpose |
|------|---------|
| `src/stores/PatchStore.ts` | Core mutations to wrap; needs restoreBlock/restoreEdge |
| `src/stores/RootStore.ts` | Add CommandStore integration |
| `src/ui/components/BlockLibrary.tsx` | Wire double-click at line 111-114 |
| `src/ui/components/BlockInspector.tsx` | Replace JSON display with forms |
| `src/ui/components/TableView.tsx` | Add context menu for delete |
| `src/ui/components/app/Toolbar.tsx` | Add undo/redo buttons |
| `src/ui/components/app/App.tsx` | Add keyboard shortcuts |
