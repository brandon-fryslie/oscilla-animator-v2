# Evaluation: CanonicalType System Migration
Timestamp: 2026-01-28-191553
Git Commit: 6368e83

## Executive Summary
**Overall: 60% complete** | **Critical issues: 3** | **Tests reliable: PARTIAL**

Infrastructure is solid (CanonicalType, UnitSystem, 5-axis Extent all implemented correctly). Integration is 0% complete. All 8 work items from gap analysis are NOT STARTED or PARTIAL. No runtime validation exists for type invariants.

**Foundation**: Strong ✅  
**Integration**: Missing ❌  
**Validation**: None ❌

---

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| Canonical types tests | ✅ PASS | 43/43 tests pass (construction, unification) |
| EventExpr has type field | ❌ FAIL | types.ts:323-354 — NO type: CanonicalType field |
| getManyInstance helper exists | ❌ FAIL | Not found in src/core/canonical-types.ts |
| InstanceId in core/ids.ts | ❌ FAIL | Still in src/compiler/ir/Indices.ts:71 |
| FieldExprArray semantics | ⚠️ STUB | types.ts:285-289 — no backing, marked for deletion |
| ConstValue discriminated union | ❌ FAIL | types.ts:98 uses `number \| string \| boolean` |
| Axis enforcement pass | ❌ FAIL | No pass exists in src/compiler/passes-v2/ |
| reduce_field naming | ❌ INCONSISTENT | types.ts:167 uses snake_case, rest use camelCase |

**Tests cover**: Type construction, unification, axis helpers  
**Tests DO NOT cover**: EventExpr invariants, axis enforcement, getManyInstance, ConstValue discrimination

---

## Missing Checks

Implementer should create these **persistent validation checks**:

1. **EventExpr Type Invariant Validator**
   - Location: `src/core/__tests__/canonical-types.test.ts`
   - Must verify: All EventExpr have `payload.kind === 'bool'`, `unit.kind === 'none'`, `extent.temporality === discrete`
   - Test against: EventExprConst, EventExprPulse, EventExprWrap, EventExprCombine, EventExprNever
   
2. **Axis Enforcement Integration Test**
   - Location: New file `src/compiler/passes-v2/__tests__/axis-enforcement.test.ts`
   - Must verify: Pass rejects invalid axis combinations, emits AxisInvalid diagnostic
   - Negative cases: SigExpr with temporality=discrete, FieldExpr with cardinality=zero
   
3. **getManyInstance Runtime Test**
   - Location: `src/core/__tests__/canonical-types.test.ts`
   - Must verify: Returns InstanceRef when cardinality=many, null otherwise
   - Edge case: Handles cardinality var (should return null)

4. **ConstValue Payload Matching Test**
   - Location: New file `src/compiler/ir/__tests__/const-values.test.ts`
   - Must verify: ConstValue.kind matches CanonicalType.payload.kind
   - Negative case: vec2 value with float payload should fail type check

---

## Findings

### C-1: EventExpr Type Field (CRITICAL)
**Status**: NOT STARTED  
**Evidence**: `src/compiler/ir/types.ts:323-354` — All 5 EventExpr variants lack `type: CanonicalType`  
**Issues**:
- EventExprConst (L330-333): Only has `fired: boolean`, no type metadata
- EventExprPulse, EventExprWrap, EventExprCombine, EventExprNever: Same pattern
- **Runtime Impact**: Cannot enforce temporality=discrete invariant, cannot track instance cardinality for per-instance events
- **Blocking**: C-4 (axis enforcement needs types to validate)

**Spec Contract** (15-FiveAxesTypeSystem-Conclusion.md:69-100, SUMMARY.md:61):
```typescript
// REQUIRED INVARIANTS (hard checked by axis enforcement):
type.payload.kind === 'bool'           // events are fired/not-fired
type.unit.kind === 'none'              // events are dimensionless
type.extent.temporality === 'discrete' // DEFINITION: events fire at instants
// cardinality can be 'one' OR many(instanceRef) for per-instance events
```

**Confidence**: Implementation is straightforward (add field, construct types with invariants), but touches 50+ construction sites.

---

### C-2: Shared IDs Module (PARTIAL)
**Status**: PARTIAL — File exists but InstanceId/DomainTypeId not migrated  
**Evidence**:
- `src/core/ids.ts:1-45` — Axis var IDs exist, InstanceId/DomainTypeId missing
- `src/compiler/ir/Indices.ts:65-71` — InstanceId defined here (wrong module boundary)
- `src/compiler/ir/types.ts:435` — `readonly id: string // InstanceId` comment indicates intent

**Issues**:
- **Boundary Violation**: canonical-types.ts (core module) cannot import from Indices.ts (compiler module)
- **String Leakage**: 5 Step types use `instanceId: string` not branded InstanceId (L540, 546, 587, 598, 681)
- **Inconsistency**: Factory functions exist in both places (ids.ts:34-35, Indices.ts:159-161)

**Migration Path** (00-exhaustive-type-system.md:1-45):
1. Move InstanceId, DomainTypeId type definitions to core/ids.ts
2. Export factory functions from core/ids.ts (may keep re-exports in Indices.ts for compat)
3. Update imports: types.ts, canonical-types.ts, all Step definitions
4. Fix 5 string leakage sites

**Blocking**: C-5 (getManyInstance needs InstanceId), C-6 (string leakage fix needs branded type)

**Confidence**: Mechanical refactor, low risk. Estimate 20 import sites.

---

### C-3: reduce_field Naming (COSMETIC)
**Status**: NOT STARTED  
**Evidence**: `src/compiler/ir/types.ts:167` — `readonly kind: 'reduce_field'` (snake_case)  
**Issues**:
- All other kind literals use camelCase: 'map', 'zip', 'zipSig', 'stateRead'
- Inconsistency spreads: SignalEvaluator.ts uses 'reduce_field', tests use snake_case
- 17 total occurrences (2 in types.ts, 1 in runtime, 11 in tests, 3 in design docs)

**Fix**: Rename `'reduce_field'` → `'reduceField'` everywhere

**Confidence**: HIGH — Simple find-replace, no semantic changes. Tests will catch missed sites.

---

### C-4: Axis Enforcement Pass (MISSING)
**Status**: NOT STARTED  
**Evidence**: No file matching "axis.*validation" pattern in src/compiler/passes-v2/  
**Issues**:
- **No validation exists**: Type invariants (EventExpr temporality=discrete) never checked
- **No diagnostic category**: AxisInvalid diagnostic type undefined
- **Spec violation**: 15-FiveAxesTypeSystem-Conclusion.md:69-100 requires centralized enforcement gate

**Spec Requirements** (SUMMARY.md:69, 00-exhaustive.md:394-461):
- **Pure checker**: Axis-shape validity ONLY (no inference, no adapters, no coercions)
- **What to check**:
  - SigExpr: temporality=continuous (discrete forbidden)
  - EventExpr: temporality=discrete, payload=bool, unit=none
  - FieldExpr: cardinality≠zero (zero forbidden for fields)
  - State: binding∈{strong,identity} for state reads
- **Output**: Single diagnostic category `AxisInvalid` with location + reason

**Blocking**: BLOCKS U-1 (ValueExpr IR — must not start until axis enforcement passes)

**Confidence**: MEDIUM — Clear spec, but needs diagnostic infrastructure + 50+ test cases for coverage.

---

### C-5: Remove instanceId from FieldExpr (BLOCKED by C-1, C-2)
**Status**: NOT STARTED  
**Evidence**: `src/compiler/ir/types.ts:265,273,282` — 3 FieldExpr nodes have `instanceId?: InstanceId`  
**Issues**:
- **Violates Invariant I1** (15-FiveAxesTypeSystem:69): "Single authority" — instanceId duplicates type.extent.cardinality authority
- **Optional field smell**: If instanceId is present, it MUST match getManyInstance(type). Why store it twice?
- **FieldExprMap, FieldExprZip, FieldExprZipSig**: All have optional instanceId

**Spec Fix** (SUMMARY.md:70-76):
1. DELETE instanceId field from Map/Zip/ZipSig
2. Implement getManyInstance(type: CanonicalType): InstanceRef | null helper
3. Callers derive instance via: `const inst = getManyInstance(expr.type)`
4. Enforce: Map output cardinality = input cardinality (checked by axis enforcement)

**Note**: FieldExprIntrinsic KEEPS instanceId (L237) — it's required for intrinsic property lookup, not derivable from type alone.

**Blocked By**: C-1 (needs EventExpr types first), C-2 (needs InstanceId in core/ids.ts)

**Confidence**: MEDIUM — getManyInstance is 5 lines, but 30+ call sites need updating.

---

### C-6: Fix String Leakage in Steps (BLOCKED by C-2)
**Status**: NOT STARTED  
**Evidence**: 5 Step types use `instanceId: string` not `InstanceId`:
- StepMaterialize (L540)
- StepRender (L546)
- StepContinuityMapBuild (L587)
- StepContinuityApply (L598)
- StateMappingField (L681)
- InstanceDecl (L435) — has comment `// InstanceId` indicating known issue

**Issues**:
- **Type safety loss**: String can be any value, no branding protection
- **Runtime hazard**: Easy to pass wrong ID (e.g., BlockId where InstanceId expected)
- **Inconsistency**: Other FieldExpr correctly use InstanceId, Steps use string

**Fix**: Replace `instanceId: string` with `instanceId: InstanceId` at 6 sites

**Blocked By**: C-2 (InstanceId must exist in core/ids.ts first)

**Confidence**: HIGH — Purely mechanical type change, TypeScript will find all call sites.

---

### C-7: Delete FieldExprArray (NO DEPENDENCIES)
**Status**: NOT STARTED  
**Evidence**: `src/compiler/ir/types.ts:285-289`, DEFERRED-ms5.12-FieldExprArray.md  
**Issues**:
- **No semantics**: No slot, channel, or state backing reference
- **No lifetime rules**: When is array created/destroyed?
- **No runtime storage**: What allocates the array?
- **Usage**: Only in type union (L218), never constructed in IR builder

**Spec Directive** (SUMMARY.md:64): Delete until it has:
1. Concrete backing store (StateSlotId or equivalent)
2. Lifetime rules (creation, mutation, destruction)
3. Runtime storage contract (allocator integration)

**Action**: Remove from FieldExpr union (L218), delete interface definition (L285-289)

**Impact**: Zero — grep shows 12 matches, all in planning docs or unused type definition

**Confidence**: HIGH — No production usage, safe to delete immediately.

---

### C-8: ConstValue Discriminated Union (BLOCKED by C-5)
**Status**: NOT STARTED  
**Evidence**:
- `src/compiler/ir/types.ts:98` — SigExprConst uses `value: number | string | boolean`
- FieldExprConst (L225-230) — same pattern
- No ConstValue type exists in implementation

**Spec Definition** (00-exhaustive-type-system.md:275-293):
```typescript
export type ConstValue =
  | { readonly kind: 'float'; readonly value: number }
  | { readonly kind: 'int'; readonly value: number }
  | { readonly kind: 'bool'; readonly value: boolean }
  | { readonly kind: 'vec2'; readonly value: readonly [number, number] }
  | { readonly kind: 'vec3'; readonly value: readonly [number, number, number] }
  | { readonly kind: 'color'; readonly value: readonly [number, number, number, number] }
  | { readonly kind: 'cameraProjection'; readonly value: string };
```

**Issues**:
- **Violates Invariant I5** (15-FiveAxesTypeSystem:95): "Const literal shape matches payload"
- **No type safety**: Can construct SigExprConst with `value: "string"` and `type.payload.kind: 'float'`
- **Runtime hazard**: Renderer assumes value shape matches payload, crash if wrong

**Fix**:
1. Define ConstValue discriminated union in canonical-types.ts or types.ts
2. Replace `value: number | string | boolean` with `value: ConstValue`
3. Add constValueMatchesPayload(payload: PayloadType, v: ConstValue): boolean validator
4. Axis enforcement pass checks this invariant

**Blocked By**: C-5 (getManyInstance work establishes pattern), conceptually C-1 (needs type field to check against)

**Confidence**: MEDIUM — Clear spec, but 40+ const construction sites need updating.

---

## Ambiguities Found

| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| **getManyInstance null handling** | What should callers do when getManyInstance returns null? Error? Skip? | Spec says "returns null if cardinality≠many" but doesn't specify caller contract | If callers crash on null, breaks cardinality=one expressions |
| **Axis enforcement timing** | Does axis enforcement run before or after type inference? | Spec says "after normalization, inference, type assignment" but pass order unclear | If before inference, can't validate inferred types |
| **FieldExprIntrinsic.instanceId** | Why does FieldExprIntrinsic keep instanceId when others lose it? | Spec says "needed for intrinsic value lookup" but doesn't explain why not derivable | If wrong reason, we're violating I1 (single authority) |
| **EventExpr cardinality** | Can EventExpr have cardinality=many(instance)? Spec says "one OR many" but no examples | Assumed yes based on spec text "cardinality may be one OR many(instance)" | If no, getManyInstance on EventExpr is always null, simplifying logic |
| **ConstValue vec2/vec3 mutability** | Are ConstValue tuple values readonly at element level? | Spec shows `readonly [number, number]` but JavaScript allows mutation | If not deeply immutable, breaks CanonicalType immutability contract |

**Critical Ambiguity** (requires clarification before C-5):
- **getManyInstance contract**: Spec defines signature (00-exhaustive:230-235) but not caller obligations. Need decision: (a) callers must check null + handle both cases, (b) callers assume non-null (would crash on cardinality=one), or (c) helper throws error if cardinality≠many.

---

## Recommendations

### Sprint 1: Foundation (P1, No Dependencies)
1. **C-7: Delete FieldExprArray** (1 hour) — Safe, zero usage
2. **C-3: Rename reduce_field → reduceField** (2 hours) — Mechanical, low risk
3. **C-2: Migrate InstanceId to core/ids.ts** (4 hours) — Unblocks C-5, C-6

**Success Criteria**: All imports resolve, tests pass, no string leakage in new code

### Sprint 2: Core Type System (P1, Depends on Sprint 1)
4. **C-1: Add type: CanonicalType to EventExpr** (6 hours) — Critical, unblocks C-4
   - Add field to 5 EventExpr variants
   - Update 30+ construction sites with invariant enforcement
   - Add invariant tests (payload=bool, unit=none, temporality=discrete)
5. **C-6: Fix string → InstanceId leakage** (2 hours) — Depends on C-2

**Success Criteria**: EventExpr typed, tests verify invariants, no string leakage

### Sprint 3: Validation & Helpers (P2, Depends on Sprint 2)
6. **C-5: Remove FieldExpr.instanceId, add getManyInstance** (8 hours) — Depends on C-1, C-2
   - Implement getManyInstance helper (5 lines)
   - Remove instanceId from Map/Zip/ZipSig (3 fields)
   - Update 30+ call sites to derive instance
   - **BLOCKER**: Need getManyInstance null-handling contract decision
7. **C-4: Axis Enforcement Pass** (12 hours) — Depends on C-1
   - Create pass skeleton + diagnostic category
   - Implement EventExpr invariant checks (temporality=discrete, payload=bool, unit=none)
   - Implement SigExpr invariant checks (temporality=continuous)
   - Implement FieldExpr invariant checks (cardinality≠zero)
   - 50+ test cases (positive + negative)

**Success Criteria**: Axis enforcement pass exists, catches violations, gates U-1 work

### Sprint 4: Const Values (P3, Depends on Sprint 3)
8. **C-8: ConstValue Discriminated Union** (6 hours) — Depends on C-5
   - Define ConstValue type
   - Replace loose unions with ConstValue
   - Update 40+ const construction sites
   - Add constValueMatchesPayload validator
   - Add tests (positive + negative)

**Success Criteria**: All const values payload-shaped, axis enforcement checks ConstValue

**Total Estimate**: 41 hours across 4 sprints

---

## Verdict

- [x] **CONTINUE** — Issues clear, implementer can fix
- [ ] PAUSE — Ambiguities need clarification

**Rationale**:
- ✅ **Foundation solid**: CanonicalType, UnitSystem, 5-axis Extent all correct
- ✅ **Specs complete**: All 8 work items have clear specifications with line numbers
- ✅ **No hidden work**: Exploration found zero TODO/FIXME, no partial implementations
- ✅ **Dependencies clear**: C-2 → C-5,C-6 | C-1 → C-4,C-5 | C-4 gates U-1
- ⚠️ **One ambiguity**: getManyInstance null handling needs decision (can resolve during C-5)

**Critical Path**: C-2 → C-1 → C-4 (axis enforcement) → U-1 (next phase)

**Recommendation**: Start Sprint 1 immediately (C-7, C-3, C-2). Resolve getManyInstance contract question before starting C-5.

---

## Next Action

**Implementer should**:
1. Delete FieldExprArray (C-7) — 1 hour, zero risk
2. Rename reduce_field → reduceField (C-3) — 2 hours, grep + replace
3. Migrate InstanceId to core/ids.ts (C-2) — 4 hours, unblocks two work items
4. **Then pause**: Get getManyInstance null-handling decision before C-5

**Evaluator confidence**: HIGH — 60% infrastructure complete, 0% integration complete, but all 8 items have clear specs and evidence. No runtime surprises found (tests pass, no silent fallbacks).
