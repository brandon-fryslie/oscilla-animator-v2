# EVALUATION: Design Documentation State

**Date**: 2026-01-07
**Topic**: Design Docs Analysis & Roadmap
**Evaluator**: Explore Agent

---

## WHAT EXISTS: Complete Inventory

### Spec Documents (design-docs/spec/)

**Core Specifications:**
- `INDEX.md` - Navigation index for the unified specification
- `00-invariants.md` - 8 core non-negotiable invariants (Graph/Compile boundaries, Time, Multi-Writer Inputs, Buses, State/Feedback, Types, Determinism, Runtime Continuity)
- `AMBIGUITIES.md` - 4 explicitly documented open decisions

**Compiler Subsystem:**
- `compiler/01-type-system.md` - Worlds (Scalar/Signal/Field/Event), TypeDesc, Domains, Compatibility
- `compiler/04-compilation.md` - Pipeline (Normalize → Validate → Compile), GraphNormalization responsibilities, Input Resolution

**Graph Subsystem:**
- `graph/02-time.md` - TimeRoot, TimeModel (finite/infinite), TimeCtx, Rails
- `graph/03-buses.md` - CombineMode, CombinePolicy, BusBlocks, Rails, Deterministic Ordering
- `graph/06-blocks.md` - Block Definition, Block Roles, Derived Blocks, Categories
- `graph/07-transforms.md` - Adapter/Lens blocks (unary transforms), Transform Block Catalog (50+ blocks)
- `graph/08-primitives-composites.md` - Partial (recommended primitive set and starter composite library)
- `graph/stateful-blocks.md` - 4 stateful blocks detailed
- `graph/basic-12-blocks.md` - Minimal working block set

**Runtime Subsystem:**
- `runtime/05-runtime.md` - Runtime execution model (partial)

**Rendering Subsystem:**
- `renderer/09-renderer.md` - Renderer contracts (incomplete)
- `renderer/RENDER-PIPELINE.md` - Render IR details

**Time Subsystem:**
- `time/10-phase-matching-system.md` - Phase matching rules
- `time/11-phase-unwrap-IMPORTANT.md` - Phase unwrap semantics (marked critical)

### Final System Invariants (design-docs/final-System-Invariants/)

- `README.md` - States these are FINAL core invariants, rest is WIP (marked "cannot be violated")
- `1-Core-Laws.md` - 27 foundational laws across 8 categories (Time/Continuity, Graph Semantics, Fields/Identity, Rendering, Debuggability, Performance, Scaling)
- `2-Core-Checklist.md` - Prioritized implementation checklist with acceptance criteria (BAKE NOW vs LAYER LATER)
- `3-Agent-Checklist.md` - Agent implementation guidance
- `4-Agent-Checklist-2.md` - Additional agent guidance
- `5-RuntimeState.md` - Detailed specification for slot allocation, offset computation, runtime state management
- `6-program.md` - Program structure
- `7-Canonical-IR-Program-Contract.md` - IR program contract
- `13-DefaultSources.md` - Detailed specification of Default Source concept, naming, semantics
- `14-Stateful-Primitives.md` - 4 stateful blocks specification
- `15-Block-Edge-Roles.md` - Block and edge role specifications
- `16-Graph-Normalization.md` - RawGraph → NormalizedGraph transformation
- `Palette.md` - Palette system
- `Rail.md` - Rail system specification
- `Rail-Modulation-and-Feedback.md` - Rail modulation details
- `Unified-Transforms-Architecture.md` - Transform system architecture

### Other Documentation

- `ANAYLSIS-WRONG-CONFUSED-AGENT.md` - Complete architectural analysis report from previous agent (detailed, accurate)

---

## WHAT'S MISSING: Critical Gaps

### 1. Missing Specs

- `graph/08-primitives-composites.md` - Referenced but not fully reviewed
- `runtime/05-runtime.md` - Runtime execution model incomplete
- `renderer/09-renderer.md` & `renderer/RENDER-PIPELINE.md` - Renderer contracts incomplete
- No UI specification document (spec/ui/ directory appears empty)
- No complete primitive block catalog
- No test specification document
- No acceptance criteria document beyond checklists

### 2. Incomplete Coverage

- Event semantics (mentioned in AMBIGUITIES but not fully specified)
- Custom combine mode registry location and validation rules (AMBIGUITY #1)
- Stateful primitive world coverage (which primitives work on signal/field/event) (AMBIGUITY #2)
- Default source catalog enumeration (AMBIGUITY #3)
- Event combine semantics beyond boolean fired (AMBIGUITY #4)

### 3. Architectural Decisions Missing

- No explicit specification for hot-swap state continuity rules (Core Law 1.3 references but detail is in RuntimeState.md)
- No explicit specification for deterministic replay input recording format
- No specification for the "DomainId" runtime representation or stability rules
- No specification for FieldExpr canonicalization/structural sharing algorithm

### 4. Testing & Validation

- No test specification document
- No acceptance criteria document beyond checklists
- No specification for error taxonomy (mentioned in Core Law 18 but not detailed)

### 5. Integration Points

- No specification for how UI connects to graph/compiler/runtime
- No specification for transaction/edit snapshot model
- No specification for asset system (mentioned in Core Law 26)

---

## WHAT NEEDS CHANGES: Contradictions & Ambiguities

### 1. Contradictions Between Documents

**Stateful Blocks Count:**
- `00-invariants.md` line 51: "4 stateful blocks: UnitDelay, Phazor, and 2 more" [INCOMPLETE]
- `06-blocks.md` line 38: "ONLY these 4 blocks are stateful. All others are stateless: UnitDelay" [INCOMPLETE - only lists 1]
- `graph/stateful-blocks.md`: Lists 4 complete: UnitDelay, Accumulator, SampleAndHold, PhaseUnwrapper
- `final-System-Invariants/14-Stateful-Primitives.md`: Lists 4 different: UnitDelay, Lag, Phasor, SampleAndHold

**Conflicts:**
- Accumulator vs Lag (different primitives with different semantics)
- PhaseUnwrapper vs Phasor (completely different purposes)
- "Phazor" vs "Phasor" (typo or different block?)

**TimeRoot Description:**
- Described in `graph/02-time.md` with one emphasis
- Described in `final-System-Invariants/1-Core-Laws.md` with slightly different emphasis

**Transforms vs Blocks:**
- `00-invariants.md` states "Everything is a block or wire at compile time"
- `07-transforms.md` says Adapters/Lenses are "UI affordances that normalize into derived blocks"
- This is clarified but could be more explicit about timing (UI-time vs compile-time)

### 2. Ambiguous Requirements

**AMBIGUITY #1: CombineMode Registration**
- Where do custom combine reducers live (block registry vs global combine registry)?
- Unresolved

**AMBIGUITY #2: Stateful Primitives Scope**
- Should UnitDelay/Lag/SampleAndHold operate on all worlds (signal, field, event), or only on signal?
- Unresolved

**AMBIGUITY #3: Default Values**
- Standard default values per TypeDesc (e.g., color, vec2, phase) are not yet enumerated
- Unresolved

**AMBIGUITY #4: Event Semantics**
- Precise event payload shape and edge-detection behavior remain unspecified
- Unresolved

### 3. Specification Gaps Requiring Decisions

**Stateful Block Count:**
- Core Invariant states "4 stateful blocks" but only lists "UnitDelay, Phazor, and 2 more"
- The "2 more" are undefined in this document

**Phase Domain Boundaries:**
- Spec discusses phase wrapping and unwrap but doesn't formally define phase range (0..1, 0..2π, or configurable?)

**Domain Identity Mechanics:**
- Spec says "Domains provide stable element identity" and "IDs survive edits"
- Doesn't specify: How are element IDs generated? What makes them stable across patch edits?

**Combine Determinism:**
- Spec defines ordering key
- Doesn't specify: What happens when priorities are equal? How are edge IDs derived for deterministic breaks?

### 4. Implementation vs Spec Mismatch

- Spec defines 4 stateful blocks, but current v2 implementation doesn't have Phasor implemented
- Spec defines comprehensive Transforms catalog (15+ blocks) but v2 doesn't implement most adapters/lenses yet
- Spec defines Rails system (time, phaseA, phaseB, pulse, energy, palette, progress) but v2 doesn't materialize these blocks
- Spec defines full FieldExpr/SignalExpr with caching but v2 has basic IR implementation

### 5. Outdated/Incomplete Sections

- `16-Graph-Normalization.md` exists but contains critical graph surgery rules not reflected in current code
- Agent checklists (3, 4) exist but may reference outdated tasks
- V1 codex shows heavy flux in UI redesign docs

### 6. INDEX.md File Path Issues

**All paths are wrong** - INDEX.md references flat paths but files are in subdirectories:
- `01-type-system.md` → Actually at `compiler/01-type-system.md`
- `02-time.md` → Actually at `graph/02-time.md`
- `03-buses.md` → Actually at `graph/03-buses.md`
- `04-compilation.md` → Actually at `compiler/04-compilation.md`
- `05-runtime.md` → Actually at `runtime/05-runtime.md`
- `06-blocks.md` → Actually at `graph/06-blocks.md`
- `07-transforms.md` → Actually at `graph/07-transforms.md`
- `08-primitives-composites.md` → Actually at `graph/08-primitives-composites.md`
- `09-renderer.md` → Actually at `renderer/09-renderer.md`

**Missing from INDEX:**
- `graph/stateful-blocks.md`
- `graph/basic-12-blocks.md`
- `renderer/RENDER-PIPELINE.md`
- `time/10-phase-matching-system.md`
- `time/11-phase-unwrap-IMPORTANT.md`

---

## DEPENDENCIES & RISKS

### Prerequisites for Implementation

**Critical Path (must be done first):**
1. Lock TimeModel (finite/infinite and derive rules)
2. Lock Domain representation and element ID stability rules
3. Lock DefaultSource materialization timing
4. Lock bus/rail block schema
5. Finalize the 4 stateful blocks (Phasor + 2 more unspecified)
6. Finalize CombineMode registry location

**Implementation Blockers:**
- **Stateful blocks incomplete:** Core Laws reference 4 but only UnitDelay is consistently specified
- **Default source catalog missing:** Every type needs a neutral value defined
- **Event semantics undefined:** Blocks with event inputs/outputs can't be compiled until event payloads + combine rules are specified
- **Rails not specified:** The 7 rails are mentioned but their type signatures, default values, and combine policies are not fully spelled out

### Risks from V1 Legacy

From `/Users/bmf/code/oscilla-animator_codex` analysis:

**Architectural Complexity:**
- V1 has 481k+ lines of documentation
- v2 must avoid inheriting overlapping concepts (Connection/Publisher/Listener in v1 are unified in v2 as Edge)

**Transform/Adapter Proliferation:**
- V1 has 15+ transform types with overlapping purposes
- v2 spec locks a catalog but implementation is incomplete

**UI/Compiler Coupling:**
- V1 recommendations suggest unifying Connections/DefaultSources/Transforms into single abstractions
- v2 design docs this but code doesn't fully implement

**Bus Semantics Drift:**
- V1 has complex bus combination logic
- v2 simplifies but CombineMode registry location still open

### Key Differences from V1 Worth Preserving

- **Single IR approach:** V2 IR-as-data (vs V1 closure-based) is architecturally superior
- **Type system clarity:** V2 Worlds/TypeDesc/Domains split is cleaner than V1's complex TypeWorld + CoreDomain
- **Determinism-first mindset:** V2 explicitly locks determinism rules; V1 was more exploratory
- **Explicit normalization:** V2's GraphNormalization phase (not mutated by compiler) prevents subtle bugs V1 encountered

---

## CRITICAL AMBIGUITIES (Must Resolve Before Implementation)

### High Priority (Blocking Implementation)

**1. STATEFUL PRIMITIVES**
- Core Invariant says "4 stateful blocks: UnitDelay, Phazor, and 2 more"
- Which blocks are the "2 more"? Options mentioned: Lag, SampleAndHold, Integrator?
- Do all 4 support all worlds (signal/field/event) or only signal?
- For field-world state, what is element identity scope?
- **Resolution needed:** Explicit list + world/domain coverage matrix

**2. DEFAULT SOURCE CATALOG**
- Spec requires "neutral values per TypeDesc"
- number → 0, but what about: time, rate, duration, angle, color, vec2/vec3, phase, custom domains?
- **Resolution needed:** Complete catalog with semantic justification per domain

**3. BUSES & RAILS SCHEMA**
- Spec mentions 7 rails but doesn't specify types
- time rail, phase rails (A, B), pulse rail, energy rail, palette rail, progress rail
- **Resolution needed:** Formal rail definitions with type signatures and default combine modes

**4. CUSTOM COMBINE MODE REGISTRY**
- Should custom combiners live in BlockRegistry or separate?
- How are custom reducers validated against TypeDesc?
- Can a custom combiner depend on block parameters or only on input values?
- **Resolution needed:** Registry architecture + validation rules + examples

**5. EVENT SEMANTICS**
- Event payload type: Just `{ fired: boolean }` or can it carry data?
- If event carries data: what happens when multiple publishers fire?
- Edge detection: Rising edge only, or level + edge tracking?
- Can events be buses? Can they be combined with `or` / `and` / custom?
- **Resolution needed:** Event type definition + combine rules for multi-writer events

### Medium Priority (Design Clarity)

**6. DOMAIN ELEMENT IDENTITY**
- When does an element "change identity"?
- How are element IDs assigned initially?
- If a GridDomain becomes a PathDomain: do elements keep IDs?
- **Resolution needed:** Element ID assignment algorithm + edit stability rules

**7. PHASE DOMAIN RANGE**
- Is phase always 0..1 in stored values? Or 0..2π? Or context-dependent?
- PhaseToNumber conversions: what's the default output range?
- **Resolution needed:** Locked phase representation + conversion semantics

**8. TRANSFORM BLOCK CATALOG IMPLEMENTATION**
- Which blocks are MUST_HAVE for v2 launch vs NICE_TO_HAVE?
- Which blocks require extra inputs?
- How are these integrated into lens/adapter UI?
- **Resolution needed:** MVP transform set + implementation plan

**9. HOT-SWAP STATE CONTINUITY RULES**
- When StateId matches but layout changes: what transformations are legal?
- If an input now requires a different default source: do we keep the old state?
- **Resolution needed:** State migration rules + examples

**10. MATERIALIZATION SCHEDULING**
- When is a field forced to materialize?
- Can a materialized field be reused across frames if domain/upstream unchanged?
- **Resolution needed:** Cache key definition + invalidation rules

---

## PATTERNS WORTH PRESERVING FROM V1

From `/Users/bmf/code/oscilla-animator_codex` (V1 codex):

### Compiler Architecture Recommendations (Excellent)

- Unify Connection/Publisher/Listener into single Edge type ✓ (v2 spec does this)
- Unify DefaultSources with blocks ✓ (v2 spec does this)
- Unify Lenses/Adapters into TransformStep ✓ (v2 spec does this)
- The v1 recommendations document shows these were hard-won insights

### Deep Audit Reports Show

- Debug infrastructure is crucial (V1 learned this the hard way)
- DebugIndex + TraceController pattern is solid
- Debug probes in schedule are the right approach
- V2 spec captures this in Core Law 5 (Debug system prerequisites)

### Block Lowering Pattern

- V1's multi-pass system is referenced in v2 as inspiration
- V2 simplifies to single-pass linear compile, which is better
- Keep the block lowering pattern, but not the passes framework

---

## PATTERNS TO AVOID FROM V1

1. **Over-engineering of compiler passes:** V1 has separate passes for every concern; v2's unified spec is simpler
2. **Bus complexity drift:** V1's Publisher/Listener complexity suggests buses grew organically; v2 spec locks them down early
3. **Transform proliferation:** V1's lens/adapter catalog is overwhelming (50+ variants); v2 should curate aggressively
4. **Dual type systems:** V1 shows evidence of type system evolution; v2 correctly has only one unified TypeDesc

---

## VERDICT

**Status**: CONTINUE with planning

**Rationale**:
- Foundation is solid (Core Laws are excellent)
- 10+ critical design decisions still open
- Spec is 75% complete, 25% ambiguous
- INDEX.md needs complete rewrite (all paths wrong)
- Multiple contradictions between spec files need reconciliation
- Implementation is ~40% coverage of spec

**Recommendation**: Proceed to planning phase to create:
1. Contradictions/Ambiguities Report
2. Updated INDEX.md
3. Phased Implementation Roadmap
4. V1 Pattern Analysis

This evaluation provides comprehensive context for sprint planning.
