# V1 Pattern Analysis: Preserve vs Avoid

**Date**: 2026-01-07
**Sprint**: design-docs-audit
**Sources**: ANAYLSIS-WRONG-CONFUSED-AGENT.md, ARCHITECTURAL-REFACTOR-COMPLETE.md

---

## Executive Summary

V1 (oscilla-animator_codex) established strong architectural foundations that V2 successfully preserves. The analysis identifies **7 patterns worth preserving** and **6 anti-patterns to avoid**. The god block refactor (PositionSwirl ‚Üí 5 composable blocks) demonstrates V2's commitment to simplicity and composability.

**Key Insight**: V1's linear compiler pipeline, block registry pattern, and IRBuilder abstraction are excellent and should remain unchanged. The anti-patterns (god blocks, duplicate type systems, incomplete passes framework) have been largely resolved in V2.

---

## Patterns to Preserve

### 1. Single Linear Compiler Pipeline ‚úÖ PRESERVED

**V1 Pattern**:
```
Patch (graph) ‚Üí Normalize ‚Üí Type Check ‚Üí Dependency Order ‚Üí Block Lowering ‚Üí IR Program
```

**Why It Works**:
- Linear, predictable flow
- No hidden passes or transformations
- Clear separation of concerns
- Single-pass compilation (no multi-round resolution)
- Easy to reason about and debug

**V2 Status**: ‚úÖ **PRESERVED** in `src/compiler/compile.ts`

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/compile.ts`

**Key Functions**:
- `compile(patch: Patch): CompileResult | CompileFailure` - Main entry point
- `buildDependencyOrder(patch)` - Kahn's algorithm for topological sort
- `resolveInputs()` - Match outputs to inputs by edge
- Block lowering via `getBlock().lower()`

**Architectural Compliance**:
- ‚úÖ ONE SOURCE OF TRUTH: Single compile entry point
- ‚úÖ SINGLE ENFORCER: Type checking in one place (TypeChecker.ts)
- ‚úÖ ONE-WAY DEPENDENCIES: Graph ‚Üí Compiler ‚Üí IR ‚Üí Runtime ‚Üí Render

**Recommendation**: **Maintain this pattern**. Do not introduce multi-pass systems unless absolutely necessary.

---

### 2. Block Registry Pattern ‚úÖ PRESERVED

**V1 Pattern**:
```typescript
interface BlockDef {
  type: string;
  inputs: PortDef[];
  outputs: PortDef[];
  lower: BlockLower;  // (context) ‚Üí Record<portId, ValueRef>
}

registerBlock(def): void
getBlock(type): BlockDef | undefined
getAllBlocks(): BlockDef[]
```

**Why It Works**:
- Single global registry (ONE SOURCE OF TRUTH)
- Declarative block definitions
- `lower()` function provides clean abstraction boundary
- Easy to add new blocks without modifying compiler
- Supports dynamic block discovery for UI

**V2 Status**: ‚úÖ **PRESERVED** in `src/compiler/blocks/registry.ts`

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/blocks/registry.ts`

**Current Block Count**: 40+ blocks organized by category:
- Time Domain: 2 blocks
- Signal Domain: 5 blocks
- Domain Blocks: 5 blocks
- Render Blocks: 12+ blocks

**Recommendation**: **Continue this pattern**. All new blocks should register via this mechanism.

---

### 3. IRBuilder Pattern ‚úÖ PRESERVED

**V1 Pattern**:
Blocks use IRBuilder interface to emit IR, never construct IR directly.

```typescript
interface IRBuilder {
  // Signal construction
  sigConst(value, type): SigExprId
  sigTime(which, type): SigExprId
  sigMap(input, fn, type): SigExprId
  sigZip(inputs, fn, type): SigExprId

  // Field construction
  fieldConst(value, type): FieldExprId
  fieldSource(domain, sourceId, type): FieldExprId
  fieldBroadcast(signal, type): FieldExprId
  fieldMap(field, fn, type): FieldExprId
  fieldZip(fields, fn, type): FieldExprId

  // Domain construction
  domainN(n, seed): DomainId
  domainGrid(width, height): DomainId

  // Schedule emission
  stepEvalSig(id, slot): void
  stepMaterialize(domainId, fieldId, bufferId): void
  stepRender(domainId, posId, colorId, sizeId?): void
}
```

**Example from ConstFloat**:
```typescript
const lowerConstFloat: BlockLower = ({ b, config }) => {
  const value = config.value ?? 0;
  const id = b.sigConst(value, sigType('float'));
  return { out: { kind: 'sig', id, type: sigType('float') } };
};
```

**Why It Works**:
- Builder abstracts IR construction complexity
- Blocks don't need to know IR internals
- Centralized ID generation and validation
- Type checking happens in builder
- Makes blocks simple and declarative

**V2 Status**: ‚úÖ **PRESERVED** in `src/compiler/ir/IRBuilder.ts` and `IRBuilderImpl.ts`

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/`

**Recommendation**: **Maintain this pattern**. Never let blocks construct IR directly.

---

### 4. Graph Normalization Step ‚úÖ PRESERVED (BASIC)

**V1 Pattern**:
```
Patch (user graph) ‚Üí Normalize ‚Üí NormalizedPatch (dense indices)
```

**Normalization Responsibilities**:
- Convert Map-based blocks to dense array [0..N]
- Convert edge references from blockId ‚Üí array index
- Validate graph structure (no dangling edges)
- (Future: Expand composites, materialize default sources, expand lenses/adapters)

**V2 Status**: ‚úÖ **PRESERVED** in `src/graph/normalize.ts`

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/graph/normalize.ts`

```typescript
interface Patch {
  blocks: Map<BlockId, Block>;  // User-friendly IDs
  edges: Edge[];
}

interface NormalizedPatch {
  blocks: Block[];               // Dense array [0..N]
  edges: NormalizedEdge[];       // Array indices
}
```

**Why It Works**:
- Separates user-facing representation from compiler internals
- Dense array indices enable fast iteration in compiler
- Single point to validate graph topology
- Foundation for future spec features (composite expansion, default sources, lens normalization)

**Recommendation**: **Expand this pattern** per spec. The current implementation is basic; spec requires:
- Expand composites/macros into blocks + edges
- Materialize DefaultSource blocks for inputs with zero writers
- Materialize BusBlocks for bus UI wiring
- Expand lens/adapter UI transforms into explicit derived blocks

---

### 5. Composable Primitive Blocks ‚úÖ ACHIEVED in V2

**V1 Anti-Pattern (Before Refactor)**:
- PositionSwirl: 170 lines, 7 inputs, 4 behaviors (god block)
- HueRainbow: 73 lines, 4 inputs, 2 behaviors (god block)

**V2 Pattern (After Refactor)**:
Split into composable primitives:

**PositionSwirl ‚Üí 5 blocks**:
1. **FieldGoldenAngle** (42 lines, 1 input) - Golden ratio angle spread
2. **FieldAngularOffset** (59 lines, 3 inputs) - Spin offset based on phase
3. **FieldAdd** (45 lines, 2 inputs) - Binary field addition
4. **FieldRadiusSqrt** (40 lines, 1 input) - Square root distribution
5. **FieldPolarToCartesian** (55 lines, 2 inputs) - Polar‚ÜíCartesian conversion

**HueRainbow ‚Üí 2 blocks**:
1. **FieldHueFromPhase** (50 lines, 2 inputs) - Calculates hue = phase + id01
2. **HsvToRgb** (40 lines, 3 inputs) - HSV‚ÜíRGB kernel conversion

**Why It Works**:
- Each block has ‚â§5 inputs (complexity limit enforced)
- Each block does ONE mathematical/logical concept
- Blocks are reusable in different combinations
- Composability enables emergent behaviors
- Easier to test individual transformations

**V2 Status**: ‚úÖ **ACHIEVED** (completed in architectural refactor, 2026-01-05)

**Source**: `/Users/bmf/code/oscilla-animator-v2/.agent_planning/ARCHITECTURAL-REFACTOR-COMPLETE.md`

**Recommendation**: **Enforce composition over complexity**. Never create blocks with >5 inputs or multiple behaviors.

---

### 6. IR-as-Data (Not Closures) ‚úÖ SUPERIOR to V1

**V1 Context**: Early iterations used closure-based evaluation

**V2 Pattern**: IR is pure data structure

```typescript
// Signal Expressions (data)
type SigExpr =
  | SigExprConst       // { kind: 'const', value, type }
  | SigExprTime        // { kind: 'time', which, type }
  | SigExprExternal    // { kind: 'external', name, type }
  | SigExprMap         // { kind: 'map', input, fn, type }
  | SigExprZip         // { kind: 'zip', inputs, fn, type }

// Field Expressions (data)
type FieldExpr =
  | FieldExprConst     // { kind: 'const', value, type }
  | FieldExprSource    // { kind: 'source', domainId, sourceId, type }
  | FieldExprBroadcast // { kind: 'broadcast', signal, type }
  | FieldExprMap       // { kind: 'map', field, fn, type }
  | FieldExprZip       // { kind: 'zip', fields, fn, type }
```

**Why It Works**:
- IR can be serialized/deserialized
- IR can be inspected/debugged
- IR can be optimized (CSE, dead code elimination)
- IR is deterministic (no closure capture issues)
- IR can be diff'd for hot-swap

**V2 Status**: ‚úÖ **SUPERIOR** - V2's IR-as-data is architecturally better than any closure-based approach

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/types.ts`

**Recommendation**: **Never introduce closures into IR**. Keep IR as pure data.

---

### 7. Single TypeChecker Enforcer ‚úÖ PRESERVED

**V1 Pattern**:
Type compatibility checking happens at exactly one point in the pipeline.

**V2 Implementation**:
```typescript
// src/compiler/passes/TypeChecker.ts
export function checkTypes(patch: NormalizedPatch): TypeError[] {
  // SINGLE ENFORCER for all type validation
  // Returns array of type errors (empty = success)
}
```

**Why It Works**:
- ‚úÖ SINGLE ENFORCER architectural law
- No duplicate type checks scattered across codebase
- Clear error messages from one source
- Easy to update type rules (change one file)

**V2 Status**: ‚úÖ **PRESERVED** in `src/compiler/passes/TypeChecker.ts`

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes/TypeChecker.ts`

**Called From**: `src/compiler/compile.ts` (single call site)

**Recommendation**: **Maintain single enforcer**. Never add type checks outside TypeChecker.

---

## Anti-Patterns to Avoid

### 1. God Blocks ‚ùå ELIMINATED in V2

**V1 Problem**:
Blocks with too many inputs, multiple behaviors, and excessive complexity.

**Example**: PositionSwirl (170 lines, 7 inputs, 4 behaviors)

```typescript
// ANTI-PATTERN: God block doing multiple things
interface PositionSwirlInputs {
  domain: DomainRef;
  phase: SigRef;      // For spin
  innerSpin: SigRef;  // Spin speed gradient
  outerRadius: SigRef; // Radius bounds
  innerRadius: SigRef;
  xOffset: SigRef;    // Translation
  yOffset: SigRef;
}

// Inside: Does golden angle + spin + radius + polar‚Üícartesian
```

**Why It's Bad**:
- Hard to test (4 behaviors intertwined)
- Not reusable (can't use just golden angle)
- Hard to understand (too much in one place)
- Hard to maintain (changes affect multiple concerns)
- Violates SINGLE RESPONSIBILITY

**V2 Solution**: ‚úÖ **ELIMINATED** - Split into 5 composable blocks (see Pattern #5)

**Enforcement Rule**: No block with >5 inputs or multiple mathematical concepts.

**Recommendation**: **Reject any block that does multiple things**. Force composition.

---

### 2. Duplicate Type Systems ‚ùå TO BE REMOVED

**V1 Problem**:
Multiple type definition files, only one actually used.

**Duplicate Files**:
| Location                            | Status | Usage                  |
|-------------------------------------|--------|------------------------|
| `src/types/index.ts` (255 lines)    | ‚úÖ ACTIVE | Main compiler pipeline |
| `src/core/types.ts` (249 lines)     | ‚ùå UNUSED | Never imported         |
| `src/blocks/registry.ts` (94 lines) | ‚ùå UNUSED | Never imported         |

**Why It's Bad**:
- Violates ONE SOURCE OF TRUTH
- Confusing to developers (which file to use?)
- Maintenance burden (which to update?)
- Risk of divergence (definitions drift apart)

**V2 Status**: ‚ùå **STILL EXISTS** (TODO: Delete unused files)

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/`

**Recommendation**: **DELETE** `src/core/types.ts` and `src/blocks/registry.ts` immediately. They are architectural leftovers from migration.

---

### 3. Incomplete Passes Framework ‚ùå TO BE REMOVED OR COMPLETED

**V1 Problem**:
Experimental multi-pass system exists but is not integrated.

**Directory**: `src/compiler/passes-v2/` (700+ lines of code)

**Files**:
- `pass2-types.ts` - Type analysis
- `pass3-time.ts` - Time topology
- `pass4-depgraph.ts` - Dependency graph
- `pass5-scc.ts` - Cycle detection
- `pass6-block-lowering.ts` - Block lowering
- `pass8-link-resolution.ts` - Link resolution
- `combine-utils.ts` - Utility functions
- `resolveWriters.ts` - Multi-writer resolution

**Why It's Bad**:
- Dead code (not called by main compiler)
- Confusing (developers might think it's used)
- Maintenance burden (must keep in sync even though unused)
- The main `compile.ts` reimplements this logic instead of using passes

**V2 Status**: ‚ùå **STILL EXISTS** (TODO: Delete or integrate)

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes-v2/`

**Recommendation**: **DECISION REQUIRED**:
- Option A: **DELETE** passes-v2/ entirely (recommended if single-pass works)
- Option B: **INTEGRATE** passes-v2/ and refactor compile.ts to use them (only if multi-pass is needed for future features)

**Bias**: DELETE unless spec requires multi-pass. Current single-pass linear pipeline works well.

---

### 4. Unused Transform Registry ‚ùå TO BE REMOVED OR IMPLEMENTED

**V1 Problem**:
Transform/lens registry defined but never used.

**File**: `src/transforms/index.ts`

**Defines**:
```typescript
interface AdapterDef { ... }
interface LensDef { ... }
registerAdapter(def): void
getLens(id): LensDef
```

**Status**: ‚ùå **NEVER IMPORTED** anywhere in codebase

**Why It's Bad**:
- Dead code
- Confusing intent (is this for future use?)
- If needed, should be integrated; if not, delete

**V2 Status**: ‚ùå **STILL EXISTS** (TODO: Delete or implement)

**Location**: `/Users/bmf/code/oscilla-animator-v2/src/transforms/`

**Recommendation**: **DECISION REQUIRED**:
- If spec requires lens/adapter system (it does!), **IMPLEMENT** using this registry
- If not implementing soon, **DELETE** to avoid confusion

**Spec Context**: `design-docs/spec/graph/07-transforms.md` defines 50+ transform blocks. This registry may be the foundation for that system.

**Decision**: **DEFER** decision to Phase 2 planning. Document as "Foundation for future lens/adapter system per spec."

---

### 5. Ambiguous File Organization ‚ö†Ô∏è NEEDS IMPROVEMENT

**V1 Problem**:
Some blocks are in category folders, others are not consistently organized.

**Current Structure**:
```
src/compiler/blocks/
‚îú‚îÄ‚îÄ time/           # InfiniteTimeRoot
‚îú‚îÄ‚îÄ signal/         # ConstFloat, AddSignal, MulSignal, Oscillator, MousePosition
‚îú‚îÄ‚îÄ domain/         # DomainN, GridDomain, FieldBroadcast, FieldMap, FieldZipSig
‚îú‚îÄ‚îÄ render/         # 12+ render blocks
‚îî‚îÄ‚îÄ registry.ts     # Global registry
```

**Why It's Inconsistent**:
- Good: Blocks are categorized
- Bad: Category doesn't match spec taxonomy (Time/Signal/Domain/Render vs Scalar/Signal/Field/Event)
- Unclear: Where do stateful blocks go? Where do transform blocks go?

**Recommendation**: **Align folder structure with spec worlds**:
```
src/compiler/blocks/
‚îú‚îÄ‚îÄ time/           # TimeRoot variants
‚îú‚îÄ‚îÄ signal/         # Signal-world blocks
‚îú‚îÄ‚îÄ field/          # Field-world blocks
‚îú‚îÄ‚îÄ event/          # Event-world blocks (when implemented)
‚îú‚îÄ‚îÄ stateful/       # UnitDelay, Lag, Phasor, SampleAndHold (when implemented)
‚îú‚îÄ‚îÄ transforms/     # Lens/adapter blocks (when implemented)
‚îú‚îÄ‚îÄ composites/     # Composite blocks (when implemented)
‚îî‚îÄ‚îÄ registry.ts
```

---

### 6. Spec vs Implementation Drift ‚ö†Ô∏è SIGNIFICANT GAP

**V1 Problem**:
V2 spec defines features not yet implemented.

**Gap Matrix**:
| Spec Feature | Spec File | Implementation Status | Blocker |
| --- | --- | --- | --- |
| **Core Type System** | compiler/01-type-system.md | ‚úÖ Partial (src/types/index.ts) | Missing domain conversions |
| **Time Model** | graph/02-time.md | ‚úÖ Partial (TimeModel exists) | No TimeRoot integration |
| **Buses & Rails** | graph/03-buses.md | ‚ùå None | Needs graph normalization |
| **Compilation** | compiler/04-compilation.md | ‚úÖ Partial (compile.ts) | No full normalization |
| **Runtime** | runtime/05-runtime.md | ‚úÖ Partial (ScheduleExecutor) | No hot swap |
| **Blocks** | graph/06-blocks.md | ‚úÖ Partial (40 blocks) | No composites |
| **Transforms** | graph/07-transforms.md | ‚ùå None (0 of 50+) | Needs lens system |
| **Primitives** | graph/08-primitives-composites.md | üöß Stub | Not enumerated |
| **Renderer** | renderer/09-renderer.md | ‚úÖ Minimal (Canvas2D) | Only squares |
| **Stateful Blocks** | graph/stateful-blocks.md | ‚ùå None (0 of 4) | Ambiguity on which 4 |
| **Default Sources** | (invariants) | ‚ùå None | Needs normalization |
| **Graph Normalization** | 16-Graph-Normalization.md | ‚ùå None | Core blocker |
| **Phase Matching** | time/10-phase-matching-system.md | ‚ùå None | Advanced feature |

**Impact**: V2 implements ~40% of spec. Large features missing:
- No graph normalization (default sources, bus blocks, lens expansion)
- No transform catalog (0 of 50+ blocks)
- No stateful primitives (0 of 4 blocks)
- No hot-swap state continuity
- No composite block system

**Recommendation**: **This is the PRIMARY FOCUS of Phase 1**. Audit ALL code against spec, identify conformance gaps, plan implementation.

---

## V1 to V2 Concept Mapping

Mapping of V1 concepts to their V2 equivalents (or spec equivalents if not yet implemented).

| V1 Concept | V2 Equivalent | Status | Notes |
| --- | --- | --- | --- |
| **Patch** | Patch | ‚úÖ Unchanged | User-facing graph representation |
| **BlockDef** | BlockDef | ‚úÖ Unchanged | Block definition with lower() function |
| **IRProgram** | IRProgram | ‚úÖ Unchanged | Core IR structure preserved |
| **TimeModel** | TimeModel | ‚úÖ Partial | Exists but needs TimeRoot integration per spec |
| **Signal world** | Signal world | ‚úÖ Preserved | Signal<T> type unchanged |
| **Field world** | Field world | ‚úÖ Preserved | Field<T> type unchanged |
| **Scalar world** | Scalar world | ‚ö†Ô∏è Spec-only | Not yet in implementation |
| **Event world** | Event world | ‚ö†Ô∏è Spec-only | Not yet in implementation |
| **Connection** | Edge | ‚úÖ Simplified | V1 had complex Connection types, V2 unified to Edge |
| **Publisher/Listener** | Edge (multi-writer) | ‚ö†Ô∏è Partial | V1 had bus complexity, V2 spec simplifies but not implemented |
| **Lenses/Adapters** | Transform blocks | ‚ùå Spec-only | V1 explored, V2 spec defines, not implemented |
| **Default Sources** | Default Source blocks | ‚ùå Spec-only | V1 didn't have, V2 spec requires, not implemented |
| **Composites** | Composite blocks | ‚ùå Spec-only | Not in V1 or V2 implementation |
| **Stateful blocks** | 4 canonical stateful primitives | ‚ùå Spec-only | V1 had some, V2 spec locks to 4, not implemented |
| **Type checking** | TypeChecker.ts | ‚úÖ Improved | Single enforcer pattern better than V1 |
| **Dependency order** | Kahn's algorithm | ‚úÖ Unchanged | Same algorithm, cleaner implementation |
| **Block lowering** | BlockLower function | ‚úÖ Unchanged | lower() pattern preserved |
| **IR Builder** | IRBuilder interface | ‚úÖ Improved | V2 has cleaner abstraction |
| **Runtime** | ScheduleExecutor | ‚úÖ Improved | V2 has better separation |
| **Renderer** | Canvas2DRenderer | ‚úÖ Minimal | V2 has basic renderer, spec requires more |
| **Graph normalization** | NormalizedPatch | ‚úÖ Basic | V2 has basic, spec requires expansion |
| **Rails** | Bus blocks (system) | ‚ùå Spec-only | New in V2 spec, not implemented |
| **Buses** | Bus blocks (user) | ‚ùå Spec-only | V1 had complex system, V2 spec simplifies, not implemented |
| **Domains** | Domain types | ‚úÖ Partial | V2 has DomainN/GridDomain, spec requires more |

---

## Recommendations Summary

### Immediate Actions (Phase 1)

1. ‚úÖ **PRESERVE**: Single linear compiler pipeline
2. ‚úÖ **PRESERVE**: Block registry pattern
3. ‚úÖ **PRESERVE**: IRBuilder pattern
4. ‚úÖ **PRESERVE**: Graph normalization (expand per spec)
5. ‚úÖ **PRESERVE**: Composable primitive blocks
6. ‚úÖ **PRESERVE**: IR-as-data (never closures)
7. ‚úÖ **PRESERVE**: Single TypeChecker enforcer

8. ‚ùå **DELETE**: `src/core/types.ts` (duplicate type system)
9. ‚ùå **DELETE**: `src/blocks/registry.ts` (unused duplicate)
10. ‚ùå **DECIDE**: `src/compiler/passes-v2/` (delete or integrate - recommend delete)
11. ‚ùå **DECIDE**: `src/transforms/` (delete or implement - defer to Phase 2)

12. ‚ö†Ô∏è **IMPROVE**: Folder structure (align with spec worlds)
13. ‚ö†Ô∏è **AUDIT**: All code against spec (identify conformance gaps)

### Long-Term Actions (Phase 2+)

14. **IMPLEMENT**: Full graph normalization per spec
15. **IMPLEMENT**: 4 canonical stateful primitives per spec
16. **IMPLEMENT**: Transform catalog (50+ blocks) per spec
17. **IMPLEMENT**: Bus/rail system per spec
18. **IMPLEMENT**: Composite block system per spec
19. **IMPLEMENT**: Hot-swap state continuity per spec

---

## Conclusion

V1 established **strong architectural foundations** (linear pipeline, block registry, IRBuilder, composable blocks) that V2 successfully preserves. The god block refactor demonstrates V2's commitment to simplicity.

**Primary concern**: Spec vs implementation drift (40% coverage). Phase 1 must focus on auditing existing code against spec and planning incremental conformance improvements.

**Anti-patterns to eliminate**: Duplicate type systems, incomplete passes framework, and dead code (unused transforms registry).

**Guiding principle**: Preserve V1's architectural wins, eliminate V1's complexity debt, and incrementally implement spec features with the same discipline.
