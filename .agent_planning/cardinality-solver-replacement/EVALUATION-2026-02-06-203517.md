# Evaluation: Cardinality Solver Replacement Plan
Timestamp: 2026-02-06-203517
Git Commit: 95177cf

## Executive Summary
Overall: **65% complete** | Critical issues: **4** | Tests reliable: **No**

The plan is architecturally sound and aligns with the spec document, but has several gaps that would cause implementation to fail or require significant rework mid-stream. The core design is correct; the issues are in unspecified dependencies and breaking changes not accounted for.

---

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| `npm run typecheck` | N/A | Not run - evaluating plan, not code |
| Existing test coverage | Inadequate | Current tests only cover trace output, not solver correctness |

---

## Missing Checks

Implementer should create:
1. **Cardinality solver correctness tests** - Currently only trace tests exist
2. **Instance variable resolution tests** - Test that vars become concrete refs
3. **Breaking change detection** - Grep for `.instance.instanceId` and `.instance.domainTypeId` accesses

---

## Findings

### 1. CardinalityValue Type Change (Step 1)

**Status**: PARTIAL
**Evidence**:
- Plan proposes changing `CardinalityValue.many.instance` from `InstanceRef` to `InstanceTerm`
- File `/Users/bmf/code/oscilla-animator-v2/src/core/canonical-types/cardinality.ts` line 21: `{ readonly kind: 'many'; readonly instance: InstanceRef }`

**Issues**:
1. **Breaking change not accounted for**: 14+ call sites access `.instance.domainTypeId` and `.instance.instanceId` directly:
   - `/Users/bmf/code/oscilla-animator-v2/src/core/canonical-types/equality.ts` lines 30-31
   - `/Users/bmf/code/oscilla-animator-v2/src/compiler/frontend/solve-cardinality.ts` lines 128, 135, 158
   - `/Users/bmf/code/oscilla-animator-v2/src/ui/reactFlowEditor/typeValidation.ts` line 185
   - `/Users/bmf/code/oscilla-animator-v2/src/ui/graphEditor/portTooltipFormatters.ts` line 69
   - `/Users/bmf/code/oscilla-animator-v2/src/blocks/signal/default-source.ts` line 241
   - `/Users/bmf/code/oscilla-animator-v2/src/blocks/lens/construct.ts` lines 59, 71, 83

2. **Type system guardrail violation**: TYPE-SYSTEM-INVARIANTS.md rule 4 says "Vars are inference-only" - but changing the core `CardinalityValue` type to include `InstanceTerm` (which has a `var` variant) leaks vars into the canonical type system.

**Recommendation**:
- Keep `CardinalityValue.instance` as `InstanceRef` (concrete only)
- Create a separate inference-layer type `InferenceCardinalityValue` with `InstanceTerm`
- Update `cardinalityMany()` to accept either, but validate concrete before returning

---

### 2. Missing Function Reference (Step 3)

**Status**: NOT_STARTED
**Evidence**: Plan references `createBlockInstanceRef(block, blockIndex, meta.domainType)` but this function does not exist in the codebase (grep returned no matches).

**Issues**:
- Current code creates instance refs inline at `/Users/bmf/code/oscilla-animator-v2/src/compiler/frontend/analyze-type-constraints.ts` lines 445-446
- Plan assumes a helper that must be created

**Recommendation**: Plan should explicitly list this as a new function to create, or use existing inline pattern.

---

### 3. Constraint Graph Integration (Steps 3-4)

**Status**: PARTIAL
**Evidence**:
- Plan replaces `gatherCardinalityConstraints()` (lines 276-373) with `buildCardinalityGraph()`
- Plan replaces the entire solver algorithm

**Issues**:
1. **Algorithm not specified**: Plan shows Phase 4 "Resolve join constraints" with pseudocode, but the core algorithm for propagation and conflict detection is underspecified:
   - How does `instanceTermsEqual()` work when one or both terms are vars?
   - What is the iteration order for edge propagation?
   - How is termination detected?

2. **Instance variable unification missing**: Plan mentions `instanceUF = new UnionFind<InstanceVarId, InstanceRef>()` but:
   - No generic `UnionFind` class exists that takes two type parameters
   - Current `UnionFind<T>` in `analyze-type-constraints.ts` has single type parameter
   - Algorithm for unifying instance vars with concrete refs not specified

3. **EdgePolicy integration unclear**: Plan proposes `EdgeConstraint.policy: 'equal' | 'broadcastable' | 'reducible'` but:
   - Current code determines this from destination block's `broadcastPolicy`
   - Plan doesn't specify how `reducible` is used

**Recommendation**: Flesh out the algorithm in more detail before implementation, particularly:
- Instance var â†’ concrete ref resolution algorithm
- Termination conditions for propagation
- Handling of partially-resolved constraints

---

### 4. Diagnostic Code Addition (Step 6)

**Status**: PARTIAL
**Evidence**: Plan adds 6 new error codes to `CompileErrorCode`.

**Issues**:
1. **Typo in plan**: `IllegalOneToMany` shows as `E_ILLEGAL_ONE_TO_TO_MANY` (double "TO")
2. **Missing mapping updates**: `frontendDiagnosticConversion.ts` needs updates but plan doesn't show the full mapping structure
3. **Current error interface differs**: Current `CardinalityConstraintError` has different fields than what diagnostics system expects

**Recommendation**: Show complete diagnostic code additions including:
- CompileErrorCode union additions
- DiagnosticCode string constants
- FRONTEND_ERROR_KIND_TO_DIAGNOSTIC_CODE mappings

---

### 5. Test Updates (Step 7)

**Status**: STUB
**Evidence**: Plan says "Add new test cases" but only lists 4 high-level scenarios.

**Issues**:
1. **Existing tests inadequate**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/frontend/__tests__/solve-cardinality-trace.test.ts` only tests trace output, not solver correctness
2. **No regression tests**: Plan doesn't specify how to verify existing behavior is preserved
3. **Instance unification tests exist but are IR-level**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/__tests__/instance-unification.test.ts` tests the IR builder, not the solver

**Recommendation**: Before rewriting solver:
1. Add correctness tests for current solver behavior
2. Use these as regression tests for the new solver
3. Then add new tests for enhanced functionality

---

## Ambiguities Found

| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| InstanceTerm in CardinalityValue | Should canonical types contain var terms? | Plan assumes yes | Violates TYPE-SYSTEM-INVARIANTS rule 4 |
| Instance var unification | What algorithm resolves vars to concrete? | Not specified | Implementation will stall without this |
| Edge propagation order | Does order matter for determinism? | Not addressed | Non-deterministic solver would violate spec Goal 5 |
| createBlockInstanceRef | Helper or inline? | Assumes helper exists | Will fail at implementation |
| Reducer constraint handling | What does `reducible` policy do? | Mentioned but unused | Dead code or missing feature |

---

## Recommendations

### Critical (Must Fix Before Implementation)

1. **Separate inference types from canonical types**: Do not change `CardinalityValue.instance` to `InstanceTerm`. Create `InferenceCardinalityValue` in the inference layer only.

2. **Specify instance unification algorithm**: Add a section to the plan explaining:
   - How `InstanceVarId` values are unified
   - How a var is resolved to concrete ref when connected to one
   - What happens when two different concrete refs are unified (error)

3. **Create correctness tests first**: Before touching solver code:
   ```bash
   # Add to Step 7, run BEFORE Step 4
   npm run test -- src/compiler/frontend/__tests__/solve-cardinality-*.test.ts
   ```

4. **Enumerate all breaking changes**: Add a section listing every file that accesses `CardinalityValue.many.instance.*` and how each will be updated.

### Important (Should Fix)

5. **Remove `createBlockInstanceRef` reference or add it**: Either define the helper function or use the existing inline pattern.

6. **Fix diagnostic code typo**: `E_ILLEGAL_ONE_TO_TO_MANY` should be `E_ILLEGAL_ONE_TO_MANY`.

7. **Add rollback plan**: If new solver introduces regressions, how does implementer revert?

---

## Verdict

- [ ] **CONTINUE** - Issues clear, implementer can fix
- [x] **PAUSE** - Ambiguities need clarification

**Reason for PAUSE**:

The plan has 3 questions that block implementation:

1. **Should `CardinalityValue` contain `InstanceTerm` (with var variant)?**
   - Option A: Yes, change canonical type (plan's approach)
   - Option B: No, create inference-layer type only
   - Impact: Option A violates TYPE-SYSTEM-INVARIANTS rule 4 and breaks 14+ call sites. Option B requires restructuring Steps 1 and 4.

2. **What is the instance variable unification algorithm?**
   - Current plan says "instance variable unification" but gives no algorithm
   - Without this, Step 4 cannot be implemented
   - Impact: Implementation will stall at the core solver logic

3. **What should `createBlockInstanceRef` be?**
   - Plan references function that doesn't exist
   - Impact: Step 3 code will not compile

---

## Suggested Clarifications

Before continuing, resolve:

```
Q1: Should InstanceTerm with var variant exist in CanonicalType or only in inference types?

Q2: When two nodes share an instance var (e.g., iv0) and one gets resolved to
    concrete instanceRef(circle, block-0), how does the solver propagate
    that resolution to all other nodes sharing iv0?

Q3: Is createBlockInstanceRef a new function to write, or should we use the
    existing inline pattern from analyze-type-constraints.ts lines 445-446?
```

---

```
project-evaluator complete
  Scope: cardinality-solver-replacement | Completion: 65% | Gaps: 4
  Workflow: PAUSE (3 questions need answers first)
  -> Clarify InstanceTerm placement in type hierarchy before Step 1
```
