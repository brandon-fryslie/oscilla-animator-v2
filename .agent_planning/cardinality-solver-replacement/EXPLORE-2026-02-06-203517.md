# Exploration: Cardinality Solver Replacement Plan
Timestamp: 2026-02-06-203517
Git Commit: 95177cf

## Files Examined

### Core Type System
- `/Users/bmf/code/oscilla-animator-v2/src/core/ids.ts` - Current branded ID types (CardinalityVarId exists, no InstanceVarId)
- `/Users/bmf/code/oscilla-animator-v2/src/core/canonical-types/cardinality.ts` - CardinalityValue type (many uses InstanceRef directly, not InstanceTerm)
- `/Users/bmf/code/oscilla-animator-v2/src/core/canonical-types/instance-ref.ts` - InstanceRef type (no InstanceTerm exists)
- `/Users/bmf/code/oscilla-animator-v2/src/core/canonical-types/equality.ts` - cardinalitiesEqual accesses `.instance.domainTypeId` and `.instance.instanceId` directly

### Current Solver Implementation
- `/Users/bmf/code/oscilla-animator-v2/src/compiler/frontend/solve-cardinality.ts` - 495 lines, uses placeholder hack (`isPlaceholderInstance`), multi-phase algorithm
- `/Users/bmf/code/oscilla-animator-v2/src/compiler/frontend/analyze-type-constraints.ts` - 764 lines, `gatherCardinalityConstraints()` at lines 276-373, `resolveInstanceRefs()` at lines 426-472

### Block Registry
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/registry.ts` - BlockCardinalityMetadata type (lines 199-211), discriminated union on cardinalityMode

### Tests
- `/Users/bmf/code/oscilla-animator-v2/src/compiler/frontend/__tests__/solve-cardinality-trace.test.ts` - Trace mode tests only
- `/Users/bmf/code/oscilla-animator-v2/src/compiler/__tests__/instance-unification.test.ts` - Instance identity tests (type-derived)
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/__tests__/cardinality-metadata.test.ts` - Block metadata tests

### Spec Document
- `/Users/bmf/code/oscilla-animator-v2/design-docs/cardinality-solver.md` - 393 lines, constraint-graph-based design

## Key Findings

### 1. CardinalityValue Type Change Impact
Current definition in `cardinality.ts`:
```typescript
export type CardinalityValue =
  | { readonly kind: 'zero' }
  | { readonly kind: 'one' }
  | { readonly kind: 'many'; readonly instance: InstanceRef };
```

Plan proposes changing to:
```typescript
export type CardinalityValue =
  | { readonly kind: 'zero' }
  | { readonly kind: 'one' }
  | { readonly kind: 'many'; readonly instance: InstanceTerm };
```

**Impact analysis:**
- `equality.ts` line 30-31 accesses `aMany.instance.domainTypeId` directly - will break
- `solve-cardinality.ts` lines 128, 135, 158 access `.instance.domainTypeId` and `.instance.instanceId` directly
- UI files access `.instance.instanceId` (typeValidation.ts:185, portTooltipFormatters.ts:69)
- Block lowering code in `blocks/lens/construct.ts` accesses `.instance.instanceId` and `.instance.domainTypeId`
- `blocks/signal/default-source.ts` line 241 accesses `card.instance.domainTypeId`

### 2. Missing Function in Plan
Plan references `createBlockInstanceRef(block, blockIndex, meta.domainType)` in Step 3 - **this function does not exist**.

Current code creates instance refs manually in `analyze-type-constraints.ts` lines 445-446:
```typescript
const instance = instanceId(`block-${blockIndex}`);
const ref = instanceRef(domain as string, instance as string);
```

### 3. Constraint Types in Plan vs Current Code
Current `CardinalityConstraint` in `solve-cardinality.ts`:
```typescript
export type CardinalityConstraint =
  | { readonly kind: 'equal'; readonly varId: CardinalityVarId; readonly ports: readonly PortKey[] }
  | { readonly kind: 'fixed'; readonly port: PortKey; readonly value: CardinalityValue }
  | { readonly kind: 'zipBroadcast'; readonly varId: CardinalityVarId; readonly ports: readonly PortKey[] };
```

Plan proposes entirely different constraint types:
```typescript
type CardConstraint =
  | { kind: 'equal'; a: number; b: number }
  | { kind: 'join'; out: number; inputs: readonly number[]; mode: 'zip' }
  | { kind: 'clampOne'; node: number }
  | { kind: 'clampMany'; node: number; instance: InstanceTerm }
  | { kind: 'manyInstanceEq'; nodes: readonly number[] }
  | { kind: 'transformOut'; node: number; instanceRef: InstanceRef }
  | { kind: 'reduceIn'; node: number }
  | { kind: 'reduceOut'; node: number };
```

### 4. Union-Find Implementation
Current solver uses a custom `CardinalityUnionFind` class (lines 39-120 in solve-cardinality.ts).

Plan mentions `UnionFind<InstanceVarId, InstanceRef>` but does not specify:
- Whether this is a new class or reuses existing
- How instance variable unification interacts with cardinality solving
- The algorithm for instance term propagation

### 5. PortKey Definition
Current `PortKey` in `analyze-type-constraints.ts`:
```typescript
export type PortKey = `${number}:${string}:${'in' | 'out'}`;
```

Plan uses same format but also introduces `CardNode.id` as a number index. This creates dual indexing that could lead to mapping errors.

### 6. Error Types
Current error type in `solve-cardinality.ts`:
```typescript
export interface CardinalityConstraintError {
  readonly kind: 'CardinalityConflict' | 'UnresolvedCardinality' | 'InvalidZipBroadcast';
  readonly port: PortKey;
  readonly blockIndex: BlockIndex;
  readonly portName: string;
  readonly message: string;
  readonly details?: {...};
}
```

Plan proposes new diagnostic codes not present in current `CompileErrorCode`:
- `ZipBroadcastInstanceMismatch`
- `UnresolvedInstanceVar`
- `FieldOnlyViolated`
- `SignalOnlyViolated`
- `IllegalManyToOne`
- `IllegalOneToMany`

Current `frontendDiagnosticConversion.ts` maps error kinds to diagnostic codes. The plan's new codes would need additions there.

### 7. Downstream Dependencies on CardinalityValue.instance
Files accessing `CardinalityValue.many.instance` fields:
1. `src/core/canonical-types/equality.ts` - cardinalitiesEqual()
2. `src/compiler/frontend/solve-cardinality.ts` - placeholder detection and formatting
3. `src/ui/reactFlowEditor/typeValidation.ts` - port label display
4. `src/ui/graphEditor/portTooltipFormatters.ts` - tooltip display
5. `src/blocks/signal/default-source.ts` - domain type lookup
6. `src/blocks/lens/construct.ts` - instance comparison

### 8. BlockCardinalityMetadata Usage
The plan correctly identifies `getBlockCardinalityMetadata()` but the proposed constraint generation in Step 3 assumes block metadata patterns that may not cover all cases:
- `preserve` with `allowZipSig` vs `disallowSignalMix` handled correctly
- `signalOnly` handling looks correct
- `transform` handling needs `domainType` from metadata (correctly identified)
- `fieldOnly` handling is minimal in current code and plan

### 9. Test Coverage Gaps
Current tests:
- `solve-cardinality-trace.test.ts` - Only tests trace output, not solver correctness
- `instance-unification.test.ts` - Tests IR builder instance handling, not solver

Missing tests for:
- ZipBroadcast instance mismatch detection
- Instance variable resolution through edges
- Join constraint behavior
- clampOne/clampMany enforcement
