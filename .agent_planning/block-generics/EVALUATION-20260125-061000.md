# Evaluation: Block Generics and Field Renaming

**Topic**: Make all applicable blocks Payload and/or Cardinality generics, and remove 'Field' from names
**Generated**: 2026-01-25
**Verdict**: **CONTINUE**

## Current State

### What Exists

**Payload-Generic System** ✅
- Type definitions in `src/core/canonical-types.ts`
- Planning in `.agent_planning/payload-generic/` with HIGH confidence sprint
- Registry pattern established (BlockCardinalityMetadata)
- Per-block `allowedPayloads` metadata pattern documented

**Cardinality-Generic System** ✅
- Fully implemented per spec
- `CardinalityMode` metadata in BlockRegistry
- Pattern: `laneLocal` + `broadcastPolicy` define per-lane semantics
- Used in existing blocks: Add, Multiply, UnitDelay, Lag, Phasor, SampleAndHold

**Field Operation Blocks** (Candidates for genericization)
Located in `src/blocks/field-operations-blocks.ts`:
- FieldFromDomainId (16 blocks total)
- FieldAdd, FieldMultiply, FieldScale
- FieldSin, FieldCos, FieldMod
- FieldPolarToCartesian, FieldCartesianToPolar
- FieldPulse, FieldGoldenAngle, FieldAngularOffset
- FieldRadiusSqrt, FieldJitter2D, FieldHueFromPhase, FieldSetZ

**Current Limiting Factor**
- All field blocks are currently `cardinalityMode: 'fieldOnly'`
- This means they ONLY work with fields, not signals
- Makes them less generic than spec-compliant Payload-Generic blocks

### What Needs to Happen

**Phase 1: Identify Which Blocks Should Be Generic**

Candidates for Cardinality-Generic (Signal + Field):
- **FieldAdd** → **Add** (duplicate of existing signal-based Add? Need to check)
- **FieldMultiply** → **Multiply** (duplicate of existing signal-based Multiply? Need to check)
- **FieldScale** → **Scale** (multiply-by-scalar pattern)
- **FieldSin** → **Sin** (per-lane trig)
- **FieldCos** → **Cos** (per-lane trig)
- **FieldMod** → **Mod** (per-lane modulo)

Cannot be Cardinality-Generic (field-specific operations):
- **FieldFromDomainId** → Keep as field-only (relies on domain intrinsics)
- **FieldPolarToCartesian** → **PolarToCartesian** (payload-generic if per-lane)
- **FieldCartesianToPolar** → **CartesianToPolar** (payload-generic if per-lane)
- **FieldPulse** → **Pulse** (per-lane animation, could be cardinality-generic)
- **FieldGoldenAngle** → **GoldenAngle** (intrinsic, field-only? or per-lane signal?)
- **FieldAngularOffset** → **AngularOffset** (per-lane animation)
- **FieldRadiusSqrt** → **RadiusSqrt** (per-lane field operation)
- **FieldJitter2D** → **Jitter2D** (per-lane, but uses randomness)
- **FieldHueFromPhase** → **HueFromPhase** (per-lane, from phase + id)
- **FieldSetZ** → **SetZ** (per-lane vec3 mutation, cardinality-generic)

**Phase 2: Make Payload-Generic**

All these blocks work on `float` or `vec2`/`vec3`. Many should accept multiple payloads:
- **Add, Multiply, Scale**: `{float, vec2, vec3}` (homogeneous binary)
- **Sin, Cos**: `float → float` only
- **Mod**: `{float, int}` potentially
- **Polar/Cartesian**: `vec2 ↔ vec2` (payload-specific, not generic)
- **SetZ**: `vec3 → vec3`
- **Others**: Float-specific

**Phase 3: Rename and Update References**

- Remove "Field" prefix from type names
- Update all imports, tests, block kind references
- Update UI labels if needed

## Architecture Analysis

### Spec Alignment

**Per spec § Block System**:
- **Cardinality-Generic**: Per-lane semantics, works for Signal and Field
- **Payload-Generic**: Semantics defined over closed set of payload types

**Current issues**:
1. Field blocks are field-only (not cardinality-generic)
2. Field blocks use hardcoded types (not payload-generic)
3. Names don't indicate genericization status

### Mechanical Enforcement

To genericize correctly, must:
1. Add `allowedPayloads` metadata per block
2. Change `cardinalityMode` from `fieldOnly` to signal-compatible mode
3. Update lowering to dispatch on payload type
4. Emit correct kernels per specialization

### Risk Assessment

**HIGH RISK: Breaking Changes**
- If blocks are field-only by intention, making them signal-compatible changes behavior
- Need to verify current usage in patches/demos before changing

**MEDIUM RISK: Kernel Dispatch**
- Field kernels may differ from signal kernels
- May need separate kernel registry per payload type

**LOW RISK: Renaming**
- Tests and imports localized
- Git history preserves old names

## Dependencies

- ✅ Payload-Generic plan (HIGH confidence sprint exists)
- ✅ Cardinality-Generic system (fully implemented)
- ⚠️ Existing signal-based Add/Multiply (need to check for duplication)
- ⚠️ Block lowering system (update for per-payload dispatch)

## Confidence Assessment

| Area | Confidence | Rationale |
|------|-----------|-----------|
| Identify which blocks should be generic | MEDIUM | Need to audit current usage in demos/patches |
| Implement Payload-Generic metadata | HIGH | Pattern exists, straightforward |
| Implement Cardinality-Generic contracts | HIGH | System fully implemented |
| Rename blocks | HIGH | Mechanical rename |
| Update lowering for dispatch | MEDIUM | Need to verify kernel availability |
| Handle field-only blocks | LOW | Rationale for field-only unclear |

## Major Unknowns

1. **Duplication**: Are there already signal-based Add, Multiply, etc? If so, should we merge or keep separate?
2. **Kernel Availability**: Do field kernels exist for all payloads, or only float?
3. **Field-Only Rationale**: Why are field blocks separated? Performance? Correctness? Usage pattern?
4. **Backward Compatibility**: Should we keep old Field* names as aliases during transition?

## Verdict: CONTINUE

Proceed with planning, but flag the major unknowns for research before implementation.

**Next Steps**:
1. Audit current state of signal-based Add/Multiply/etc
2. Check kernel registry for field kernel availability
3. Understand field-only design rationale
4. Resolve duplications / conflicts
