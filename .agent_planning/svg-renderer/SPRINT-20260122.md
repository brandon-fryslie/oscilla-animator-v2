# Sprint Tasks: SVG Renderer

**Bead ID**: oscilla-animator-v2-0uk
**Generated**: 2026-01-22
**Status**: BLOCKED (waiting on dependencies)

## Sprint Goal

Implement SVG renderer that leverages `<defs>`/`<use>` for geometry reuse, consuming DrawPathInstancesOp from RenderAssembler v2.

## Prerequisites (BLOCKING)

### P0: Verify Dependencies Complete

**Task**: Check dependency status before starting implementation
**Time**: 10 minutes
**Acceptance Criteria**:
- [ ] oscilla-animator-v2-46m (local-space migration) status is COMPLETE
- [ ] oscilla-animator-v2-583 (RenderAssembler v2) status is COMPLETE
- [ ] Canvas2DRenderer uses instance transforms (not control point scaling)
- [ ] RenderAssembler exports `assembleDrawPathInstancesOp()` function
- [ ] Local-space geometry verified (control points centered at origin)

**Commands**:
```bash
bd show oscilla-animator-v2-46m --json  # Check status
bd show oscilla-animator-v2-583 --json  # Check status
```

**Blockers**: If either dependency is not COMPLETE, STOP and wait.

---

## Phase 1: Core Structure (2-3 hours)

### Task 1.1: Create SVGRenderer Module Skeleton

**File**: `src/render/SVGRenderer.ts`
**Time**: 30 minutes

**Steps**:
1. Create file with module header
2. Import required types from `future-types.ts`
3. Define SVGRenderer class with constructor
4. Create SVG element, defs, render group
5. Implement dispose() method

**Code Template**:
```typescript
/**
 * SVG Renderer - Geometry Reuse via <defs>/<use>
 */
import type { RenderFrameIR_Future, DrawPathInstancesOp } from './future-types';

export class SVGRenderer {
  private svg: SVGSVGElement;
  private defs: SVGDefsElement;
  private renderGroup: SVGGElement;

  constructor(container: HTMLElement, width: number, height: number) {
    // TODO: Create SVG element with viewBox
    // TODO: Create defs element
    // TODO: Create render group
  }

  render(frame: RenderFrameIR_Future, width: number, height: number): void {
    // TODO: Implement
  }

  clear(): void {
    // TODO: Clear render group
  }

  dispose(): void {
    // TODO: Remove SVG from DOM
  }
}
```

**Acceptance Criteria**:
- [ ] Module compiles without TypeScript errors
- [ ] Constructor creates SVG element with correct viewBox
- [ ] defs and renderGroup appended to SVG
- [ ] SVG appended to container
- [ ] dispose() removes SVG from container

**Test**:
```typescript
const container = document.createElement('div');
const renderer = new SVGRenderer(container, 1000, 1000);
expect(container.querySelector('svg')).toBeTruthy();
expect(container.querySelector('defs')).toBeTruthy();
renderer.dispose();
expect(container.querySelector('svg')).toBeNull();
```

---

### Task 1.2: Implement GeometryCache

**File**: `src/render/SVGRenderer.ts` (in same module)
**Time**: 45 minutes

**Steps**:
1. Create GeometryCache class
2. Use WeakMap for buffer identity tracking
3. Implement get() with lazy factory
4. Implement clear()

**Code Template**:
```typescript
class GeometryCache {
  private cache = new Map<string, string>();
  private bufferKeys = new WeakMap<Float32Array, symbol>();

  get(
    topologyId: number,
    points: Float32Array,
    factory: () => string
  ): string {
    const key = this.computeKey(topologyId, points);
    if (!this.cache.has(key)) {
      this.cache.set(key, factory());
    }
    return this.cache.get(key)!;
  }

  private computeKey(topologyId: number, points: Float32Array): string {
    // TODO: Get or create buffer identity symbol
    // TODO: Return `${topologyId}:${bufferKey}`
  }

  clear(): void {
    this.cache.clear();
  }
}
```

**Acceptance Criteria**:
- [ ] Cache returns same d string for same buffer reference
- [ ] Cache returns different d strings for different buffers (same topology)
- [ ] Factory called only once per unique (topology, buffer) pair
- [ ] clear() removes all entries

**Test**:
```typescript
const cache = new GeometryCache();
const points1 = new Float32Array([0, -1, 1, 0, -1, 0]);
const points2 = new Float32Array([0, -1, 1, 0, -1, 0]); // Same content, different buffer

let calls = 0;
const factory = () => { calls++; return 'M 0 -1 L 1 0 L -1 0 Z'; };

const d1 = cache.get(0, points1, factory);
expect(calls).toBe(1);

const d2 = cache.get(0, points1, factory); // Same buffer
expect(calls).toBe(1); // No new call

const d3 = cache.get(0, points2, factory); // Different buffer
expect(calls).toBe(2); // New call
```

---

## Phase 2: Path D String Generation (2-3 hours)

### Task 2.1: Implement pathToSvgD()

**File**: `src/render/SVGRenderer.ts`
**Time**: 1.5 hours

**Steps**:
1. Create pathToSvgD() function
2. Iterate verbs array
3. For each verb, format SVG command
4. Increment point index correctly
5. Validate pointsCount matches consumed points

**Code Template**:
```typescript
function pathToSvgD(
  verbs: Uint8Array,
  points: Float32Array,
  pointsCount: number
): string {
  const parts: string[] = [];
  let pi = 0; // Point index

  for (let vi = 0; vi < verbs.length; vi++) {
    const verb = verbs[vi];

    switch (verb) {
      case 0: { // MOVE
        // TODO: Format 'M x y'
        break;
      }
      case 1: { // LINE
        // TODO: Format 'L x y'
        break;
      }
      case 2: { // CUBIC
        // TODO: Format 'C cp1x cp1y cp2x cp2y x y'
        break;
      }
      case 3: { // QUAD
        // TODO: Format 'Q cpx cpy x y'
        break;
      }
      case 4: { // CLOSE
        parts.push('Z');
        break;
      }
      default:
        throw new Error(`Unknown PathVerb: ${verb}`);
    }
  }

  if (pi !== pointsCount) {
    throw new Error(`Path consumed ${pi} points but pointsCount is ${pointsCount}`);
  }

  return parts.join(' ');
}
```

**Acceptance Criteria**:
- [ ] MOVE (0) produces `M x y`
- [ ] LINE (1) produces `L x y`
- [ ] CUBIC (2) produces `C cp1x cp1y cp2x cp2y x y`
- [ ] QUAD (3) produces `Q cpx cpy x y`
- [ ] CLOSE (4) produces `Z`
- [ ] Point index tracking correct
- [ ] Throws error if pointsCount mismatch
- [ ] Numbers formatted with `.toFixed(6)`

**Test**:
```typescript
test('pathToSvgD handles pentagon', () => {
  const verbs = new Uint8Array([0, 1, 1, 1, 1, 4]); // MOVE, 4xLINE, CLOSE
  const points = new Float32Array([
    0, -1,
    0.951, 0.309,
    0.588, 1,
    -0.588, 1,
    -0.951, 0.309,
  ]);

  const d = pathToSvgD(verbs, points, 5);

  expect(d).toContain('M 0.000000 -1.000000');
  expect(d).toContain('L 0.951000 0.309000');
  expect(d).toContain('Z');
});
```

---

### Task 2.2: Implement ensureGeometryDef()

**File**: `src/render/SVGRenderer.ts`
**Time**: 30 minutes

**Steps**:
1. Check if `<path id="{geomKey}">` exists in defs
2. If not, create `<path>` element
3. Set id and d attributes
4. Append to defs

**Code Template**:
```typescript
function ensureGeometryDef(
  defs: SVGDefsElement,
  geomKey: string,
  dString: string
): void {
  let path = defs.querySelector(`path[id="${geomKey}"]`);
  if (!path) {
    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('id', geomKey);
    path.setAttribute('d', dString);
    defs.appendChild(path);
  }
  // Optional: Update d if changed (rare edge case)
}
```

**Acceptance Criteria**:
- [ ] Creates `<path>` if not exists
- [ ] Sets id and d attributes
- [ ] Appends to defs
- [ ] Reuses existing path if id matches
- [ ] Does not create duplicates

**Test**:
```typescript
const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
ensureGeometryDef(defs, 'geom_0', 'M 0 0 L 1 1 Z');
expect(defs.children.length).toBe(1);

ensureGeometryDef(defs, 'geom_0', 'M 0 0 L 1 1 Z'); // Same key
expect(defs.children.length).toBe(1); // No duplicate

ensureGeometryDef(defs, 'geom_1', 'M 0 0 L 2 2 Z'); // Different key
expect(defs.children.length).toBe(2);
```

---

## Phase 3: Instance Rendering (2-3 hours)

### Task 3.1: Implement computeInstanceTransform()

**File**: `src/render/SVGRenderer.ts`
**Time**: 1 hour

**Steps**:
1. Extract world-space position
2. Map to viewport coordinates
3. Resolve size (uniform or per-instance)
4. Resolve rotation (optional)
5. Resolve scale2 (optional, overrides isotropic)
6. Format transform string

**Code Template**:
```typescript
function computeInstanceTransform(
  position: Float32Array,
  instanceIndex: number,
  size: number | Float32Array,
  rotation: Float32Array | number | undefined,
  scale2: Float32Array | undefined,
  width: number,
  height: number
): string {
  const xW = position[instanceIndex * 2];
  const yW = position[instanceIndex * 2 + 1];
  const xSvg = xW * width;
  const ySvg = yW * height;

  const D = Math.min(width, height);
  const s = typeof size === 'number' ? size : size[instanceIndex];

  const θ = rotation
    ? (typeof rotation === 'number' ? rotation : rotation[instanceIndex])
    : 0;
  const θDeg = θ * 180 / Math.PI;

  let sxSvg = s * D;
  let sySvg = s * D;
  if (scale2) {
    sxSvg = scale2[instanceIndex * 2] * D;
    sySvg = scale2[instanceIndex * 2 + 1] * D;
  }

  return `translate(${xSvg.toFixed(6)},${ySvg.toFixed(6)}) rotate(${θDeg.toFixed(6)}) scale(${sxSvg.toFixed(6)},${sySvg.toFixed(6)})`;
}
```

**Acceptance Criteria**:
- [ ] Position mapped from [0,1] to viewport
- [ ] Size scaled by min(width, height)
- [ ] Rotation in degrees
- [ ] scale2 overrides isotropic size
- [ ] Transform order: translate, rotate, scale
- [ ] Numbers formatted with 6 decimals

**Test**:
```typescript
test('computeInstanceTransform at center', () => {
  const position = new Float32Array([0.5, 0.5]);
  const transform = computeInstanceTransform(
    position, 0, 0.1, Math.PI / 4, undefined, 1000, 1000
  );
  expect(transform).toBe('translate(500.000000,500.000000) rotate(45.000000) scale(100.000000,100.000000)');
});
```

---

### Task 3.2: Implement buildStyleAttributes()

**File**: `src/render/SVGRenderer.ts`
**Time**: 45 minutes

**Steps**:
1. Extract RGBA from fillColor buffer
2. Format as `rgb(r,g,b)`
3. Extract alpha as fill-opacity
4. Add fill-rule if specified

**Code Template**:
```typescript
function buildStyleAttributes(
  style: PathStyle,
  instanceIndex: number,
  instanceCount: number
): Record<string, string> {
  const attrs: Record<string, string> = {};

  const fillColor = style.fillColor;
  const isUniform = fillColor.length === 4;
  const offset = isUniform ? 0 : instanceIndex * 4;

  const r = fillColor[offset + 0];
  const g = fillColor[offset + 1];
  const b = fillColor[offset + 2];
  const a = fillColor[offset + 3];

  attrs['fill'] = `rgb(${r},${g},${b})`;

  if (a !== 255) {
    attrs['fill-opacity'] = (a / 255).toFixed(3);
  }

  if (style.fillRule) {
    attrs['fill-rule'] = style.fillRule;
  }

  return attrs;
}
```

**Acceptance Criteria**:
- [ ] Extracts per-instance color if buffer length === count * 4
- [ ] Extracts uniform color if buffer length === 4
- [ ] Formats fill as `rgb(r,g,b)`
- [ ] Computes fill-opacity from alpha
- [ ] Includes fill-rule if specified

**Test**:
```typescript
test('buildStyleAttributes per-instance', () => {
  const style = {
    fillColor: new Uint8ClampedArray([255, 0, 0, 255, 0, 255, 0, 128]),
  };

  const attrs0 = buildStyleAttributes(style, 0, 2);
  expect(attrs0['fill']).toBe('rgb(255,0,0)');
  expect(attrs0['fill-opacity']).toBeUndefined(); // Alpha 255

  const attrs1 = buildStyleAttributes(style, 1, 2);
  expect(attrs1['fill']).toBe('rgb(0,255,0)');
  expect(attrs1['fill-opacity']).toBe('0.502'); // Alpha 128
});
```

---

### Task 3.3: Implement renderInstances()

**File**: `src/render/SVGRenderer.ts`
**Time**: 1 hour

**Steps**:
1. Clear existing children from renderGroup
2. Loop instances
3. Create `<use>` element for each
4. Set href, transform, fill, fill-opacity, fill-rule
5. Append to renderGroup

**Code Template**:
```typescript
function renderInstances(
  renderGroup: SVGGElement,
  defs: SVGDefsElement,
  op: DrawPathInstancesOp,
  geomKey: string,
  width: number,
  height: number
): void {
  // Clear existing instances
  while (renderGroup.firstChild) {
    renderGroup.removeChild(renderGroup.firstChild);
  }

  const { instances, style } = op;

  for (let i = 0; i < instances.count; i++) {
    const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');

    use.setAttribute('href', `#${geomKey}`);

    const transform = computeInstanceTransform(
      instances.position,
      i,
      instances.size,
      instances.rotation,
      instances.scale2,
      width,
      height
    );
    use.setAttribute('transform', transform);

    const styleAttrs = buildStyleAttributes(style, i, instances.count);
    for (const [key, value] of Object.entries(styleAttrs)) {
      use.setAttribute(key, value);
    }

    renderGroup.appendChild(use);
  }
}
```

**Acceptance Criteria**:
- [ ] Clears existing instances
- [ ] Creates N `<use>` elements for N instances
- [ ] Sets href to `#geomKey`
- [ ] Sets transform attribute
- [ ] Sets style attributes (fill, opacity, fillRule)
- [ ] Appends to renderGroup

**Test**:
```typescript
test('renderInstances creates use elements', () => {
  const renderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

  const op: DrawPathInstancesOp = {
    kind: 'drawPathInstances',
    geometry: { /* ... */ },
    instances: {
      count: 3,
      position: new Float32Array([0.5, 0.5, 0.3, 0.7, 0.8, 0.2]),
      size: 0.1,
    },
    style: {
      fillColor: new Uint8ClampedArray([255, 0, 0, 255]),
    },
  };

  renderInstances(renderGroup, defs, op, 'geom_0', 1000, 1000);
  expect(renderGroup.children.length).toBe(3);
  expect(renderGroup.children[0].tagName).toBe('use');
  expect(renderGroup.children[0].getAttribute('href')).toBe('#geom_0');
});
```

---

## Phase 4: Integration (1-2 hours)

### Task 4.1: Implement render() Method

**File**: `src/render/SVGRenderer.ts`
**Time**: 45 minutes

**Steps**:
1. Update viewBox if dimensions changed
2. Iterate frame.ops
3. For each op:
   - Generate geometry key
   - Get or create d string (via cache)
   - Ensure geometry def in defs
   - Render instances

**Code Template**:
```typescript
render(frame: RenderFrameIR_Future, width: number, height: number): void {
  // Update viewBox
  this.svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

  for (const op of frame.ops) {
    if (op.kind !== 'drawPathInstances') {
      console.warn('SVGRenderer: Unsupported op kind:', op.kind);
      continue;
    }

    // Generate geometry key
    const geomKey = `geom_${op.geometry.topologyId}_${/* buffer symbol */}`;

    // Get or create d string
    const dString = this.geometryCache.get(
      op.geometry.topologyId,
      op.geometry.points,
      () => pathToSvgD(op.geometry.verbs, op.geometry.points, op.geometry.pointsCount)
    );

    // Ensure geometry def
    ensureGeometryDef(this.defs, geomKey, dString);

    // Render instances
    renderInstances(this.renderGroup, this.defs, op, geomKey, width, height);
  }
}
```

**Acceptance Criteria**:
- [ ] viewBox updated
- [ ] All ops processed
- [ ] Geometry reused (cache hit for same buffer)
- [ ] Errors logged but don't crash
- [ ] Multiple ops coexist

**Test**:
```typescript
test('render processes multiple ops', () => {
  const container = document.createElement('div');
  const renderer = new SVGRenderer(container, 1000, 1000);

  const frame: RenderFrameIR_Future = {
    version: 2,
    ops: [
      { /* op 1 */ },
      { /* op 2 */ },
    ],
  };

  renderer.render(frame, 1000, 1000);

  const defs = container.querySelector('defs');
  expect(defs.children.length).toBeGreaterThan(0);

  renderer.dispose();
});
```

---

### Task 4.2: Create Test Page

**File**: `test-svg-renderer.html` (project root)
**Time**: 45 minutes

**Steps**:
1. Create HTML file
2. Import SVGRenderer
3. Create test DrawPathInstancesOp
4. Render side-by-side with Canvas2DRenderer
5. Visual verification

**Template**:
```html
<!DOCTYPE html>
<html>
<head>
  <title>SVG Renderer Test</title>
  <style>
    body { margin: 20px; display: flex; gap: 20px; }
    #svg-container { border: 2px solid blue; }
    #canvas-container { border: 2px solid red; }
  </style>
</head>
<body>
  <div>
    <h3>SVG Renderer</h3>
    <div id="svg-container"></div>
  </div>
  <div>
    <h3>Canvas Renderer (Reference)</h3>
    <canvas id="canvas-container" width="500" height="500"></canvas>
  </div>

  <script type="module">
    import { SVGRenderer } from './src/render/SVGRenderer.js';

    const op = {
      kind: 'drawPathInstances',
      geometry: {
        topologyId: 0,
        verbs: new Uint8Array([0, 1, 1, 1, 1, 4]), // Pentagon
        points: new Float32Array([0, -1, 0.951, 0.309, 0.588, 1, -0.588, 1, -0.951, 0.309]),
        pointsCount: 5,
      },
      instances: {
        count: 5,
        position: new Float32Array([0.2, 0.2, 0.5, 0.5, 0.8, 0.8, 0.3, 0.7, 0.7, 0.3]),
        size: 0.1,
      },
      style: {
        fillColor: new Uint8ClampedArray([
          255, 0, 0, 255,
          0, 255, 0, 255,
          0, 0, 255, 255,
          255, 255, 0, 255,
          255, 0, 255, 255,
        ]),
      },
    };

    const frame = { version: 2, ops: [op] };

    const svgRenderer = new SVGRenderer(
      document.getElementById('svg-container'),
      500,
      500
    );
    svgRenderer.render(frame, 500, 500);

    // TODO: Also render with Canvas2DRenderer for comparison
  </script>
</body>
</html>
```

**Acceptance Criteria**:
- [ ] Page loads without errors
- [ ] SVG renderer shows pentagons
- [ ] Pentagons positioned correctly
- [ ] Colors correct (red, green, blue, yellow, magenta)
- [ ] Visual match with Canvas renderer

---

## Phase 5: Documentation & Cleanup (1 hour)

### Task 5.1: Add Module Documentation

**File**: `src/render/SVGRenderer.ts`
**Time**: 30 minutes

**Steps**:
1. Add module-level JSDoc
2. Document coordinate space assumptions
3. Document each public method
4. Document helper functions

**Acceptance Criteria**:
- [ ] Module header describes purpose
- [ ] Coordinate spaces documented
- [ ] Public API documented
- [ ] Verb mapping documented
- [ ] Transform composition documented

---

### Task 5.2: Code Review Checklist

**Time**: 30 minutes

**Steps**:
1. Run `npm run typecheck` → No errors
2. Run `npm run lint` → No warnings
3. Visual verification → Matches Canvas
4. DOM inspection → One `<path>` per topology, N `<use>` per instance
5. Performance check → Renders 100 instances smoothly

**Acceptance Criteria**:
- [ ] No TypeScript errors
- [ ] No linter warnings
- [ ] Visual output correct
- [ ] DOM structure correct
- [ ] Performance acceptable

---

## Summary

**Total Time Estimate**: 8-12 hours (1-2 days)

**Critical Path**:
1. Verify dependencies → Blocking
2. Create structure → Foundation
3. Implement pathToSvgD → Core logic
4. Implement instance rendering → Core logic
5. Integrate & test → Validation

**Risk Areas**:
- Buffer identity tracking (use WeakMap)
- Transform order (translate → rotate → scale)
- Per-instance vs uniform values (check types)

**Success Metrics**:
- Visual match with Canvas2DRenderer
- DOM shows geometry reuse (inspect defs)
- No TypeScript/lint errors
- Test page demonstrates functionality
