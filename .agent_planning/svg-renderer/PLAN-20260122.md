# SVG Renderer Implementation Plan

**Bead ID**: oscilla-animator-v2-0uk
**Generated**: 2026-01-22
**Status**: READY FOR IMPLEMENTATION
**Confidence**: HIGH

## Overview

Create an SVG renderer that leverages local-space geometry for `<defs>`/`<use>` reuse. This renderer will be a sibling to Canvas2DRenderer, consuming the same DrawPathInstancesOp structure produced by RenderAssembler.

## Key Benefits

1. **Geometry Reuse**: One `<path id="geomKey" d="...">` per geometry template in `<defs>`
2. **Instancing**: Per-instance `<use href="#geomKey" transform="...">` elements
3. **Performance**: Massive win vs per-instance unique d strings
4. **Scalability**: Perfect for vector graphics export, print-quality output

## Architecture Context

### Coordinate Spaces (from spec section 1)

- **Local Space (L)**: Geometry/control points, centered at (0,0), |L| ≈ O(1)
- **World Space (W)**: Instance positions in normalized [0,1] coordinates
- **Viewport Space (V)**: SVG viewBox coordinates (xSvg, ySvg)

### Transform Model (from spec section 2)

```
xSvg = xW * viewBoxWidth
ySvg = yW * viewBoxHeight

sizeSvg = size * D  where D = min(viewBoxWidth, viewBoxHeight)
```

### Rendering Model (from spec section 8)

For each PathGeometryTemplate:
1. Compute d string once: `pathToSvgD(verbs, points, pointsCount)`
2. Cache by (topologyId, pointsBuffer identity)
3. Emit or update `<path id="geomKey" d="...">` in `<defs>`

For each instance:
1. Compute world→viewport transform
2. Compose SVG transform: `translate(xSvg, ySvg) rotate(θ*180/π) scale(sxSvg, sySvg)`
3. Emit or update `<use href="#geomKey" transform="..." fill="..." />`

## Dependencies

### Blocking (MUST be complete)
- ✅ **oscilla-animator-v2-583**: RenderAssembler v2 (IN_PROGRESS)
  - Provides DrawPathInstancesOp with PathGeometry, InstanceTransforms, PathStyle
- ⚠️ **oscilla-animator-v2-46m**: Renderer local-space migration (OPEN)
  - Control points must be in local space, not normalized world space
  - **CRITICAL**: Without this, control point semantics are wrong

### Non-Blocking (Nice to have)
- Future stroke rendering (oscilla-animator-v2-02h)
- Future per-instance shapes (oscilla-animator-v2-f2w)

## Implementation Plan

### Phase 1: Core SVG Renderer Structure

**File**: `src/render/SVGRenderer.ts`

#### 1.1 Renderer Interface & Setup

```typescript
export class SVGRenderer {
  private svg: SVGSVGElement;
  private defs: SVGDefsElement;
  private renderGroup: SVGGElement;
  private geometryCache: GeometryCache;

  constructor(container: HTMLElement, width: number, height: number);
  render(frame: RenderFrameIR_Future, width: number, height: number): void;
  clear(): void;
  dispose(): void;
}
```

**Tasks**:
- Create SVG element with proper viewBox
- Create `<defs>` for geometry templates
- Create `<g>` for instances
- Initialize geometry cache

**Acceptance Criteria**:
- [ ] SVG element created with viewBox="0 0 {width} {height}"
- [ ] `<defs>` element created and appended
- [ ] Render group created and appended
- [ ] Renderer can be constructed and disposed cleanly

#### 1.2 Geometry Cache

```typescript
interface GeometryCache {
  get(key: string, factory: () => string): string;
  has(key: string): boolean;
  clear(): void;
}

function computeGeometryKey(
  topologyId: number,
  pointsBuffer: Float32Array
): string;
```

**Caching Strategy**:
- Key: `${topologyId}:${pointsBufferIdentity}`
- Value: SVG path d string
- Identity: WeakMap for buffer object identity OR hash of points

**Tasks**:
- Implement GeometryCache class
- Implement computeGeometryKey with buffer identity tracking
- Implement pathToSvgD conversion

**Acceptance Criteria**:
- [ ] Cache stores d strings by (topologyId, buffer identity)
- [ ] Cache returns same d string for same buffer reference
- [ ] Cache handles different buffers with same topologyId
- [ ] Cache clears all entries on demand

### Phase 2: Path D String Generation

#### 2.1 Path Verb to SVG Command Mapping

```typescript
function pathToSvgD(
  verbs: Uint8Array,
  points: Float32Array,
  pointsCount: number
): string;
```

**Verb Mapping** (from PathVerb enum):
- `MOVE (0)` → `M x y`
- `LINE (1)` → `L x y`
- `CUBIC (2)` → `C cp1x cp1y cp2x cp2y x y`
- `QUAD (3)` → `Q cpx cpy x y`
- `CLOSE (4)` → `Z`

**Point Consumption**:
- MOVE: 1 point
- LINE: 1 point
- CUBIC: 3 points
- QUAD: 2 points
- CLOSE: 0 points

**Tasks**:
- Implement pathToSvgD with verb switch
- Handle point index tracking
- Validate pointsCount matches verbs
- Format numbers with appropriate precision (6 decimals)

**Acceptance Criteria**:
- [ ] MOVE verb produces `M x y`
- [ ] LINE verb produces `L x y`
- [ ] CUBIC verb produces `C cp1x cp1y cp2x cp2y x y`
- [ ] QUAD verb produces `Q cpx cpy x y`
- [ ] CLOSE verb produces `Z`
- [ ] Point index increments correctly for each verb
- [ ] Throws error if pointsCount is insufficient
- [ ] Numbers formatted with 6 decimal precision

#### 2.2 Geometry Definition Management

```typescript
function ensureGeometryDef(
  defs: SVGDefsElement,
  geomKey: string,
  dString: string
): void;

function createPathElement(id: string, d: string): SVGPathElement;
```

**Tasks**:
- Check if `<path id="{geomKey}">` exists in defs
- If not, create and append
- If exists, verify d attribute matches (or update if needed)

**Acceptance Criteria**:
- [ ] Creates `<path>` element with id and d attributes
- [ ] Appends to `<defs>` if not present
- [ ] Reuses existing path if id matches
- [ ] Updates d attribute if geometry changes (rare edge case)

### Phase 3: Instance Rendering

#### 3.1 Transform Composition

```typescript
function computeInstanceTransform(
  position: Float32Array,
  instanceIndex: number,
  size: number | Float32Array,
  rotation: Float32Array | number | undefined,
  scale2: Float32Array | undefined,
  width: number,
  height: number
): string;
```

**Algorithm** (from spec section 8):
```typescript
const xW = position[i*2];
const yW = position[i*2+1];
const xSvg = xW * width;
const ySvg = yW * height;

const D = Math.min(width, height);
const s = (typeof size === 'number') ? size : size[i];
const θ = Array.isArray(rotation) ? rotation[i] : (rotation ?? 0);

let sxSvg = s * D;
let syaSvg = s * D;
if (scale2) {
  sxSvg = scale2[i*2] * D;
  sySvg = scale2[i*2+1] * D;
}

const θDeg = θ * 180 / Math.PI;
return `translate(${xSvg},${ySvg}) rotate(${θDeg}) scale(${sxSvg},${sySvg})`;
```

**Tasks**:
- Extract position from buffer
- Resolve size (uniform or per-instance)
- Resolve rotation (optional)
- Resolve scale2 (optional)
- Compute viewport coordinates
- Format transform string

**Acceptance Criteria**:
- [ ] Position mapped from normalized [0,1] to viewport coordinates
- [ ] Size scaled by D (min dimension)
- [ ] Rotation converted from radians to degrees
- [ ] scale2 overrides isotropic size if present
- [ ] Transform order: translate, rotate, scale
- [ ] Numbers formatted with 6 decimal precision

#### 3.2 Style Mapping

```typescript
function buildStyleAttributes(
  style: PathStyle,
  instanceIndex: number
): Record<string, string>;
```

**Style Attributes**:
- `fill`: RGBA color → `rgb(r,g,b)` or `#RRGGBB`
- `fill-opacity`: Alpha channel → `0.0` to `1.0`
- `fill-rule`: `'nonzero'` | `'evenodd'`
- Future: `stroke`, `stroke-width`, `stroke-opacity`, etc.

**Tasks**:
- Extract RGBA from fillColor buffer (per-instance or uniform)
- Format color as hex or rgb()
- Extract alpha as opacity
- Map fill rule

**Acceptance Criteria**:
- [ ] Fill color extracted from Uint8ClampedArray
- [ ] Per-instance colors supported (i*4 offset)
- [ ] Uniform color supported (single RGBA)
- [ ] Alpha mapped to fill-opacity [0,1]
- [ ] Fill rule mapped correctly
- [ ] Attributes returned as object for easy setAttribute

#### 3.3 Instance Element Management

```typescript
function renderInstances(
  renderGroup: SVGGElement,
  op: DrawPathInstancesOp,
  geomKey: string,
  width: number,
  height: number
): void;
```

**Rendering Strategy**:
- Clear existing children (simple approach for v1)
- For each instance, create `<use>` element
- Set href, transform, fill, fill-opacity, fill-rule

**Future Optimization** (out of scope for initial implementation):
- Reuse existing `<use>` elements
- Update only changed attributes
- Pool `<use>` elements

**Tasks**:
- Clear renderGroup children
- Loop instances and create `<use>` elements
- Set attributes (href, transform, fill, etc.)
- Append to renderGroup

**Acceptance Criteria**:
- [ ] Existing instances cleared before render
- [ ] One `<use>` element per instance
- [ ] href attribute points to correct geometry def
- [ ] transform attribute computed correctly
- [ ] fill and fill-opacity set correctly
- [ ] fill-rule set if specified

### Phase 4: Frame Rendering & Integration

#### 4.1 Main Render Function

```typescript
render(frame: RenderFrameIR_Future, width: number, height: number): void {
  // Update viewBox if dimensions changed
  // For each DrawPathInstancesOp:
  //   1. Get or create geometry definition
  //   2. Render instances
}
```

**Tasks**:
- Handle viewBox updates
- Iterate frame.ops
- Dispatch to renderInstances for each op
- Handle errors gracefully

**Acceptance Criteria**:
- [ ] viewBox updated if width/height change
- [ ] All ops rendered in order
- [ ] Errors logged but don't crash renderer
- [ ] Multiple ops can coexist in same frame

#### 4.2 Renderer Registration & Testing

**Tasks**:
- Export SVGRenderer from module
- Create manual test page (similar to Canvas2D test)
- Integrate with main App.tsx (optional toggle)

**Acceptance Criteria**:
- [ ] SVGRenderer exports public API
- [ ] Test page renders a simple frame
- [ ] Multiple instances render correctly
- [ ] Geometry reuse verified (inspect DOM)
- [ ] Transform attributes correct (visual verification)

## Testing Strategy

### Unit Tests
- `pathToSvgD()`: Verify all verb types produce correct commands
- `computeGeometryKey()`: Verify same buffer → same key
- `computeInstanceTransform()`: Verify coordinate space mapping
- `buildStyleAttributes()`: Verify color/opacity formatting

### Integration Tests
- Render single DrawPathInstancesOp with 1 instance
- Render single DrawPathInstancesOp with N instances
- Render multiple DrawPathInstancesOp (different topologies)
- Verify geometry reuse (same topology, multiple instances)

### Visual Tests
- Compare Canvas2D vs SVG output (should match)
- Inspect SVG DOM structure (defs, use elements)
- Test with pentagon, circle, square topologies
- Test with different colors, sizes, rotations

## Risks & Mitigations

### Risk: Control Points in Wrong Space
**Impact**: Geometry will be incorrectly scaled or positioned
**Mitigation**: Depends on oscilla-animator-v2-46m completion. Document assumption clearly in code comments.
**Status**: BLOCKING - Must wait for local-space migration

### Risk: Buffer Identity Tracking
**Impact**: Cache may not reuse geometry correctly
**Mitigation**: Use WeakMap for buffer identity first. If issues arise, fall back to content hash.
**Status**: MEDIUM - Has fallback strategy

### Risk: Performance with Many Instances
**Impact**: Creating N `<use>` elements per frame may be slow
**Mitigation**: Start with simple clear+recreate. Profile later. Optimization (element reuse) can be added later.
**Status**: LOW - Optimization not in critical path

## Success Criteria

- [ ] SVGRenderer renders DrawPathInstancesOp correctly
- [ ] Geometry reused via `<defs>`/`<use>` pattern
- [ ] Instance transforms computed correctly (position, size, rotation, scale2)
- [ ] Style attributes applied correctly (fill, opacity, fillRule)
- [ ] Visual output matches Canvas2DRenderer
- [ ] DOM inspection shows one `<path>` per topology, N `<use>` per instance
- [ ] Code documented with coordinate space assumptions
- [ ] Test page demonstrates renderer functionality

## Out of Scope

- Stroke rendering (depends on oscilla-animator-v2-02h)
- Per-instance shapes Field<shape> (depends on oscilla-animator-v2-f2w)
- Element pooling/reuse optimization
- SVG export to file
- Animation/SMIL
- Filters, gradients, patterns
- Text rendering

## Next Steps

1. Wait for oscilla-animator-v2-46m (local-space migration) to complete
2. Verify RenderAssembler produces correct DrawPathInstancesOp
3. Implement SVGRenderer following this plan
4. Test with existing topologies (pentagon, ellipse, rect)
5. Integrate with App.tsx for side-by-side comparison
