# SVG Renderer Implementation Context

**Bead ID**: oscilla-animator-v2-0uk
**Generated**: 2026-01-22

## Purpose

This document provides comprehensive context for implementing the SVG renderer. An agent with ONLY this file should be able to implement the feature with minimal external research.

## Architectural Background

### The Rendering Pipeline

The Oscilla rendering pipeline has three stages:

1. **Compilation** (compiler/): Graph → IR (Intermediate Representation)
2. **Runtime** (runtime/): Execute IR → Fill state banks → Produce RenderFrameIR
3. **Rendering** (render/): RenderFrameIR → Pixels/SVG

The SVG renderer lives in stage 3, consuming the output of RenderAssembler.

### Coordinate Space Model

Three coordinate spaces exist:

#### Local Space (L)
- **Purpose**: Geometry definition (control points, shape templates)
- **Origin**: (0, 0) at shape's logical center
- **Magnitude**: |L| ≈ O(1) (e.g., radius 1.0 for unit circle)
- **Example**: Pentagon vertices at (cos(2π*k/5), sin(2π*k/5)), k=0..4
- **Independence**: No dependence on viewport or instance position

#### World Space (W)
- **Purpose**: Instance placement and animation
- **Coordinates**: Normalized [0, 1] for both x and y
- **Example**: Center of screen = (0.5, 0.5), top-left = (0, 0)
- **Independence**: Resolution-independent logical coordinates

#### Viewport Space (V)
- **Purpose**: Backend-specific render coordinates
- **Canvas**: Pixel coordinates (xPx, yPx)
- **SVG**: viewBox coordinates (xSvg, ySvg)
- **Mapping**: `xSvg = xW * viewBoxWidth`, `ySvg = yW * viewBoxHeight`

### Transform Model

The canonical transform from local to viewport:

```
Given:
  pL = (xL, yL)         // Local-space point
  pW = (xW, yW)         // World-space instance position
  θ                     // Rotation (radians)
  s                     // Isotropic scale (world units)
  S = (sx, sy)          // Optional anisotropic scale (world units)

Viewport mapping:
  xSvg = xW * viewBoxWidth
  ySvg = yW * viewBoxHeight

  D = min(viewBoxWidth, viewBoxHeight)  // Reference length
  sizeSvg = s * D
  sxSvg = sx * D  (if scale2 present)
  sySvg = sy * D  (if scale2 present)

SVG transform attribute:
  translate(xSvg, ySvg) rotate(θ*180/π) scale(sxSvg, sySvg)
```

**CRITICAL**: Transform order is `translate`, then `rotate`, then `scale`. This ensures rotation happens around the instance's center.

### The DrawPathInstancesOp Structure

The SVG renderer consumes `DrawPathInstancesOp` from RenderAssembler:

```typescript
interface DrawPathInstancesOp {
  readonly kind: 'drawPathInstances';
  readonly geometry: PathGeometry;      // WHAT to draw
  readonly instances: InstanceTransforms; // WHERE to draw it
  readonly style: PathStyle;            // HOW to style it
}

interface PathGeometry {
  readonly topologyId: number;          // Unique topology identifier
  readonly verbs: Uint8Array;           // Path commands (MOVE, LINE, etc.)
  readonly points: Float32Array;        // Control points in LOCAL SPACE
  readonly pointsCount: number;         // Number of vec2 points
  readonly flags?: number;              // Path flags (closed, etc.)
}

interface InstanceTransforms {
  readonly count: number;               // Number of instances
  readonly position: Float32Array;      // World [0,1] coords (x,y interleaved)
  readonly size: number | Float32Array; // Isotropic scale (uniform or per-instance)
  readonly rotation?: Float32Array;     // Radians (per-instance, optional)
  readonly scale2?: Float32Array;       // Anisotropic (x,y interleaved, optional)
}

interface PathStyle {
  readonly fillColor: Uint8ClampedArray; // RGBA (per-instance or uniform)
  readonly fillRule?: 'nonzero' | 'evenodd';
  readonly strokeColor?: Uint8ClampedArray;  // Future
  readonly strokeWidth?: number | Float32Array; // Future
  readonly globalAlpha?: number | Float32Array; // Future
}
```

## Key Files & Symbols

### Dependencies (Read these to understand context)

#### `src/render/future-types.ts`
- **Purpose**: Target types for v2 rendering
- **Key Types**: `DrawPathInstancesOp`, `PathGeometry`, `InstanceTransforms`, `PathStyle`, `RenderFrameIR_Future`
- **Lines of Interest**: 36-201 (all type definitions)

#### `src/runtime/RenderAssembler.ts`
- **Purpose**: Produces DrawPathInstancesOp from IR
- **Key Functions**:
  - `assembleDrawPathInstancesOp()`: Lines 403-491 (produces the op)
  - `buildPathGeometry()`: Lines 316-341 (geometry extraction)
  - `buildInstanceTransforms()`: Lines 357-371 (transform assembly)
  - `buildPathStyle()`: Lines 383-391 (style assembly)
- **Status**: IN_PROGRESS (oscilla-animator-v2-583)

#### `src/render/Canvas2DRenderer.ts` (Reference Implementation)
- **Purpose**: Canvas backend, sibling to SVG renderer
- **Key Functions**:
  - `renderFrame()`: Lines 50-64 (frame rendering entry point)
  - `renderPass()`: Lines 69-81 (pass dispatch)
  - `renderInstances2D()`: Lines 96-144 (instance loop)
  - `renderPathAtParticle()`: Lines 180-259 (path rendering)
- **Current Issue**: Lines 199-227 scale control points by width/height (WRONG for local-space)
- **Note**: Will be fixed by oscilla-animator-v2-46m

#### `src/shapes/types.ts`
- **Purpose**: Shape topology definitions
- **Key Types**:
  - `PathVerb` (enum): Lines 100-111 (MOVE=0, LINE=1, CUBIC=2, QUAD=3, CLOSE=4)
  - `PathTopologyDef`: Lines 132-141 (path topology structure)
- **Key Concepts**: Verbs define WHAT to draw, control points define WHERE

### Files to Create

#### `src/render/SVGRenderer.ts` (NEW)
- **Purpose**: SVG renderer implementation
- **Module Structure**:
  ```typescript
  // Geometry cache for d string reuse
  class GeometryCache { ... }

  // Main renderer class
  export class SVGRenderer {
    constructor(container: HTMLElement, width: number, height: number);
    render(frame: RenderFrameIR_Future, width: number, height: number): void;
    clear(): void;
    dispose(): void;
  }

  // Utility functions
  function pathToSvgD(verbs, points, pointsCount): string;
  function computeGeometryKey(topologyId, pointsBuffer): string;
  function computeInstanceTransform(...): string;
  function buildStyleAttributes(style, instanceIndex): Record<string, string>;
  ```

## Implementation Details

### Geometry Cache Strategy

The cache maps geometry templates to SVG `d` strings:

```typescript
class GeometryCache {
  private cache = new Map<string, string>();
  private bufferKeys = new WeakMap<Float32Array, symbol>();

  get(topologyId: number, points: Float32Array, factory: () => string): string {
    const key = this.computeKey(topologyId, points);
    if (!this.cache.has(key)) {
      this.cache.set(key, factory());
    }
    return this.cache.get(key)!;
  }

  private computeKey(topologyId: number, points: Float32Array): string {
    // Get or create unique symbol for buffer identity
    let bufferKey = this.bufferKeys.get(points);
    if (!bufferKey) {
      bufferKey = Symbol();
      this.bufferKeys.set(points, bufferKey);
    }
    return `${topologyId}:${String(bufferKey)}`;
  }
}
```

**Why WeakMap?**: If a buffer is garbage collected, its entry in WeakMap is automatically removed. This prevents memory leaks.

**Alternative**: If buffer identity is unreliable, hash the buffer contents. Trade-off: more computation, but deterministic cache key.

### Path D String Generation

SVG path commands map 1:1 to PathVerb:

| PathVerb | Value | SVG Command | Points Consumed |
|----------|-------|-------------|-----------------|
| MOVE     | 0     | `M x y`     | 1               |
| LINE     | 1     | `L x y`     | 1               |
| CUBIC    | 2     | `C cp1x cp1y cp2x cp2y x y` | 3 |
| QUAD     | 3     | `Q cpx cpy x y` | 2           |
| CLOSE    | 4     | `Z`         | 0               |

```typescript
function pathToSvgD(
  verbs: Uint8Array,
  points: Float32Array,
  pointsCount: number
): string {
  const parts: string[] = [];
  let pi = 0; // Point index

  for (let vi = 0; vi < verbs.length; vi++) {
    const verb = verbs[vi];

    switch (verb) {
      case 0: { // MOVE
        const x = points[pi*2].toFixed(6);
        const y = points[pi*2+1].toFixed(6);
        parts.push(`M ${x} ${y}`);
        pi++;
        break;
      }

      case 1: { // LINE
        const x = points[pi*2].toFixed(6);
        const y = points[pi*2+1].toFixed(6);
        parts.push(`L ${x} ${y}`);
        pi++;
        break;
      }

      case 2: { // CUBIC
        const cp1x = points[pi*2].toFixed(6);
        const cp1y = points[pi*2+1].toFixed(6);
        const cp2x = points[(pi+1)*2].toFixed(6);
        const cp2y = points[(pi+1)*2+1].toFixed(6);
        const endx = points[(pi+2)*2].toFixed(6);
        const endy = points[(pi+2)*2+1].toFixed(6);
        parts.push(`C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${endx} ${endy}`);
        pi += 3;
        break;
      }

      case 3: { // QUAD
        const cpx = points[pi*2].toFixed(6);
        const cpy = points[pi*2+1].toFixed(6);
        const endx = points[(pi+1)*2].toFixed(6);
        const endy = points[(pi+1)*2+1].toFixed(6);
        parts.push(`Q ${cpx} ${cpy} ${endx} ${endy}`);
        pi += 2;
        break;
      }

      case 4: { // CLOSE
        parts.push('Z');
        break;
      }

      default:
        throw new Error(`Unknown PathVerb: ${verb}`);
    }
  }

  if (pi !== pointsCount) {
    throw new Error(
      `Path consumed ${pi} points but pointsCount is ${pointsCount}`
    );
  }

  return parts.join(' ');
}
```

**Why toFixed(6)?**: SVG doesn't need float64 precision. 6 decimals is ~micron precision at 1000px scale, plenty for graphics.

### Instance Transform Computation

```typescript
function computeInstanceTransform(
  position: Float32Array,
  instanceIndex: number,
  size: number | Float32Array,
  rotation: Float32Array | number | undefined,
  scale2: Float32Array | undefined,
  width: number,
  height: number
): string {
  // Extract world-space position
  const xW = position[instanceIndex * 2];
  const yW = position[instanceIndex * 2 + 1];

  // Map to viewport
  const xSvg = xW * width;
  const ySvg = yW * height;

  // Compute reference dimension
  const D = Math.min(width, height);

  // Resolve size (uniform or per-instance)
  const s = typeof size === 'number' ? size : size[instanceIndex];

  // Resolve rotation (optional)
  const θ = rotation
    ? (typeof rotation === 'number' ? rotation : rotation[instanceIndex])
    : 0;
  const θDeg = θ * 180 / Math.PI;

  // Resolve scale (isotropic or anisotropic)
  let sxSvg = s * D;
  let sySvg = s * D;
  if (scale2) {
    sxSvg = scale2[instanceIndex * 2] * D;
    sySvg = scale2[instanceIndex * 2 + 1] * D;
  }

  // Format transform (order matters!)
  return `translate(${xSvg.toFixed(6)},${ySvg.toFixed(6)}) rotate(${θDeg.toFixed(6)}) scale(${sxSvg.toFixed(6)},${sySvg.toFixed(6)})`;
}
```

**Transform Order Rationale**:
1. **Translate**: Move to instance position in viewport
2. **Rotate**: Rotate around instance center (now at origin due to translate)
3. **Scale**: Scale local-space geometry to world size

If we did `scale` before `translate`, the translation would be scaled too (wrong). If we did `rotate` before `translate`, rotation would be around viewport origin (wrong).

### Style Attribute Mapping

```typescript
function buildStyleAttributes(
  style: PathStyle,
  instanceIndex: number
): Record<string, string> {
  const attrs: Record<string, string> = {};

  // Fill color
  const fillColor = style.fillColor;
  const r = fillColor[instanceIndex * 4 + 0];
  const g = fillColor[instanceIndex * 4 + 1];
  const b = fillColor[instanceIndex * 4 + 2];
  const a = fillColor[instanceIndex * 4 + 3];

  // Format as hex (more compact) or rgb()
  attrs['fill'] = `rgb(${r},${g},${b})`;

  // Alpha as opacity
  if (a !== 255) {
    attrs['fill-opacity'] = (a / 255).toFixed(3);
  }

  // Fill rule
  if (style.fillRule) {
    attrs['fill-rule'] = style.fillRule;
  }

  return attrs;
}
```

**Note**: If fillColor is uniform (length 4), all instances share the same color. Check `fillColor.length === 4` vs `fillColor.length === count * 4`.

### SVG DOM Structure

The renderer creates this DOM structure:

```xml
<svg viewBox="0 0 {width} {height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <path id="geom_0_symbolA" d="M 0 -1 L 0.951 0.309 L 0.588 1 ..." />
    <path id="geom_1_symbolB" d="M -0.5 -0.5 L 0.5 -0.5 L 0.5 0.5 ..." />
  </defs>
  <g id="instances">
    <use href="#geom_0_symbolA" transform="translate(250,250) rotate(0) scale(50,50)" fill="rgb(255,0,0)" />
    <use href="#geom_0_symbolA" transform="translate(500,500) rotate(45) scale(75,75)" fill="rgb(0,255,0)" />
    <use href="#geom_1_symbolB" transform="translate(750,250) rotate(90) scale(100,100)" fill="rgb(0,0,255)" />
  </g>
</svg>
```

**Key Observations**:
- One `<path>` per unique geometry (topology + points)
- N `<use>` elements for N instances
- Geometry defines WHAT, `<use>` defines WHERE and HOW

## Dependency Details

### Blocking: oscilla-animator-v2-46m (Local-Space Migration)

**Status**: OPEN
**Issue**: Control points currently in normalized [0,1] world space
**Required**: Control points in local space (centered at origin)

**Impact on SVG Renderer**:
- Without this fix, geometry in `<defs>` will be incorrect
- Scale transforms will behave unexpectedly
- MUST wait for this fix before SVG renderer can work correctly

**Files Affected**:
- `src/render/Canvas2DRenderer.ts`: Lines 199-227 (removes `* width`, `* height`)
- `src/runtime/Materializer.ts`: Kernel outputs (polygonVertex, etc.)
- Tests verifying local-space semantics

**Verification**:
```typescript
// Before fix: points in [0, 1] range
points = [0.5, 0.3, 0.7, 0.8, ...]  // WRONG

// After fix: points centered at origin
points = [0, -1, 0.951, 0.309, ...]  // CORRECT (pentagon at radius 1.0)
```

### Blocking: oscilla-animator-v2-583 (RenderAssembler v2)

**Status**: IN_PROGRESS
**Required**: `assembleDrawPathInstancesOp()` function complete

**Current State** (as of 2026-01-22):
- RenderAssembler.ts exists with v2 functions (lines 303-521)
- `assembleDrawPathInstancesOp()` implemented (lines 403-491)
- Helper functions (`buildPathGeometry`, etc.) implemented
- **NEED TO VERIFY**: Function is tested and used in ScheduleExecutor

**Verification**:
- Call `assembleDrawPathInstancesOp()` with a render step
- Verify it returns DrawPathInstancesOp structure
- Verify geometry.points is Float32Array
- Verify instances.position is Float32Array

## Testing Strategy

### Unit Test Examples

#### Test: pathToSvgD with Pentagon

```typescript
test('pathToSvgD generates correct d string for pentagon', () => {
  const verbs = new Uint8Array([0, 1, 1, 1, 1, 4]); // MOVE, 4xLINE, CLOSE
  const points = new Float32Array([
    0, -1,          // Top vertex
    0.951, 0.309,   // Upper-right
    0.588, 1,       // Lower-right
    -0.588, 1,      // Lower-left
    -0.951, 0.309,  // Upper-left
  ]);

  const d = pathToSvgD(verbs, points, 5);

  expect(d).toContain('M 0.000000 -1.000000');
  expect(d).toContain('L 0.951000 0.309000');
  expect(d).toContain('Z');
});
```

#### Test: computeInstanceTransform

```typescript
test('computeInstanceTransform computes correct SVG transform', () => {
  const position = new Float32Array([0.5, 0.5]); // Center
  const size = 0.1; // Isotropic
  const rotation = Math.PI / 4; // 45 degrees
  const width = 1000;
  const height = 1000;

  const transform = computeInstanceTransform(
    position, 0, size, rotation, undefined, width, height
  );

  expect(transform).toBe('translate(500.000000,500.000000) rotate(45.000000) scale(100.000000,100.000000)');
});
```

### Integration Test Example

```typescript
test('SVGRenderer renders DrawPathInstancesOp', () => {
  const container = document.createElement('div');
  const renderer = new SVGRenderer(container, 1000, 1000);

  const op: DrawPathInstancesOp = {
    kind: 'drawPathInstances',
    geometry: {
      topologyId: 0,
      verbs: new Uint8Array([0, 1, 1, 4]), // Triangle
      points: new Float32Array([0, -1, 0.866, 0.5, -0.866, 0.5]),
      pointsCount: 3,
    },
    instances: {
      count: 2,
      position: new Float32Array([0.5, 0.5, 0.7, 0.3]),
      size: 0.1,
    },
    style: {
      fillColor: new Uint8ClampedArray([255, 0, 0, 255, 0, 255, 0, 255]),
    },
  };

  const frame: RenderFrameIR_Future = { version: 2, ops: [op] };
  renderer.render(frame, 1000, 1000);

  // Verify DOM structure
  const svg = container.querySelector('svg');
  expect(svg).toBeTruthy();

  const defs = svg.querySelector('defs');
  expect(defs.children.length).toBe(1); // One geometry

  const instances = svg.querySelector('#instances');
  expect(instances.children.length).toBe(2); // Two instances

  renderer.dispose();
});
```

### Visual Test Page

Create `test-svg-renderer.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <title>SVG Renderer Test</title>
  <style>
    body { margin: 0; display: flex; gap: 20px; }
    #svg-container, #canvas-container { border: 1px solid #ccc; }
  </style>
</head>
<body>
  <div id="svg-container"></div>
  <canvas id="canvas-container" width="1000" height="1000"></canvas>

  <script type="module">
    import { SVGRenderer } from './src/render/SVGRenderer.js';
    import { renderFrame as renderCanvas } from './src/render/Canvas2DRenderer.js';

    // Create test DrawPathInstancesOp
    const op = { /* ... */ };
    const frame = { version: 2, ops: [op] };

    // Render with SVG
    const svgRenderer = new SVGRenderer(
      document.getElementById('svg-container'),
      1000,
      1000
    );
    svgRenderer.render(frame, 1000, 1000);

    // Render with Canvas (for comparison)
    const canvas = document.getElementById('canvas-container');
    const ctx = canvas.getContext('2d');
    renderCanvas(ctx, frame, 1000, 1000);
  </script>
</body>
</html>
```

## Common Pitfalls & Solutions

### Pitfall: Transform Order
**Problem**: Rotating before translating causes rotation around wrong origin
**Solution**: Always `translate` → `rotate` → `scale`

### Pitfall: Radians vs Degrees
**Problem**: SVG `rotate()` expects degrees, transforms use radians
**Solution**: Always multiply by `180/π` when formatting rotation

### Pitfall: Buffer Identity vs Content
**Problem**: Same geometry with different buffer instances → duplicate `<path>` elements
**Solution**: Use WeakMap for buffer identity tracking, or hash content

### Pitfall: Per-Instance vs Uniform Values
**Problem**: Accessing `size[i]` when size is a number crashes
**Solution**: Always check `typeof size === 'number'` before indexing

### Pitfall: Color Buffer Length
**Problem**: Assuming per-instance colors when buffer is uniform
**Solution**: Check `fillColor.length === 4` (uniform) vs `fillColor.length === count * 4` (per-instance)

## Performance Considerations

### Initial Implementation (Simple)
- Clear all `<use>` elements every frame
- Recreate N `<use>` elements
- Update `<defs>` only when geometry changes

**Pros**: Simple, correct, easy to debug
**Cons**: Creates/destroys DOM elements every frame

### Future Optimization (Out of Scope)
- Pool `<use>` elements, update attributes only
- Track which instances changed (dirty flags)
- Batch DOM updates

**When to Optimize**: After profiling shows DOM manipulation is bottleneck

## Success Metrics

### Functional
- [ ] Geometry reused (1 `<path>` for N instances)
- [ ] Transforms correct (visual match with Canvas)
- [ ] Colors correct (per-instance or uniform)
- [ ] Multiple topologies coexist in same frame

### Performance
- [ ] Renders 100 instances at 60fps (not critical for v1)
- [ ] DOM structure minimal (no duplicate `<path>` elements)

### Code Quality
- [ ] No TypeScript errors
- [ ] Documented coordinate space assumptions
- [ ] Error handling present (throws with clear messages)
- [ ] Follows project conventions

## Related Documentation

- **Spec**: `.agent_planning/_future/3-local-space-spec-deeper.md` section 8
- **Types**: `src/render/future-types.ts` lines 36-201
- **Reference**: `src/render/Canvas2DRenderer.ts` (current implementation)
- **Topology**: `src/shapes/types.ts` (PathVerb enum, topology definitions)

## Questions & Clarifications

If you encounter ambiguity during implementation:

1. **Coordinate space unclear?** → Check spec section 1 (coordinate spaces)
2. **Transform order wrong?** → Check spec section 2 (transform model)
3. **Verb mapping unclear?** → Check PathVerb enum in shapes/types.ts
4. **Buffer format unclear?** → Check future-types.ts (PathGeometry, InstanceTransforms)
5. **Still unclear?** → Ask user for clarification

## Summary

You now have:
- **Architecture**: Understand pipeline stages, coordinate spaces, transform model
- **Types**: Know DrawPathInstancesOp structure and fields
- **Algorithm**: Know how to convert verbs→d string, compute transforms, apply styles
- **Files**: Know what to read (context) and what to create (SVGRenderer.ts)
- **Tests**: Have examples for unit, integration, and visual verification
- **Dependencies**: Know what must be complete (46m, 583) before implementation

**Next Step**: Wait for dependencies (46m, 583) to complete, then implement SVGRenderer following PLAN-20260122.md.
