# EVALUATION: ScheduleExecutor Two-Phase Execution Pattern Documentation

**Date**: 2026-01-27  
**Timestamp**: 20260127-045625  
**Topic**: Document why the two-phase execution pattern in ScheduleExecutor is non-negotiable  
**Directory**: `.agent_planning/schedule-executor-two-phase-doc/`

---

## EXECUTIVE SUMMARY

The ScheduleExecutor implements a **two-phase execution model** where:
- **Phase 1** executes all non-state-write steps (evalSig, slotWriteStrided, materialize, continuity operations, events, render)
- **Phase 2** executes all state-write steps (stateWrite, fieldStateWrite)

This pattern is **critical to correctness** but is **currently under-documented**. The code is well-implemented but lacks:
1. Explicit documentation of *why* this ordering matters
2. Architecture-level rationale in design docs
3. Clear specification of what invariants depend on it
4. Guidance for maintainers/future contributors

---

## SECTION 1: WHAT EXISTS

### 1.1 Current Implementation (ScheduleExecutor.ts)

The two-phase pattern is implemented in `src/runtime/ScheduleExecutor.ts` (lines 167-505):

#### Phase 1: Lines 184-410
```typescript
// PHASE 1: Execute all non-stateWrite steps
for (const step of steps) {
  switch (step.kind) {
    case 'evalSig': { /* evaluate and cache */ }
    case 'slotWriteStrided': { /* write multi-component values */ }
    case 'materialize': { /* instantiate field buffers */ }
    case 'render': { /* collect render ops */ }
    case 'continuityMapBuild': { /* detect domain changes */ }
    case 'continuityApply': { /* smooth field transitions */ }
    case 'evalEvent': { /* fire events */ }
    case 'fieldStateWrite': { /* SKIP - handled in Phase 2 */ }
    case 'stateWrite': { /* SKIP - handled in Phase 2 */ }
  }
}
```

#### Phase 2: Lines 464-505
```typescript
// PHASE 2: Execute all stateWrite steps
// This ensures state reads in Phase 1 saw previous frame's values
for (const step of steps) {
  if (step.kind === 'stateWrite') {
    const value = evaluateSignal(step.value, signals, state);
    state.state[step.stateSlot as number] = value;
  }
  if (step.kind === 'fieldStateWrite') {
    // ... materialize field and write each lane to state ...
  }
}
```

#### Key Code Comments (Lines 167-171)
```typescript
// 3. Execute schedule steps in TWO PHASES
// Phase 1: Execute evalSig, slotWriteStrided, materialize, render (skip stateWrite)
// Phase 2: Execute all stateWrite steps
// This ensures state reads see previous frame's values
```

### 1.2 Schedule Compilation (pass7-schedule.ts)

The schedule is built in `src/compiler/passes-v2/pass7-schedule.ts` with explicit ordering constraints:

- Lines 4-15 document the phase ordering:
  ```
  1. Update rails/time inputs
  2. Execute continuous scalars (evalSig)
  3. Build continuity mappings (continuityMapBuild)
  4. Execute continuous fields (materialize)
  5. Apply continuity to field targets (continuityApply)
  6. Apply discrete ops (events)
  7. Sinks (render)
  8. State writes (stateWrite)
  ```

- ScheduleIR (lines 43-67) is data, not code, but contains explicit phases
- Steps are topologically sorted within phases to respect dependencies

### 1.3 Related Implementation

**Step Type Definitions** (`src/compiler/ir/types.ts:434-550`):
- `StepStateWrite` (scalar state): reads a signal, writes to state array
- `StepFieldStateWrite` (field state): reads a field, writes per-lane to state array
- All other step types have no side effects on persistent state

**State Types** (`src/compiler/ir/types.ts:553-573`):
- `StableStateId` identifies state arrays across recompilation
- State is semantic (stable) but slots are positional (unstable)
- Only stateful primitives (UnitDelay, Lag, Phasor, SampleAndHold) have state

**Signal Evaluator** (`src/runtime/SignalEvaluator.ts`):
- Reads from signal cache in Phase 1
- Reads from state store using `SigExprStateRead` nodes
- **Critical**: State reads happen in Phase 1, writes deferred to Phase 2

---

## SECTION 2: WHAT'S MISSING (Documentation Gaps)

### 2.1 Missing Core Rationale Documentation

**Gap 1: No explicit "why" document**
- No design doc explaining why this pattern is necessary
- No invariant explicitly tied to two-phase execution
- Rationale is implicit in code comments only

**Gap 2: No stateful boundary specification**
- Where stateful blocks are allowed (cycles must cross stateful boundary)
- How two-phase execution enforces this
- What happens if phases are violated

**Gap 3: Missing hot-swap implications**
- How state continuity interacts with two-phase execution
- State migration happens *after* Phase 2
- Why this ordering prevents glitches

**Gap 4: No architecture diagram**
- Visual showing Phase 1 reads from t-1 state, Phase 2 writes t state
- Data flow: slot cache → renders, state array → Phase 2

### 2.2 Missing Spec Integration

**Invariant I7 (Cycles must cross stateful boundary)** is documented in ESSENTIAL-SPEC.md but:
- No explanation that Phase 2 *is* that boundary
- No diagram showing how phases enforce DAG-within-phases + cycle-across-phases
- Stale reference in INVARIANTS.md without elaboration

**No Topic in Canonical Spec** covers:
- Execution phasing (only individual concepts: state, signals, events)
- How scheduler builds phase-aware ordering
- Why stateWrite must be last

### 2.3 Missing Test Coverage & Documentation

**Tests exist** but don't document the pattern:
- `phase7-kernel-sanity.test.ts` tests individual kernels, not phase ordering
- `EventEvaluator.test.ts` tests edge detection but not two-phase isolation
- No test explicitly validates "state reads happened before writes" invariant

**No behavioral tests** for:
- Stateful feedback loops (e.g., delay block feeding back to itself)
- State read/write ordering with multiple state arrays
- Phase 1 ↔ Phase 2 boundary conditions

### 2.4 Missing Guidelines for Maintainers

No documentation on:
- When adding a new step type, which phase should it go in?
- How to recognize if a new feature violates two-phase assumptions?
- What breaks if phases are merged or reordered?
- Performance implications of the split (cache locality, GC pressure)?

---

## SECTION 3: WHAT NEEDS CHANGES (Documentation Strategy)

### 3.1 Recommended Documentation Locations

#### **Location A: Code Comments (ScheduleExecutor.ts)**
Currently has 4 lines of comment. Should expand to 15-20 lines explaining:
- The safety property being maintained
- What invariants rely on this
- Link to spec and design docs
- Common mistakes to avoid

**Current state**: Minimal  
**Recommended state**: Detailed with examples

#### **Location B: New Architecture Document**
Create `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/XX-execution-phasing.md`

Should cover:
- Overview: Why phasing matters for stateful systems
- The problem being solved (state read/write conflicts)
- Phase 1 detailed (what happens, why safe)
- Phase 2 detailed (only state writes, preserves causality)
- Invariants (I7 and others that depend on this)
- Schedule construction (how compiler builds phases)
- Hot-swap safety (state continuity + phases)
- Examples with diagrams

**Size estimate**: 5-8k tokens

#### **Location C: CLAUDE.md Update**
Add a new section under "Key Design Patterns":
- One paragraph explaining two-phase execution
- Link to full architecture doc
- Quick reference: which step types go where

**Current state**: No mention  
**Recommended state**: 3-4 sentences with context

#### **Location D: Runtime Rules (.claude/rules/runtime/runtime.md)**
Expand from 3 bullet points to include:
- Phasing rules (what goes in Phase 1 vs Phase 2)
- State safety property
- Schedule validation rules
- Exceptions or edge cases (none currently)

**Current state**: Incomplete  
**Recommended state**: Comprehensive coverage

#### **Location E: Step Type Documentation (ir/types.ts)**
Add JSDoc block before `StepStateWrite` and `StepFieldStateWrite`:
- Explanation that these are Phase 2 only
- Why (to preserve state read/write causality)
- How scheduler ensures ordering
- Example: simple feedback loop

**Current state**: No JSDoc  
**Recommended state**: Detailed JSDoc comment

### 3.2 Key Concepts to Document

**The Safety Property**:
```
State reads always see the previous frame's values.
State writes always update values for the next frame.
Phases enforce this separation without explicit per-step scheduling.
```

**The Invariant Being Enforced**:
```
I7: Cycles must cross stateful boundary
→ Operationalized as: Phase 1 forms a DAG, cycles allowed only via Phase 2 writes
→ Guaranteed by: stateWrite always deferred to Phase 2
```

**The Failure Mode** (if violated):
```
If stateWrite happened in Phase 1, a delay block could read its own output
in the same frame, creating a combinatorial loop instead of a proper delay.
```

**The Trust Boundary**:
- Compiler guarantees: Schedule respect phases (stateful blocks produce stateWrite-only outputs)
- Runtime enforces: stateWrite strictly deferred
- Scheduler validates: no side-stepping possible (types prevent it)

---

## SECTION 4: RATIONALE & INVARIANTS (The "Why")

### 4.1 Core Problem Being Solved

**Stateful Block Architecture**:
- Blocks like `UnitDelay` have internal state that persists across frames
- A delay(signal) block must output the *previous* frame's value, not current
- Without phase separation, a naive implementation could create causality loops

**Example Failure Scenario** (if phases were merged):
```
Frame N:
  Step 1: evalSig → input = 5.0
  Step 2: stateWrite → state[delay1] = input  // Oops! This is too early
  Step 3: Read state[delay1] → could get 5.0 instead of previous value
  Result: Delay block doesn't delay; becomes feedthrough
```

### 4.2 Two-Phase Solution

**Phase 1** (Lines 184-410):
- Evaluates all signal expressions
- Caches results so dependent nodes see consistent values
- Reads state using `SigExprStateRead` (reads *old* state)
- Materializes fields
- Applies continuity
- Fires events
- Collects render operations
- **Invariant**: State array untouched; only slots populated

**Phase 2** (Lines 464-505):
- Iterates steps a second time
- Writes new values to state array
- **Invariant**: Only state writes happen; signal evaluation already done
- New state ready for next frame's Phase 1

### 4.3 Invariants Depending on Two-Phase Execution

| Invariant | Reference | How Two-Phase Enforces It |
|-----------|-----------|--------------------------|
| **I7**: Cycles must cross stateful boundary | ESSENTIAL-SPEC.md | Phase 1 is DAG; cycles only via Phase 2 writes |
| **I1**: Time is monotonic | (time system) | State reads see t-1; state writes prepare t |
| **I3**: State continuity with stable IDs | (state migration) | Stable post-phase boundaries enable hot-swap validation |
| (Implicit) **State Semantics**: One-frame delay for stateful blocks | (block defs) | Phase separation guarantees semantic properties |

### 4.4 Performance & Correctness Trade-Off

**Why this trade-off is worth it**:
- **Correctness**: Eliminates entire class of causality bugs
- **Simplicity**: No per-block scheduling needed; unified phase ordering
- **Debuggability**: State reads/writes are explicit and testable
- **Performance cost**: Minimal (two passes, but each pass is O(N) anyway)

**Alternative approaches rejected**:
1. **Per-block scheduling**: Would require topological sort + cycle detection per block
2. **Explicit state tokens**: Would require threading state through all signal expressions (massive complexity)
3. **Lazy state evaluation**: Would couple signal evaluation to state machine scheduling (bad separation)

---

## SECTION 5: AMBIGUITIES REQUIRING USER CLARIFICATION

### 5.1 **Ambiguity 1: Audience & Detail Level**

**Question**: What is the target audience?
- **Option A**: Implementers maintaining ScheduleExecutor (need deep understanding)
- **Option B**: Compiler engineers building new passes (need integration points)
- **Option C**: Future contributors new to codebase (need conceptual overview)
- **Option D**: All of the above (different docs for different audiences)

**Current status**: Code assumes Option A; no docs exist for B/C

**Recommendation needed**: User should specify primary audience. Probably want option D with tiered docs.

### 5.2 **Ambiguity 2: Design Doc Scope**

**Question**: Should the architecture doc cover just two-phase execution, or broader execution model?

**Option A**: Narrow focus
- Just two phases, state semantics, example feedback loop
- Tightly focused (~3-4k tokens)

**Option B**: Broad execution model
- Complete frame execution (time resolution, external inputs, phasing, continuity, rendering)
- Comprehensive (~8-12k tokens, covers most of runtime/)

**Option C**: Just update existing Topic 05 (Runtime)
- Current runtime doc exists but is incomplete
- Could be expanded in-place rather than new doc

**Recommendation needed**: User should clarify whether we're documenting one feature or the whole runtime.

### 5.3 **Ambiguity 3: Depth of Continuity Integration**

**Question**: How much should documentation explain continuity system's interaction with phasing?

**Option A**: Minimal
- Just note that continuity apply happens in Phase 1
- Leave continuity details to separate doc (Topic 11)

**Option B**: Moderate
- Explain continuity happen before render to avoid jank
- Show why phase ordering matters for gauges & slew

**Option C**: Detailed
- Full explanation of continuity state isolation + phase interaction
- Could duplicate content from Topic 11

**Recommendation needed**: User should specify integration depth.

### 5.4 **Ambiguity 4: Test Documentation Strategy**

**Question**: Should we document via new tests or via docs?

**Option A**: Behavioral tests
- Write tests that validate phase ordering invariants
- Let tests serve as executable documentation
- Add comments explaining what invariant is being checked

**Option B**: Example-based documentation
- Create detailed examples in design doc showing feedback loops
- Use pseudocode or actual step sequences

**Option C**: Both
- Comprehensive tests (ensures correctness)
- + Documentation (explains concepts)

**Recommendation needed**: User should specify preferred approach.

### 5.5 **Ambiguity 5: Compiler Guarantees vs Runtime Enforcement**

**Question**: Should documentation focus on:

**Option A**: Compiler guarantees
- "Schedule production ensures phases are respected"
- Assumes compiler is always correct
- Simpler reasoning but less defensive

**Option B**: Runtime enforcement
- "Runtime verifies step types match expected phase"
- More defensive, easier to catch compiler bugs
- Adds assertions but may impact perf

**Option C**: Both (with ratios)
- Primary: compiler guarantees (assume correct)
- Secondary: runtime assertions for safety net
- Clear separation of concerns

**Recommendation needed**: What's the trust model?

### 5.6 **Ambiguity 6: Schedule Construction Details**

**Question**: How much detail about `pass7-schedule.ts` should documentation include?

**Option A**: Just the output
- Document what ScheduleIR contains
- Don't explain how scheduler builds it
- Links to pass7 for details

**Option B**: Full pass semantics
- Explain phase ordering algorithm
- Document topological sort within phases
- Show dependency resolution

**Option C**: Mid-level
- Explain phase constraints scheduler enforces
- Show example: "Input dependencies trigger earlier phase"
- Defer implementation to pass7 comments

**Recommendation needed**: User's preference for coupled documentation.

---

## SECTION 6: DEPENDENCIES & RISKS

### 6.1 **Risk if Documentation is NOT Provided**

| Risk | Severity | Impact |
|------|----------|--------|
| Future maintainer breaks phasing without realizing | HIGH | Causality bugs, hard to detect |
| New step types added without phase awareness | MEDIUM | Compilation succeeds but semantics wrong |
| State migration assumes phase ordering (not explicit) | MEDIUM | Hot-swap could corrupt state silently |
| Performance optimization changes execution order | HIGH | Correctness failure, no validation caught it |
| New contributors duplicate effort/get confused | LOW | Slower ramp-up, more questions |

### 6.2 **Documentation Dependencies**

**Must exist before this is complete**:
- [ ] Topic 11 (Continuity System) is finalized (needed for integration doc)
- [ ] Pass7 schedule.ts is well-commented (needed to explain construction)
- [ ] StateMigration.ts rationale is clear (needed to explain hot-swap interaction)

**Recommends**:
- [ ] INVARIANTS.md clarified for I7 (phasing is key enforcer)
- [ ] Example blocks with state documented (delay, lag, etc.)

### 6.3 **Documentation Maintenance Requirements**

If we document this pattern, we need:
- [ ] Lint rule: All stateWrite steps must verify Phase 2 execution
- [ ] Test coverage: Verify stateWrite ordering invariants
- [ ] Checklist for new step types: "Does this touch state? If yes, must be Phase 2"
- [ ] Code review guideline: "Phase assignment reviewed?" (like `@ts-ignore` comments)

---

## SECTION 7: ASSESSMENT SUMMARY

### What Exists (Completeness: 30%)
✅ Implementation is correct and well-coded  
✅ Code comments exist (4 lines)  
✅ Step types clearly separated (stateWrite isolated)  
✅ Compiler respects phases (pass7-schedule.ts)  

❌ No architecture-level documentation  
❌ No rationale for why this pattern matters  
❌ No explicit connection to invariants  
❌ No maintenance guidelines  

### What's Missing (Completeness: 0%)
❌ Design doc explaining two-phase execution  
❌ Spec connection to invariants (I7 uses this, not stated)  
❌ Examples of correct/incorrect usage  
❌ Behavioral tests validating phase ordering  
❌ Maintainer guidelines  

### Documentation Impact (Importance: CRITICAL)
- **Blocks correct understanding**: Anyone reading code sees phasing but not *why*
- **Enables safe changes**: Maintainers can verify new features respect pattern
- **Accelerates ramp-up**: New contributors understand design intent, not just implementation
- **Prevents regressions**: Test coverage ensures pattern isn't accidentally violated

### Effort Estimate
| Artifact | Hours | Difficulty |
|----------|-------|-----------|
| ScheduleExecutor comments expansion | 0.5 | Trivial |
| Architecture doc (5-8k tokens) | 2-3 | Medium |
| CLAUDE.md update | 0.5 | Trivial |
| Runtime rules update | 1 | Easy |
| Step type JSDoc | 0.5 | Trivial |
| Behavioral tests | 2-3 | Medium |
| **Total** | **6.5-8** | **Moderate** |

---

## SECTION 8: RECOMMENDATIONS FOR USER

### Immediate Action: Clarify Scope

Before planning implementation, please answer:

1. **Audience**: Who should understand this? (implementers / compiler engineers / all)
2. **Scope**: Just two-phase, or broader execution model?
3. **Depth**: Light overview or comprehensive coverage?
4. **Continuity Integration**: Minimal mention or detailed interaction?
5. **Testing**: Behavioral tests, example docs, or both?
6. **Trust Model**: Compiler guarantees, runtime enforcement, or both?
7. **Schedule Details**: Document pass7 or just its output?

### Recommended Approach (If No User Input)

If you want a single default plan:

**Tier 1 (Quick, high-impact)**:
1. Expand ScheduleExecutor.ts comments (15-20 lines)
2. Add JSDoc to StepStateWrite/fieldStateWrite
3. Update CLAUDE.md with 3-4 sentence overview
4. Add 3 examples to runtime.md rules

**Tier 2 (Comprehensive)**:
1. Create Topic 05a: "Execution Phases" (~6k tokens)
   - Problem statement
   - Two-phase model
   - Invariants (I7)
   - Integration with continuity
   - Schedule construction overview

2. Add behavioral tests
   - Feedback loop (delay reading itself)
   - Multi-state scenario
   - Hot-swap + phases

3. Update pass7-schedule.ts comments

**Tier 3 (Reference)**:
1. Add architecture diagram to design docs
2. Create examples in github wiki
3. Add to code review checklist

---

## CONCLUSION

The two-phase execution pattern in ScheduleExecutor is:
- **Correctly implemented** ✅
- **Critically important** ✅
- **Severely under-documented** ❌

The pattern solves a fundamental problem (state causality in feedback loops) but this rationale is invisible to readers. Documentation should explain:
1. **What** the pattern is (Phase 1 reads/compute, Phase 2 writes state)
2. **Why** it's necessary (maintains one-frame-delay semantics for stateful blocks)
3. **How** it enforces invariants (I7: cycles cross state boundary)
4. **Where** to put new code (decision tree for step phase assignment)

**Next step**: User should provide clarifications from Section 5 to guide the documentation plan.

