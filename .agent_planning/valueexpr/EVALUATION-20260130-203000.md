# Evaluation: ValueExpr Type System (Post-Sprint Reassessment)
Timestamp: 2026-01-30-203000
Git Commit: 103c022

## Executive Summary
Overall: 85% complete | Critical issues: 0 | Tests reliable: yes (with caveats)

The sprint (WI-1 through WI-5) accomplished its stated goals. All 5 work items are done: instanceId removed from FieldExpr builders, instance name mismatch fixed, deriveKind eliminated from production imports, pre-existing test failures fixed, structural invariant tests written. 2004 tests pass, TypeScript compiles clean.

However, the "85% complete" framing requires context. The sprint did infrastructure work (cleaned types, wrote enforcement tests), but the ValueExpr canonical table defined in `value-expr.ts` has **zero production consumers**. It is a type definition with tests but no code that dispatches on it. The actual runtime still uses the legacy SigExpr/FieldExpr/EventExpr types. The enforcement tests protect the new type definitions and the cleaned-up builders, which is genuine value -- but the migration itself has not started.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| npx vitest run | PASS | 2004 passed, 0 failures |
| npx tsc --noEmit | PASS | 0 errors |
| no-instanceid-on-fieldexpr.test.ts | PASS | 10/10 tests |
| no-deriveKind-imports.test.ts | PASS | 1/1 test |
| value-expr-invariants.test.ts | PASS | 8/8 tests |
| grep deriveKind imports (prod) | PASS | 0 violations |
| grep inferFieldInstance | PASS | 0 matches (removed) |

## Missing Checks
1. **No test for ValueExprId duplication**: `ValueExprId` is defined identically in both `src/compiler/ir/value-expr.ts:35` and `src/compiler/ir/Indices.ts:45`. This violates ONE SOURCE OF TRUTH. No test catches this.
2. **No test for zero-cardinality evaluation**: `canonicalConst()` exists but no block emits it and no evaluator handles it.
3. **No CI/lint rule preventing new deriveKind call sites**: The grep-based test catches imports but not calls to helpers that wrap deriveKind internally (requireSignalType etc.).
4. **No test that ValueExpr covers all legacy variants**: The LEGACY_MAPPING const is documentation only. No test verifies it stays in sync with actual SigExpr/FieldExpr/EventExpr union members.

## Findings

### WI-1: instanceId removal from FieldExpr builders
**Status**: COMPLETE
**Evidence**:
- All 8 field builder methods in IRBuilderImpl (lines 307-827) confirmed clean -- no instanceId in expr objects
- `inferFieldInstance()` and `inferZipInstance()` fully removed (grep returns 0 matches)
- 10 enforcement tests in `no-instanceid-on-fieldexpr.test.ts` pass
- Tests use `Object.keys()` runtime assertion, not just TypeScript type checking
**Issues**: None

### WI-2: Instance name mismatch fix
**Status**: COMPLETE
**Evidence**:
- Commit 01473ed resolves the "default" vs "instance_0" naming mismatch
- All 24 projection test failures from prior evaluation are now resolved (0 failures)
- Instance names in type match registered instances
**Issues**: None

### WI-3: deriveKind elimination from production code
**Status**: COMPLETE (with residual dead code)
**Evidence**:
- No production file imports `deriveKind` (enforcement test passes)
- `axis-validate.ts` uses local `derivedKindLabel()` function with direct axis dispatch (lines 91-97)
- `assertKindAgreement` in `lowerTypes.ts:75` uses direct axis dispatch
- `lower-blocks.ts:497` calls `assertKindAgreement` (properly refactored)
**Issues**:
- `requireSignalType`, `requireFieldType`, `requireEventType` (canonical-types.ts:815-842) still internally call `deriveKind`. These helpers have ZERO consumers, so this is dead code, not a bug.
- `isSignalType`, `isFieldType`, `isEventType` (canonical-types.ts:848-867) internally call `tryDeriveKind`. Also ZERO consumers. More dead code.
- `deriveKind` and `tryDeriveKind` functions remain exported. The enforcement test only checks `import` statements, not the existence of the functions. This is fine for now but should be cleaned up when ValueExpr migration completes.

### WI-4: Pre-existing test failures
**Status**: COMPLETE
**Evidence**:
- Commit 0013b52 resolves 3 pre-existing failures (the DOD mentioned 5, actual was 3)
- All 2004 tests pass
**Issues**: None

### WI-5: ValueExpr structural invariant tests
**Status**: COMPLETE
**Evidence**:
- 8 tests in `value-expr-invariants.test.ts`
- Covers: 9 kinds count, exhaustive kind check, type on every variant, no op discriminant, no instanceId, sub-discriminant correctness (kernelKind, eventKind, intrinsicKind)
**Issues**:
- Tests construct manual mock objects (`{kind, type: {} as CanonicalType, ...}`), not objects from the builder. This means the tests verify the *type definition* compiles correctly but not that any *real code* produces ValueExpr objects. Since no production code produces ValueExpr objects yet, this is expected but should be noted.
- The "exhaustive kind check" test (line 49) does `{kind} as ValueExpr` -- this is a cast, not a narrowing check. TypeScript will not error if a kind is added to the union but not to EXPECTED_KINDS. The test relies on the hardcoded array length (9) to catch additions, which works but is fragile.

### ValueExpr canonical table
**Status**: COMPLETE (as a type definition) / NOT_STARTED (as a consumer migration)
**Evidence**:
- `value-expr.ts` defines ValueExpr with 9 kinds, complete documentation
- Complete legacy mapping table (LEGACY_MAPPING const, lines 271-301)
- Every variant has `readonly kind` and `readonly type: CanonicalType`
- No `op` discriminant, no `instanceId`
**Issues**:
- **ZERO production consumers**. No file outside `__tests__` imports from `value-expr.ts`.
- `ValueExprId` is defined in BOTH `value-expr.ts:35` AND `Indices.ts:45`. This is a one-source-of-truth violation. When migration begins, which one is canonical?
- The legacy types (SigExpr, FieldExpr, EventExpr in types.ts) remain the actual production types. IRBuilderImpl builds legacy types. ScheduleExecutor dispatches on legacy types. All evaluators use legacy types.

### canonicalConst / zero-cardinality
**Status**: PARTIAL (type-system complete, runtime unused)
**Evidence**:
- `canonicalConst()` function exists at canonical-types.ts:746
- Used in exactly 1 test (`instance-unification.test.ts:82`)
- No block lowering code calls `canonicalConst()`
- Const blocks still emit `cardinalityOne`
- No evaluator has special handling for `cardinalityZero`
**Issues**: This is tracked by deferred bead oscilla-animator-v2-73lv. Not a sprint failure, but noted.

### assertKindAgreement (lowerTypes.ts:75)
**Status**: COMPLETE (properly refactored)
**Evidence**:
- Uses direct axis dispatch via `requireInst` -- no deriveKind import
- Correctly handles zero-cardinality: zero + continuous = 'sig' (line 86-87)
- Called from `lower-blocks.ts:497`
**Issues**: None

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| ValueExprId duplication | Which is canonical: value-expr.ts or Indices.ts? | Both exist identically, no explicit canonical source | LOW now, HIGH when migration starts |
| deriveKind helpers | Should requireSignalType/isSignalType be deleted or refactored? | Left as dead code | LOW: no consumers, no breakage |
| canonicalConst adoption | When should const blocks switch to zero-cardinality? | Deferred to bead oscilla-animator-v2-73lv | LOW: current behavior is functional |
| ValueExpr migration order | Which evaluator/executor migrates first? | Deferred to bead oscilla-animator-v2-bzh2 | MEDIUM: determines if ValueExpr design is actually viable |

## Deferred Work Assessment

### oscilla-animator-v2-vqkj: AdapterSpec restructure (P2)
**Assessment**: Reasonable deferral. AdapterSpec in `src/graph/adapters.ts` works. Moving to blocks layer is organization, not correctness.

### oscilla-animator-v2-73lv: Zero-cardinality enforcement (P3)
**Assessment**: Reasonable deferral. Infrastructure (canonicalConst) is in place. No runtime code exercises it. Risk: the longer this waits, the more likely someone adds const handling that assumes cardinalityOne.

### oscilla-animator-v2-bzh2: First ValueExpr consumer (P3)
**Assessment**: This is the critical path item. Until a real consumer dispatches on ValueExpr instead of SigExpr/FieldExpr/EventExpr, the ValueExpr type system is untested in practice. The enforcement tests verify the *shape* of the type, not its *usability*. This is the difference between "looks done" and "actually works."

## New Work Items Discovered

1. **ValueExprId duplication**: Remove one of the two identical definitions. Recommend keeping in `Indices.ts` (where all other branded IDs live) and importing in `value-expr.ts`.

2. **Dead code cleanup**: `requireSignalType`, `requireFieldType`, `requireEventType`, `isSignalType`, `isFieldType`, `isEventType`, `deriveKind`, `tryDeriveKind` -- all have zero consumers. These should either be deleted or marked with a clear "kept for ValueExpr migration" comment.

3. **bridges.ts.bak**: Leftover backup file at `src/compiler/ir/bridges.ts.bak`. Should be deleted.

## Recommendations
1. **Resolve ValueExprId duplication** (5 min): Pick one canonical location, delete the other, import where needed.
2. **Plan first consumer migration** (bead oscilla-animator-v2-bzh2): This is the real test of whether ValueExpr works. Suggest ScheduleExecutor as the first candidate -- it already dispatches on SigExpr/FieldExpr/EventExpr kind discriminants.
3. **Delete bridges.ts.bak** (1 min): Leftover file.
4. **Add deprecation timeline to dead helpers**: The 6 unused helpers in canonical-types.ts should have explicit "delete after ValueExpr migration" comments.
5. **Strengthen invariant test**: The exhaustive kind check in value-expr-invariants.test.ts relies on array length. Consider a compile-time exhaustiveness helper using conditional types.

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix
- [ ] PAUSE - Ambiguities need clarification

The sprint accomplished its goals. All stated work items are done and tested. The remaining gap is not a bug or ambiguity -- it is the expected next phase of work (consumer migration, tracked in beads). The 85% assessment from the user is accurate: the type infrastructure is solid, enforcement tests prevent regression, but the ValueExpr type has no production consumers yet.

---

## Completion Matrix

| Item | Status | Evidence |
|------|--------|----------|
| WI-1: instanceId removal | DONE | IRBuilderImpl clean, 10 enforcement tests |
| WI-2: Instance name mismatch | DONE | 0 test failures (was 24) |
| WI-3: deriveKind elimination | DONE | 0 production imports, enforcement test |
| WI-4: Pre-existing test failures | DONE | 2004/2004 pass |
| WI-5: Structural invariant tests | DONE | 8 tests covering type shape |
| ValueExpr canonical table | DONE (definition only) | 9 kinds, complete mapping |
| ValueExpr consumers | NOT STARTED | 0 production imports |
| Zero-cardinality runtime | NOT STARTED | canonicalConst exists, unused |
| AdapterSpec restructure | NOT STARTED | Deferred (P2) |
