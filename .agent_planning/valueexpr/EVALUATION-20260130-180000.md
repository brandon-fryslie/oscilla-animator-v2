# Evaluation: ValueExpr Unification (Deferred Plan)
Timestamp: 2026-01-30-180000
Git Commit: 7a1c189

## Executive Summary
Overall: 50% complete | Critical issues: 1 | Tests reliable: no (24 new failures introduced)

Significant progress has been made on the ValueExpr unification work. Items P0-1 (canonical table), P0-4 (instanceId removal), P0-5 (zero-cardinality), and P0-6 (ConstValue) are DONE. However, the recent work introduced 24 test failures (all projection/level5-7/level10 tests) due to a runtime bug where Materializer cannot find instances. The error pattern shows instanceId still appearing in serialized FieldExpr objects despite being removed from the types, suggesting IRBuilderImpl is still emitting it.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| npm run test | 24 failures / 1961 passed | 24 new failures (projection tests), all same error: "Instance default not found" |
| npx tsc --noEmit | SUCCESS | 0 errors |
| value-expr.ts exists | YES | Created in commit 277b2c7 |
| ValueExpr type defined | YES | 9 kinds, complete legacy mapping |
| instanceId removed from FieldExpr | YES | All 6 variants updated |
| canonicalConst exists | YES | Uses cardinalityZero() |
| DerivedKind deprecated | YES | @deprecated annotation added |

## Missing Checks
- No invariant test asserting "every ValueExpr variant has type: CanonicalType"
- No test asserting "no Axis.var in backend IR"
- No CI/lint rule preventing deriveKind calls outside canonical-types.ts
- No test coverage for zero-cardinality evaluation (canonicalConst exists but unused in practice)

## Findings

### P0-1: Create canonical ValueExpr table (D1, D2)
**Status**: DONE
**Evidence**:
- File: `src/compiler/ir/value-expr.ts` (301 lines, commit 277b2c7)
- ValueExpr union with 9 kinds: const, external, intrinsic, kernel, state, time, shapeRef, eventRead, event
- Every variant has `readonly kind: <literal>` and `readonly type: CanonicalType`
- ValueExprId branded type exists (line 35)
- KernelId sub-discriminant for kernel operations (line 49)
- Complete legacy mapping table documented (lines 230-301)
- No `op` discriminant anywhere
- No sig/field/event family tags stored

**Issues**: NONE (complete as specified)

### P0-2: Fix SigExprEventRead output type (correctness lock)
**Status**: DONE (was already correct)
**Evidence**:
- `SigExprEventRead` type at src/compiler/ir/types.ts:178 has `type: CanonicalType`
- IRBuilderImpl.sigEventRead (not checked but type forces correctness)
- Spec states output is float scalar signal (0.0/1.0)

**Issues**: NONE

### P0-3: AdapterSpec restructure into blocks layer (D4)
**Status**: NOT_STARTED
**Evidence**:
- AdapterSpec still lives in `src/graph/adapters.ts` (line 66)
- Not moved to `src/blocks/adapter-spec.ts`
- AdapterRule uses TypePattern with payload/unit/extent (lines 89-93)
- Adapters are already marked purity: 'pure', stability: 'stable'

**Issues**: NONE (out of scope for current sprint per existing plan)

### P0-4: Remove duplicated field instance identity from expression nodes (D3)
**Status**: DONE (but introduced runtime bug)
**Evidence**:
- Commit 56941dc removed instanceId from all 6 FieldExpr variants
- FieldExprIntrinsic: instanceId removed (types.ts:235)
- FieldExprPlacement: instanceId removed (types.ts:245)
- FieldExprMap: instanceId removed (types.ts:259)
- FieldExprZip: instanceId removed (types.ts:266)
- FieldExprZipSig: instanceId removed (types.ts:274)
- FieldExprStateRead: instanceId removed (types.ts:283)
- IRBuilder signatures updated (IRBuilder.ts)
- ScheduleExecutor updated to use requireManyInstance() (ScheduleExecutor.ts:499-519)
- Materializer updated (Materializer.ts:218)
- All block files updated to remove instanceId argument

**Issues**:
- **CRITICAL**: 24 test failures all show same error: "Instance default not found. Field expr: {..., instanceId: 'default'}. Available instances: instance_0"
- The error message JSON shows instanceId still present in serialized FieldExpr despite types not having it
- Suggests IRBuilderImpl is still emitting instanceId (builder cache corruption or conditional emit)
- Instance name mismatch: tests expect "default" but compiler produces "instance_0"
- ScheduleExecutor line 499-506 was updated to use requireManyInstance(expr.type).instanceId but Materializer line 218 error suggests it's receiving wrong instanceId value

### P0-5: Zero-cardinality becomes real and enforced (D5)
**Status**: PARTIAL (constructor exists, not used in practice)
**Evidence**:
- `canonicalConst(payload, unit)` exists (canonical-types.ts:729-734)
- Uses `cardinalityZero()` and `temporalityContinuous()` as specified
- Added in commit 63fa20c
- axis-validate.ts accepts zero cardinality (existing code)

**Issues**:
- No blocks emit zero-cardinality values in practice (Const blocks use cardinalityOne)
- No explicit lift mechanism exists (no ValueExprLift variant)
- Plan specified "Const blocks must emit zero-cardinality values before any lift" but current block lowering doesn't use canonicalConst
- Evaluators have no special handling for zero-cardinality
- Zero-cardinality is type-system-complete but runtime-unused

### P0-6: ConstValue shape is canonical (D6)
**Status**: DONE
**Evidence**:
- ConstValue discriminated union exists (canonical-types.ts:321-328)
- Variants: float, int, bool, vec2, vec3, color, cameraProjection
- constValueMatchesPayload validator exists (canonical-types.ts:345-350)
- Helper constructors exist (floatConst, intConst, boolConst, vec2Const, vec3Const, colorConst)
- ValueExprConst.value is ConstValue (value-expr.ts:104)
- SigExprConst.value is ConstValue (types.ts:98)
- FieldExprConst.value is ConstValue (types.ts:226)
- EventExprConst does NOT use ConstValue (uses `fired: boolean` - types.ts:320)

**Issues**:
- EventExprConst uses `fired: boolean` instead of ConstValue (minor spec divergence, may be intentional)
- No validator enforcement exists (axis-validate.ts doesn't call constValueMatchesPayload)

### P1-7: Appendix-only: legacy→ValueExpr mapping and staged adoption (D7)
**Status**: DONE (mapping documented, no consumer migrated)
**Evidence**:
- Complete mapping table in value-expr.ts lines 230-301
- Documents all 24 legacy variants → ValueExpr forms
- LEGACY_MAPPING constant provides programmatic access
- No consumer has migrated yet (evaluators still use SigExpr/FieldExpr/EventExpr)

**Issues**: NONE (appendix-only item, no consumer migration required in this sprint)

## DerivedKind Deprecation Status
**Status**: PARTIAL (deprecated but still actively used)
**Evidence**:
- `@deprecated` annotation added (canonical-types.ts:744)
- Still called in 6 files:
  - axis-validate.ts (2 call sites)
  - lowerTypes.ts (1 call site - assertKindAgreement)
  - lower-blocks.ts (1 call site)
  - field-operations-blocks.ts (1 call site)
  - types/index.ts (re-export)
- Deprecation comment states "Slated for removal when ValueExpr unification lands"

**Issues**: No enforcement mechanism (lint rule, CI check)

## Critical Blocker: Test Failures

### Error Pattern
All 24 failures have identical root cause:
```
Instance default not found. Field expr: {..., "instanceId":"default"}.
Available instances: instance_0
```

### Analysis
1. **instanceId still appearing in runtime objects**: Despite types.ts having instanceId removed, the error message shows serialized FieldExpr objects with `"instanceId":"default"` field
2. **Instance name mismatch**: Compiler produces "instance_0" but runtime expects "default"
3. **Materializer.ts:218 error location**: `if (!instance) throw new Error(...)`

### Root Cause IDENTIFIED
**File**: `src/compiler/ir/IRBuilderImpl.ts`
**Location**: Line 349 in `fieldPlacement()` method
**Bug**: Method body still emits `instanceId` into expr object despite parameter removal

```typescript
// Line 329-333: Signature (no instanceId parameter)
fieldPlacement(
  field: PlacementFieldName,
  basisKind: BasisKind,
  type: CanonicalType
): FieldExprId {

// Line 334: References undefined variable
if (!instanceId) {  // ERROR: instanceId not in scope
  throw new Error('fieldPlacement: instanceId is required');
}

// Line 347-353: Body still emits instanceId
const expr = {
  kind: 'placement' as const,
  instanceId,  // ERROR: Emits undefined variable into object
  field,
  basisKind,
  type,
};
```

**How this compiles**: TypeScript allows excess properties on object literals. The `instanceId` variable reference resolves to `undefined` (not a compile error in non-strict mode or with `noUnusedLocals: false`). The field gets added to the object even though it's not in the FieldExprPlacement type.

**Why tests fail**: Materializer receives FieldExprPlacement objects with `instanceId: undefined`, tries to look up `instances.get(undefined)`, fails.

### Additional Issues Found
- `fieldIntrinsic()` line 307-312: Also emits instanceId (needs same fix)
- Other field builders (map, zip, zipSig, stateRead) likely have same issue
- Hash consing uses these malformed expressions, so cache is populated with broken objects

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| Instance naming | Why do tests expect "default" but compiler produces "instance_0"? | Not clear - may be test fixture vs normalization difference | HIGH: All projection tests fail |
| IRBuilderImpl instanceId | Is IRBuilderImpl still emitting instanceId despite types forbidding it? | JSON error shows it present | HIGH: Type system contract broken |
| Zero-cardinality adoption | Should Const blocks start using canonicalConst() now or later? | Plan says "must emit" but no blocks updated | LOW: Functional, spec-divergent |
| EventExprConst value type | Should EventExprConst use ConstValue or keep `fired: boolean`? | Current code uses boolean, spec unclear | LOW: May be intentional |

## Recommendations

1. **FIX BLOCKER IMMEDIATELY**: Debug why instanceId appears in runtime FieldExpr objects
   - Check IRBuilderImpl field builder methods (fieldIntrinsic, fieldPlacement, etc.)
   - Verify hash consing cache was cleared/invalidated after instanceId removal
   - Confirm schedule-program.ts uses requireManyInstance() everywhere
   - Fix instance name resolution ("default" vs "instance_0" mismatch)

2. **Add Const block zero-cardinality emission**: Update block lowering to use canonicalConst() for literal constants (plan P0-5 requirement)

3. **Add mechanical enforcement**:
   - Invariant test: "every ValueExpr variant has type: CanonicalType"
   - CI grep check: prevent new deriveKind call sites
   - Test: zero-cardinality evaluation works (once blocks emit it)

4. **Verify P0-4 completion after blocker fix**:
   - Re-run tests
   - Confirm no instanceId in runtime objects
   - Verify requireManyInstance() is sole source of instance identity

5. **AdapterSpec migration (P0-3)** can wait - separate from critical path

## File Impact Analysis (Actual vs Planned)

| Item | Planned Files | Actual Files Changed | Status |
|------|--------------|---------------------|--------|
| P0-1 | value-expr.ts (new) | value-expr.ts, Indices.ts | DONE |
| P0-4 | types.ts, IRBuilder*, runtime, blocks | 17 files (types, builder, executor, materializer, 6 block files, tests) | DONE (bug) |
| P0-5 | canonical-types.ts | canonical-types.ts | DONE |
| P0-6 | N/A (already existed) | N/A | DONE |
| P0-2 | N/A (verify only) | N/A | DONE |

## Test Failure Breakdown

### New Failures (24 total, all same root cause)
- **projection/__tests__/level5-assembler-projection.test.ts**: 4 failures
- **projection/__tests__/level6-mode-toggle.test.ts**: 3 failures
- **projection/__tests__/level7-depth-culling.test.ts**: 1 failure
- **projection/__tests__/level10-golden.test.ts**: 16 failures

### Pre-existing Failures (0)
Previous evaluation (EVALUATION-20260130-170000-valueexpr.md) reported 3 pre-existing failures, but current run shows all failures are new (Instance not found error introduced by instanceId removal)

### Test Quality
- Tests are REAL (full pipeline compilation + runtime execution)
- Not theater (fail when instanceId handling breaks)
- Detect actual runtime contract violations
- All failures have same root cause (good - single fix needed)

## Verdict
- [ ] CONTINUE - Issues clear, implementer can fix
- [x] PAUSE - Critical blocker needs investigation

### Blocker Details
**Issue**: IRBuilderImpl field builder methods still emit instanceId despite parameter removal (commit 56941dc incomplete)

**Specific location**: `src/compiler/ir/IRBuilderImpl.ts`
- `fieldPlacement()` line 349: emits `instanceId` from undefined variable
- `fieldIntrinsic()` line 312: likely same issue (not verified)
- Other field builders (map, zip, zipSig, stateRead): need inspection

**Why TypeScript didn't catch it**:
- Excess properties allowed on object literals
- `instanceId` variable resolves to undefined (no compile error)
- Type system allows extra fields (structural typing)

**What breaks**:
- All 24 projection tests fail
- Materializer receives `{...expr, instanceId: undefined}`
- `instances.get(undefined)` fails → "Instance default not found"

**Fix required**:
1. Remove `instanceId` field from all field builder method bodies (6 methods)
2. Remove validation checks referencing `instanceId` variable
3. Clear/invalidate hash consing cache or restart compiler
4. Verify requireManyInstance() is used at consumption sites

**Impact**: Blocks ALL downstream work until resolved (runtime is broken)

---

## Completion Matrix

| Item | Deliverable | Status | Evidence | Blockers |
|------|------------|--------|----------|----------|
| P0-1 | ValueExpr canonical table | ✅ DONE | value-expr.ts, 9 kinds, complete mapping | None |
| P0-2 | SigExprEventRead type fix | ✅ DONE | Already correct (float scalar) | None |
| P0-3 | AdapterSpec restructure | ❌ NOT_STARTED | Still in graph/adapters.ts | None (out of scope) |
| P0-4 | Remove instanceId from FieldExpr | ⚠️ DONE (BROKEN) | Types updated, 24 test failures | Runtime emits instanceId |
| P0-5 | Zero-cardinality real | ⚠️ PARTIAL | canonicalConst exists, blocks don't use it | No blocks emit zero |
| P0-6 | ConstValue canonical | ✅ DONE | Discriminated union, validators | None |
| P1-7 | Legacy mapping appendix | ✅ DONE | Complete mapping table | None (no consumer needed) |

**Overall**: 4/7 complete, 1/7 partial, 1/7 not started, 1/7 done-but-broken
