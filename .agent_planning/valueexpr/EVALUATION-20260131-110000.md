# Evaluation: ValueExpr Migration
Timestamp: 2026-01-31-110000
Git Commit: 9d84e78

## Executive Summary
Overall: 65% complete | Critical issues: 2 | Tests reliable: partially

The ValueExpr type system, lowering pass, and three consumer evaluators (signal, event, materializer) are structurally implemented and type-check cleanly. However, the migration is NOT validated at runtime: all shadow mode flags and all cutover flags are `false`. No shadow comparison has ever been observed to run in CI or test. The system is a well-built parallel track that has never been proven equivalent to legacy.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| `npx tsc --noEmit` | PASS | 0 errors |
| `npx vitest run` | PASS | 2057 passed, 15 skipped, 2 todo |
| Shadow signal validation | NOT RUN | `SHADOW_EVAL = false` (ScheduleExecutor.ts:45) |
| Shadow event validation | NOT RUN | `SHADOW_EVAL = false` (reused flag, ScheduleExecutor.ts:714) |
| Shadow materializer validation | NOT RUN | `SHADOW_MATERIALIZE = false` (ScheduleExecutor.ts:73) |
| Signal cutover | NOT ENABLED | `VALUE_EXPR_ONLY = false` (ScheduleExecutor.ts:59) |
| Materializer cutover | NOT ENABLED | `VALUE_EXPR_MATERIALIZE = false` (ScheduleExecutor.ts:87) |
| Event cutover | MISSING | No cutover flag exists for events |

## Missing Checks

1. **Shadow mode integration test that actually enables shadow mode** - The existing shadow tests at `src/runtime/__tests__/valueexpr-signal-shadow.test.ts` do NOT enable shadow mode. They compile patches and execute frames, but `SHADOW_EVAL = false` means no comparison runs. The tests verify that `program.valueExprs.nodes.length > 0` (table exists) but not that evaluator output matches.

2. **Cutover-mode integration test** - No test runs with `VALUE_EXPR_ONLY = true` or `VALUE_EXPR_MATERIALIZE = true`. The DOD for Sprint 3 requires "All 2004+ tests pass in ValueExpr-only mode" -- this has not been verified.

3. **ValueExprSignalEvaluator unit tests** - No dedicated unit test file exists. The evaluator is only exercised indirectly through shadow mode tests that don't actually shadow.

4. **ValueExprMaterializer unit tests** - No dedicated unit test file exists.

5. **Event cutover test** - The event evaluator has no cutover flag and no way to switch legacy off.

## Findings

### Sprint 1: Type Definitions (value-expr.ts)
**Status**: COMPLETE
**Evidence**: `src/compiler/ir/value-expr.ts` - 10 kinds, all carry CanonicalType, kernel sub-union on `kernelKind`, event sub-union on `eventKind`. Compile-time exhaustiveness check in `value-expr-invariants.test.ts:56-62`.
**Issues**: None. Well-structured, clean discriminated unions.

### Sprint 2: Lowering Pass (lowerToValueExprs.ts)
**Status**: COMPLETE
**Evidence**: `src/compiler/ir/lowerToValueExprs.ts` - Pure function, 4-phase lowering (signals, fields, reduceField, events). Called from `src/compiler/compile.ts:670`. Integration tested in `lowerToValueExprs.test.ts`. All switch cases exhaustive with `never` checks.
**Issues**:
- `lowerToValueExprs.test.ts.orig` file exists (leftover, should be deleted)

### Sprint 3: Signal Evaluator (ValueExprSignalEvaluator.ts)
**Status**: PARTIAL - Implementation exists but NOT validated
**Evidence**: `src/runtime/ValueExprSignalEvaluator.ts` - Handles all signal-extent kinds. Exhaustive switch. NaN/Inf detection. Frame-stamped caching. Shadow mode wiring in ScheduleExecutor.ts:386-468.
**Issues**:
1. **Shadow mode never runs** - `SHADOW_EVAL = false` at line 45. No test enables it. DOD WI-3 requires "At least one end-to-end test compiles a real patch and runs shadow mode for 10 frames with zero mismatches" -- this is NOT met.
2. **`reduce` kernel returns 0** (line 201-205) - documented as "placeholder" with comment "actual work done in executor". However legacy ALSO returns 0 for `reduceField` (SignalEvaluator.ts:202-207). This is likely correct but undocumented design: reduce probably never appears as a signal-evaluated step (it would be in the schedule as a materialize step). Needs verification.
3. **`shapeRef` returns 0** (line 150-154) - Silent fallback with comment "safe numeric fallback." This matches legacy behavior but should be documented as intentional.
4. **`palette` time signal returns 0** (line 126-127) - Hardcoded. Comment says "Slot number for palette" but actually returns literal 0. If palette is ever used as a numeric value, this is wrong.
5. **No dedicated unit tests** - Only indirect exercise via shadow tests that don't actually compare.
6. **~300 lines of duplicated kernel code** from legacy SignalEvaluator (applySignalKernel function).

### Sprint 4: Event Evaluator (ValueExprEventEvaluator.ts)
**Status**: PARTIAL - Implementation exists but NOT validated, missing cutover path
**Evidence**: `src/runtime/ValueExprEventEvaluator.ts` - 5 event kinds, cycle detection, edge detection with separate `prevPredicate` array. Shadow wiring in ScheduleExecutor.ts:714-725. Dedicated unit tests at `ValueExprEventEvaluator.test.ts`.
**Issues**:
1. **No cutover flag** - Unlike signal (VALUE_EXPR_ONLY) and materializer (VALUE_EXPR_MATERIALIZE), events have NO cutover mechanism. ScheduleExecutor.ts:726 says "Use legacy result for execution" with no alternative path.
2. **Shadow mode never runs** - Same flag as signals (`SHADOW_EVAL = false`).
3. **Edge detection state indexed by ValueExprId** - `state.eventPrevPredicateValue[veId as number]` at line 137. If veId numbering is sparse (gaps), this wastes memory. Appears safe since ValueExprTable.nodes is dense.

### Sprint 5: Materializer (ValueExprMaterializer.ts)
**Status**: PARTIAL - Implementation exists but NOT validated
**Evidence**: `src/runtime/ValueExprMaterializer.ts` - Handles const, intrinsic, kernel (all 6 sub-kinds except reduce which throws correctly), state. Buffer caching. Shadow wiring in ScheduleExecutor.ts:496-569.
**Issues**:
1. **Shadow mode never runs** - `SHADOW_MATERIALIZE = false` at line 73.
2. **Dummy CanonicalType construction** (line 515-516) - `instanceRef('_dummy', instanceId as any as string)` creates a fake type for `applyFieldKernel`. While `_type` parameter is unused in FieldKernels.ts, this `as any as string` cast violates TYPE-SYSTEM-INVARIANTS #10 (instance identity from type). If FieldKernels ever starts using the type parameter, this will silently produce wrong results.
3. **Same dummy pattern at line 551-552** for zipSig.
4. **No dedicated unit tests**.
5. **Cache conditional** (line 124-127) - `if (state.cache.valueExprFieldBuffers && ...)` guards suggest uncertainty about whether cache arrays exist. They are always created in `createRuntimeState`, so these guards are defensive no-ops.

### RuntimeState Cache Additions
**Status**: COMPLETE
**Evidence**: `src/runtime/RuntimeState.ts:206-244` - Both signal cache (Float64Array + Uint32Array) and field cache (Float32Array[] + number[]) properly allocated. Sized from `maxValueExprs`. Frame-stamped invalidation.
**Issues**: None significant. Cache sizing uses same value for signals and fields which may over-allocate, but not a correctness issue.

### ScheduleExecutor Integration
**Status**: PARTIAL - Wiring complete but all switches are off
**Evidence**: Shadow mode wiring for signals (line 398), strided signals (line 462), materializer (line 524), events (line 714). Cutover paths for signals (line 386) and materializer (line 496).
**Issues**:
1. All 4 flags disabled (`SHADOW_EVAL`, `SHADOW_MATERIALIZE`, `VALUE_EXPR_ONLY`, `VALUE_EXPR_MATERIALIZE`).
2. Flags are module-level `const` -- toggling requires source edit. No env var, no runtime config, no test parameter.
3. Event cutover path entirely missing.

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| Signal `reduce` | Should ValueExpr evaluator handle reduce or delegate to materializer? | Returned 0 (matching legacy) | LOW - matches legacy, probably correct since reduce is scheduled as materialize step |
| Signal `palette` | What numeric value does palette represent? | Returned 0 with misleading comment | MEDIUM - if palette is used numerically, 0 is wrong |
| Signal `shapeRef` | Should signal evaluator ever be called for shapeRef? | Returned 0 as "safe fallback" | LOW - executor handles shape directly, this is defense-in-depth |
| Materializer dummy type | Should the expr's actual type be passed to applyFieldKernel? | Created dummy type with `as any` cast | LOW for now - field param unused. HIGH if FieldKernels ever uses it |
| Event cutover | Is event cutover needed as separate flag or combined with signal? | Not addressed - no cutover flag | MEDIUM - event cutover pathway is incomplete |
| Shadow flag mechanism | Should shadow be testable without editing source? | Hardcoded const booleans | HIGH for testing - can't validate equivalence in CI |

## Cleanup Debt
1. `src/compiler/ir/__tests__/lowerToValueExprs.test.ts.orig` - leftover file, should be deleted
2. ~300 lines duplicated signal kernel code between `SignalEvaluator.ts` and `ValueExprSignalEvaluator.ts`
3. Dummy CanonicalType construction in materializer (2 instances)
4. Defensive null checks on cache arrays that are always initialized

## Recommendations

1. **[CRITICAL] Enable shadow mode in tests** - The single most important gap. Create a test utility that temporarily enables shadow comparison (e.g., via a function parameter rather than module const). Run the full test suite with shadow enabled. If zero mismatches, the migration is validated. If mismatches, they must be fixed before any cutover.

2. **[CRITICAL] Run cutover mode in tests** - After shadow validation passes, run the full test suite with `VALUE_EXPR_ONLY = true` and `VALUE_EXPR_MATERIALIZE = true`. This is the DOD acceptance criteria for Sprints 3 and 5 that is currently unmet.

3. **[HIGH] Add event cutover flag** - Add `VALUE_EXPR_EVENT` flag parallel to the signal and materializer cutover flags. Without this, the event evaluator migration cannot complete.

4. **[HIGH] Make flags testable** - Replace module-level `const` flags with a mechanism that can be toggled in tests (e.g., pass as parameter to `executeFrame`, or use a test-only runtime config). Hardcoded booleans that require source edits cannot be validated in CI.

5. **[MEDIUM] Write ValueExprSignalEvaluator unit tests** - Cover each kind (const, slotRead, time, external, kernel/map, kernel/zip, state, eventRead). Currently no dedicated tests.

6. **[MEDIUM] Write ValueExprMaterializer unit tests** - Cover each field-extent kind (const, intrinsic/property, intrinsic/placement, kernel/broadcast, kernel/map, kernel/zip, kernel/zipSig, kernel/pathDerivative, state).

7. **[LOW] Delete lowerToValueExprs.test.ts.orig** - Cleanup.

8. **[LOW] Extract shared kernel code** - After cutover, deduplicate `applySignalKernel` into a shared module. During migration, duplication is acceptable for independence.

9. **[LOW] Replace dummy CanonicalType in materializer** - Use `expr.type` directly instead of constructing a fake type. The `_type` param is unused now but the cast is a latent bug.

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix
- [ ] PAUSE - Ambiguities need clarification

The implementation is structurally sound. The primary gap is validation: shadow mode and cutover mode have never been exercised. This is a testing gap, not an architecture gap. The implementer should:

1. Make shadow flags testable (not hardcoded const)
2. Run shadow mode across the full test suite
3. Fix any mismatches found
4. Run cutover mode across the full test suite
5. Add event cutover flag
6. Clean up after validation confirms equivalence
