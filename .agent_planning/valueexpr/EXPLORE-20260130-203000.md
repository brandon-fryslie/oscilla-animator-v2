# Explore Output: ValueExpr Type System
Timestamp: 2026-01-30-203000
Agent: opus (direct exploration, no haiku subagent)

## Raw Findings

### Test Results
- `npx vitest run`: 127 files, 2004 passed, 15 skipped, 2 todo. ZERO failures.
- `npx tsc --noEmit`: Clean exit, 0 errors.

### Git State
- Branch: bmf_type_system_refactor
- HEAD: 103c022 (test(ir): Add ValueExpr structural invariant tests)
- Uncommitted changes: DOD file edits + .beads/issues.jsonl (trivial)

### Sprint Commits (WI-1 through WI-5)
- 2cc3f2c: WI-1 - Remove phantom instanceId from IRBuilderImpl field builders
- 01473ed: WI-2 - Resolve instance name mismatch between block definitions and runtime
- 78d28ab: WI-3 - Replace all deriveKind consumers with direct axis checks
- 0013b52: WI-4 - Resolve 3 pre-existing test failures
- 103c022: WI-5 - Add ValueExpr structural invariant tests

### Enforcement Tests Created
1. `src/compiler/ir/__tests__/no-instanceid-on-fieldexpr.test.ts` (10 tests)
   - Tests all 8 FieldExpr builder methods for absence of instanceId
   - Tests requireManyInstance derives instance from type
   - Uses Object.keys() runtime check, not just TS types

2. `src/compiler/__tests__/no-deriveKind-imports.test.ts` (1 test)
   - Grep-based scan for `import.*deriveKind` in production code
   - Exempts canonical-types.ts (definition) and test files

3. `src/compiler/ir/__tests__/value-expr-invariants.test.ts` (8 tests)
   - Asserts 9 kinds, type on every variant, no op discriminant, no instanceId
   - Sub-discriminant coverage (kernelKind, eventKind, intrinsicKind)

### deriveKind Status
- `deriveKind()` function still exists in canonical-types.ts:780 (marked @deprecated)
- NO production code imports it directly (enforcement test passes)
- Internal usage: `requireSignalType`, `requireFieldType`, `requireEventType` at lines 815-842 call `deriveKind` internally
- `isSignalType`, `isFieldType`, `isEventType` at lines 848-867 call `tryDeriveKind` internally
- NONE of these helper functions have any consumers in production code
- `assertKindAgreement` in lowerTypes.ts:75 does its own axis dispatch (no deriveKind import)
- `axis-validate.ts` has local `derivedKindLabel` function (no deriveKind import)

### ValueExpr Consumer Status
- `ValueExpr` type defined in value-expr.ts (9 kinds, complete)
- `ValueExprId` branded type DUPLICATED: defined in both value-expr.ts:35 AND Indices.ts:45
- ZERO production code imports from value-expr.ts
- ZERO production code uses ValueExpr type
- All evaluators still use legacy SigExpr/FieldExpr/EventExpr
- IRBuilderImpl still builds legacy types, not ValueExpr

### IRBuilderImpl Field Builder Methods (verified clean)
- fieldIntrinsic (line 307): no instanceId in expr object
- fieldPlacement (line 329): no instanceId in expr object
- Broadcast (line 361): no instanceId in expr object
- fieldMap (line 387): no instanceId in expr object
- fieldZip (line 400): no instanceId in expr object
- fieldZipSig (line 413): no instanceId in expr object
- fieldStateRead (line 816): no instanceId in expr object
- inferFieldInstance / inferZipInstance: REMOVED (grep confirms)

### Legacy FieldExpr Types (types.ts)
- All 8 FieldExpr variants: NO instanceId field
- Step types (StepMaterialize, StepRender, StepContinuityMapBuild, StepContinuityApply): STILL have instanceId -- these are legitimate (Steps are not expressions)

### canonicalConst Status
- Defined at canonical-types.ts:746
- Used in exactly 1 test (instance-unification.test.ts:82)
- NOT used by any block lowering code
- Const blocks still emit cardinalityOne, not cardinalityZero

### Deferred Beads
- oscilla-animator-v2-vqkj: AdapterSpec restructure (P2, open)
- oscilla-animator-v2-73lv: Zero-cardinality enforcement (P3, open)
- oscilla-animator-v2-bzh2: First ValueExpr consumer migration (P3, open)

### TODOs in IR directory
- bridges.ts:241: `// TODO: Q6 - shape handling deferred`
- bridges.ts.bak file exists (leftover)

### Duplicate ValueExprId
- value-expr.ts:35: `export type ValueExprId = number & { readonly __brand: 'ValueExprId' };`
- Indices.ts:45: `export type ValueExprId = number & { readonly __brand: 'ValueExprId' };`
- Both define the same type and constructor. This is a ONE-SOURCE-OF-TRUTH violation.
