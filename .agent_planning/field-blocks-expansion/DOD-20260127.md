# Definition of Done - Field Blocks Expansion

**Topic**: Extended block system for layouts, vector state, path primitives, and per-element randomness
**Created**: 2026-01-27

---

## Sprint 1: Layout Blocks (P0)

### SpiralLayout Block
- [ ] `spiralLayout` kernel added to `FieldKernels.ts`
- [ ] Kernel computes Archimedean spiral: θ = 2π×turns×t, r = innerR + (outerR-innerR)×t
- [ ] `SpiralLayout` block registered with inputs: elements, turns, innerRadius, outerRadius, phase
- [ ] Output is `Field<vec3>` positions
- [ ] Block uses `fieldZipSig` with kernel
- [ ] Cardinality mode is `preserve`
- [ ] Instance context propagates correctly

### RandomScatter Block
- [ ] `scatterLayout` kernel added to `FieldKernels.ts`
- [ ] Kernel uses randomId + seed mixing for decorrelated X/Y
- [ ] `RandomScatter` block registered with inputs: elements, minX, maxX, minY, maxY, seed
- [ ] Output is `Field<vec3>` positions
- [ ] Positions are deterministic (same seed → same positions across frames)
- [ ] Positions stay within bounds

### Tests (Sprint 1)
- [ ] `spiralLayout` kernel test: output count matches input count
- [ ] `spiralLayout` kernel test: positions lie on spiral curve
- [ ] `spiralLayout` kernel test: different turns/radius produce different layouts
- [ ] `scatterLayout` kernel test: deterministic (same inputs → same outputs)
- [ ] `scatterLayout` kernel test: positions within bounds
- [ ] `scatterLayout` kernel test: different seeds produce different layouts
- [ ] Integration test: SpiralLayout block compiles and executes
- [ ] Integration test: RandomScatter block compiles and executes

### Verification (Sprint 1)
- [ ] `npm run typecheck` passes
- [ ] `npm run test` passes (all existing + new tests)
- [ ] Visual verification in dev server (optional but recommended)

---

## Sprint 2: Enhanced Randomness (P1)

### AnimatedNoise Block
- [ ] `animatedNoise` kernel added to `FieldKernels.ts`
- [ ] Kernel formula: `hash(seed + time × speed) × scale`
- [ ] `AnimatedNoise` block with inputs: seed (Field), speed, scale
- [ ] Output is `Field<float>` evolving noise
- [ ] Noise evolves smoothly over time (no discontinuities)

### NoiseField Block
- [ ] `noiseField2d` kernel added to `FieldKernels.ts`
- [ ] 2D hash-based noise (position-dependent)
- [ ] `NoiseField` block with inputs: position (Field<vec2>), scale, seed
- [ ] Output is `Field<float>` spatial noise
- [ ] Optional: FBM octaves parameter (1-4)

### GaussianRandom Block
- [ ] Box-Muller transform implementation in kernel
- [ ] `GaussianRandom` block with inputs: mean, stddev, seed (Field)
- [ ] Output is `Field<float>` Gaussian distributed
- [ ] No NaN or Inf values (clamp extreme inputs)

### Tests (Sprint 2)
- [ ] `animatedNoise` test: deterministic given same seed + time
- [ ] `animatedNoise` test: different speeds produce different evolution rates
- [ ] `noiseField2d` test: spatially coherent (nearby positions similar values)
- [ ] `noiseField2d` test: output range [0, 1)
- [ ] `GaussianRandom` test: mean approximately correct (statistical test)
- [ ] `GaussianRandom` test: no NaN/Inf values with edge inputs

---

## Sprint 3: Vector State Blocks (P2)

### FieldLag Block
- [ ] Block defined with `cardinalityMode: 'preserve'`
- [ ] Uses `StateMappingField` for per-lane state
- [ ] Inputs: target (Field<float>), smoothing (Signal), initialValue (Signal)
- [ ] Output: `Field<float>` smoothed values
- [ ] State formula: `state[i](t) = lerp(state[i](t-1), target[i](t), 1-smoothing)`
- [ ] Initial values respect `initialValue` parameter
- [ ] State persists across frames

### FieldUnitDelay Block
- [ ] Block defined with `cardinalityMode: 'preserve'`
- [ ] Uses `StateMappingField` for per-lane state
- [ ] Inputs: in (Field<float>), initialValue (Signal)
- [ ] Output: `Field<float>` (previous frame's values)
- [ ] Semantics: `out[i](t) = in[i](t-1)`

### FieldPhasor Block
- [ ] Block defined with `cardinalityMode: 'preserve'`
- [ ] Uses `StateMappingField` for per-lane state
- [ ] Inputs: frequency (Field<float>), initialPhase (Signal)
- [ ] Output: `Field<float>` phase values [0, 1)
- [ ] Wraps correctly at boundaries
- [ ] Each element accumulates independently

### State Migration
- [ ] Field state migrates on hot-swap
- [ ] Same laneCount: direct copy
- [ ] Larger laneCount: copy existing, init new with initialValue
- [ ] Smaller laneCount: copy retained lanes only
- [ ] State ID survives recompilation

### Tests (Sprint 3)
- [ ] `FieldLag` test: smoothing works per element
- [ ] `FieldLag` test: smoothing=0 means instant
- [ ] `FieldLag` test: state persists across frames
- [ ] `FieldUnitDelay` test: outputs previous frame
- [ ] `FieldUnitDelay` test: initial frame outputs initialValue
- [ ] `FieldPhasor` test: phase accumulates per element
- [ ] `FieldPhasor` test: phase wraps at 1.0
- [ ] State migration test: field state migrates correctly on hot-swap
- [ ] State migration test: lane count increase
- [ ] State migration test: lane count decrease

---

## Sprint 4: Polygon Primitive (P2)

### Polygon Block
- [ ] Block defined in `primitive-blocks.ts`
- [ ] Inputs: sides (Signal<int>), radius (Signal<float>), rotation (Signal<float>)
- [ ] Output: `Signal<shape>` (shape reference)
- [ ] Uses `polygonVertex` kernel for control points
- [ ] Works with existing shape system (stride 8)
- [ ] Integrates with Array → Layout pipeline

### Tests (Sprint 4)
- [ ] Polygon block test: compiles successfully
- [ ] Polygon block test: outputs valid shape reference
- [ ] Polygon block test: different sides produce different shapes
- [ ] Integration test: Polygon → Array → CircleLayout renders

---

## Sprint 5: Full AlongPath (P3 - Stretch Goal)

### AlongPath Block
- [ ] Path → LUT conversion during lowering
- [ ] `pathLayout` field kernel
- [ ] Block accepts path source (shape with control points)
- [ ] Outputs: position (Field<vec3>), tangent (Field<vec2>), t (Field<float>)
- [ ] Works with bezier and arc paths

### Tests (Sprint 5)
- [ ] AlongPath test: elements follow linear path
- [ ] AlongPath test: elements follow curved path
- [ ] AlongPath test: tangent output correct

---

## Overall Acceptance Criteria

### Code Quality
- [ ] All new code follows existing patterns
- [ ] No `any` types without justification
- [ ] New kernels documented with input/output contracts
- [ ] Block descriptions accurate

### Testing
- [ ] All existing tests still pass
- [ ] New tests cover happy paths and edge cases
- [ ] Determinism tests for all random operations
- [ ] State persistence tests for all stateful blocks

### Performance
- [ ] 60fps with 1000 elements (spot check)
- [ ] No memory leaks (field buffers released)
- [ ] No excessive allocations in hot loops

### Integration
- [ ] Blocks appear in block library UI
- [ ] Blocks connect correctly in graph editor
- [ ] Parameters have appropriate UI hints (sliders, ranges)

---

## Not In Scope

- WebGL/GPU acceleration
- Perlin/Simplex noise (hash-based is acceptable)
- Cross-instance field access (requires architecture change)
- Path drawing/editing UI
- Audio/MIDI integration
