# Field Blocks Expansion Plan

**Topic**: Extended block system for layouts, vector state, path primitives, and per-element randomness
**Spec Reference**: `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/02-block-system.md:195+`
**Created**: 2026-01-27
**Status**: PLANNING

---

## Executive Summary

This plan expands the block library with **four interconnected feature sets** that enhance per-element control and procedural variation. These features share architectural patterns and should be implemented together for coherent design.

**Scope**:
1. **Missing Layout Blocks** - SpiralLayout, RandomScatter, full AlongPath
2. **Vector State Blocks** - Per-field stateful operations (FieldLag, FieldUnitDelay)
3. **Path Primitive Block** - Arbitrary shapes via path commands
4. **Enhanced Field Randomness** - More ways to add per-element variation

**Non-Goals**:
- Changes to the core state architecture (already solid)
- Changes to the three-stage architecture (Primitive → Array → Layout)
- WebGL/GPU acceleration (future optimization)

---

## Architectural Foundation

### Current Infrastructure (Leveraged)

The codebase has a **mature, well-designed infrastructure** for per-element operations:

| Component | Location | Status |
|-----------|----------|--------|
| `randomId` intrinsic | `Materializer.ts:437-443` | ✅ Complete |
| `hash` opcode | `OpcodeInterpreter.ts:171-184` | ✅ Complete |
| `jitter2d` field kernel | `FieldKernels.ts:125-158` | ✅ Complete |
| `fieldZipSig` API | `IRBuilder` | ✅ Complete |
| Field state read/write | `ScheduleExecutor.ts` | ✅ Complete |
| Layout kernel pattern | `instance-blocks.ts` | ✅ Complete |

### Design Principles

1. **Deterministic**: All randomness is seeded; same inputs → same outputs
2. **Lane-local**: Per-element operations don't cross lanes (no boids/blur)
3. **Kernel-based**: New operations add field kernels, not special IR
4. **Composable**: Blocks chain via standard Field→Field patterns
5. **Cardinality-preserving**: Layout/effect blocks preserve instance cardinality

---

## Feature 1: Missing Layout Blocks

### 1.1 SpiralLayout

**Purpose**: Arrange elements along an Archimedean spiral.

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `elements` | `Field<T>` | required | Instance to position |
| `turns` | `Signal<float>` | 3.0 | Number of spiral turns |
| `innerRadius` | `Signal<float>` | 0.05 | Starting radius |
| `outerRadius` | `Signal<float>` | 0.4 | Ending radius |
| `phase` | `Signal<float>` | 0.0 | Rotation offset [0,1] |

**Output**: `Field<vec3>` positions

**Formula**:
```
θ(t) = 2π × turns × t + phase × 2π
r(t) = innerRadius + (outerRadius - innerRadius) × t
x = 0.5 + r(t) × cos(θ(t))
y = 0.5 + r(t) × sin(θ(t))
z = 0
```

**Implementation**:
1. Add `spiralLayout` kernel to `FieldKernels.ts`
2. Add `SpiralLayout` block to `instance-blocks.ts`
3. Add tests to verify no element overlap and correct spacing

### 1.2 RandomScatter

**Purpose**: Distribute elements randomly within a bounded region.

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `elements` | `Field<T>` | required | Instance to position |
| `minX` | `Signal<float>` | 0.1 | Left bound |
| `maxX` | `Signal<float>` | 0.9 | Right bound |
| `minY` | `Signal<float>` | 0.1 | Bottom bound |
| `maxY` | `Signal<float>` | 0.9 | Top bound |
| `seed` | `Signal<float>` | 0.0 | Random seed for reproducibility |

**Output**: `Field<vec3>` positions

**Formula**:
```
// Per-element using randomId intrinsic + seed mixing
randX = hash(randomId[i] + seed × 0.618)  // Golden ratio for decorrelation
randY = hash(randomId[i] × 2.718 + seed)  // e for different sequence
x = minX + (maxX - minX) × randX
y = minY + (maxY - minY) × randY
z = 0
```

**Implementation**:
1. Add `scatterLayout` kernel to `FieldKernels.ts`
2. Add `RandomScatter` block to `instance-blocks.ts`
3. Ensure deterministic (same seed → same positions across frames)

### 1.3 Full AlongPath (Stretch Goal)

**Current State**: MVP exists for circular paths only.

**Full Version Requirements**:
- Accept arbitrary `Field<shape>` as path source
- Sample control points from path for position/tangent
- Requires cross-domain field access (path's control points vs. positioned elements)

**Architecture Challenge**: Current field kernel architecture doesn't support accessing fields from different instances within a single kernel.

**Proposed Solution**:
```
Option A: Path → Signal conversion
- Convert path to lookup table (Signal<pathLUT>) during lowering
- Field kernel samples from constant LUT

Option B: Two-pass evaluation
- Phase 1: Materialize path control points to buffer
- Phase 2: Field kernel reads from materialized buffer

Recommendation: Option A (simpler, fits current architecture)
```

**Defer Decision**: Mark AlongPath full version as P3 (stretch goal). Implement Option A if time permits.

---

## Feature 2: Vector State Blocks

### Motivation

Current stateful blocks (UnitDelay, Lag, Phasor) operate at **signal cardinality** (one value). For rich per-element animation, we need **field cardinality** state:

- Per-element smoothing (independent lag per element)
- Per-element delay (staggered effects)
- Per-element phase accumulators (desynchronized oscillations)

### 2.1 FieldLag

**Purpose**: Per-element exponential smoothing (independent state per lane).

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `target` | `Field<float>` | required | Target values to smooth toward |
| `smoothing` | `Signal<float>` | 0.1 | Smoothing factor (0=instant, 1=frozen) |
| `initialValue` | `Signal<float>` | 0.0 | Initial state per element |

**Output**: `Field<float>` smoothed values

**State**: `StateMappingField` with `laneCount × stride` floats

**Update**: `state[i](t) = lerp(state[i](t-1), target[i](t), 1 - smoothing)`

**Implementation**:
1. Define `FieldLag` block with `cardinalityMode: 'preserve'`
2. Use `ctx.b.allocFieldStateSlot()` for per-lane state
3. Use `fieldStateRead` / `stepFieldStateWrite` IR operations
4. Add field kernel `fieldLagKernel` or inline in Materializer

### 2.2 FieldUnitDelay

**Purpose**: One-frame delay per element (for feedback loops).

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `in` | `Field<float>` | required | Input values |
| `initialValue` | `Signal<float>` | 0.0 | Initial state per element |

**Output**: `Field<float>` (previous frame's input per element)

**State**: `StateMappingField`

**Semantics**: `out[i](t) = in[i](t-1)`

### 2.3 FieldPhasor

**Purpose**: Per-element phase accumulator (desynchronized oscillations).

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `frequency` | `Field<float>` | required | Frequency per element |
| `initialPhase` | `Signal<float>` | 0.0 | Starting phase |

**Output**: `Field<float>` phase values [0, 1)

**State**: `StateMappingField`

**Update**: `phase[i](t) = wrap01(phase[i](t-1) + frequency[i] × dt)`

### State Migration for Field State

Per Invariant I3, state migrates using `StateId`:
- Same StateId + same laneCount → copy
- Same StateId + larger laneCount → copy existing, init new
- Same StateId + smaller laneCount → copy retained lanes
- Stable identity mode → use continuity lane mapping

**Already Implemented**: `StateMigration.ts` handles this correctly.

---

## Feature 3: Path Primitive Block

### Purpose

Create arbitrary shapes via canvas-style path commands. The spec (line 329) lists:
- Circle (exists as Ellipse)
- Rectangle (exists as Rect)
- **Polygon** (missing - vertices list)

The TODO at line 236 says: "Path block for arbitrary shapes via canvas path commands"

### 3.1 Polygon Block

**Simpler version** - fixed vertex count polygon.

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `sides` | `Signal<int>` | 6 | Number of sides |
| `radius` | `Signal<float>` | 0.1 | Circumradius |
| `rotation` | `Signal<float>` | 0.0 | Rotation angle [0,1] |

**Output**: `Signal<shape>` (shape reference)

**Implementation**: Use existing `polygonVertex` field kernel for control points.

### 3.2 Path Block (Canvas Commands)

**Full version** - arbitrary path via command buffer.

**Design Challenge**: How to represent path commands in the signal graph?

**Option A: Parameter-based presets**
```
Path block with mode selector:
- mode: 'arc' | 'bezier' | 'line' | 'custom'
- Different ports visible based on mode
```

**Option B: Path string constant**
```
Path block with SVG-like path string parameter:
- pathData: "M 0 0 L 100 0 Q 100 100 0 100 Z"
- Parsed at compile time, control points become fields
```

**Option C: Control point fields**
```
Path block with Field<vec2> control points:
- controlPoints: Field<vec2> (from another Array)
- commands: constant command buffer
```

**Recommendation**: Start with **Polygon block** (3.1) for MVP. Path block (3.2) requires more design work and cross-field access.

---

## Feature 4: Enhanced Field Randomness

### Current Capabilities

| Operation | Output Range | Temporal | Per-Element |
|-----------|--------------|----------|-------------|
| `randomId` | [0, 1) | Static | ✅ |
| `hash(v, seed)` | [0, 1) | Static | Depends on input |
| `jitter2d` | vec2 offset | Static | ✅ |

### Gaps Identified

1. **Temporal noise**: Noise that evolves over time per element
2. **Multi-scale noise**: Perlin/Simplex for organic patterns
3. **Distribution control**: Gaussian, Poisson, etc.
4. **Correlated noise**: Noise fields with spatial coherence

### 4.1 AnimatedNoise Block

**Purpose**: Per-element noise that evolves over time.

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `seed` | `Field<float>` | randomId | Per-element seed |
| `speed` | `Signal<float>` | 1.0 | Temporal evolution rate |
| `scale` | `Signal<float>` | 1.0 | Amplitude scaling |

**Output**: `Field<float>` noise values

**Formula**:
```
// Time-varying per-element noise
noise[i](t) = hash(seed[i] + time × speed) × scale
```

**Implementation**:
1. Add `animatedNoise` field kernel
2. Takes time signal as broadcast input
3. Hash-based (not Perlin) for simplicity

### 4.2 SimplexNoise1D Signal Kernel

**Purpose**: Higher quality 1D noise for smooth organic motion.

**Current State**: Referenced in `Oscillator` block but uses simple hash noise.

**Implementation**:
1. Add proper Simplex noise implementation to `SignalEvaluator.ts`
2. Classic Simplex algorithm for 1D
3. Output range [-1, 1] for oscillator use, normalize to [0, 1] for general use

### 4.3 NoiseField Block

**Purpose**: 2D spatial noise field (same noise function sampled at different positions).

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `position` | `Field<vec2>` | required | Sample positions |
| `scale` | `Signal<float>` | 1.0 | Noise scale (frequency) |
| `seed` | `Signal<float>` | 0.0 | Global seed |
| `octaves` | `Signal<int>` | 1 | FBM octaves (1-4) |

**Output**: `Field<float>` noise values

**Implementation**:
1. Add `noiseField2d` kernel to `FieldKernels.ts`
2. 2D hash-based noise (not Perlin for MVP)
3. Optional FBM layering with octaves parameter

### 4.4 GaussianRandom Block

**Purpose**: Per-element Gaussian (normal) distribution.

**Inputs**:
| Port | Type | Default | Description |
|------|------|---------|-------------|
| `mean` | `Signal<float>` | 0.0 | Distribution center |
| `stddev` | `Signal<float>` | 1.0 | Standard deviation |
| `seed` | `Field<float>` | randomId | Per-element seed |

**Output**: `Field<float>` Gaussian distributed values

**Formula**: Box-Muller transform from uniform random
```
u1 = hash(seed[i])
u2 = hash(seed[i] × golden_ratio)
z = sqrt(-2 × ln(u1)) × cos(2π × u2)
out = mean + stddev × z
```

---

## Implementation Sprints

### Sprint 1: Layout Blocks (P0)

**Deliverables**:
- [ ] `spiralLayout` field kernel
- [ ] `SpiralLayout` block
- [ ] `scatterLayout` field kernel
- [ ] `RandomScatter` block
- [ ] Unit tests for both layouts

**Effort**: ~4-6 hours

**Verification**:
- Elements don't overlap with reasonable parameters
- Deterministic positioning (same seed → same positions)
- Parameters affect layout correctly
- Compile without errors in test patches

### Sprint 2: Enhanced Randomness (P1)

**Deliverables**:
- [ ] `animatedNoise` field kernel
- [ ] `AnimatedNoise` block
- [ ] `noiseField2d` kernel (2D spatial noise)
- [ ] `NoiseField` block
- [ ] `GaussianRandom` block (Box-Muller)
- [ ] Unit tests

**Effort**: ~4-6 hours

**Verification**:
- Noise values are deterministic given same seeds
- Animated noise evolves smoothly over time
- Gaussian distribution approximately correct (chi-square test in tests)
- No NaN or Inf values

### Sprint 3: Vector State Blocks (P2)

**Deliverables**:
- [ ] `FieldLag` block with per-lane state
- [ ] `FieldUnitDelay` block with per-lane state
- [ ] `FieldPhasor` block with per-lane state
- [ ] State migration tests for field state
- [ ] Integration tests

**Effort**: ~6-8 hours

**Verification**:
- State persists across frames correctly
- Each element has independent state
- State migrates correctly on hot-swap
- Cardinality changes handled (grow: init new, shrink: drop)

### Sprint 4: Polygon Primitive (P2)

**Deliverables**:
- [ ] `Polygon` primitive block
- [ ] Uses `polygonVertex` kernel for control points
- [ ] Integrates with existing shape system
- [ ] Unit tests

**Effort**: ~2-4 hours

**Verification**:
- Polygon renders correctly with N sides
- Rotation parameter works
- Shape integrates with Array → Layout pipeline

### Sprint 5: Full AlongPath (P3 - Stretch)

**Deliverables**:
- [ ] Path → LUT conversion in lowering
- [ ] `pathLayout` field kernel
- [ ] `AlongPath` block with full path support
- [ ] Tests for bezier/arc paths

**Effort**: ~8-12 hours (complex)

**Verification**:
- Elements follow path correctly
- Tangent output correct for oriented elements
- Works with bezier and arc segments

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Field state complexity | High | Existing infrastructure is solid; follow patterns |
| AlongPath cross-domain | High | Defer to P3, use LUT approach |
| Performance with many elements | Medium | Profile early, batch kernel ops |
| Simplex noise quality | Low | Hash-based noise is acceptable for MVP |

---

## Dependencies

**Existing Infrastructure (no changes needed)**:
- ✅ Field kernel registration (`FieldKernels.ts`)
- ✅ Block registration (`registry.ts`)
- ✅ Field state read/write (`IRBuilder`, `ScheduleExecutor`)
- ✅ State migration (`StateMigration.ts`)
- ✅ Intrinsic system (`Materializer.ts`)

**May Need Extension**:
- `fieldZipSig` signature for 5+ signal inputs (check limits)
- Field kernel output stride handling for vec3

---

## Success Criteria

1. **All tests pass** (existing + new)
2. **No runtime errors** in test patches
3. **Deterministic** (same inputs → same outputs)
4. **Hot-swap preserves state** where appropriate
5. **Performance acceptable** (60fps with 1000 elements)
6. **Documentation updated** (block library README)

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/runtime/FieldKernels.ts` | Add spiral, scatter, noise kernels |
| `src/blocks/instance-blocks.ts` | Add SpiralLayout, RandomScatter |
| `src/blocks/signal-blocks.ts` | Add vector state blocks |
| `src/blocks/primitive-blocks.ts` | Add Polygon block |
| `src/blocks/noise-blocks.ts` | New file for noise blocks |
| `src/runtime/Materializer.ts` | Field state kernel execution |
| `src/compiler/ir/IRBuilderImpl.ts` | Verify field state API (likely no changes) |
| `src/blocks/__tests__/` | New test files |

---

## Appendix: Kernel Signatures

### spiralLayout
```typescript
// zipSig kernel: field(normalizedIndex) + signals(turns, innerRadius, outerRadius, phase) → vec3
(t: number, turns: number, innerR: number, outerR: number, phase: number) => [x, y, z]
```

### scatterLayout
```typescript
// zipSig kernel: field(randomId) + signals(minX, maxX, minY, maxY, seed) → vec3
(rand: number, minX: number, maxX: number, minY: number, maxY: number, seed: number) => [x, y, z]
```

### animatedNoise
```typescript
// zipSig kernel: field(seed) + signals(time, speed, scale) → float
(seed: number, time: number, speed: number, scale: number) => noise
```

### noiseField2d
```typescript
// zip kernel: fields(posX, posY) + signals(scale, seed, octaves) → float
(x: number, y: number, scale: number, seed: number, octaves: number) => noise
```

---

## Approval Request

This plan covers 4 feature areas across 5 sprints. Recommended execution order:

1. **Sprint 1** (Layout Blocks) - Foundation for spatial variety
2. **Sprint 2** (Randomness) - Enhances expressiveness
3. **Sprint 3** (Vector State) - Enables per-element animation
4. **Sprint 4** (Polygon) - Completes primitive set
5. **Sprint 5** (AlongPath) - Stretch goal if time permits

**Total estimated effort**: 24-36 hours

Ready for approval?
