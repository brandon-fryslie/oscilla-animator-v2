# Context Document - Field Blocks Expansion

**Topic**: Extended block system for layouts, vector state, path primitives, and per-element randomness
**Created**: 2026-01-27

---

## Background

The user requested planning for `02-block-system.md:195` which covers **Stateful Primitives** and the **Three-Stage Architecture**. Research revealed that the core stateful primitives are already complete:

| Block | Status | Location |
|-------|--------|----------|
| UnitDelay | ✅ Complete | `signal-blocks.ts:354-400` |
| Lag | ✅ Complete | `signal-blocks.ts:406-459` |
| Phasor | ✅ Complete | `signal-blocks.ts:465-529` |
| SampleAndHold | ✅ Complete | `event-blocks.ts:55-117` |
| Accumulator | ✅ Complete | `signal-blocks.ts:289-348` |

The **Three-Stage Architecture** (Primitive → Array → Layout) is also implemented with:
- Primitive blocks: Ellipse, Rect ✅
- Array block: Complete ✅
- Layout blocks: GridLayout, CircleLayout, LineLayout, LinearLayout ✅

**Gaps Identified**:
1. Missing layout blocks: SpiralLayout, RandomScatter, full AlongPath
2. Vector state blocks: Per-field stateful operations for per-element animation
3. Path primitive: Polygon and arbitrary path shapes
4. Enhanced randomness: More per-element noise/variation options

---

## Codebase Architecture

### Field Kernel System

The codebase has a mature field kernel architecture:

**Registration** (`FieldKernels.ts`):
```typescript
// ZIP kernels: multiple field inputs → output
// ZIPSIG kernels: field input + signal broadcasts → output
export function applyFieldKernel(
  out: ArrayLike<number>,
  inputs: readonly ArrayLike<number>[],
  fieldOp: string,
  N: number,
  outputType: SignalType
): void
```

**Existing Kernels**:
- ZIP: `makeVec2`, `makeVec3`, `hsvToRgb`, `jitter2d`, `attract2d`, `fieldAdd`, etc.
- ZIPSIG: `circleLayout`, `gridLayout`, `lineLayout`, `polygonVertex`, etc.

**Adding New Kernels**:
1. Add case to `applyFieldKernel` switch
2. Implement loop over N elements
3. Handle stride correctly for multi-component outputs

### Block Registration

Blocks register via `registerBlock()`:

```typescript
registerBlock({
  type: 'BlockName',
  label: 'Display Name',
  category: 'layout',
  cardinality: {
    cardinalityMode: 'preserve',  // 'signalOnly' | 'transform' | 'preserve' | 'fieldOnly'
    laneCoupling: 'laneLocal',
    broadcastPolicy: 'allowZipSig',
  },
  inputs: { ... },
  outputs: { ... },
  lower: ({ ctx, inputsById, config }) => { ... },
});
```

### State System

**Scalar State** (current stateful blocks):
```typescript
const stateId = stableStateId(ctx.instanceId, 'delay');
const stateSlot = ctx.b.allocStateSlot(stateId, { initialValue });
const prevValue = ctx.b.sigStateRead(stateSlot, type);
ctx.b.stepStateWrite(stateSlot, newValue);
```

**Field State** (for vector state blocks):
```typescript
// StateMappingField in IR
interface StateMappingField {
  kind: 'field';
  stateId: StableStateId;
  instanceId: string;
  slotStart: number;
  laneCount: number;
  stride: number;
  initial: readonly number[];
}

// IR operations
ctx.b.allocFieldStateSlot(stateId, { instanceId, laneCount, initialValue, stride });
ctx.b.fieldStateRead(stateSlot, instanceId, type);
ctx.b.stepFieldStateWrite(stateSlot, valueField);
```

### Randomness Infrastructure

**Intrinsics**:
- `randomId`: Per-element deterministic random [0, 1) from `pseudoRandom(index)`
- Formula: `Math.sin(seed * 12.9898) * 43758.5453` (fractional part)

**Opcodes**:
- `hash(value, seed)`: xxHash-style mixing → [0, 1)

**Kernels**:
- `jitter2d(pos, rand, amtX, amtY)`: 2D position offset
- `fieldJitterVec(pos, rand, amtX, amtY, amtZ)`: 3D position offset

---

## Spec References

### From `02-block-system.md`

**Three-Stage Architecture** (lines 232-318):
- Stage 1: Primitives create `Signal<T>` (WHAT kind)
- Stage 2: Array transforms `Signal<T>` → `Field<T>` (HOW MANY)
- Stage 3: Layout operates on fields → `Field<vec3>` positions (WHERE)

**Layout Blocks MVP** (line 354-366):
| Block | Algorithm | Key Inputs |
|-------|-----------|------------|
| Grid Layout | Row-major grid | rows, cols |
| Spiral Layout | Archimedean spiral | turns, spacing |
| Random Scatter | Random positions | bounds, seed |
| Along Path | Path-following | path, spacing |

**Cardinality-Generic Blocks** (lines 405-470):
- Lane-local operations (no cross-lane dependencies)
- Cardinality preserved (input field count = output field count)
- Stateful blocks can be cardinality-generic (per-lane state)

### From `05-runtime.md`

**State Mapping Types** (lines 116-138):
- `StateMappingScalar`: Single state value (stride floats)
- `StateMappingField`: Per-lane state (laneCount × stride floats)

**State Migration** (lines 155-188):
- Same StateId → copy
- Lane count changed → init new, discard removed
- Stable identity → use continuity lane mapping

### From `INVARIANTS.md`

**I3: State Continuity with Stable IDs**
- Stateful blocks have stable StateIds
- Migration: copy if compatible, reset with diagnostic if not

**I7: Explicit Cycle Semantics**
- Cycles must cross stateful boundary
- Enables feedback loops through UnitDelay/Phasor

**I11: Stable Element Identity**
- Instances provide stable element IDs
- Required for temporal effects, per-element state

---

## Implementation Patterns

### Layout Block Pattern

From existing `CircleLayout`:

```typescript
registerBlock({
  type: 'CircleLayout',
  cardinality: {
    cardinalityMode: 'preserve',
    laneCoupling: 'laneLocal',
    broadcastPolicy: 'allowZipSig',
  },
  lower: ({ ctx, inputsById, config }) => {
    // 1. Get instance context
    const instanceId = ctx.inferredInstance;

    // 2. Get parameters as signals
    const radiusSig = inputsById.radius?.k === 'sig'
      ? inputsById.radius.id
      : ctx.b.sigConst(config?.radius ?? 0.3, signalType(FLOAT));

    // 3. Create intrinsic field (normalizedIndex for position calculation)
    const normalizedIndexField = ctx.b.fieldIntrinsic(
      instanceId,
      'normalizedIndex',
      signalTypeField(FLOAT, 'default')
    );

    // 4. Apply field kernel
    const positionField = ctx.b.fieldZipSig(
      normalizedIndexField,
      [radiusSig, phaseSig],
      { kind: 'kernel', name: 'circleLayout' },
      signalTypeField(VEC3, 'default')
    );

    // 5. Return outputs
    return {
      outputsById: {
        position: { k: 'field', id: positionField, slot, type, stride },
      },
      instanceContext: instanceId,
    };
  },
});
```

### Field Kernel Pattern

From existing `circleLayout`:

```typescript
else if (fieldOp === 'circleLayout') {
  // Inputs: [normalizedIndex: Field<float>]
  // Signals: [radius, phase]
  // Output: vec3 (stride 3)
  const outArr = out as Float32Array;
  const idArr = inputs[0] as Float32Array;
  const radius = signals[0];
  const phase = signals[1];

  for (let i = 0; i < N; i++) {
    const t = idArr[i];
    const angle = 2 * Math.PI * (t + phase);
    outArr[i * 3 + 0] = 0.5 + radius * Math.cos(angle);  // x
    outArr[i * 3 + 1] = 0.5 + radius * Math.sin(angle);  // y
    outArr[i * 3 + 2] = 0;                                // z
  }
}
```

### Stateful Block Pattern

From existing `UnitDelay`:

```typescript
registerBlock({
  type: 'UnitDelay',
  lower: ({ ctx, inputsById }) => {
    const input = inputsById.in;

    // 1. Create stable state ID
    const stateId = stableStateId(ctx.instanceId, 'delay');

    // 2. Allocate state slot
    const stateSlot = ctx.b.allocStateSlot(stateId, {
      initialValue: config?.initialValue ?? 0
    });

    // 3. Read previous state (Phase 1)
    const prevValue = ctx.b.sigStateRead(stateSlot, type);

    // 4. Schedule write for Phase 2
    ctx.b.stepStateWrite(stateSlot, input.id);

    // 5. Output previous value
    return {
      outputsById: {
        out: { k: 'sig', id: prevValue, slot, type, stride },
      },
    };
  },
});
```

---

## Test Patterns

### Kernel Unit Test

```typescript
describe('circleLayout kernel', () => {
  it('positions elements on a circle', () => {
    const out = new Float32Array(9);  // 3 elements × stride 3
    const id01 = new Float32Array([0, 0.5, 1.0]);

    applyFieldKernelZipSig(out, [id01], [0.3, 0], 'circleLayout', 3, testFieldType(VEC3));

    // Element 0 at angle 0: (0.5 + 0.3, 0.5, 0)
    expect(out[0]).toBeCloseTo(0.8);
    expect(out[1]).toBeCloseTo(0.5);
  });
});
```

### Stateful Block Test

```typescript
describe('UnitDelay', () => {
  it('outputs previous frame input', () => {
    const patch = createPatch([
      { type: 'Constant', params: { value: 1.0 } },
      { type: 'UnitDelay' },
    ]);
    const { executeFrame, getOutput } = compileAndRun(patch);

    // Frame 1: output is initial value (0)
    executeFrame();
    expect(getOutput('UnitDelay', 'out')).toBe(0);

    // Frame 2: output is previous input (1.0)
    executeFrame();
    expect(getOutput('UnitDelay', 'out')).toBe(1.0);
  });
});
```

---

## Key Files

| Purpose | File |
|---------|------|
| Field kernels | `src/runtime/FieldKernels.ts` |
| Layout blocks | `src/blocks/instance-blocks.ts` |
| Stateful blocks | `src/blocks/signal-blocks.ts` |
| Primitive blocks | `src/blocks/primitive-blocks.ts` |
| Block registry | `src/blocks/registry.ts` |
| IR state types | `src/compiler/ir/types.ts` |
| IR builder | `src/compiler/ir/IRBuilderImpl.ts` |
| Schedule executor | `src/runtime/ScheduleExecutor.ts` |
| Materializer | `src/runtime/Materializer.ts` |
| State migration | `src/runtime/StateMigration.ts` |
| Kernel tests | `src/runtime/__tests__/field-kernel-contracts.test.ts` |
| Stateful tests | `src/blocks/__tests__/stateful-primitives.test.ts` |

---

## Gotchas

1. **Stride handling**: Vec3 outputs have stride 3, access as `out[i*3+0]`, `out[i*3+1]`, `out[i*3+2]`

2. **Instance context**: Layout blocks MUST propagate `instanceContext` in return value

3. **Signal vs Field inputs**: Check `input.k === 'sig'` vs `input.k === 'field'`

4. **Determinism**: All randomness must be seeded; no `Math.random()`

5. **Phase 1 vs Phase 2**: State reads happen in Phase 1, writes in Phase 2 (no same-frame feedback)

6. **State ID stability**: Use `stableStateId(ctx.instanceId, 'kind')` format

7. **Default sources**: All block inputs need default sources for combine semantics
