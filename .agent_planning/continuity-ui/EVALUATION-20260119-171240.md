# Evaluation: Continuity Panel Controls

**Date**: 2026-01-19
**Timestamp**: 1768868364
**Topic**: Controls for the continuity panel
**Verdict**: CONTINUE

## 1. Current State

### What Exists in the Continuity Panel

The ContinuityPanel component (`src/ui/components/app/ContinuityPanel.tsx`) currently displays **read-only observational data**:

- **Header**: Shows "domain changed" indicator when active, total domain changes count
- **Recent Changes Section**: Displays last 10 domain change events with:
  - Instance ID
  - Old count → new count
  - Delta (+/- element count change)
  - Timestamp (model time ms)
- **Active Targets Section**: Lists continuity targets with:
  - Semantic role (position, radius, opacity, color)
  - Instance ID
  - Element count
  - Slew progress bar (currently hardcoded to 1.0)
- **Mappings Section**: Shows active mappings with:
  - Instance ID
  - Mapping kind (identity, byId, byPosition)
  - Mapped vs unmapped element counts
- **Stats Footer**: Time since last domain change

The panel receives updates at 5Hz from `ContinuityStore` which is fed by `RuntimeState.continuity`.

### Current Architecture

- **Data Flow**: RuntimeState.continuity → ContinuityStore (MobX) → ContinuityPanel (React)
- **Update Rate**: 5Hz batched updates to minimize overhead
- **State Location**: Continuity parameters live in:
  - `ContinuityDefaults.ts` - System-wide defaults (tau values, policies)
  - `ContinuityApply.ts` - Hardcoded decay exponent (0.7 in `decayGauge()`)
  - Individual target state in `RuntimeState.continuity.targets`

## 2. Gauge Decay Controls

### New Gauge Decay Feature
The recently implemented gauge decay feature (in `decayGauge()` function) has two key parameters:

1. **Tau (time constant)**: Currently 360ms for position (from `ContinuityDefaults.ts`)
   - Controls how quickly the gauge decays
   - Position: 360ms (slow, smooth), Radius: 120ms (medium), Opacity: 80ms (fast), Color: 150ms (slow)

2. **Decay Exponent**: Currently 0.7 (hardcoded in `decayGauge()`)
   - Creates ease-in behavior (gentle start, accelerates to snap)
   - Formula: `decay = exp(-dt/τ)^exponent`
   - After τ ms at 0.7 exponent: decays to ~46% (vs 37% for linear exponential)

### Recommended Controls

**For Debugging & Tuning:**

1. **Decay Exponent Slider** (0.1 - 2.0, default 0.7)
   - Label: "Gauge Decay Curve"
   - Help text: "Lower = gentler start, Higher = more linear"
   - Directly affects the feel of how elements settle into new positions
   - Real-time preview of effect on active animations

2. **Tau Override Multiplier** (0.5x - 3.0x, default 1.0x)
   - Label: "Slew Time Scale"
   - Help text: "Multiplier for all time constants (faster/slower transitions)"
   - Applies globally to all semantic targets
   - Useful for experimenting with different animation speeds

3. **Per-Target Tau Override** (optional, advanced)
   - Only expose for position target initially
   - Individual control of tau for debugging specific behaviors
   - Would need dropdown selector (which semantic target)

### Implementation Notes

- These controls would need to be **persisted in RuntimeState** to survive hot-swap
- Changes should apply immediately to active continuity operations
- Original defaults should be easily restorable (reset button)

## 3. Other Useful Controls

### High Priority (Debugging Essentials)

1. **Continuity Reset Button**
   - "Clear All Continuity State"
   - Calls `clearContinuityState()` - useful when system gets into weird state
   - Confirmation dialog recommended

2. **Toggle Per-Semantic Logging**
   - Checkboxes: [ ] Position [ ] Radius [ ] Opacity [ ] Color
   - Currently logging is all-or-nothing via `DEBUG_CONTINUITY` const
   - Would help reduce noise when debugging specific targets

3. **Gauge Buffer Inspector** (Advanced)
   - Show actual gauge values for selected target
   - Display as: `[0]: base=10.5, gauge=2.3, effective=12.8`
   - Useful for understanding why elements are where they are
   - Sample first 5 elements only (avoid overwhelming output)

### Medium Priority (UX Polish)

4. **Slew Progress Computation**
   - Currently hardcoded to 1.0 in `ContinuityStore.updateFromRuntime()`
   - TODO comment exists: "Compute actual slew progress from buffer analysis"
   - Would show real-time slew convergence per target
   - Algorithm: Compare `slewBuffer` vs target values, threshold at 99% settled

5. **Mapping Visualization Toggle**
   - Button: "Highlight New Elements"
   - Overlays canvas with color-coding: green=mapped, yellow=new
   - Requires canvas rendering integration
   - Very useful for understanding what's happening during domain changes

6. **Domain Change History Filtering**
   - Dropdown: "Show: All | Position | Radius | Opacity | Color"
   - Filter recent changes by semantic target
   - Current display shows all changes mixed together

### Lower Priority (Nice to Have)

7. **Crossfade Window Override**
   - Only relevant for custom/untyped targets (crossfade policy)
   - Default: 150ms
   - Less common use case than slew-based policies

8. **Policy Override UI**
   - Switch a target from one policy to another (e.g., slew → crossfade)
   - Complex UX, needs careful design
   - Would violate canonical defaults (but useful for experimentation)

## 4. Implementation Approach

### Where Controls Should Go

**Option A: Expand ContinuityPanel (RECOMMENDED)**
- Add collapsible "Controls" section at top of existing panel
- Pros: Single source of truth, everything in one place
- Cons: Panel could get cluttered
- Mitigation: Use collapsible sections, default to collapsed

**Option B: Separate "Continuity Settings" Panel**
- New dockview panel for controls only
- Observation panel stays read-only
- Pros: Clean separation, can dock independently
- Cons: Two panels to manage, split attention

**Option C: Settings Modal/Drawer**
- Gear icon in panel header → opens modal with controls
- Pros: Keeps panel clean, hide complexity
- Cons: Less discoverable, modal friction

**Recommendation**: Option A (expand existing panel) with collapsible sections:
```
Continuity State
├─ [▼] Controls (collapsible, default collapsed)
│   ├─ Decay Exponent: [slider]
│   ├─ Time Scale: [slider]
│   ├─ [Reset to Defaults] [Clear State]
├─ [▶] Advanced (collapsible, default collapsed)
│   ├─ Logging: [x] Position [ ] Radius
│   ├─ Gauge Inspector: [dropdown + values]
├─ Recent Changes (10)
├─ Active Targets (N)
└─ Mappings (N)
```

### Implementation Path

1. **Add ContinuityControls component**
   - New file: `src/ui/components/app/ContinuityControls.tsx`
   - Renders sliders, buttons, toggles
   - Calls into `rootStore.continuity.setDecayExponent()`, etc.

2. **Extend ContinuityStore with actions**
   ```typescript
   @action setDecayExponent(value: number): void
   @action setTauMultiplier(value: number): void
   @action resetToDefaults(): void
   @action clearState(): void
   ```

3. **Bridge to RuntimeState**
   - Store controls in `RuntimeState.continuityConfig` (new field)
   - `ContinuityApply.ts` reads from config instead of hardcoded values
   - Preserves config across hot-swap

4. **Update ContinuityPanel.tsx**
   - Import and render `<ContinuityControls />` at top
   - Add collapsible section wrapper

### State Management

**New RuntimeState Field:**
```typescript
interface ContinuityConfig {
  decayExponent: number;        // Default: 0.7
  tauMultiplier: number;        // Default: 1.0
  debugLogSemantics: Set<string>; // Which targets to log
  showGaugeInspector: boolean;
  inspectedTarget: StableTargetId | null;
}
```

This config would:
- Live in `RuntimeState.continuityConfig`
- Be created in `createRuntimeState()`
- Survive hot-swap (not replaced during recompile)
- Be accessible to `ContinuityApply.applyContinuity()`

## 5. Unknowns

### Questions Needing Resolution

1. **Performance Impact**: What's the overhead of checking `RuntimeState.continuityConfig` every frame in `applyContinuity()`?
   - Likely negligible (simple field access)
   - Could measure with performance trace

2. **Control Interaction**: If user changes tau multiplier mid-slew, does it create artifacts?
   - Need to test empirically
   - May want to smooth transitions of control changes themselves

3. **Reset Semantics**: When user hits "Reset to Defaults", should it:
   - A) Only reset control values (keep continuity buffers)
   - B) Reset controls AND clear continuity state
   - Recommendation: Option A, with separate "Clear State" button for B

4. **Persistence**: Should control values persist across sessions?
   - Currently nothing persists (fresh state on reload)
   - Could add localStorage for dev convenience
   - Not critical for initial implementation

5. **Gauge Inspector Selection**: How to choose which target to inspect?
   - Dropdown of active targets by semantic:instanceId:port?
   - Auto-select first position target?
   - Only show inspector when user explicitly selects?

### Validation Needed

- **Test with real domain changes**: Current spiral demo may not trigger domain changes easily
  - Need to verify controls work when gauge is actually active (non-zero)
  - Consider adding test patch that frequently changes count

- **Visual verification**: Changes to decay exponent should be visually obvious
  - May need to record before/after videos for tuning
  - Side-by-side comparison view?

## 6. Verdict: CONTINUE

**Confidence Level**: HIGH

The path forward is clear:
1. Well-defined parameters to expose (decay exponent, tau multiplier)
2. Obvious location for controls (expand existing panel)
3. Clean implementation path (ContinuityControls component + ContinuityStore actions)
4. Minimal unknowns (mostly UX polish questions, not blockers)

**Next Steps**:
1. Implement `ContinuityConfig` in RuntimeState
2. Create `ContinuityControls.tsx` component with sliders
3. Add MobX actions to ContinuityStore
4. Update `decayGauge()` to read exponent from config
5. Update `getPolicyForSemantic()` to apply tau multiplier
6. Test with domain changes to verify real-time control

**Estimated Complexity**: Medium
- Core controls: 2-3 hours (decay exponent, tau multiplier, reset)
- Advanced features: 2-4 hours (gauge inspector, per-semantic logging)
- Testing & polish: 1-2 hours

**Risks**: Low
- All parameters are well-understood (from spec and implementation)
- No architectural changes needed (pure additive feature)
- Can implement incrementally (start with basic sliders, add advanced later)
