# Exploration: compiler-design-frontend-backend
Timestamp: 2026-01-28-161500

## COMPILER-DESIGN FRONTEND/BACKEND EXPLORATION

### **1. PROPOSAL (Complete)**

The PROPOSAL.md is fully available at `/Users/bmf/code/oscilla-animator-v2/.agent_planning/compiler-design-frontend-backend/PROPOSAL.md` (384 lines). Key sections:

**Frontend Pipeline (§2.1):**
- Normalize.Structural → Analyze.Types → Normalize.Adapters → Analyze.Types.Final
- Outputs: NormalizedGraph, TypedGraph, Diagnostics

**Backend Pipeline (§2.2):**
- Lowering → IR Building → Schedule → CompiledProgramIR
- Must NOT: insert adapters, infer types, apply implicit conversions

**Core Invariants:**
- Visibility: all conversions must be explicit blocks
- Determinism: same input → same output (stable IDs)
- Backend ignorance: no special-casing of auto-inserted adapters
- Type soundness: every connected edge type-correct by exact rules

---

### **2. CURRENT COMPILER PIPELINE IMPLEMENTATION**

**Entry Point:** `/Users/bmf/code/oscilla-animator-v2/src/compiler/compile.ts:110-427`

**Pass Orchestration (Lines 133-356):**

```typescript
// Pass 1: Normalization
const normResult = normalize(patch);  // src/graph/normalize.ts

// Pass 1: Type Constraints (union-find)
const pass1Result = pass1TypeConstraints(normalized);  
// Output: TypeResolvedPatch with portTypes Map

// Pass 2: Type Graph (validation)
const typedPatch = pass2TypeGraph(typeResolved);

// Pass 3: Time Topology
const timeResolvedPatch = pass3Time(typedPatch);

// Pass 4: Dependency Graph
const depGraphPatch = pass4DepGraph(timeResolvedPatch);

// Pass 5: Cycle Validation (SCC)
const acyclicPatch = pass5CycleValidation(depGraphPatch);

// Pass 6: Block Lowering
const unlinkedIR = pass6BlockLowering(acyclicPatch, {...});

// Pass 7: Schedule Construction
const scheduleIR = pass7Schedule(unlinkedIR, acyclicPatch);
```

**All 7 Passes Implemented:**
| Pass | File | Function | Output |
|------|------|----------|--------|
| Norm | `/src/graph/passes/index.ts` | `runNormalizationPasses()` | NormalizedPatch |
| 1 | `/src/compiler/passes-v2/pass1-type-constraints.ts` | `pass1TypeConstraints()` | TypeResolvedPatch + portTypes |
| 2 | `/src/compiler/passes-v2/pass2-types.ts` | `pass2TypeGraph()` | TypedPatch |
| 3 | `/src/compiler/passes-v2/pass3-time.ts` | `pass3Time()` | TimeResolvedPatch |
| 4 | `/src/compiler/passes-v2/pass4-depgraph.ts` | `pass4DepGraph()` | DepGraphWithTimeModel |
| 5 | `/src/compiler/passes-v2/pass5-scc.ts` | `pass5CycleValidation()` | AcyclicOrLegalGraph |
| 6 | `/src/compiler/passes-v2/pass6-block-lowering.ts` | `pass6BlockLowering()` | UnlinkedIRFragments |
| 7 | `/src/compiler/passes-v2/pass7-schedule.ts` | `pass7Schedule()` | ScheduleIR |

---

### **3. ADAPTER INSERTION**

**Location:** `/Users/bmf/code/oscilla-animator-v2/src/graph/passes/pass2-adapters.ts` (Backend/Graph Normalization)

**Status:** ⚠️ **FRONTEND ONLY** - Part of graph normalization (pre-compilation)

**Implementation (Lines 366-480):**

```typescript
// autoInsertAdapters() - Lines 366-480
function autoInsertAdapters(patch: Patch): Pass2Result | Pass2Error {
  const insertions = [];
  
  for (const edge of patch.edges) {
    const fromBlock = patch.blocks.get(edge.from.blockId);
    const toBlock = patch.blocks.get(edge.to.blockId);
    
    const fromType = getPortType(fromBlock.type, edge.from.slotId, 'output');
    const toType = getPortType(toBlock.type, edge.to.slotId, 'input');
    
    // KEY: Try to find adapter for type mismatch
    const adapterSpec = findAdapter(fromType, toType);  // Line 407
    
    if (adapterSpec) {
      // Insert adapter block (lines 415-445)
      const adapterId = `_adapter_${edge.id}` as BlockId;
      const adapterBlock: Block = {
        id: adapterId,
        type: adapterSpec.blockType,
        role: {
          kind: 'derived',
          meta: {
            kind: 'adapter',
            edgeId: edge.id,
            adapterType: adapterSpec.blockType,
          },
        },
        ...
      };
      
      // Rewire: source → adapter input → adapter output → target
      const edgeToAdapter = {...edge, to: {blockId: adapterId, slotId: adapterSpec.inputPortId}};
      const edgeFromAdapter = {...edge, from: {blockId: adapterId, slotId: adapterSpec.outputPortId}};
      
      insertions.push({block: adapterBlock, edgeToAdapter, edgeFromAdapter});
    }
  }
}
```

**Adapter Registry:** `/Users/bmf/code/oscilla-animator-v2/src/graph/adapters.ts:75-100`

```typescript
const ADAPTER_RULES: AdapterRule[] = [
  // Phase / Scalar
  { from: {payload: FLOAT, unit: {kind: 'phase01'}, ...},
    to: {payload: FLOAT, unit: {kind: 'scalar'}, ...},
    adapter: {blockType: 'Adapter_PhaseToScalar01', ...} },
  // Degrees ↔ Radians
  { from: {payload: FLOAT, unit: {kind: 'degrees'}, ...},
    to: {payload: FLOAT, unit: {kind: 'radians'}, ...},
    adapter: {blockType: 'Adapter_DegreesToRadians', ...} },
  // ... 10 total unit-conversion adapters
];
```

**Adapter Blocks Defined:** `/Users/bmf/code/oscilla-animator-v2/src/blocks/adapter-blocks.ts:1-100`

- `Adapter_PhaseToScalar01` (identity)
- `Adapter_ScalarToPhase01` (wrap)
- `Adapter_DegreesToRadians` 
- `Adapter_RadiansToDegrees`
- ... etc

---

### **4. TYPE RESOLUTION (Pass 1)**

**File:** `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes-v2/pass1-type-constraints.ts:1-520`

**Union-Find Implementation (Lines 70-174):**

```typescript
// UnitUnionFind - Lines 70-118
class UnitUnionFind {
  private parent: Map<string, string | Unit> = new Map();
  
  find(unit: Unit): Unit {
    if (unit.kind !== 'var') return unit;
    const id = unit.id;
    const p = this.parent.get(id);
    if (p === undefined) return unit;
    
    if (typeof p === 'string') {
      const root = this.find({kind: 'var', id: p});
      if (root.kind === 'var') {
        this.parent.set(id, root.id);
      } else {
        this.parent.set(id, root);  // Path compression
      }
      return root;
    }
    return p;
  }
  
  union(a: Unit, b: Unit): {ok: true} | {ok: false; conflict: [Unit, Unit]} {
    const rootA = this.find(a);
    const rootB = this.find(b);
    
    if (rootA.kind !== 'var' && rootB.kind !== 'var') {
      if (unitsEqual(rootA, rootB)) return {ok: true};
      return {ok: false, conflict: [rootA, rootB]};
    }
    
    if (rootA.kind === 'var' && rootB.kind !== 'var') {
      this.parent.set(rootA.id, rootB);  // Union: var → concrete
      return {ok: true};
    }
    if (rootB.kind === 'var' && rootA.kind !== 'var') {
      this.parent.set(rootB.id, rootA);
      return {ok: true};
    }
    if (rootA.kind === 'var' && rootB.kind === 'var' && rootA.id !== rootB.id) {
      this.parent.set(rootA.id, rootB.id);  // Link two vars
    }
    return {ok: true};
  }
}

// Same pattern for PayloadUnionFind - Lines 126-174
class PayloadUnionFind { ... }
```

**Main Algorithm (Lines 210-490):**

```typescript
export function pass1TypeConstraints(normalized: NormalizedPatch): Pass1Result {
  const portInfos = new Map();
  const errors = [];
  const unitUf = new UnitUnionFind();
  const payloadUf = new PayloadUnionFind();
  
  // Phase 1: Collect constraints from blocks
  for (let i = 0; i < normalized.blocks.length; i++) {
    const block = normalized.blocks[i];
    const blockDef = getBlockDefinition(block.type);
    
    // Extract unit/payload variables from port definitions
    for (const [portName, outputDef] of Object.entries(blockDef.outputs)) {
      const instanceUnit = isUnitVar(outputDef.type.unit)
        ? instanceUnitVar(i, portName, 'out')  // Create var instance
        : outputDef.type.unit;
      const instancePayload = isPayloadVar(outputDef.type.payload)
        ? instancePayloadVar(i, portName, 'out')
        : outputDef.type.payload;
      
      portInfos.set(`${i}:${portName}:out`, {
        instanceUnit, instancePayload, defType: outputDef.type, ...
      });
    }
  }
  
  // Phase 2: Collect constraints from edges
  for (const edge of normalized.edges) {
    const fromInfo = portInfos.get(`${edge.fromBlock}:${edge.fromPort}:out`);
    const toInfo = portInfos.get(`${edge.toBlock}:${edge.toPort}:in`);
    
    // Union unit variables
    const unitResult = unitUf.union(fromInfo.instanceUnit, toInfo.instanceUnit);
    if (!unitResult.ok) {
      errors.push({kind: 'ConflictingUnits', ...});
    }
    
    // Union payload variables
    const payloadResult = payloadUf.union(fromInfo.instancePayload, toInfo.instancePayload);
    if (!payloadResult.ok) {
      errors.push({kind: 'ConflictingPayloads', ...});
    }
  }
  
  // Phase 3: Resolve all ports
  const portTypes = new Map<PortKey, CanonicalType>();
  for (const [key, info] of portInfos) {
    let resolvedUnit = unitUf.find(info.instanceUnit);
    let resolvedPayload = payloadUf.find(info.instancePayload);
    
    if (isUnitVar(resolvedUnit)) {
      errors.push({kind: 'UnresolvedUnit', ...});
      continue;
    }
    
    portTypes.set(key, {
      ...info.defType,
      payload: resolvedPayload as ConcretePayloadType,
      unit: resolvedUnit,
    });
  }
  
  return {
    ...normalized,
    portTypes,  // THE source of truth for all downstream passes
  };
}
```

**TypeResolvedPatch Output Structure (Lines 40-49):**

```typescript
export interface TypeResolvedPatch extends NormalizedPatch {
  readonly portTypes: ReadonlyMap<PortKey, CanonicalType>;
  // Key: "blockIndex:portName:in|out"
  // Value: Fully resolved CanonicalType (no variables)
}
```

**Downstream Access (Lines 501-508):**

```typescript
export function getPortType(
  patch: TypeResolvedPatch,
  blockIndex: BlockIndex,
  portName: string,
  direction: 'in' | 'out'
): CanonicalType | undefined {
  return patch.portTypes.get(
    `${blockIndex}:${portName}:${direction}` as PortKey
  );
}
```

---

### **5. UI TYPE ACCESS PROBLEM**

**Problem Identified:** UI reads types from BlockDef directly, not from compiled TypeResolvedPatch

**UI Code Currently Using BlockDef Types:**
- `/src/ui/reactFlowEditor/typeValidation.ts:14` - `formatTypeForDisplay(type: CanonicalType)`
- `/src/ui/reactFlowEditor/nodes.ts:14` - `getPortTypeFromBlockType()` (BlockDef lookup)
- `/src/ui/reactFlowEditor/sync.ts:23` - `getPortTypeFromBlockType()` (BlockDef lookup)

**Evidence (sync.ts:55-80):**

```typescript
function findSmartPosition(
  newBlockDef: BlockDef,
  existingNodes: Node[]
) {
  const newInputTypes = Object.values(newBlockDef.inputs)
    .filter(input => input.exposedAsPort !== false)
    .map(input => input.type.payload);  // ← Reading from BlockDef, not TypeResolvedPatch!
}
```

**Why UI sees TypeVars:**
1. UI doesn't have access to compilation output (TypeResolvedPatch.portTypes)
2. BlockDef ports often have polymorphic types: `{ kind: 'var', id: 'T' }`
3. UI reads BlockDef types directly instead of resolved types from compiler

**TypedGraph Status:** ✅ **EXISTS as TypeResolvedPatch**

`/src/compiler/ir/patches.ts:70-79`:
```typescript
export interface TypedPatch extends TypeResolvedPatch {
  readonly blockOutputTypes: ReadonlyMap<string, ReadonlyMap<string, CanonicalType | InstanceRef>>;
}
```

But it's **not exposed to UI** - only used in backend compilation pipeline.

---

### **6. RECENT COMMITS (Git History)**

The project uses local git. Key recent changes visible in planning docs:

- **SPRINT-20260125-time-normalization**: Time model normalization (`./agent_planning/slot-simplification/`)
- **audit-cleanup-2026-01-19**: Pass 8 cleanup (PLAN-pass8-cleanup.md)
- **DEBUG-pass1**: Debug utility for type constraints (`./debug-pass1.ts`)

Key files with recent activity (from grep patterns):
- `src/compiler/passes-v2/pass*.ts` - All 7 passes recently active
- `src/graph/passes/pass*.ts` - Normalization passes stable
- `src/blocks/adapter-blocks.ts` - Adapter definitions

---

## **SUMMARY: SPEC vs IMPLEMENTATION**

| **Aspect** | **Proposal Spec** | **Current Implementation** | **Status** |
|---|---|---|---|
| **Frontend/Backend Split** | Explicit separation | ✅ Exists (`src/compiler/frontend` concept implicit, explicit backend) | ✅ Implemented |
| **7-Pass Pipeline** | Normalize + Types + Repair + Time + DepGraph + SCC + Lowering + Schedule | ✅ All implemented | ✅ Complete |
| **Union-Find Solver** | Required for type resolution | ✅ `UnitUnionFind` + `PayloadUnionFind` with path compression | ✅ Complete |
| **Adapter Insertion** | In normalization, deterministic IDs | ✅ `/graph/passes/pass2-adapters.ts` with `_adapter_${edgeId}` IDs | ✅ Implemented |
| **TypedGraph Artifact** | Must contain portTypes Map | ✅ `TypeResolvedPatch.portTypes` in `pass1-type-constraints.ts` | ✅ Exists |
| **UI Access to Types** | Should read from TypedGraph | ⚠️ UI currently reads BlockDef directly | ❌ **Gap: UI not using compiled types** |
| **Backend Contract** | Only TypedGraph input | ✅ Compiler only takes `AcyclicOrLegalGraph` (fully typed) | ✅ Enforced |
| **Deterministic IDs** | Adapters + derived blocks stable | ✅ Adapter ID = `_adapter_${edgeId}` (deterministic) | ✅ Implemented |

**Critical Gap:** UI doesn't consume `portTypes` from compiler output. UI should call frontend compiler and use `TypeResolvedPatch.portTypes` for type display, but currently relies on BlockDef definitions which may contain unresolved type variables.
