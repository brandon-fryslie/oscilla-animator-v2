Agent: iterative-implementer | 2026-01-20 07:52:00
Mode: manual
Completed: Core shape types, topology registry, IR updates | Files: 5 | Commits: 0 (pending)
Tests: Not yet run (implementation incomplete)
Cache invalidated: Not yet done (will invalidate after completion)
Status: in_progress - architectural decision needed

## Work Completed

### 1. Core Shape Types (src/shapes/types.ts)
- ✅ TopologyId type
- ✅ TopologyDef interface with id, params[], render function
- ✅ ParamDef interface with name, type, default
- ✅ ShapeRef interface with topologyId, paramSlots[]
- ✅ SlotRef type

### 2. Built-in Topologies (src/shapes/topologies.ts)  
- ✅ TOPOLOGY_ELLIPSE defined with params: rx, ry, rotation
- ✅ TOPOLOGY_RECT defined with params: width, height, rotation, cornerRadius
- ✅ Both topologies include render functions using Canvas API
- ✅ Objects frozen for immutability

### 3. Topology Registry (src/shapes/registry.ts)
- ✅ getTopology(id) returns correct TopologyDef
- ✅ hasTopology(id) for validation
- ✅ getAllTopologyIds() for introspection
- ✅ Registry is immutable (frozen Map)

### 4. IR Type Updates (src/compiler/ir/types.ts)
- ✅ Added SigExprShapeRef to SigExpr union
- ✅ Defined SigExprShapeRef interface with topologyId + paramSignals
- ✅ Imported TopologyId from shapes/types

### 5. IRBuilder Updates
- ✅ Added sigShapeRef method to IRBuilder interface (src/compiler/ir/IRBuilder.ts)
- ✅ Implemented sigShapeRef in IRBuilderImpl (src/compiler/ir/IRBuilderImpl.ts)

## Remaining Work & Architectural Question

### Architectural Decision Needed:

The DoD specifies that "ShapeRef flows through IR" and "Schedule carries topology + param slot refs". However, there's an architectural question about HOW ShapeRef integrates with the signal evaluation system:

**Option A: ShapeRef as metadata (recommended)**
- ShapeRef is attached to render steps as metadata
- Param signals are evaluated normally  
- Render step knows: topologyId + which slots contain params
- No need to "evaluate" ShapeRef as a signal value

**Option B: ShapeRef as special signal**
- ShapeRef is a signal expression that doesn't evaluate to a number
- Requires special handling in SignalEvaluator
- Adds complexity to the signal system

**Option C: Encode topology as number index**
- Simple numeric encoding (0=ellipse, 1=rect)
- Params passed separately
- Less type-safe, harder to extend

### Remaining Implementation (after decision):

1. Update primitive-blocks.ts
   - Ellipse block outputs ShapeRef with topology='ellipse' 
   - Rect block outputs ShapeRef with topology='rect'
   - Create signals for all params and store in slots

2. Update schedule generation (pass7-schedule.ts)
   - Wire shape through render step with topology + param slots
   - Handle ShapeRef metadata attachment

3. Update SignalEvaluator (if needed for chosen approach)
   - Add case for 'shapeRef' kind OR skip if using metadata approach

4. Update Canvas2DRenderer.ts
   - Remove hardcoded switch on shape index
   - Call `topology.render(ctx, params)` dispatch
   - Build params object from evaluated slot values

5. Update ScheduleExecutor.ts  
   - Evaluate param values each frame
   - Pass topology + params to renderer

6. Run validation
   - npm run typecheck
   - npm test
   - Verify steel-thread.test.ts works

7. Update demo (main.ts)
   - Use Ellipse block (not placeholder)
   - Verify rendering

## Recommendation

I recommend **Option A (metadata)** because:
1. Cleaner separation: topology is compile-time, params are runtime
2. No need to extend signal evaluation for non-numeric values
3. Matches the existing pattern for render steps
4. Easier to extend for future path topologies

The render step would look like:
```typescript
{
  kind: 'render',
  instanceId: '...',
  topologyId: 'ellipse',  // NEW
  paramSlots: [rxSlot, rySlot, rotSlot],  // NEW
  positionSlot: ...,
  colorSlot: ...,
}
```

## Files Modified
- src/shapes/types.ts (new)
- src/shapes/topologies.ts (new)
- src/shapes/registry.ts (new)
- src/compiler/ir/types.ts (updated)
- src/compiler/ir/IRBuilder.ts (updated)
- src/compiler/ir/IRBuilderImpl.ts (updated)

## Next Steps

User decision needed on architectural approach. Once decided, I can complete the remaining implementation (est. 30-45 min).
