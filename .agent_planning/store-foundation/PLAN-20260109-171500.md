# Store Foundation Plan (TypeScript-Enforced)

**Created**: 2026-01-09
**Goal**: Create MobX store architecture that prevents the v1 mistake of scattered sources of truth

## Problem Statement

V1 had 15+ MobX stores with overlapping data, leading to:
- `BusStore` duplicating parts of `PatchStore`
- `DefaultSourceStore` as a separate concern from block params
- `CompositeStore` redundant with block nesting
- `UIStateStore` mixing UI and domain concerns

We need TypeScript to **make wrong patterns impossible**, not just discouraged.

## Enforcement Strategy

### 1. Module Boundary Enforcement

Only the `stores/` module may import `mobx`. Components import from `stores/` only.

```
src/stores/          # OWNS all MobX usage
  ├── index.ts       # Public API - ONLY exports allowed for components
  ├── internal.ts    # Internal types/helpers - NOT exported
  └── ...

src/ui/              # MAY NOT import mobx directly
  └── components/    # Import from '../stores' only
```

**Enforcement**: ESLint rule or TypeScript paths to forbid `mobx` imports outside `stores/`.

### 2. Single Source of Truth via Opaque Types

```typescript
// stores/internal.ts - NOT EXPORTED
interface PatchData {
  blocks: Map<BlockId, Block>;
  edges: Edge[];
}

// stores/index.ts - EXPORTED
// Opaque wrapper - only PatchStore can create/modify
declare const PatchBrand: unique symbol;
export type ImmutablePatch = Patch & { readonly [PatchBrand]: never };

// Components receive ImmutablePatch - cannot construct their own
// PatchStore is the only way to get one
```

### 3. Action Boundary Enforcement

```typescript
// stores/PatchStore.ts
import { makeAutoObservable, action } from 'mobx';
import { configure } from 'mobx';

// STRICT MODE - mutations only in actions
configure({
  enforceActions: 'always',
  computedRequiresReaction: true,
  reactionRequiresObservable: true,
});

export class PatchStore {
  // Private mutable state
  private _patch: PatchData;

  // Public readonly access - components can read, never write
  get patch(): ImmutablePatch { ... }

  // Explicit actions - the ONLY way to mutate
  @action addBlock(...) { ... }
  @action removeBlock(...) { ... }
  @action addEdge(...) { ... }
  @action removeEdge(...) { ... }
  @action updateBlockParams(...) { ... }
}
```

### 4. Derived State via Computed (No Duplication)

```typescript
// WRONG - v1 pattern (duplicates data)
class BusStore {
  buses: Bus[] = [];  // Duplicates blocks with role.kind === 'bus'
}

// RIGHT - v2 pattern (derived from canonical source)
class PatchStore {
  get buses(): readonly Block[] {
    return computed(() =>
      [...this._patch.blocks.values()].filter(b => b.role.kind === 'bus')
    );
  }
}
```

### 5. Store Composition via RootStore

```typescript
// stores/RootStore.ts
export class RootStore {
  readonly patch: PatchStore;
  readonly selection: SelectionStore;
  readonly viewport: ViewportStore;
  readonly playback: PlaybackStore;
  readonly diagnostics: DiagnosticsStore;

  constructor() {
    this.patch = new PatchStore();
    this.selection = new SelectionStore(this.patch);
    this.viewport = new ViewportStore();
    this.playback = new PlaybackStore();
    this.diagnostics = new DiagnosticsStore();
  }
}

// Selection derives from patch, doesn't duplicate
class SelectionStore {
  constructor(private patchStore: PatchStore) {}

  @observable selectedBlockId: BlockId | null = null;

  // Computed - derives from canonical PatchStore
  get selectedBlock(): Block | undefined {
    return this.selectedBlockId
      ? this.patchStore.patch.blocks.get(this.selectedBlockId)
      : undefined;
  }
}
```

## Store Definitions

### PatchStore (THE Source of Truth)

**Owns**: All patch data (blocks, edges)
**No other store may store blocks or edges**

```typescript
interface PatchStore {
  // State
  readonly patch: ImmutablePatch;

  // Derived (computed)
  readonly blocks: ReadonlyMap<BlockId, Block>;
  readonly edges: readonly Edge[];
  readonly buses: readonly Block[];  // Derived from blocks
  readonly domains: readonly Block[]; // Derived from blocks

  // Actions (mutations)
  addBlock(type: BlockType, params?: Record<string, unknown>, options?: BlockOptions): BlockId;
  removeBlock(id: BlockId): void;
  updateBlockParams(id: BlockId, params: Partial<Record<string, unknown>>): void;
  updateBlockDisplayName(id: BlockId, displayName: string | null): void;

  addEdge(from: Endpoint, to: Endpoint): string;
  removeEdge(id: string): void;
  updateEdge(id: string, updates: Partial<Pick<Edge, 'enabled' | 'sortKey'>>): void;

  // Bulk operations
  loadPatch(patch: Patch): void;
  clear(): void;
}
```

### SelectionStore (UI State)

**Owns**: Selection state only (IDs, not copies of blocks)
**Derives**: Selected block/edge from PatchStore

```typescript
interface SelectionStore {
  // State (just IDs)
  selectedBlockId: BlockId | null;
  selectedEdgeId: string | null;
  hoveredBlockId: BlockId | null;
  hoveredPortRef: PortRef | null;

  // Derived (computed from PatchStore)
  readonly selectedBlock: Block | undefined;
  readonly selectedEdge: Edge | undefined;
  readonly hoveredBlock: Block | undefined;

  // Actions
  selectBlock(id: BlockId | null): void;
  selectEdge(id: string | null): void;
  hoverBlock(id: BlockId | null): void;
  hoverPort(ref: PortRef | null): void;
  clearSelection(): void;
}
```

### ViewportStore (UI State)

**Owns**: Pan, zoom, layout state
**Independent**: No dependency on PatchStore

```typescript
interface ViewportStore {
  // State
  pan: { x: number; y: number };
  zoom: number;

  // Actions
  setPan(x: number, y: number): void;
  setZoom(zoom: number): void;
  panBy(dx: number, dy: number): void;
  zoomBy(factor: number, centerX?: number, centerY?: number): void;
  resetView(): void;
}
```

### PlaybackStore (Runtime State)

**Owns**: Time, playback controls
**Independent**: No dependency on PatchStore

```typescript
interface PlaybackStore {
  // State
  time: number;
  isPlaying: boolean;
  speed: number;
  seed: number;

  // Actions
  play(): void;
  pause(): void;
  togglePlayPause(): void;
  setSpeed(speed: number): void;
  setSeed(seed: number): void;
  setTime(time: number): void;
  reset(): void;
}
```

### DiagnosticsStore (Transient State)

**Owns**: Errors, warnings, logs
**Independent**: No dependency on PatchStore

```typescript
interface DiagnosticsStore {
  // State
  readonly errors: readonly Diagnostic[];
  readonly warnings: readonly Diagnostic[];
  readonly logs: readonly LogEntry[];

  // Derived
  readonly hasErrors: boolean;
  readonly errorCount: number;
  readonly warningCount: number;

  // Actions
  addError(error: Diagnostic): void;
  addWarning(warning: Diagnostic): void;
  log(entry: LogEntry): void;
  clearDiagnostics(): void;
  clearLogs(): void;
}

interface Diagnostic {
  id: string;
  message: string;
  source?: string;
  blockId?: BlockId;
  timestamp: number;
}

interface LogEntry {
  id: string;
  level: 'info' | 'warn' | 'error' | 'debug';
  message: string;
  timestamp: number;
  data?: unknown;
}
```

## File Structure

```
src/stores/
├── index.ts              # Public exports only
├── internal.ts           # Internal types (not exported)
├── configure.ts          # MobX strict mode setup
├── RootStore.ts          # Coordinates all stores
├── PatchStore.ts         # THE source of truth
├── SelectionStore.ts     # Selection UI state
├── ViewportStore.ts      # Pan/zoom state
├── PlaybackStore.ts      # Time/playback state
├── DiagnosticsStore.ts   # Errors/warnings/logs
├── context.tsx           # React context provider
└── __tests__/
    ├── PatchStore.test.ts
    ├── SelectionStore.test.ts
    └── integration.test.ts
```

## Implementation Order

1. **configure.ts** - MobX strict mode (2 min)
2. **internal.ts** - Internal types (5 min)
3. **PatchStore.ts** - Core store with tests (30 min)
4. **SelectionStore.ts** - Selection with derivation (15 min)
5. **ViewportStore.ts** - Simple independent store (10 min)
6. **PlaybackStore.ts** - Simple independent store (10 min)
7. **DiagnosticsStore.ts** - Logging store (15 min)
8. **RootStore.ts** - Composition (10 min)
9. **context.tsx** - React integration (10 min)
10. **index.ts** - Public API (5 min)

## Anti-Patterns to Prevent

### ❌ Duplicating Block Data
```typescript
// WRONG - BusStore copying blocks
class BusStore {
  buses: Block[] = [];  // NO! Duplicates PatchStore data
}
```

### ❌ Storing Derived State
```typescript
// WRONG - Storing what can be computed
class SelectionStore {
  selectedBlock: Block | null = null;  // NO! Store ID, compute block
}
```

### ❌ Cross-Store Mutations
```typescript
// WRONG - SelectionStore mutating PatchStore internals
class SelectionStore {
  deleteSelected() {
    this.patchStore._patch.blocks.delete(this.selectedBlockId);  // NO!
  }
}

// RIGHT - Call action
class SelectionStore {
  deleteSelected() {
    if (this.selectedBlockId) {
      this.patchStore.removeBlock(this.selectedBlockId);
    }
  }
}
```

### ❌ Importing mobx in Components
```typescript
// WRONG - Component imports mobx directly
import { observable } from 'mobx';  // NO! Only stores/ may import mobx

// RIGHT - Component uses observer from mobx-react-lite
import { observer } from 'mobx-react-lite';
import { useStores } from '../stores';
```

## Success Criteria

1. [ ] MobX configured in strict mode (enforceActions: 'always')
2. [ ] PatchStore is the ONLY store that holds blocks/edges
3. [ ] SelectionStore stores IDs only, derives blocks via computed
4. [ ] All mutations go through @action methods
5. [ ] Components cannot import from 'mobx' (only 'mobx-react-lite')
6. [ ] RootStore provides single context for all stores
7. [ ] Tests verify store invariants (no data duplication)
8. [ ] TypeScript prevents creating Patch outside PatchStore
