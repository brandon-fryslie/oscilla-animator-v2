# Implementation Context: Domain Unification

**For:** Write-only implementation agents
**Sprint:** 2026-01-09
**Topic:** Compilation Pipeline - Domain Unification

---

## Summary

Implement domain compatibility checking for field expressions. Fields from different domains should not be zipped together or passed to render sinks without explicit domain alignment.

---

## File Changes Required

### File 1: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/types.ts`

**Goal:** Add optional `domain` field to composite FieldExpr types.

**Location:** Around line 151-179 (FieldExprMap, FieldExprZip, FieldExprZipSig)

**Find FieldExprMap (around line 151):**
```typescript
export interface FieldExprMap {
  readonly kind: 'map';
  readonly input: FieldExprId;
  readonly fn: PureFn;
  readonly type: SignalType;
}
```

**Change to:**
```typescript
export interface FieldExprMap {
  readonly kind: 'map';
  readonly input: FieldExprId;
  readonly fn: PureFn;
  readonly type: SignalType;
  readonly domain?: DomainId;  // Propagated from input
}
```

**Find FieldExprZip (around line 158):**
```typescript
export interface FieldExprZip {
  readonly kind: 'zip';
  readonly inputs: readonly FieldExprId[];
  readonly fn: PureFn;
  readonly type: SignalType;
}
```

**Change to:**
```typescript
export interface FieldExprZip {
  readonly kind: 'zip';
  readonly inputs: readonly FieldExprId[];
  readonly fn: PureFn;
  readonly type: SignalType;
  readonly domain?: DomainId;  // Unified from inputs
}
```

**Find FieldExprZipSig (around line 165):**
```typescript
export interface FieldExprZipSig {
  readonly kind: 'zipSig';
  readonly field: FieldExprId;
  readonly signals: readonly SigExprId[];
  readonly fn: PureFn;
  readonly type: SignalType;
}
```

**Change to:**
```typescript
export interface FieldExprZipSig {
  readonly kind: 'zipSig';
  readonly field: FieldExprId;
  readonly signals: readonly SigExprId[];
  readonly fn: PureFn;
  readonly type: SignalType;
  readonly domain?: DomainId;  // From field input
}
```

---

### File 2: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/builder.ts`

**Goal:** Add domain inference and validation during field expression construction.

**Add these new methods after line 208 (after fieldMapIndexed):**

```typescript
// ===========================================================================
// Domain Inference
// ===========================================================================

/** Infer domain from a field expression (public for render sink validation) */
inferFieldDomain(fieldId: FieldExprId): DomainId | undefined {
  const expr = this.fields.get(fieldId);
  if (!expr) return undefined;

  switch (expr.kind) {
    case 'source':
      return expr.domain;
    case 'mapIndexed':
      return expr.domain;
    case 'map':
      return expr.domain ?? this.inferFieldDomain(expr.input);
    case 'zip':
      return expr.domain ?? this.inferZipDomain(expr.inputs);
    case 'zipSig':
      return expr.domain ?? this.inferFieldDomain(expr.field);
    case 'broadcast':
    case 'const':
      return undefined; // No inherent domain
  }
}

/** Infer domain from zip inputs, error if they differ */
private inferZipDomain(inputs: readonly FieldExprId[]): DomainId | undefined {
  const domains: DomainId[] = [];
  for (const id of inputs) {
    const d = this.inferFieldDomain(id);
    if (d !== undefined) {
      domains.push(d);
    }
  }

  if (domains.length === 0) return undefined;

  const first = domains[0];
  for (let i = 1; i < domains.length; i++) {
    if (domains[i] !== first) {
      throw new Error(
        `Domain mismatch in fieldZip: '${first}' vs '${domains[i]}'. ` +
        `All field inputs must share the same domain.`
      );
    }
  }
  return first;
}
```

**Update fieldMap method (around line 172):**

Find:
```typescript
fieldMap(input: FieldExprId, fn: PureFn, type: SignalType): FieldExprId {
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'map', input, fn, type });
  return id;
}
```

Change to:
```typescript
fieldMap(input: FieldExprId, fn: PureFn, type: SignalType): FieldExprId {
  const domain = this.inferFieldDomain(input);
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'map', input, fn, type, domain });
  return id;
}
```

**Update fieldZip method (around line 178):**

Find:
```typescript
fieldZip(
  inputs: readonly FieldExprId[],
  fn: PureFn,
  type: SignalType
): FieldExprId {
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'zip', inputs, fn, type });
  return id;
}
```

Change to:
```typescript
fieldZip(
  inputs: readonly FieldExprId[],
  fn: PureFn,
  type: SignalType
): FieldExprId {
  const domain = this.inferZipDomain(inputs);  // Validates + infers
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'zip', inputs, fn, type, domain });
  return id;
}
```

**Update fieldZipSig method (around line 188):**

Find:
```typescript
fieldZipSig(
  field: FieldExprId,
  signals: readonly SigExprId[],
  fn: PureFn,
  type: SignalType
): FieldExprId {
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'zipSig', field, signals, fn, type });
  return id;
}
```

Change to:
```typescript
fieldZipSig(
  field: FieldExprId,
  signals: readonly SigExprId[],
  fn: PureFn,
  type: SignalType
): FieldExprId {
  const domain = this.inferFieldDomain(field);
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'zipSig', field, signals, fn, type, domain });
  return id;
}
```

---

### File 3: `/Users/bmf/code/oscilla-animator-v2/src/compiler/blocks/render/RenderInstances2D.ts`

**Goal:** Validate field inputs have domains matching the sink's domain.

**Add validation at the start of the lower function (after extracting inputs):**

```typescript
// Domain validation
const domain = inputsById.domain;
const pos = inputsById.pos;
const color = inputsById.color;

if (domain && domain.kind === 'domain') {
  // Validate pos field domain
  if (pos && pos.kind === 'field') {
    const posDomain = b.inferFieldDomain(pos.id);
    if (posDomain !== undefined && posDomain !== domain.id) {
      throw new Error(
        `RenderInstances2D: pos field domain '${posDomain}' does not match ` +
        `sink domain '${domain.id}'`
      );
    }
  }

  // Validate color field domain
  if (color && color.kind === 'field') {
    const colorDomain = b.inferFieldDomain(color.id);
    if (colorDomain !== undefined && colorDomain !== domain.id) {
      throw new Error(
        `RenderInstances2D: color field domain '${colorDomain}' does not match ` +
        `sink domain '${domain.id}'`
      );
    }
  }
}
```

---

### File 4: `/Users/bmf/code/oscilla-animator-v2/src/compiler/__tests__/domain-unification.test.ts` (NEW FILE)

**Create this new test file:**

```typescript
import { describe, it, expect } from 'vitest';
import { IRBuilder } from '../ir/builder';
import { signalTypeField } from '../../core/canonical-types';

describe('Domain Unification', () => {
  describe('domain inference', () => {
    it('infers domain from FieldExprSource', () => {
      const b = new IRBuilder();
      const domain = b.domainN(10);
      const type = signalTypeField('number');
      const field = b.fieldSource(domain, 'index', type);

      expect(b.inferFieldDomain(field)).toBe(domain);
    });

    it('propagates domain through FieldExprMap', () => {
      const b = new IRBuilder();
      const domain = b.domainN(10);
      const type = signalTypeField('number');
      const source = b.fieldSource(domain, 'index', type);
      const mapped = b.fieldMap(source, { kind: 'opcode', opcode: 'sin' }, type);

      expect(b.inferFieldDomain(mapped)).toBe(domain);
    });

    it('returns undefined for broadcast fields', () => {
      const b = new IRBuilder();
      const type = signalTypeField('number');
      const sig = b.sigConst(1.0, type);
      const broadcast = b.fieldBroadcast(sig, type);

      expect(b.inferFieldDomain(broadcast)).toBeUndefined();
    });
  });

  describe('fieldZip domain validation', () => {
    it('accepts fields from the same domain', () => {
      const b = new IRBuilder();
      const domain = b.domainN(10);
      const type = signalTypeField('number');
      const field1 = b.fieldSource(domain, 'index', type);
      const field2 = b.fieldSource(domain, 'normalizedIndex', type);

      // Should not throw
      const zipped = b.fieldZip([field1, field2], { kind: 'opcode', opcode: 'add' }, type);
      expect(b.inferFieldDomain(zipped)).toBe(domain);
    });

    it('rejects fields from different domains', () => {
      const b = new IRBuilder();
      const domain1 = b.domainN(10);
      const domain2 = b.domainN(20);
      const type = signalTypeField('number');
      const field1 = b.fieldSource(domain1, 'index', type);
      const field2 = b.fieldSource(domain2, 'index', type);

      expect(() => {
        b.fieldZip([field1, field2], { kind: 'opcode', opcode: 'add' }, type);
      }).toThrow(/Domain mismatch/);
    });

    it('handles broadcast fields (no domain) gracefully', () => {
      const b = new IRBuilder();
      const domain = b.domainN(10);
      const type = signalTypeField('number');
      const source = b.fieldSource(domain, 'index', type);
      const sig = b.sigConst(1.0, type);
      const broadcast = b.fieldBroadcast(sig, type);

      // Broadcast has no domain, so zip should use source's domain
      const zipped = b.fieldZip([source, broadcast], { kind: 'opcode', opcode: 'add' }, type);
      expect(b.inferFieldDomain(zipped)).toBe(domain);
    });
  });
});
```

---

## Verification Commands

```bash
# 1. Type checking
npm run typecheck
# Expected: 0 errors

# 2. Run tests
npm run test
# Expected: All tests pass including new domain-unification.test.ts

# 3. Manual verification
npm run dev
# Expected: Animation renders correctly
```

---

## Key Points

1. **Domain field is optional** - Backward compatible with existing IR
2. **inferFieldDomain is public** - Needed by render sink validation
3. **Validation happens in fieldZip** - Throws immediately on mismatch
4. **Broadcast has no domain** - Returns undefined, compatible with any domain
5. **Render sinks validate alignment** - Fields must match sink's domain

---

## Do NOT Change

- Do not modify TypeChecker.ts in this sprint (DomainRef may not carry ID)
- Do not change existing test files
- Do not modify ScheduleIR or schedule handling
- Do not add new block types
