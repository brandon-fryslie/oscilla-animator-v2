# Sprint Plan: Domain Unification

**Created:** 2026-01-09
**Topic:** Compilation Pipeline - Domain Unification
**Scope:** Implement domain compatibility checking for field expressions

---

## Context

### Current State
- Domains created correctly via `domainGrid()` and `domainN()` in IRBuilder
- `FieldExprSource` and `FieldExprMapIndexed` carry explicit `DomainId`
- Composite operations (`zip`, `map`, `broadcast`) **lose domain information**
- TypeChecker accepts `DomainRef â†’ DomainRef` without checking ID equality
- No validation that field inputs to render sinks share the same domain

### The Problem
Fields from different domains can be zipped together or passed to render sinks without error:

```typescript
// This compiles but is semantically invalid:
field1 = fieldSource(grid_4x4, 'pos0')   // 16 lanes
field2 = fieldSource(domainN_10, 'index') // 10 lanes
result = fieldZip([field1, field2], fn)   // Mixing 16 + 10 lanes!
```

### Spec Requirements
From `design-docs/compiler-changes.md`:
> `many(domain A)` and `many(domain B)` mismatch unless A==B

---

## Sprint Goal

Catch domain mismatches at compile time by validating that field operations unify to a single domain.

---

## Scope

**In scope (this sprint):**
1. Add domain field to composite FieldExpr types
2. Implement domain inference in IRBuilder
3. Add domain mismatch validation in TypeChecker
4. Add domain validation to render sink blocks

**Explicitly out of scope:**
- Broadcast domain assignment (requires context propagation)
- Domain-based optimization (dead domain detection)
- Multi-pass architecture changes
- ScheduleIR typing

---

## Deliverables

### P0: Add Domain Field to FieldExpr Types

**Goal:** Track domain through composite field operations.

**File:** `src/compiler/ir/types.ts`

**Changes:**

1. Add optional `domain?: DomainId` to `FieldExprZip` (line ~160):
```typescript
export interface FieldExprZip {
  readonly kind: 'zip';
  readonly inputs: readonly FieldExprId[];
  readonly fn: PureFn;
  readonly type: SignalType;
  readonly domain?: DomainId;  // NEW: Inferred from inputs
}
```

2. Add optional `domain?: DomainId` to `FieldExprMap` (line ~152):
```typescript
export interface FieldExprMap {
  readonly kind: 'map';
  readonly input: FieldExprId;
  readonly fn: PureFn;
  readonly type: SignalType;
  readonly domain?: DomainId;  // NEW: Propagated from input
}
```

3. Add optional `domain?: DomainId` to `FieldExprZipSig` (line ~166):
```typescript
export interface FieldExprZipSig {
  readonly kind: 'zipSig';
  readonly field: FieldExprId;
  readonly signals: readonly SigExprId[];
  readonly fn: PureFn;
  readonly type: SignalType;
  readonly domain?: DomainId;  // NEW: From field input
}
```

**Acceptance Criteria:**
- [ ] FieldExprZip, FieldExprMap, FieldExprZipSig have optional domain field
- [ ] Types compile without errors
- [ ] Existing tests pass

---

### P1: Implement Domain Inference in IRBuilder

**Goal:** Infer and validate domains during field expression construction.

**File:** `src/compiler/ir/builder.ts`

**Add helper method:**
```typescript
/** Infer domain from a field expression */
private inferFieldDomain(fieldId: FieldExprId): DomainId | undefined {
  const expr = this.fields.get(fieldId);
  if (!expr) return undefined;

  switch (expr.kind) {
    case 'source':
      return expr.domain;
    case 'mapIndexed':
      return expr.domain;
    case 'map':
      return expr.domain ?? this.inferFieldDomain(expr.input);
    case 'zip':
      return expr.domain ?? this.inferZipDomain(expr.inputs);
    case 'zipSig':
      return expr.domain ?? this.inferFieldDomain(expr.field);
    case 'broadcast':
    case 'const':
      return undefined; // No inherent domain
  }
}

/** Infer domain from zip inputs, error if they differ */
private inferZipDomain(inputs: readonly FieldExprId[]): DomainId | undefined {
  const domains = inputs.map(id => this.inferFieldDomain(id)).filter(Boolean);
  if (domains.length === 0) return undefined;

  const first = domains[0];
  for (const d of domains) {
    if (d !== first) {
      throw new Error(
        `Domain mismatch in fieldZip: ${first} vs ${d}. ` +
        `All field inputs must share the same domain.`
      );
    }
  }
  return first;
}
```

**Update field methods to infer/store domain:**

```typescript
fieldMap(input: FieldExprId, fn: PureFn, type: SignalType): FieldExprId {
  const domain = this.inferFieldDomain(input);  // NEW
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'map', input, fn, type, domain });  // NEW: store domain
  return id;
}

fieldZip(inputs: readonly FieldExprId[], fn: PureFn, type: SignalType): FieldExprId {
  const domain = this.inferZipDomain(inputs);  // NEW: validates + infers
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'zip', inputs, fn, type, domain });  // NEW
  return id;
}

fieldZipSig(field: FieldExprId, signals: readonly SigExprId[], fn: PureFn, type: SignalType): FieldExprId {
  const domain = this.inferFieldDomain(field);  // NEW
  const id = makeFieldExprId(this.nextFieldId++);
  this.fields.set(id, { kind: 'zipSig', field, signals, fn, type, domain });  // NEW
  return id;
}
```

**Acceptance Criteria:**
- [ ] `inferFieldDomain()` recursively resolves domain from field expression tree
- [ ] `inferZipDomain()` validates all inputs share the same domain
- [ ] `fieldZip()` throws on domain mismatch
- [ ] Domain propagates through map/zipSig operations
- [ ] Existing tests pass

---

### P2: Add Domain Validation to TypeChecker

**Goal:** Validate domain ID equality when checking field-to-field connections.

**File:** `src/compiler/passes/TypeChecker.ts`

**Add domain mismatch error type:**
```typescript
interface DomainMismatchError extends CompileError {
  readonly kind: 'DomainMismatch';
  readonly domainA: string;
  readonly domainB: string;
}
```

**Enhance `getCanonicalConversion()` to check domain IDs:**
```typescript
function getCanonicalConversion(source: PortType, target: PortType): Conversion | null {
  // Existing DomainRef handling...
  if (isDomainRef(source) || isDomainRef(target)) {
    if (isDomainRef(source) && isDomainRef(target)) {
      // NEW: Check domain IDs match
      if (source.domain !== target.domain) {
        return null; // Domain mismatch - not compatible
      }
      return { kind: 'direct' };
    }
    return null;
  }

  // ... rest of function
}
```

**Note:** If DomainRef doesn't currently carry an ID, this step may need to wait until the type system tracks domain identity.

**Acceptance Criteria:**
- [ ] Domain mismatch produces compile error
- [ ] Error message includes both domain IDs
- [ ] Existing valid connections still work

---

### P3: Add Domain Validation to Render Sinks

**Goal:** Validate that field inputs to RenderInstances2D share the sink's domain.

**File:** `src/compiler/blocks/render/RenderInstances2D.ts`

**Add validation in lower function:**
```typescript
const lowerRenderInstances2D: BlockLower = ({ b, config, inputsById }) => {
  const domain = inputsById.domain as ValueRef & { kind: 'domain' };
  const pos = inputsById.pos as ValueRef & { kind: 'field' };
  const color = inputsById.color as ValueRef & { kind: 'field' };

  // NEW: Validate field domain alignment
  if (domain && pos) {
    const posDomain = b.inferFieldDomain(pos.id);
    if (posDomain && posDomain !== domain.id) {
      throw new Error(
        `RenderInstances2D: pos field domain '${posDomain}' does not match ` +
        `required domain '${domain.id}'`
      );
    }
  }

  if (domain && color) {
    const colorDomain = b.inferFieldDomain(color.id);
    if (colorDomain && colorDomain !== domain.id) {
      throw new Error(
        `RenderInstances2D: color field domain '${colorDomain}' does not match ` +
        `required domain '${domain.id}'`
      );
    }
  }

  // ... rest of lowering
};
```

**Note:** This requires `inferFieldDomain` to be accessible from block lowering context.

**Acceptance Criteria:**
- [ ] RenderInstances2D validates pos field domain matches sink domain
- [ ] RenderInstances2D validates color field domain matches sink domain
- [ ] Misaligned fields produce clear error message
- [ ] Existing valid renders still work

---

## Implementation Sequence

1. **Phase 1: IR Types** (10 min)
   - Add optional `domain` field to FieldExprZip, FieldExprMap, FieldExprZipSig
   - Run typecheck to verify

2. **Phase 2: IRBuilder Inference** (30 min)
   - Add `inferFieldDomain()` helper
   - Add `inferZipDomain()` with validation
   - Update fieldMap, fieldZip, fieldZipSig to store domain
   - Add unit tests for domain inference

3. **Phase 3: TypeChecker Enhancement** (20 min)
   - Add domain ID equality check to DomainRef handling
   - Add DomainMismatch error type
   - Add test cases for domain mismatch errors

4. **Phase 4: Render Sink Validation** (15 min)
   - Add domain validation to RenderInstances2D
   - Add test case for misaligned render inputs

5. **Phase 5: Verification** (10 min)
   - Run full test suite
   - Manual smoke test with npm run dev
   - Verify error messages are clear

---

## Test Coverage

**New test file:** `src/compiler/__tests__/domain-unification.test.ts`

```typescript
describe('Domain Unification', () => {
  describe('fieldZip domain validation', () => {
    it('accepts fields from the same domain');
    it('rejects fields from different domains');
    it('handles broadcast fields (no domain) gracefully');
  });

  describe('domain inference', () => {
    it('infers domain from source');
    it('propagates domain through map');
    it('propagates domain through zipSig');
    it('returns undefined for broadcast');
  });

  describe('render sink validation', () => {
    it('accepts aligned field domains');
    it('rejects misaligned pos field');
    it('rejects misaligned color field');
  });
});
```

---

## Risk Assessment

**Low Risk:**
- Optional domain field is backward compatible
- Domain inference is additive (doesn't change existing behavior)
- Tests provide regression safety

**Medium Risk:**
- TypeChecker enhancement may need DomainRef to carry ID (check if it does)
- Render validation requires inferFieldDomain to be accessible from blocks

**Mitigation:**
- Make inferFieldDomain a public method on IRBuilder
- If DomainRef lacks ID, defer TypeChecker enhancement to P2

---

## Dependencies

- Requires IRBuilder method to be accessible from block lowering
- May require DomainRef type enhancement if it doesn't carry ID

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/compiler/ir/types.ts` | Add domain field to FieldExprZip/Map/ZipSig |
| `src/compiler/ir/builder.ts` | Add inferFieldDomain, update field methods |
| `src/compiler/passes/TypeChecker.ts` | Add domain ID check (if DomainRef has ID) |
| `src/compiler/blocks/render/RenderInstances2D.ts` | Add domain validation |
| `src/compiler/__tests__/domain-unification.test.ts` | New test file |
