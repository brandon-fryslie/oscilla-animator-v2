# Evaluation: Unit-Safe Type System for Numeric Signals

**Generated**: 2026-01-20T05:15:00
**Verdict**: CONTINUE
**Topic**: Preventing phase/radians/time misuse systematically

## Context

A bug was discovered where `sin`/`cos` kernels in `SignalEvaluator.ts` expected radians but received phase (0-1), causing animations to run at ~16% of expected speed. The fix was applied, but the root cause is systemic: **the type system doesn't distinguish between different numeric units**.

## Current State

### 1. Type System (CanonicalType)

**Location**: `src/core/canonical-types.ts`

Current structure:
```typescript
type PayloadType = 'float' | 'int' | 'vec2' | 'color' | 'phase' | 'bool' | 'unit' | '???';

interface CanonicalType {
  payload: PayloadType;
  extent?: Extent;  // 5-axis coordinate
}
```

**Gap**: `phase` exists as a PayloadType but:
- Blocks don't use it consistently (most use `'float'` for phase values)
- No compiler validation prevents mixing phase with float
- No unit annotation (radians, degrees, normalized, ms, etc.)

### 2. Kernel Definitions - Inconsistent Expectations

| Location | sin/cos Behavior | Expected Input |
|----------|------------------|----------------|
| `SignalEvaluator.ts` (signal kernels) | `Math.sin(x * 2 * Math.PI)` | Phase (0-1) |
| `OpcodeInterpreter.ts` (opcodes) | `Math.sin(x)` | Radians |
| `Materializer.ts` (field kernels) | Both patterns exist | Varies by kernel |

**Problem**: No machine-readable declaration of what kernels expect.

### 3. Block Definitions - Wrong Types Used

**TimeRoot** (`src/blocks/time-blocks.ts:23-26`):
```typescript
outputs: [
  { id: 'tMs', label: 'Time (ms)', type: canonicalType('float') },
  { id: 'phaseA', label: 'Phase A', type: canonicalType('float') },  // Should be 'phase'!
  { id: 'phaseB', label: 'Phase B', type: canonicalType('float') },  // Should be 'phase'!
],
```

**Oscillator** (`src/blocks/signal-blocks.ts:156`):
```typescript
inputs: [
  { id: 'phase', label: 'Phase', type: canonicalType('float') },  // Should be 'phase'!
],
```

### 4. Spec vs Implementation Gap

**Spec** (`design-docs/CANONICAL-oscilla-v2.5-20260109/topics/03-time-system.md`):
- Line 63: `phaseA` defined with type: `phase` (correct in spec)
- Lines 195-200: Phase arithmetic rules documented (phase + float = phase, etc.)

**Implementation**: Rules not enforced anywhere.

### 5. What's Needed

1. **Use `phase` PayloadType Consistently** - Fix TimeRoot, Oscillator, field blocks
2. **Add Unit Annotation** - Extend CanonicalType with optional `unit` field
3. **Kernel Signatures** - Declare expected input/output units
4. **Compile-Time Validation** - Validate phase/float/radians compatibility
5. **Auto-Conversion Operators** - `phaseToRadians`, `radiansToPhase` kernels

## Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Breaking changes to CanonicalType | Medium | Additive change (optional `unit` field) |
| Existing patches use wrong types | Low | Hot-swap survives, just add warnings |
| Performance overhead | None | Type checking is compile-time only |

## Dependencies

- None - type system is foundational

## Ambiguities

None - approach is clear. Standard solution is to add unit annotations.

## Recommendation

Proceed with implementation in 2 sprints:
1. **HIGH confidence**: Fix immediate type inconsistencies (use `phase` where appropriate)
2. **MEDIUM confidence**: Add unit annotation system with validation
