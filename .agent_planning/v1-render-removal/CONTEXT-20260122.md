# Implementation Context: Remove v1 RenderPassIR Code Path

**Bead**: oscilla-animator-v2-ry2
**Created**: 2026-01-22

## Architectural Background

### The RenderIR Migration Story

Oscilla v2 is migrating from an **intermediate v1 RenderIR** to a **final v2 RenderIR** that enables:
1. Local-space geometry (control points centered at origin)
2. World-space instance transforms (position/size/rotation/scale2)
3. Explicit style separation
4. Multiple backend support (Canvas, SVG, WebGL)

This cleanup removes the v1 code path once v2 is fully operational.

### Why Two Phases Existed

**Phase 1 (v1 - Current):**
- RenderAssembler produces `RenderPassIR` with `ResolvedShape`
- Control points scaled by viewport dimensions in renderer
- Shape interpretation happens in renderer
- Single `renderInstances2D()` dispatch function

**Phase 2 (v2 - Target):**
- RenderAssembler produces `DrawPathInstancesOp` with separated concerns
- Control points in local space (not scaled)
- Instance transforms applied in renderer
- Geometry reusable across backends (SVG `<defs>/<use>`)

**This cleanup removes Phase 1 code after Phase 2 is proven.**

## Key Files and Responsibilities

### src/runtime/RenderAssembler.ts

**Current state (dual path):**
```
Lines 52-104:   assembleRenderPass() → RenderPassIR (v1)
Lines 279-293:  assembleAllPasses() → RenderPassIR[] (v1)
Lines 403-491:  assembleDrawPathInstancesOp() → DrawPathInstancesOp (v2)
Lines 503-520:  assembleRenderFrame_v2() → RenderFrameIR_Future (v2)
```

**After cleanup (v2 only):**
- Delete all v1 functions
- Keep all v2 functions
- Retain helper functions and type guards

**Rationale:** RenderAssembler is the "interpretation boundary" where IR slot references become concrete geometry. V2 makes this boundary explicit with separated structures.

### src/runtime/ScheduleExecutor.ts

**Current state:**
```typescript
// Lines 34-124: V1 type definitions
export interface RenderFrameIR { version: 1; passes: RenderPassIR[]; }
export interface RenderPassIR { ... }
export interface ShapeDescriptor { ... }
export interface ResolvedShape { ... }

// Line 239: V1 assembly call
const pass = assembleRenderPass(step, assemblerContext);
```

**After cleanup:**
```typescript
// Import v2 types from future-types.ts
import type { RenderFrameIR_Future, DrawPathInstancesOp } from '../render/future-types';

// Use v2 assembly
const frame = assembleRenderFrame_v2(renderSteps, assemblerContext);
```

**Rationale:** ScheduleExecutor orchestrates frame execution. Once v2 is operational, v1 types and calls are dead weight.

### src/render/Canvas2DRenderer.ts

**Current state (v1 dispatch):**
```typescript
Lines 96-143: renderInstances2D(pass: RenderPassIR) {
  const shapeMode = convertResolvedShapeToMode(pass.resolvedShape);
  // ... dispatch to topology or path rendering
}

Lines 180-259: renderPathAtParticle() {
  // PROBLEM: Multiplies local points by width/height
  const px = controlPoints[pointIndex * 2] * width;
  const py = controlPoints[pointIndex * 2 + 1] * height;
}
```

**After cleanup (v2 dispatch):**
```typescript
renderFrame(frame: RenderFrameIR_Future) {
  for (const op of frame.ops) {
    renderDrawPathInstancesOp(op, width, height);
  }
}

renderDrawPathInstancesOp(op: DrawPathInstancesOp) {
  // Apply instance transforms
  ctx.translate(xPx, yPx);
  ctx.rotate(rotation);
  ctx.scale(sizePx, sizePx);

  // Draw with local-space points (NO width/height scaling)
  drawPath(ctx, verbs, points);
}
```

**Rationale:** Renderer becomes a pure sink that applies transforms and rasterizes. No shape interpretation, no coordinate scaling. This enables geometry reuse for SVG backend.

## Coordinate Space Model

### V1 Model (to be removed)

**Control points:** Normalized [0,1] world space
**Rendering:** Multiply by width/height to get pixels
**Problem:** Geometry tied to viewport dimensions, can't reuse across instances

```typescript
// V1 rendering (wrong)
const px = controlPoints[i*2] * width;   // World → viewport
const py = controlPoints[i*2+1] * height;
ctx.lineTo(px, py);
```

### V2 Model (keep)

**Control points:** Local space, centered at (0,0), magnitude O(1)
**Instance transforms:** World space [0,1] → viewport pixels
**Rendering:** Apply transforms, then draw local points

```typescript
// V2 rendering (correct)
ctx.translate(xNorm * width, yNorm * height); // World → viewport
ctx.rotate(rotation);                         // Instance rotation
ctx.scale(sizeVal * scaleRef, sizeVal * scaleRef); // Instance size

// Draw with LOCAL points (no scaling)
ctx.moveTo(points[i*2], points[i*2+1]);
```

**Benefits:**
- Geometry independent of viewport
- Size/rotation modulators work uniformly
- SVG can use `<defs>/<use>` for geometry reuse
- Multiple backends share same geometry

## Data Flow

### V1 Flow (to be removed)

```
StepRender (IR)
  ↓ assembleRenderPass()
RenderPassIR { resolvedShape, position, color, scale }
  ↓ renderInstances2D()
  ↓ convertResolvedShapeToMode()
  ↓ renderPathAtParticle()
Canvas (px = points * width/height)
```

### V2 Flow (keep)

```
StepRender (IR)
  ↓ assembleDrawPathInstancesOp()
DrawPathInstancesOp {
  geometry: { points (local), verbs },
  instances: { position, size, rotation },
  style: { fillColor }
}
  ↓ renderDrawPathInstancesOp()
  ↓ Apply instance transforms
  ↓ drawPath(local points)
Canvas (transforms handle world → viewport)
```

## Type Hierarchy

### V1 Types (delete)

```typescript
// Top-level frame
interface RenderFrameIR {
  version: 1;
  passes: RenderPassIR[];
}

// Per-pass data
interface RenderPassIR {
  kind: 'instances2d';
  count: number;
  position: ArrayBufferView;
  color: ArrayBufferView;
  scale: number;
  shape: ShapeDescriptor | ArrayBufferView | number; // @deprecated
  resolvedShape: ResolvedShape; // REQUIRED
}

// Shape resolution
interface ShapeDescriptor {
  topologyId: TopologyId;
  params: Record<string, number>;
}

interface ResolvedShape {
  resolved: true;
  topologyId: TopologyId;
  mode: 'path' | 'primitive';
  params: Record<string, number>;
  verbs?: Uint8Array;
  controlPoints?: ArrayBufferView;
}
```

### V2 Types (keep - from future-types.ts)

```typescript
// Top-level frame
interface RenderFrameIR_Future {
  version: 2;
  ops: readonly DrawOp[];
}

type DrawOp = DrawPathInstancesOp;

// Draw operation
interface DrawPathInstancesOp {
  kind: 'drawPathInstances';
  geometry: PathGeometry;
  instances: InstanceTransforms;
  style: PathStyle;
}

// Geometry (local space)
interface PathGeometry {
  topologyId: number; // Note: number, not string
  verbs: Uint8Array;
  points: Float32Array; // LOCAL SPACE
  pointsCount: number;
  flags?: number;
}

// Instances (world space)
interface InstanceTransforms {
  count: number;
  position: Float32Array; // [0,1] normalized
  size: number | Float32Array; // World units
  rotation?: Float32Array; // Radians
  scale2?: Float32Array; // Anisotropic (optional)
}

// Style (explicit)
interface PathStyle {
  fillColor: Uint8ClampedArray;
  fillRule?: 'nonzero' | 'evenodd';
  // Future: stroke, opacity, blend
}
```

## Dependencies

### Blocking Dependencies (MUST complete first)

**1. oscilla-animator-v2-583: RenderAssembler v2**
- **Status**: in_progress
- **Files**: `src/runtime/RenderAssembler.ts`
- **Delivers**: Working `assembleRenderFrame_v2()` function
- **Why blocking**: Can't delete v1 if v2 doesn't work

**2. oscilla-animator-v2-46m: Renderer local-space migration**
- **Status**: open
- **Files**: `src/render/Canvas2DRenderer.ts`
- **Delivers**: Renderer using instance transforms
- **Why blocking**: V2 assembly requires v2 renderer

### Dependent Work (can happen after)

**3. oscilla-animator-v2-0uk: SVG renderer**
- **Status**: open
- **Depends on**: This cleanup
- **Benefits from**: Clean v2-only codebase

**4. oscilla-animator-v2-4h6: Topology ID migration (string → number)**
- **Status**: open
- **Note**: Type mismatch documented but not blocking

## Implementation Notes

### Safe Deletion Order

1. **First**: Remove v1 assembly functions from RenderAssembler.ts
   - Risk: Low (v2 functions are separate)
   - Verify: Check no imports of deleted functions

2. **Second**: Remove v1 types from ScheduleExecutor.ts
   - Risk: Medium (many imports)
   - Verify: Update all type imports

3. **Third**: Update renderer dispatch in Canvas2DRenderer.ts
   - Risk: Low (after local-space migration)
   - Verify: Visual regression test

4. **Fourth**: Update type exports in index.ts files
   - Risk: Low (downstream consumers)
   - Verify: TypeScript compilation

5. **Fifth**: Update tests
   - Risk: Low (isolated)
   - Verify: `npm test` passes

### Verification Commands

```bash
# Check for v1 references (should return 0 after cleanup)
rg "assembleRenderPass\(" --type ts src/
rg "assembleAllPasses\(" --type ts src/
rg "RenderPassIR" --type ts src/ | grep -v future-types
rg "ShapeDescriptor" --type ts src/ | grep -v future-types
rg "ResolvedShape" --type ts src/

# Verify v2 usage (should find references)
rg "assembleRenderFrame_v2" --type ts src/
rg "DrawPathInstancesOp" --type ts src/
rg "RenderFrameIR_Future" --type ts src/

# Type checking
npm run typecheck

# Tests
npm test

# Visual verification
npm run dev
# Load test patches, check rendering
```

### Common Pitfalls

**1. Forgetting to update type exports**
- Problem: Downstream imports break
- Fix: Update `src/runtime/index.ts` and `src/render/index.ts`

**2. Missing import updates**
- Problem: TypeScript errors for missing types
- Fix: Search for all imports of deleted types

**3. Test expectations still use v1 types**
- Problem: Tests fail with type errors
- Fix: Update test files to expect v2 structures

**4. Renderer still tries to dispatch v1**
- Problem: Runtime errors for undefined functions
- Fix: Update `renderFrame()` to use v2 dispatch

## Testing Strategy

### Unit Tests

**RenderAssembler.test.ts:**
```typescript
// OLD (delete)
describe('assembleRenderPass', () => {
  it('returns RenderPassIR', () => {
    const pass = assembleRenderPass(step, context);
    expect(pass.kind).toBe('instances2d');
  });
});

// NEW (keep)
describe('assembleDrawPathInstancesOp', () => {
  it('returns DrawPathInstancesOp', () => {
    const op = assembleDrawPathInstancesOp(step, context);
    expect(op.kind).toBe('drawPathInstances');
  });
});

describe('assembleRenderFrame_v2', () => {
  it('returns RenderFrameIR_Future', () => {
    const frame = assembleRenderFrame_v2(steps, context);
    expect(frame.version).toBe(2);
    expect(frame.ops).toHaveLength(1);
  });
});
```

### Integration Tests

**Visual regression:**
1. Load test patch with polygon instances
2. Verify shapes render at correct positions
3. Verify colors are correct
4. Verify sizes are correct
5. Check console for errors/warnings

**Performance:**
1. Measure frame time for 1000 instances
2. Verify no memory leaks
3. Check GC pressure

## File-by-File Deletion Checklist

### src/runtime/RenderAssembler.ts

**Delete:**
- [ ] Lines 52-104: `assembleRenderPass()`
- [ ] Lines 112-132: `resolveScale()`
- [ ] Lines 143-176: `resolveShape()`
- [ ] Lines 180-194: `resolveControlPoints()`
- [ ] Lines 206-210: `isShapeDescriptor()`
- [ ] Lines 224-270: `resolveShapeFully()`
- [ ] Lines 279-293: `assembleAllPasses()`

**Keep:**
- [ ] Lines 19: Import of v1 types (will be deleted from ScheduleExecutor)
- [ ] Lines 316-341: `buildPathGeometry()`
- [ ] Lines 357-371: `buildInstanceTransforms()`
- [ ] Lines 383-391: `buildPathStyle()`
- [ ] Lines 403-491: `assembleDrawPathInstancesOp()`
- [ ] Lines 503-520: `assembleRenderFrame_v2()`
- [ ] Lines 199-201: `isPathTopology()`
- [ ] Lines 298-300: `isRenderStep()`

### src/runtime/ScheduleExecutor.ts

**Delete:**
- [ ] Line 21: `import { assembleRenderPass, ... }`
- [ ] Lines 34-37: `interface RenderFrameIR`
- [ ] Lines 42-46: `interface ShapeDescriptor`
- [ ] Lines 58-80: `interface ResolvedShape`
- [ ] Lines 96-124: `interface RenderPassIR`
- [ ] Lines 230-243: Render step case with `assembleRenderPass()`

**Update:**
- [ ] Line 21: Import `assembleRenderFrame_v2` instead
- [ ] Lines 230-243: Replace with v2 assembly call

### src/render/Canvas2DRenderer.ts

**Delete:**
- [ ] Line 42: Import of `RenderPassIR, ResolvedShape`
- [ ] Lines 50-64: Old `renderFrame()` signature
- [ ] Lines 69-81: Old `renderPass()` dispatcher
- [ ] Lines 96-143: `renderInstances2D()`
- [ ] Lines 262-264: `type ShapeMode`
- [ ] Lines 274-282: `convertResolvedShapeToMode()`

**Update:**
- [ ] Line 42: Import `RenderFrameIR_Future, DrawPathInstancesOp`
- [ ] Lines 180-259: Update `renderPathAtParticle()` to use local-space points

**Add:**
- [ ] New `renderDrawPathInstancesOp()` function
- [ ] New `drawPath()` helper

### src/runtime/__tests__/RenderAssembler.test.ts

**Update:**
- [ ] All test expectations for v2 types
- [ ] Delete v1 test cases
- [ ] Add v2 test cases

## Success Indicators

After completion, these should all be true:

1. ✅ TypeScript compiles: `npm run typecheck`
2. ✅ All tests pass: `npm test`
3. ✅ No v1 references: `rg "RenderPassIR|ShapeDescriptor" src/ | wc -l` = 0
4. ✅ Visual output unchanged: Manual verification
5. ✅ Console clean: No errors or warnings
6. ✅ ~600 lines deleted: Check git diff stats
7. ✅ Only v2 types exported: Check index.ts files

## Reference Documentation

**Specs:**
- `.agent_planning/_future/2-local-space-end-to-end-spec.md` - Coordinate space model
- `.agent_planning/_future/3-local-space-spec-deeper.md` - RenderAssembler algorithm
- `.agent_planning/_future/8-before-render.md` - Architecture rationale
- `.agent_planning/_future/9-renderer.md` - Renderer contract

**Related Planning:**
- `.agent_planning/render-assembler-v2/` - V2 implementation planning
- `.agent_planning/renderer-local-space/` - Renderer migration planning

**Bead Chain:**
1. oscilla-animator-v2-583: RenderAssembler v2 (IN PROGRESS)
2. oscilla-animator-v2-46m: Renderer local-space (OPEN)
3. oscilla-animator-v2-ry2: V1 cleanup (THIS BEAD - BLOCKED)
4. oscilla-animator-v2-0uk: SVG renderer (FUTURE)
