# Evaluation: U-32 DomainDecl in NormalizedGraph
Timestamp: 2026-01-28-060712
Git Commit: 79e9c51
Evaluator: project-evaluator

## Executive Summary
Overall: **0% complete** | Critical issues: **3 architectural conflicts** | Tests reliable: **N/A (not implemented)**

**VERDICT: PAUSE - Fundamental spec/implementation misalignment requires clarification**

---

## Critical Finding: Spec-Implementation Divergence

The spec describes a `DomainDecl` type and requires `NormalizedGraph` to contain `domains: DomainDecl[]`, but this has been **completely replaced** by a different architecture in the current codebase.

### Evidence

**1. Spec Requirement** (`04-compilation.md:82-87`):
```typescript
type NormalizedGraph = {
  domains: DomainDecl[];    // <-- Required by spec
  nodes: Node[];
  edges: Edge[];
};
```

**2. Spec DomainDecl Definition** (`04-compilation.md:172-177`):
```typescript
type DomainDecl =
  | { kind: 'domain_decl'; id: DomainId; shape: { kind: 'fixed_count'; count: number } }
  | { kind: 'domain_decl'; id: DomainId; shape: { kind: 'grid_2d'; width: number; height: number } }
  | { kind: 'domain_decl'; id: DomainId; shape: { kind: 'voices'; maxVoices: number } }
  | { kind: 'domain_decl'; id: DomainId; shape: { kind: 'mesh_vertices'; assetId: string } };
```

**3. Actual Implementation** (`src/compiler/frontend/normalize-indexing.ts:67-79`):
```typescript
export interface NormalizedPatch {
  readonly patch: Patch;
  readonly blockIndex: ReadonlyMap<BlockId, BlockIndex>;
  readonly blocks: readonly Block[];
  readonly edges: readonly NormalizedEdge[];
  // NO domains field
}
```

**4. Current Architecture** (as of 2026-01-17, commit cfe765c):
- `DomainDecl` **deleted from codebase entirely**
- Replaced with `DomainTypeId` (classification) + `InstanceDecl` (instantiation)
- Domain registry pattern (`src/core/domain-registry.ts`)
- Instances created at IR compilation stage, not normalization stage

---

## Architecture Analysis

### What Was Refactored (8 sprints, Jan 17, 2026)

**Old model (spec)**: Domain declarations as graph data
```typescript
DomainDecl → contains shape info (count, grid dimensions, etc.)
```

**New model (implementation)**: Domain types + instances
```typescript
DomainTypeId → classification only (shape, circle, control)
InstanceDecl → instantiation (count, lifecycle, identityMode)
DomainRegistry → centralized type definitions + intrinsics
```

**Commits**:
- Sprint 1 (ba1cabe): Foundation types + registry
- Sprint 2 (ebb148d, 86fe7a1, 800101f): IR migration
- Sprint 3-7: Compiler + runtime migration
- Sprint 8 (cfe765c): **Deleted old DomainDecl types**

**Verification** (`grep -r "DomainDecl" src/` = 0 matches):
```bash
✅ No DomainDecl interface
✅ No DomainRef interface  
✅ No DomainShape union
✅ No domain declaration factories
```

### Current Domain Flow

**Normalization stage** (`normalize-indexing.ts`):
- Only handles: block indexing, edge normalization
- Explicitly **excludes** domain concerns (contract lines 27-50)
- Output: `NormalizedPatch` with blocks/edges only

**IR compilation stage** (`src/compiler/ir/types.ts:417-425`):
```typescript
export interface InstanceDecl {
  readonly id: string;           // InstanceId
  readonly domainType: string;   // DomainTypeId (registry lookup)
  readonly count: number | 'dynamic';
  readonly lifecycle: 'static' | 'dynamic' | 'pooled';
  readonly identityMode: 'stable' | 'none';
  readonly elementIdSeed?: number;
}
```

**Domain registry** (`src/core/domain-registry.ts`):
- Central type definitions (DOMAIN_SHAPE, DOMAIN_CIRCLE, etc.)
- Intrinsic property specs (position, bounds, area, etc.)
- Type hierarchy (subtyping relationships)

---

## Findings

### 1. NormalizedPatch Structure
**Status**: COMPLETE (for current architecture)
**Evidence**: `src/compiler/frontend/normalize-indexing.ts:67-79`
**Issues**: 
- Does NOT contain `domains: DomainDecl[]` field as spec requires
- This is by design in current architecture — domains are registry lookups, not graph data

### 2. DomainDecl Type
**Status**: NOT_STARTED (deleted)
**Evidence**: 
- Spec defines it at `04-compilation.md:172-177`
- Grep shows 0 matches in `src/` directory
- Replaced by `DomainTypeId` + `InstanceDecl` model
**Issues**: 
- Spec's `DomainDecl` does not exist in codebase
- Replacement model (`InstanceDecl`) has different semantics

### 3. NormalizedGraph Type
**Status**: NOT_STARTED
**Evidence**: `grep -rn "interface NormalizedGraph\|type NormalizedGraph" src/` returns no matches
**Issues**: 
- Spec defines it with `domains`, `nodes`, `edges` fields
- Implementation uses `NormalizedPatch` instead (different structure)
- No TypeScript type exists matching spec

### 4. Domain Extraction Pipeline
**Status**: NOT_STARTED (different architecture)
**Evidence**: 
- Normalization pass explicitly excludes domain handling (contract)
- Domain/instance creation happens in IR layer
- No extraction logic exists in frontend
**Issues**: 
- Gap analysis assumes adding domains to normalization
- Current architecture uses registry pattern instead

---

## Ambiguities Found

| Area | Question | How LLM Would Guess | Impact |
|------|----------|---------------------|--------|
| **Architecture** | Should we implement spec's DomainDecl model or update spec to match implementation? | Likely implement spec literally, creating duplicate domain system | Creates parallel domain systems, architectural confusion |
| **Scope** | Does NormalizedGraph replace NormalizedPatch or coexist? | Unclear — might rename or create both | Type system confusion, two "normalized" structures |
| **Data Flow** | Where do domains get declared in patches? | Look for domain blocks/declarations in patch | None exist — domains are types, not graph nodes |
| **Semantics** | What's difference between DomainDecl and InstanceDecl? | Treat as synonyms or evolution | They're fundamentally different concepts (classification vs instantiation) |
| **Refactor Status** | Was the domain refactor intentional or incomplete? | Assume incomplete, try to "fix" by adding back DomainDecl | Undoes completed 8-sprint refactor |

---

## Missing Checks

Since implementation doesn't exist, no runtime checks possible. **Required before implementation**:
1. Spec clarification: Which model is authoritative?
2. Architecture decision: Registry pattern vs graph data pattern
3. Type system alignment: What should `NormalizedGraph` actually contain?

---

## Spec vs Implementation Comparison

### Spec Model (Topic 04)
```typescript
// Spec: Domain as declarative graph data
type DomainDecl = { kind: 'domain_decl'; id: DomainId; shape: Shape };
type NormalizedGraph = {
  domains: DomainDecl[];  // Domain info in graph
  nodes: Node[];
  edges: Edge[];
};
```

### Implementation Model (Current)
```typescript
// Code: Domain as classification + registry
type DomainTypeId = string & { __brand: 'DomainTypeId' };
type InstanceDecl = {
  domainType: DomainTypeId;  // Registry lookup
  count: number;
  lifecycle: 'static' | 'dynamic';
  // ... instance config
};

// Registry (compile-time)
DomainRegistry.get('circle') → { intrinsics: [position, bounds, ...] }
```

**Key Differences**:
1. **Spec**: Shape info in declarations → **Code**: Shape info in instances
2. **Spec**: Domains as graph data → **Code**: Domains as types (registry)
3. **Spec**: Domain IDs are strings → **Code**: Domain types are branded strings with hierarchy
4. **Spec**: Domains collected during normalization → **Code**: Instances created during IR compilation

---

## Questions Requiring Answers

### Q1: Which architecture is correct?
**Options**:
- A) Implement spec literally (add DomainDecl, domains array to NormalizedGraph)
- B) Update spec to reflect current registry-based architecture
- C) Hybrid: Both models serve different purposes

**Impact**: Determines entire implementation approach

### Q2: What is NormalizedGraph's purpose?
**Spec says**: "Canonical compile-time representation the compiler consumes"
**Code has**: `NormalizedPatch` (blocks + edges, no domains)

**Options**:
- A) NormalizedGraph = new type that replaces NormalizedPatch
- B) NormalizedGraph = documentation term for NormalizedPatch
- C) NormalizedGraph = different concept (IR-level, not frontend)

**Impact**: Determines where to add code, what to rename

### Q3: Why does normalization need domains?
**Spec claims**: Organizational improvement for compiler clarity
**Current code**: Works without domain field in normalization

**Options**:
- A) Domains needed for future features (not yet implemented)
- B) Domains useful for debugging/tooling (not execution)
- C) Spec describes ideal state, not current requirements

**Impact**: Determines whether this is P0, P1, or optional

### Q4: Should we preserve the domain refactor?
**Evidence**: 8 sprints (Jan 17, 2026) replaced DomainDecl with DomainTypeId + InstanceDecl

**Options**:
- A) Refactor was correct — update spec to match
- B) Refactor was premature — revert to spec model
- C) Both models needed for different stages

**Impact**: Determines whether we're adding to or undoing work

### Q5: What goes in DomainDecl if we implement it?
**Spec shows**: `id`, `shape` (with kind: fixed_count | grid_2d | voices | mesh_vertices)
**Current instances have**: `domainType`, `count`, `lifecycle`, `identityMode`

**Options**:
- A) Use spec structure literally (id + shape)
- B) Adapt to include current InstanceDecl fields
- C) Keep both structures for different purposes

**Impact**: Determines API surface, compatibility with rest of codebase

---

## Recommendations

### 1. PAUSE Implementation (HIGH priority)
**Rationale**: Cannot implement with confidence when spec and code fundamentally diverge.

**Risk**: 
- Implementing spec literally creates parallel domain system
- Updating spec without understanding refactor rationale loses design intent
- Either approach may break existing compiler pipeline

### 2. Conduct Spec/Code Alignment Session (BLOCKING)
**Actions**:
- Review domain refactor commits + rationale
- Determine if refactor was:
  - Intentional improvement → Update spec
  - Incomplete work → Continue toward spec
  - Divergence → Reconcile both models
- Document decision in design-docs

### 3. If Spec is Authoritative: Major Refactor Required
**Scope**:
- Reintroduce DomainDecl type (spec structure)
- Add domains array to NormalizedPatch (or create NormalizedGraph type)
- Extract domain declarations during normalization
- Reconcile with InstanceDecl (different concept or evolution?)
- Update IR layer to consume domains from normalized graph

**Estimate**: 3-5 days (medium-large change)
**Risk**: May undo validated refactor work

### 4. If Implementation is Authoritative: Spec Update Required
**Scope**:
- Update Topic 04 to reflect DomainTypeId + InstanceDecl model
- Document registry pattern
- Clarify NormalizedGraph vs NormalizedPatch terminology
- Update glossary entries

**Estimate**: 1-2 days (documentation)
**Risk**: Spec may describe intended future state, not just current implementation

---

## Verdict

- [ ] CONTINUE - Issues clear, implementer can fix
- [x] **PAUSE - Ambiguities need clarification**

**Specific blockers**:
1. **Fundamental architecture mismatch**: Spec describes one model, code implements different model
2. **Cannot determine intent**: Is refactor correct or incomplete?
3. **Cannot assess scope**: Don't know if this is additive feature or major rework
4. **High error risk**: Wrong choice breaks either spec compliance or runtime functionality

**Required before proceeding**:
- Answer Q1-Q5 (architecture decision)
- Decide: Update spec or update code?
- Document decision rationale
- Assess impact on existing compiler passes

**Confidence**: 0% — Cannot proceed without architectural clarity

---

## Additional Context

### Domain Refactor Timeline (for decision-making)
```
Jan 17, 2026 - 8 sprint completion
├─ Sprint 1 (ba1cabe): DomainTypeId + registry foundation
├─ Sprint 2: IR migration to InstanceDecl
├─ Sprint 3: Instance blocks (CircleInstance, RectangleInstance)
├─ Sprint 4-5: Field operations + render blocks
├─ Sprint 6: Compiler passes updated
├─ Sprint 7: Runtime (Materializer, ScheduleExecutor) migrated
└─ Sprint 8 (cfe765c): OLD TYPES DELETED
```

**All tests passing** (verification in COMPLETION-20260117.md)
**No grep matches** for old DomainDecl, DomainRef, DomainShape

This suggests refactor was **intentional and validated**, not abandoned work.

### Spec Last Updated
- CANONICAL-oscilla-v2.5-20260109 (Jan 9, 2026)
- Domain refactor completed Jan 17, 2026 (8 days later)
- **Spec predates refactor** — explains divergence

### Recommended Next Step
**Before implementation**: Spawn a status-planner or research agent to:
1. Read full domain refactor completion doc
2. Compare spec requirements vs implemented architecture
3. Propose one of:
   - Update spec to match (with rationale)
   - Revert code to match spec (with migration plan)
   - Explain how both coexist (with reconciliation)

---

## Files Referenced

**Spec**:
- `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/04-compilation.md` (lines 82-87, 172-177)
- `design-docs/CANONICAL-oscilla-v2.5-20260109/GLOSSARY.md` (lines 952-970)

**Implementation**:
- `src/compiler/frontend/normalize-indexing.ts` (lines 67-79, contract 27-50)
- `src/compiler/ir/types.ts` (lines 417-425, InstanceDecl)
- `src/core/domain-registry.ts` (domain type system)

**Completion Docs**:
- `COMPLETION-20260117.md` (domain refactor validation)
