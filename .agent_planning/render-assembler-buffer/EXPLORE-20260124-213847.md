# Exploration: RenderAssembler Buffer Type Issue
Timestamp: 2026-01-24-213847
Git Commit: 436cd12

## Raw Test Failures

### 1. RenderAssembler.test.ts - "assembles DrawPathInstancesOp for path topologies"
```
AssertionError: expected Float32Array[ ...(4.899999998509884) ] to be Float32Array[ ...(4.899999998509884) ] // Object.is equality

expect(op.instances.position).toBe(positionBuffer);

Line 231: Test expects op.instances.position to BE (reference equality) the original positionBuffer passed in
Actual: op.instances.position IS a Float32Array with same values but different reference
```

### 2. RenderAssembler-per-instance-shapes.test.ts - "slices position and color buffers correctly"
```
AssertionError: expected Float32Array[ ...(4.899999998509884) ] to deeply equal Float32Array[ ...(6.899999998509884) ]

- Expected: Float32Array [ 0.1, 0.1, 0, 0.4, 0.4, 0 ] (stride-3 vec3)
+ Received: Float32Array [ 0.1, 0.1, 0.4, 0.4 ] (stride-2 vec2)

Line 433: Test expects stride-3 vec3 world-space positions
Actual: stride-2 vec2 screen-space positions after projection
```

### 3. level1-vec3-data.test.ts - "compiled schedule position slot is typed as vec3"
```
AssertionError: expected 32 to be 48 // Object.is equality

Line 233: expect(position.length).toBe(N * 3); // 16 instances * 3 floats = 48
Actual: position.length === 32 (16 instances * 2 floats = stride-2)
```

## Code Analysis

### RenderAssembler.ts - depthSortAndCompact() at line 113
```typescript
export function depthSortAndCompact(
  projection: ProjectionOutput,
  count: number,
  color: ArrayBufferView,
  rotation?: Float32Array,
  scale2?: Float32Array,
): {
  count: number;
  screenPosition: Float32Array;  // <-- stride-2
  screenRadius: Float32Array;
  depth: Float32Array;
  color: ArrayBufferView;
  rotation?: Float32Array;
  scale2?: Float32Array;
}
```
Returns **screen-space** positions (stride-2 vec2), not world-space positions (stride-3 vec3).

### RenderAssembler.ts - projectInstances() at line 236
```typescript
export function projectInstances(...): ProjectionOutput {
  // Allocate output buffers (separate from world-space inputs)
  const screenPosition = new Float32Array(count * 2);  // <-- stride-2
  ...
}
```
Creates a NEW stride-2 buffer for screen positions.

### ortho-kernel.ts - projectFieldOrtho() at line 117
```typescript
export function projectFieldOrtho(
  worldPositions: Float32Array,  // stride-3 input
  N: number,
  camera: OrthoCameraParams,
  outScreenPos: Float32Array,    // stride-2 output
  outDepth: Float32Array,
  outVisible: Uint8Array,
): void {
  // Reads stride-3, writes stride-2
  outScreenPos[i * 2 + 0] = worldX;
  outScreenPos[i * 2 + 1] = worldY;
}
```

### render/types.ts - InstanceTransforms at line 136
```typescript
export interface InstanceTransforms {
  readonly position: Float32Array;
  // Comments say:
  // - WHEN PROJECTED: screen-space positions (stride-2, normalized [0,1])
  // - Otherwise: normalized [0,1] coordinates (x,y interleaved)
}
```

## Key Findings

1. **Position stride changed intentionally**: Projection was deliberately added to transform world-space vec3 (stride-3) to screen-space vec2 (stride-2)

2. **Tests written for OLD contract**: Tests expect:
   - World-space stride-3 positions
   - Reference equality with input buffer (`.toBe(positionBuffer)`)
   - fillColor as Uint8ClampedArray

3. **Implementation changed contract**: Implementation now:
   - Always projects to screen-space stride-2 positions
   - Creates new buffer (breaks reference equality)
   - Color buffer type unchanged (still Uint8ClampedArray in render/types.ts)

4. **NOT a Float32Array vs Uint8ClampedArray issue**: User's description was about fillColor type, but the actual failures are about:
   - Position stride (3 vs 2)
   - Reference equality (toBe vs toEqual)

## Files Involved

- `/Users/bmf/code/oscilla-animator-v2/src/runtime/RenderAssembler.ts` - Implementation
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/__tests__/RenderAssembler.test.ts` - Test line 231
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/__tests__/RenderAssembler-per-instance-shapes.test.ts` - Test lines 433-451
- `/Users/bmf/code/oscilla-animator-v2/src/projection/__tests__/level1-vec3-data.test.ts` - Test line 233
- `/Users/bmf/code/oscilla-animator-v2/src/render/types.ts` - InstanceTransforms definition
- `/Users/bmf/code/oscilla-animator-v2/src/projection/ortho-kernel.ts` - Projection implementation

## Type Contract

### render/types.ts PathStyle.fillColor
```typescript
readonly fillColor?: Uint8ClampedArray; // RGBA per instance or uniform
```
Type is correct as Uint8ClampedArray.

### RenderAssembler.ts depthSortAndCompact color return
```typescript
color: ArrayBufferView,  // Input type
...
color: compacted.color as Uint8ClampedArray,  // Cast on line 815
```
Cast to Uint8ClampedArray but input allows any ArrayBufferView.

## Steel-Thread Test Failures (Related but Different Issue)

The steel-thread tests are failing with:
```
NoConversionPath: Type mismatch: cannot connect one+continuous<shape, unit:none> to one+continuous<float, unit:none>
```
This is a TYPE SYSTEM issue in the compiler, not a buffer type issue.
