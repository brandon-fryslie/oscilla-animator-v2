# Work Evaluation - 2026-02-04T07:40:10
Scope: defaultsource-frontend-snapshot / frontend-ui-wiring
Confidence: FRESH

## Goals Under Evaluation
From SPRINT-2026-02-03-230000-frontend-ui-wiring-DOD.md:

### Functional Criteria
1. Unconnected input ports that have materialized default sources display the default source indicator
2. Port type colors in the graph editor reflect the compiler frontend's resolved types
3. When compileFrontend() produces errors, the UI still updates with partial frontend data
4. When no frontend result exists (before first compile), UI gracefully falls back to registry data
5. All existing UI behavior preserved -- no visual regressions for connected ports, params, edge labels
6. Port provenance is queryable by canonical address

### Technical Criteria
7. FrontendSnapshot type defined with status, revision, provenance, resolved types, errors
8. FrontendResultStore is a MobX store with observable snapshot
9. RootStore.frontend is the single access point for frontend compilation results
10. CompileOrchestrator.compileAndSwap() calls compileFrontend() and passes result to compile() via precomputedFrontend
11. compile() accepts precomputedFrontend and skips inline frontend when provided
12. compile() still works standalone without precomputedFrontend (backward compatible)
13. reconcileNodes() receives FrontendResultStore and passes data to createNodeFromBlock()
14. getEffectiveDefaultSource() checks FrontendResultStore before falling back to registry
15. Canonical address index built inside FrontendResultStore.updateFromFrontendResult()
16. patchRevision coherence: snapshot carries revision, UI checks match

### Test Criteria
17. All existing tests pass (no regressions)
18. Unit test: FrontendResultStore correctly reports hasDefaultSource() by canonical address
19. Unit test: FrontendResultStore.getResolvedPortType() returns resolved types
20. Integration test: compileAndSwap() populates FrontendResultStore
21. Integration test: unconnected port has defaultSource provenance in snapshot
22. Integration test: connected port has userEdge provenance in snapshot
23. Typecheck passes

## Previous Evaluation Reference
Last evaluation: EVALUATION-2026-02-03-230000.md (pre-implementation assessment, not runtime evaluation)
No prior runtime evaluation exists.

## Persistent Check Results
| Check | Status | Output Summary |
|-------|--------|----------------|
| `npm run test` | PASS | 2163 passed, 22 skipped, 2 todo (148 files) |
| `npm run typecheck` | PASS | Clean, no errors |
| FrontendResultStore unit tests | PASS | 8/8 |
| Frontend pipeline integration tests | PASS | 6/6 |
| Default-source field tests | PASS | 3/3 |
| Compiler compile.test.ts | PASS | 17/17 (standalone path) |

## Assessment

### PASS: Working Criteria

- **[7] FrontendSnapshot type**: Defined in `src/stores/FrontendResultStore.ts:35-57` with status, patchRevision, portProvenance, resolvedPortTypes, errors, backendReady, cycleSummary. Correct.

- **[8] FrontendResultStore MobX store**: Uses `makeAutoObservable(this)`, observable `snapshot` field. Correct.

- **[9] RootStore.frontend**: `src/stores/RootStore.ts:45` declares `readonly frontend: FrontendResultStore`, instantiated at line 95. Single access point. Correct.

- **[10] CompileOrchestrator calls compileFrontend()**: `src/services/CompileOrchestrator.ts:89-96` calls `compileFrontend(patch)`, stores result in `store.frontend.updateFromFrontendResult()` or `updateFromFrontendFailure()`, then passes `precomputedFrontend: frontendResult.result` to `compile()` at line 144. Correct.

- **[11] compile() accepts precomputedFrontend**: `src/compiler/compile.ts:87` adds `precomputedFrontend?: FrontendResult` to `CompileOptions`. Lines 132-144 reuse it when provided. Correct.

- **[12] compile() standalone path preserved**: `src/compiler/compile.ts:145-321` runs the full inline frontend when `precomputedFrontend` is absent. Verified by running `compile.test.ts` (17 tests pass) and `default-source-field.test.ts` (3 tests pass), which call `compile(patch)` without options. Correct.

- **[13] reconcileNodes() receives FrontendResultStore**: `src/ui/reactFlowEditor/sync.ts:175` accepts `frontendResultStore: FrontendResultStore` and passes it to `createNodeFromBlock()` at line 210. Correct.

- **[15] Canonical address index**: Built in `rebuildBlockIdMap()` called from `updateFromFrontendResult()` at line 112. Correct.

- **[16] patchRevision coherence**: `CompileOrchestrator.ts:84` reads `store.getPatchRevision()`, passes to `updateFromFrontendResult(..., patchRevision)`. Snapshot carries revision at `FrontendSnapshot.patchRevision`. MobX reaction in `sync.ts:315` tracks `frontendSnapshotRevision` for reactive updates. Correct.

- **[17] All existing tests pass**: 2163 passed, no regressions. Confirmed.

- **[18] Unit test hasDefaultSource()**: `FrontendResultStore.test.ts:45-66` tests both canonical address and id-based queries. Passes.

- **[19] Unit test getResolvedPortType()**: `FrontendResultStore.test.ts:95-140` tests both canonical address and id-based queries. Passes.

- **[21] Integration test: unconnected port defaultSource provenance**: `frontend-pipeline-integration.test.ts:15-39`. Builds Patch with Ellipse, calls real `compileFrontend()`, verifies provenance kind is `'defaultSource'`. Not tautological -- exercises real compiler pipeline.

- **[22] Integration test: connected port userEdge provenance**: `frontend-pipeline-integration.test.ts:41-68`. Builds Patch with Const wired to Ellipse rx, verifies provenance kind is `'userEdge'`. Not tautological -- exercises real compiler pipeline.

- **[23] Typecheck passes**: Confirmed clean.

- **[3] Frontend errors update UI with partial data**: `FrontendResultStore.updateFromFrontendFailure()` stores partial data (normalizedPatch, errors). `CompileOrchestrator.ts:94-96` calls this on failure. Unit test at `FrontendResultStore.test.ts:164-183` and integration test at `frontend-pipeline-integration.test.ts:96-121` cover this.

- **[4] Fallback to registry before first compile**: `getEffectiveDefaultSource()` checks `snapshot.status !== 'none'` before using frontend data. When status is `'none'`, falls through to instance override then registry default. Correct.

- **[5] Existing UI behavior preserved**: All 2163 tests pass. The only change to rendering code is the addition of `frontendStore` parameter (optional) to `getEffectiveDefaultSource()` and `createNodeFromBlock()`. When absent, behavior is identical to pre-change.

- **[6] Port provenance queryable by canonical address**: `hasDefaultSource(addr)`, `getResolvedPortType(addr)`, `getPortProvenance(addr)` all work by canonical address string. Verified by tests.

### BUG: getEffectiveDefaultSource() logic flaw [MEDIUM severity]

**[14] getEffectiveDefaultSource() checks FrontendResultStore before falling back to registry**: PARTIALLY CORRECT, with a logic gap.

In `src/ui/reactFlowEditor/nodes.ts:112-135`:

When the frontend snapshot IS available (`status !== 'none'`):
- If `hasDefaultSourceByIds` returns true: returns `input.defaultSource` -- CORRECT
- If `hasDefaultSourceByIds` returns false: FALLS THROUGH to step 2 (instance override) and step 3 (registry default)

This means the frontend snapshot's "no default source" determination is ignored. A connected port still gets `input.defaultSource` returned from the fallback path. The function should return `undefined` when the frontend says the port has no default source.

**Why this does not cause a visible bug today**: The UI component at `OscillaNode.tsx:220` gates rendering on `!input.isConnected && input.defaultSource`, so connected ports never show the indicator. The `isConnected` flag acts as a second enforcer.

**Why this is still a bug**: It violates "Single Enforcer" (from CLAUDE.md architectural laws). The correctness depends on two independent checks agreeing. If `isConnected` ever drifts from the frontend's provenance (e.g., race condition during recompile, or a port that has no user edge but also no default source), the indicator would display incorrectly. The fix is:

```typescript
if (frontendStore && frontendStore.snapshot.status !== 'none') {
  const hasDefault = frontendStore.hasDefaultSourceByIds(block.id, inputId);
  if (hasDefault) {
    return input.defaultSource;
  }
  // Frontend says no default source -- respect that determination
  return undefined;
}
```

### NOT VERIFIED (cannot verify without running UI)

- **[1] Unconnected input ports display default source indicator**: Code path is correct (frontendStore flows through reconcileNodes to createNodeFromBlock to getEffectiveDefaultSource). However, this is a visual criterion that would require browser rendering to fully verify. Code analysis says it SHOULD work.

- **[2] Port type colors reflect resolved types**: The `frontendStore` is wired through but `createPortData()` still reads `input.type` (the registry type at line 243), NOT the resolved type from the frontend snapshot. Port type colors do NOT use `getResolvedPortTypeByIds()` from the frontend store. This criterion is NOT MET by the code.

### NOT MET: Port type colors from resolved types

**[2] Port type colors in the graph editor reflect the compiler frontend's resolved types**: The `createNodeFromBlock()` function at `nodes.ts:240-248` creates input port data using `input.type` (the static registry type), not the resolved type from the frontend snapshot. The `getResolvedPortTypeByIds()` method exists and works, but is never called during node creation. This means port type colors still come from the static registry, not the frontend's resolved types.

### MISSING: Integration test for compileAndSwap()

**[20] Integration test: compileAndSwap() populates FrontendResultStore**: The integration tests in `frontend-pipeline-integration.test.ts` call `compileFrontend()` directly and then manually call `store.updateFromFrontendResult()`. No test exercises the full `compileAndSwap()` flow that goes through `CompileOrchestrator`. This is an end-to-end integration gap -- though a full `compileAndSwap()` test would require mocking `RootStore` and its dependencies, making it heavyweight.

## Test Quality Assessment

### Tests are NOT tautological

All tests call the real `compileFrontend()` with real patches and verify the results through `FrontendResultStore`. The tests exercise the real compiler pipeline (normalization, type resolution, default source materialization). If the implementation were deleted, these tests would fail.

### Test coverage gap

No test verifies that `getEffectiveDefaultSource()` returns `undefined` for a connected port when the frontend snapshot is available. The existing test for connected ports (`hasDefaultSource() returns false for connected inputs`) only checks the store query, not the `getEffectiveDefaultSource()` function itself.

## Missing Checks (implementer should create)

1. **Test for `getEffectiveDefaultSource()` with active snapshot + connected port**: Should verify it returns `undefined` (after fixing the bug). File: `src/ui/reactFlowEditor/__tests__/getEffectiveDefaultSource.test.ts`.

2. **Test for resolved type colors**: When the DOD criterion #2 is implemented, add a test that verifies `createNodeFromBlock()` uses resolved types from the frontend for port coloring.

3. **Integration test for `compileAndSwap()` populating FrontendResultStore**: Even a lightweight test that creates a minimal RootStore and calls `compileAndSwap()` would close the gap for DOD criterion #20.

## Verdict: INCOMPLETE

### Criteria Summary: 19/23 met, 2 bugs, 1 missing test, 1 unverifiable

| # | Criterion | Status |
|---|-----------|--------|
| 1 | Default source indicators display | LIKELY MET (code path correct, visual unverifiable) |
| 2 | Port type colors from resolved types | NOT MET |
| 3 | Frontend errors update partial data | MET |
| 4 | Fallback to registry before first compile | MET |
| 5 | Existing UI preserved | MET |
| 6 | Canonical address queries | MET |
| 7 | FrontendSnapshot type | MET |
| 8 | FrontendResultStore MobX | MET |
| 9 | RootStore.frontend | MET |
| 10 | CompileOrchestrator wiring | MET |
| 11 | compile() precomputedFrontend | MET |
| 12 | compile() standalone | MET |
| 13 | reconcileNodes() wiring | MET |
| 14 | getEffectiveDefaultSource() logic | BUG (masked by UI) |
| 15 | Canonical address index | MET |
| 16 | patchRevision coherence | MET |
| 17 | All tests pass | MET |
| 18 | hasDefaultSource() unit test | MET |
| 19 | getResolvedPortType() unit test | MET |
| 20 | compileAndSwap() integration test | NOT MET (tests exercise compileFrontend directly, not through orchestrator) |
| 21 | Unconnected port provenance test | MET |
| 22 | Connected port provenance test | MET |
| 23 | Typecheck passes | MET |

## What Needs to Change

1. **`src/ui/reactFlowEditor/nodes.ts:119-125`** -- `getEffectiveDefaultSource()` must return `undefined` when frontend snapshot is active and says port has no default source. Currently falls through to registry default. Fix: add `return undefined` after the `if (hasDefault)` block when snapshot is active.

2. **`src/ui/reactFlowEditor/nodes.ts:240-248`** -- Port data creation should use resolved types from `frontendStore.getResolvedPortTypeByIds()` when available, falling back to `input.type` (registry) when not. This is required for DOD criterion #2.

3. **`src/stores/__tests__/frontend-pipeline-integration.test.ts`** -- Add a test that exercises `compileAndSwap()` end-to-end through the orchestrator, not just `compileFrontend()` directly. This would cover DOD criterion #20.
