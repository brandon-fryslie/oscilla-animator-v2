# Evaluation: DefaultSource UI Visibility via FrontendSnapshot

**Generated:** 2026-02-03T23:00:00
**Topic:** defaultsource-frontend-snapshot
**Verdict:** CONTINUE

## Context

DefaultSource block (`src/blocks/signal/default-source.ts`) has been made polymorphic — it now resolves payload/unit via constraint propagation and handles field-cardinality outputs (vec3 circular arrangement, color rainbow, broadcast for others). All 2149 tests pass.

**The remaining problem is purely UI plumbing**: the compiler frontend materializes DefaultSource blocks during normalization, but the UI bypasses this entirely, reading directly from the static block registry. The UI cannot show default source indicators on unconnected ports because it doesn't know which ports had defaults materialized.

## Completed Work

### DefaultSource Polymorphism (uncommitted, working)
- Output type changed from `canonicalType(FLOAT)` to `inferType(payloadVar, unitVar)` — polymorphic
- Field-cardinality dispatch: vec3→circular, color→rainbow, other→broadcast
- 3 new tests in `src/blocks/__tests__/default-source-field.test.ts`
- All 2149 tests pass, typecheck clean

## Architecture Gap

```
PatchStore (user blocks/edges only)
  → compile()
    → Pass 0: normalize → NormalizedPatch (has derived default source blocks) ← DISCARDED
    → Pass 1: types → TypeResolvedPatch (has port types)                     ← DISCARDED
    → Pass 2-7: backend passes
  → CompiledProgramIR (no frontend provenance)
  → UI renders (can't tell which ports have materialized defaults)
```

The compiler's `convertLinkedIRToProgram()` builds `DebugIndexIR` which already contains `PortBindingIR` entries with `role: 'defaultSource'` and `defaultOfPort` — but the UI's `getEffectiveDefaultSource()` in `nodes.ts:103-116` reads from the static registry, completely bypassing compiled artifacts.

## Key Finding: DebugIndexIR Already Has Partial Data

`DebugIndexIR.ports` contains `PortBindingIR` entries with:
- `role: 'userWire' | 'defaultSource' | 'implicitCoerce' | 'internalHelper'`
- `defaultOfPort?: PortId` — identifies which user port a default source targets

This means some provenance data already flows through to `CompiledProgramIR.debugIndex`. The question is whether this is sufficient or whether a separate `FrontendSnapshot` with richer type data is needed.

## Remaining Work

### Sprint 1: FrontendSnapshot + UI Wiring (core fix)
- Add `FrontendSnapshot` to `CompiledProgramIR`
- Populate from normalized patch + type-resolved data in `convertLinkedIRToProgram()`
- Expose through CompileOrchestrator to UI stores
- Update `getEffectiveDefaultSource()` to read from snapshot

### Sprint 2: Commit & Cleanup
- Commit DefaultSource polymorphism changes
- Commit FrontendSnapshot changes
- Remove stale plan file `.agent_planning/plan-defaultsource-cardinality-fix.md`
- Address `TODO(oscilla-animator-v2-cpc)` tracking

## Risks

| Risk | Mitigation |
|------|------------|
| DebugIndexIR may already provide enough data | Evaluate if PortBindingIR.role + defaultOfPort is sufficient before building FrontendSnapshot |
| Threading snapshot through stores adds coupling | Follow existing pattern: CompileOrchestrator → RuntimeStore → UI reads from store |
| FrontendSnapshot type definitions may overlap with DebugIndexIR | Use DebugIndexIR data where it suffices; FrontendSnapshot only for data DebugIndexIR lacks (port types) |

## Confidence Assessment

| Work Item | Confidence |
|-----------|------------|
| FrontendSnapshot type definition | HIGH |
| Populate snapshot in compile.ts | HIGH |
| Expose through CompileOrchestrator | HIGH |
| UI wiring (nodes.ts, sync.ts) | MEDIUM — need to trace exact data flow through stores |
| DebugIndexIR sufficiency assessment | MEDIUM — need to verify what's already available |
