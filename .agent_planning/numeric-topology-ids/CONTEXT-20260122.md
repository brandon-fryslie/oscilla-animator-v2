# Implementation Context: Numeric Topology IDs

**Bead**: oscilla-animator-v2-4h6
**Plan**: PLAN-20260122.md
**DoD**: DOD-20260122.md
**Created**: 2026-01-22

## Purpose

This document contains comprehensive background, code references, and implementation details for converting topology IDs from string to numeric. An agent with ONLY this file should be able to implement the full change.

---

## Architecture Context

### Slot-Addressed Philosophy

**From** `.agent_planning/_future/9-renderer.md:56-64`:

> **B. Topology lookup must be numeric + stable**
>
> Right now you do getTopology(shape.topologyId) where topologyId looks stringy. Change that.
> - Registry assigns numeric ids at init/compile time
> - topologyId in RenderIR is numeric
> - Renderer uses topologies[topologyId] array indexing
>
> No string lookups, no hash maps. This matches your slot-addressed philosophy.

**Design Principle**: The Oscilla runtime uses **slot-addressed execution** for value storage. Slots are numeric indices into typed arrays (Float32Array for scalars, Uint32Array for objects). This provides O(1) access and cache-friendly memory layout. The topology system currently violates this principle by using string-based Map lookups. Converting to numeric IDs brings topologies in line with the rest of the system.

**Performance Context**:
- Current: `Map<string, TopologyDef>` = O(log n) hash map lookup
- Target: `TopologyDef[]` = O(1) array index
- Real-world impact: Modest (topology lookup not hottest path), but **consistency matters more than raw performance**

### Shape System Overview

**The Unified Shape Model** (`src/shapes/types.ts:1-10`):

```
Shape = TopologyDef (compile-time) + ParamSlots (runtime)

- TopologyDef: WHAT to draw (static, immutable)
- ParamSlots: WHERE to draw it (dynamic, per-frame)
```

**Built-in Topologies**:
- `ellipse`: Ellipse defined by rx, ry, rotation
- `rect`: Rectangle defined by width, height, rotation, cornerRadius

**Dynamic Topologies**:
- Created by blocks at compile time (e.g., `ProceduralPolygon`)
- Registered during block lowering via `registerDynamicTopology()`
- Currently assigned string IDs like `'polygon-5'`

**Topology Flow**:
1. **Compile time**: Block creates topology definition
2. **Registration**: `registerDynamicTopology()` assigns ID
3. **IR emission**: Compiler emits `ShapeRef` with `topologyId`
4. **Runtime**: RenderAssembler resolves `topologyId` → `TopologyDef`
5. **Render**: Canvas2DRenderer dispatches on topology's render logic

---

## Current Implementation (String-Based)

### Type Definition

**File**: `src/shapes/types.ts:16`

```typescript
/**
 * TopologyId - String identifier for a topology
 */
export type TopologyId = string;
```

**Usage**: Exported and imported across:
- `src/shapes/registry.ts` (storage and lookup)
- `src/shapes/topologies.ts` (built-in definitions)
- `src/blocks/path-blocks.ts` (dynamic creation)
- `src/compiler/ir/types.ts` (IR references)
- `src/runtime/RenderAssembler.ts` (resolution)
- `src/render/Canvas2DRenderer.ts` (dispatch)

### Registry Implementation

**File**: `src/shapes/registry.ts:19-22`

```typescript
/**
 * Registry of all available topologies
 *
 * Mutable map of TopologyId → TopologyDef.
 * Built-in topologies are registered at module load.
 * Dynamic topologies (e.g., paths) are registered during compilation.
 */
const TOPOLOGY_REGISTRY: Map<TopologyId, TopologyDef> = new Map([
  [TOPOLOGY_ELLIPSE.id, TOPOLOGY_ELLIPSE],
  [TOPOLOGY_RECT.id, TOPOLOGY_RECT],
]);
```

**Initialization**: Module-level side effect (runs at import time)

**Lookup Function** (`src/shapes/registry.ts:31-37`):

```typescript
export function getTopology(id: TopologyId): TopologyDef {
  const topology = TOPOLOGY_REGISTRY.get(id);
  if (!topology) {
    throw new Error(`Unknown topology ID: ${id}`);
  }
  return topology;
}
```

**Registration Function** (`src/shapes/registry.ts:66-68`):

```typescript
/**
 * Register a dynamic topology (e.g., path topologies created by blocks)
 *
 * This is called during block lowering to register procedurally-created topologies.
 * If a topology with the same ID already exists, it will be replaced (idempotent).
 *
 * @param topology - Topology definition to register
 */
export function registerDynamicTopology(topology: TopologyDef | PathTopologyDef): void {
  TOPOLOGY_REGISTRY.set(topology.id, topology);
}
```

**Note**: Current implementation is **void return** (doesn't return ID). This must change.

### Built-in Topologies

**File**: `src/shapes/topologies.ts:20-35`

```typescript
export const TOPOLOGY_ELLIPSE: TopologyDef = Object.freeze({
  id: 'ellipse',  // ← String ID
  params: Object.freeze([
    { name: 'rx', type: 'float' as const, default: 0.02 },
    { name: 'ry', type: 'float' as const, default: 0.02 },
    { name: 'rotation', type: 'float' as const, default: 0 },
  ]),
  render: (ctx: CanvasRenderingContext2D, p: Record<string, number>, space: RenderSpace2D) => {
    // ... implementation ...
  },
});
```

**File**: `src/shapes/topologies.ts:48-73`

```typescript
export const TOPOLOGY_RECT: TopologyDef = Object.freeze({
  id: 'rect',  // ← String ID
  params: Object.freeze([
    { name: 'width', type: 'float' as const, default: 0.04 },
    { name: 'height', type: 'float' as const, default: 0.02 },
    { name: 'rotation', type: 'float' as const, default: 0 },
    { name: 'cornerRadius', type: 'float' as const, default: 0 },
  ]),
  render: (ctx: CanvasRenderingContext2D, p: Record<string, number>, space: RenderSpace2D) => {
    // ... implementation ...
  },
});
```

### Dynamic Topology Creation (Blocks)

**File**: `src/blocks/path-blocks.ts:32-66`

```typescript
function createPolygonTopology(sides: number): PathTopologyDef {
  if (sides < 3) {
    throw new Error(`Polygon must have at least 3 sides, got ${sides}`);
  }

  // Build verb sequence: MOVE, LINE, LINE, ..., CLOSE
  const verbs: PathVerb[] = [PathVerb.MOVE];
  for (let i = 1; i < sides; i++) {
    verbs.push(PathVerb.LINE);
  }
  verbs.push(PathVerb.CLOSE);

  // Points per verb: MOVE=1, LINE=1, CLOSE=0
  const pointsPerVerb: number[] = [1];  // MOVE
  for (let i = 1; i < sides; i++) {
    pointsPerVerb.push(1);  // LINE
  }
  pointsPerVerb.push(0);  // CLOSE

  const totalControlPoints = sides;

  return {
    id: `polygon-${sides}`,  // ← String ID generation
    params: [],
    closed: true,
    verbs,
    pointsPerVerb,
    totalControlPoints,
    render: (ctx: CanvasRenderingContext2D, params: Record<string, number>) => {
      throw new Error('PathTopologyDef render() should not be called directly - use Canvas2DRenderer');
    },
  };
}
```

**Note**: This function constructs the `id` field. After our change, it should **omit** the `id` field (registry will assign).

**Registration Call Site** (approximate location, need to verify exact line):

Somewhere in `ProceduralPolygon` block's lowering logic:

```typescript
const topology = createPolygonTopology(sides);
registerDynamicTopology(topology);  // ← Returns void currently
// Need to capture returned ID and use it
```

### Compiler IR References

**File**: `src/shapes/types.ts:78-81`

```typescript
/**
 * ShapeRef - Reference to a shape with runtime parameter slots
 *
 * Contains:
 * - topologyId: Which topology to use (compile-time constant)
 * - paramSlots: Where to find parameter values at runtime
 *
 * This is what flows through the signal/field system.
 */
export interface ShapeRef {
  readonly topologyId: TopologyId;
  readonly paramSlots: readonly number[]; // SlotRef indices
}
```

**Impact**: `ShapeRef.topologyId` will automatically change type when `TopologyId` changes (no manual update needed).

**Files Using `ShapeRef` or `TopologyId`** (from grep):
- `src/compiler/ir/types.ts` - IR node definitions
- `src/compiler/ir/IRBuilderImpl.ts` - IR construction
- `src/compiler/ir/IRBuilder.ts` - Builder interface
- `src/compiler/passes-v2/pass7-schedule.ts` - Schedule generation
- `src/runtime/ScheduleExecutor.ts` - IR execution
- `src/runtime/RenderAssembler.ts` - Shape resolution

**Expected Impact**: Compilation errors at each usage site → forces exhaustive update.

### Runtime Resolution

**File**: `src/runtime/RenderAssembler.ts:23`

```typescript
import { getTopology } from '../shapes/registry';
import type { PathTopologyDef, TopologyDef, TopologyId } from '../shapes/types';
```

**Usage**: Line numbers unknown (need to search), but `getTopology()` called to resolve topology during render assembly.

**Example Pattern** (hypothetical):

```typescript
const topology = getTopology(shapeDescriptor.topologyId);
// ... use topology to build render data ...
```

### Renderer Dispatch

**File**: `src/render/Canvas2DRenderer.ts` (exact usage unknown, need to search)

**Expected Pattern**:

```typescript
const topology = getTopology(shape.topologyId);
topology.render(ctx, params, renderSpace);
```

**Note**: Renderer may cache topology lookups or inline dispatch logic. Need to verify no hardcoded string comparisons.

---

## Target Implementation (Numeric-Based)

### Type Definition Change

**File**: `src/shapes/types.ts:16`

**Before**:
```typescript
export type TopologyId = string;
```

**After**:
```typescript
/**
 * TopologyId - Numeric identifier for a topology
 *
 * INVARIANTS:
 * - IDs 0-99: Reserved for built-in topologies
 * - IDs 100+: Assigned to dynamic topologies sequentially
 * - IDs are stable within a program execution (immutable after assignment)
 *
 * PERFORMANCE: O(1) array-indexed lookup via TOPOLOGY_REGISTRY[id]
 */
export type TopologyId = number;
```

### Registry Implementation

**File**: `src/shapes/registry.ts`

**Complete New Implementation**:

```typescript
/**
 * Topology Registry - Array-based storage for O(1) lookup
 *
 * Design:
 * - Array-indexed storage for O(1) access
 * - Reserved IDs 0-99 for built-in topologies
 * - Dynamic IDs 100+ for runtime-registered topologies
 * - Optional debug name mapping for error messages
 */

import type { TopologyId, TopologyDef, PathTopologyDef } from './types';
import { TOPOLOGY_ELLIPSE, TOPOLOGY_RECT } from './topologies';

// =============================================================================
// ID Assignment Constants
// =============================================================================

/** Built-in topology ID for ellipse */
export const TOPOLOGY_ID_ELLIPSE = 0;

/** Built-in topology ID for rect */
export const TOPOLOGY_ID_RECT = 1;

/** Starting ID for dynamic topologies */
const NEXT_DYNAMIC_ID_START = 100;

// =============================================================================
// Registry Storage
// =============================================================================

/**
 * Array-based topology registry
 *
 * INVARIANT: TOPOLOGY_REGISTRY[id] === TopologyDef with TopologyDef.id === id
 *
 * NOTE: Array may be sparse (gaps between built-ins and dynamics)
 */
const TOPOLOGY_REGISTRY: TopologyDef[] = [];

/**
 * Debug name mapping (optional)
 *
 * Maps human-readable names to numeric IDs for error messages and debugging.
 * This is NOT used for lookup (use numeric ID directly).
 */
const TOPOLOGY_BY_NAME: Map<string, TopologyId> = new Map();

/**
 * Next available dynamic topology ID
 *
 * Incremented on each call to registerDynamicTopology()
 */
let nextDynamicId = NEXT_DYNAMIC_ID_START;

// =============================================================================
// Initialization
// =============================================================================

/**
 * Initialize built-in topologies at module load
 *
 * MUST be called before any topology lookups.
 * Called automatically at module initialization.
 */
function initializeBuiltinTopologies(): void {
  // Assign numeric IDs to built-in topologies
  const ellipseWithId: TopologyDef = { ...TOPOLOGY_ELLIPSE, id: TOPOLOGY_ID_ELLIPSE };
  const rectWithId: TopologyDef = { ...TOPOLOGY_RECT, id: TOPOLOGY_ID_RECT };

  // Store at reserved indices
  TOPOLOGY_REGISTRY[TOPOLOGY_ID_ELLIPSE] = ellipseWithId;
  TOPOLOGY_REGISTRY[TOPOLOGY_ID_RECT] = rectWithId;

  // Register debug names
  TOPOLOGY_BY_NAME.set('ellipse', TOPOLOGY_ID_ELLIPSE);
  TOPOLOGY_BY_NAME.set('rect', TOPOLOGY_ID_RECT);
}

// Run initialization at module load
initializeBuiltinTopologies();

// =============================================================================
// Public API
// =============================================================================

/**
 * Get a topology definition by numeric ID
 *
 * PERFORMANCE: O(1) array index
 *
 * @param id - Numeric topology ID
 * @returns TopologyDef for the given ID
 * @throws Error if topology ID is not found or out of bounds
 */
export function getTopology(id: TopologyId): TopologyDef {
  // Bounds check
  if (id < 0 || id >= TOPOLOGY_REGISTRY.length) {
    throw new Error(`Topology ID out of bounds: ${id} (registry size: ${TOPOLOGY_REGISTRY.length})`);
  }

  const topology = TOPOLOGY_REGISTRY[id];
  if (!topology) {
    // Sparse array: slot exists but is undefined
    throw new Error(`Unassigned topology ID: ${id}`);
  }

  return topology;
}

/**
 * Check if a topology ID is registered
 *
 * @param id - Topology ID to check
 * @returns true if registered and valid, false otherwise
 */
export function hasTopology(id: TopologyId): boolean {
  return id >= 0 && id < TOPOLOGY_REGISTRY.length && TOPOLOGY_REGISTRY[id] !== undefined;
}

/**
 * Get all registered topology IDs
 *
 * @returns Array of all valid numeric topology IDs
 */
export function getAllTopologyIds(): readonly TopologyId[] {
  const ids: TopologyId[] = [];
  for (let i = 0; i < TOPOLOGY_REGISTRY.length; i++) {
    if (TOPOLOGY_REGISTRY[i] !== undefined) {
      ids.push(i);
    }
  }
  return ids;
}

/**
 * Register a dynamic topology and assign a numeric ID
 *
 * This is called during block lowering to register procedurally-created topologies.
 * The registry assigns the next available numeric ID and returns it to the caller.
 *
 * THREADING: Assumed single-threaded (no concurrent registration)
 * ID STABILITY: Once assigned, IDs never change within program execution
 *
 * @param topology - Topology definition WITHOUT 'id' field (registry assigns it)
 * @param debugName - Optional human-readable name for debugging (e.g., 'polygon-5')
 * @returns Assigned numeric topology ID
 */
export function registerDynamicTopology(
  topology: Omit<TopologyDef, 'id'>,
  debugName?: string
): TopologyId {
  const id = nextDynamicId++;

  // Construct full topology with assigned ID
  const fullTopology: TopologyDef = { ...topology, id } as TopologyDef;

  // Store at assigned index
  TOPOLOGY_REGISTRY[id] = fullTopology;

  // Register debug name if provided
  if (debugName) {
    TOPOLOGY_BY_NAME.set(debugName, id);
  }

  return id;
}

/**
 * Get topology ID by debug name (for debugging/testing only)
 *
 * DO NOT USE IN HOT PATHS. Use numeric IDs directly.
 *
 * @param name - Debug name (e.g., 'ellipse', 'polygon-5')
 * @returns Numeric topology ID, or undefined if not found
 */
export function getTopologyIdByName(name: string): TopologyId | undefined {
  return TOPOLOGY_BY_NAME.get(name);
}

/**
 * Get debug name for a topology ID (for error messages)
 *
 * @param id - Numeric topology ID
 * @returns Debug name if available, otherwise undefined
 */
export function getTopologyDebugName(id: TopologyId): string | undefined {
  for (const [name, registeredId] of TOPOLOGY_BY_NAME.entries()) {
    if (registeredId === id) {
      return name;
    }
  }
  return undefined;
}
```

### Built-in Topology Updates

**File**: `src/shapes/topologies.ts`

**Option 1: Remove `id` field entirely** (cleaner, requires registry change):

```typescript
import type { TopologyDef, RenderSpace2D } from './types';

// NOTE: 'id' field omitted - assigned by registry during initialization

export const TOPOLOGY_ELLIPSE: Omit<TopologyDef, 'id'> = Object.freeze({
  params: Object.freeze([
    { name: 'rx', type: 'float' as const, default: 0.02 },
    { name: 'ry', type: 'float' as const, default: 0.02 },
    { name: 'rotation', type: 'float' as const, default: 0 },
  ]),
  render: (ctx: CanvasRenderingContext2D, p: Record<string, number>, space: RenderSpace2D) => {
    const rxPx = p.rx * space.width * space.scale;
    const ryPx = p.ry * space.height * space.scale;
    ctx.beginPath();
    ctx.ellipse(0, 0, rxPx, ryPx, p.rotation ?? 0, 0, Math.PI * 2);
    ctx.fill();
  },
});

export const TOPOLOGY_RECT: Omit<TopologyDef, 'id'> = Object.freeze({
  params: Object.freeze([
    { name: 'width', type: 'float' as const, default: 0.04 },
    { name: 'height', type: 'float' as const, default: 0.02 },
    { name: 'rotation', type: 'float' as const, default: 0 },
    { name: 'cornerRadius', type: 'float' as const, default: 0 },
  ]),
  render: (ctx: CanvasRenderingContext2D, p: Record<string, number>, space: RenderSpace2D) => {
    const wPx = p.width * space.width * space.scale;
    const hPx = p.height * space.height * space.scale;
    const crPx = p.cornerRadius * Math.min(space.width, space.height) * space.scale;

    ctx.save();
    ctx.rotate(p.rotation ?? 0);
    if (crPx > 0) {
      ctx.beginPath();
      ctx.roundRect(-wPx / 2, -hPx / 2, wPx, hPx, crPx);
      ctx.fill();
    } else {
      ctx.fillRect(-wPx / 2, -hPx / 2, wPx, hPx);
    }
    ctx.restore();
  },
});
```

**Option 2: Keep placeholder numeric IDs** (simpler, less registry change):

```typescript
export const TOPOLOGY_ELLIPSE: TopologyDef = Object.freeze({
  id: 0,  // Placeholder - registry will overwrite
  // ... rest unchanged ...
});

export const TOPOLOGY_RECT: TopologyDef = Object.freeze({
  id: 1,  // Placeholder - registry will overwrite
  // ... rest unchanged ...
});
```

**Recommendation**: Option 1 (cleaner separation of concerns - topology definitions don't know their IDs).

### Dynamic Topology Creation Update

**File**: `src/blocks/path-blocks.ts:32-66`

**Change**: Remove `id` field from return value

```typescript
function createPolygonTopology(sides: number): Omit<PathTopologyDef, 'id'> {
  if (sides < 3) {
    throw new Error(`Polygon must have at least 3 sides, got ${sides}`);
  }

  const verbs: PathVerb[] = [PathVerb.MOVE];
  for (let i = 1; i < sides; i++) {
    verbs.push(PathVerb.LINE);
  }
  verbs.push(PathVerb.CLOSE);

  const pointsPerVerb: number[] = [1];
  for (let i = 1; i < sides; i++) {
    pointsPerVerb.push(1);
  }
  pointsPerVerb.push(0);

  const totalControlPoints = sides;

  return {
    // NO 'id' FIELD - registry will assign
    params: [],
    closed: true,
    verbs,
    pointsPerVerb,
    totalControlPoints,
    render: (ctx: CanvasRenderingContext2D, params: Record<string, number>) => {
      throw new Error('PathTopologyDef render() should not be called directly - use Canvas2DRenderer');
    },
  };
}
```

**Registration Call Site** (need to locate exact line in block lowering):

**Before**:
```typescript
const topology = createPolygonTopology(sides);
registerDynamicTopology(topology);
// ID not captured
```

**After**:
```typescript
const topology = createPolygonTopology(sides);
const topologyId: TopologyId = registerDynamicTopology(topology, `polygon-${sides}`);
// Store topologyId for use in IR emission
```

**Where to store**: Need to find where block lowering emits `ShapeRef` and ensure `topologyId` is available.

---

## Key File Locations

### Files to Modify (Priority Order)

**P0 - Core Changes** (must be in same commit):
1. `src/shapes/types.ts` - Type definition
2. `src/shapes/registry.ts` - Registry implementation
3. `src/shapes/topologies.ts` - Built-in IDs
4. `src/blocks/path-blocks.ts` - Dynamic registration

**P1 - Consumers** (follow type errors):
5. `src/compiler/ir/types.ts` - Verify type imports
6. `src/compiler/ir/IRBuilderImpl.ts` - Check for string manipulation
7. `src/compiler/ir/IRBuilder.ts` - Check for string manipulation
8. `src/compiler/passes-v2/pass7-schedule.ts` - Check for string manipulation
9. `src/runtime/RenderAssembler.ts` - Update resolution logic
10. `src/runtime/ScheduleExecutor.ts` - Verify type usage
11. `src/runtime/RuntimeState.ts` - Check for caching issues
12. `src/render/Canvas2DRenderer.ts` - Update dispatch logic

**P2 - Tests** (separate commit):
13. `src/shapes/__tests__/registry.test.ts` - New test file
14. `src/runtime/__tests__/RenderAssembler.test.ts` - Update fixtures
15. `src/shapes/__tests__/registry.bench.ts` - New benchmark file
16. `src/blocks/__tests__/path-blocks.test.ts` - Update tests
17. `src/render/__tests__/Canvas2DRenderer.test.ts` - Update tests

### Expected Compilation Errors After Type Change

**Immediate Errors** (TypeScript will flag):
- Any `TopologyId` variable assigned a string literal
- Any function call `registerDynamicTopology(topologyWithStringId)`
- Any comparison `topologyId === 'ellipse'`

**Search Patterns to Find Issues**:
```bash
# Find potential string ID usage
grep -r "'ellipse'" src/
grep -r "'rect'" src/
grep -r "'polygon" src/
grep -r "id: '" src/shapes/
grep -r 'id: `' src/shapes/

# Find topology ID comparisons
grep -r "topologyId ===" src/
grep -r "topologyId !==" src/
grep -r "switch.*topologyId" src/
```

---

## Implementation Checklist (Atomic Commit)

### Step 1: Type System

- [ ] Change `TopologyId = number` in `src/shapes/types.ts`
- [ ] Add JSDoc explaining ID allocation strategy
- [ ] Run `npm run typecheck` → expect errors

### Step 2: Registry Core

- [ ] Replace `Map` with `TopologyDef[]` in `src/shapes/registry.ts`
- [ ] Add ID constants (`TOPOLOGY_ID_ELLIPSE`, `TOPOLOGY_ID_RECT`)
- [ ] Implement `initializeBuiltinTopologies()`
- [ ] Update `getTopology()` for array indexing
- [ ] Update `hasTopology()` for bounds checking
- [ ] Update `getAllTopologyIds()` for array iteration
- [ ] Change `registerDynamicTopology()` signature to return `TopologyId`
- [ ] Add `TOPOLOGY_BY_NAME` mapping
- [ ] Add `getTopologyIdByName()` debug helper
- [ ] Add `getTopologyDebugName()` debug helper

### Step 3: Built-in Topologies

- [ ] Update `TOPOLOGY_ELLIPSE` (remove `id` or set to 0)
- [ ] Update `TOPOLOGY_RECT` (remove `id` or set to 1)
- [ ] Update registry initialization to assign IDs
- [ ] Export ID constants from registry

### Step 4: Block System

- [ ] Update `createPolygonTopology()` return type to `Omit<PathTopologyDef, 'id'>`
- [ ] Remove `id` field from returned object
- [ ] Find block lowering call site for `registerDynamicTopology()`
- [ ] Capture returned `TopologyId` and store for IR emission
- [ ] Verify other blocks using `registerDynamicTopology()` (should be none)

### Step 5: Compiler IR

- [ ] Run `npm run typecheck` and follow errors
- [ ] For each error in compiler files, verify no string manipulation
- [ ] Ensure `ShapeRef` propagates numeric ID correctly
- [ ] Verify IR builder passes through numeric IDs

### Step 6: Runtime

- [ ] Verify `RenderAssembler.ts` passes numeric IDs to `getTopology()`
- [ ] Check `ScheduleExecutor.ts` for type usage
- [ ] Check `RuntimeState.ts` for topology ID caching (should be none)

### Step 7: Renderer

- [ ] Verify `Canvas2DRenderer.ts` calls `getTopology()` with numeric ID
- [ ] Check for switch statements on topology IDs (should be none)
- [ ] Verify dispatch logic doesn't assume string IDs

### Step 8: Verification

- [ ] Run `npm run typecheck` → should pass
- [ ] Run `npm run build` → should succeed
- [ ] Run `npm run test` → expect failures (tests need updates)

### Step 9: Test Updates (Separate Commit)

- [ ] Create `src/shapes/__tests__/registry.test.ts`
- [ ] Update `src/runtime/__tests__/RenderAssembler.test.ts`
- [ ] Update block tests if they exist
- [ ] Update renderer tests if they exist
- [ ] Run `npm run test` → should pass

### Step 10: Performance Validation (Optional Commit)

- [ ] Create `src/shapes/__tests__/registry.bench.ts`
- [ ] Run benchmark and document results

---

## Testing Strategy

### Unit Tests (New File)

**File**: `src/shapes/__tests__/registry.test.ts`

```typescript
import { describe, test, expect } from 'vitest';
import {
  getTopology,
  hasTopology,
  getAllTopologyIds,
  registerDynamicTopology,
  getTopologyIdByName,
  getTopologyDebugName,
  TOPOLOGY_ID_ELLIPSE,
  TOPOLOGY_ID_RECT,
} from '../registry';
import type { TopologyDef, PathTopologyDef } from '../types';

describe('Topology Registry (Numeric IDs)', () => {
  describe('Built-in Topologies', () => {
    test('ellipse has ID 0', () => {
      expect(TOPOLOGY_ID_ELLIPSE).toBe(0);
      const topology = getTopology(TOPOLOGY_ID_ELLIPSE);
      expect(topology).toBeDefined();
      expect(topology.id).toBe(0);
    });

    test('rect has ID 1', () => {
      expect(TOPOLOGY_ID_RECT).toBe(1);
      const topology = getTopology(TOPOLOGY_ID_RECT);
      expect(topology).toBeDefined();
      expect(topology.id).toBe(1);
    });

    test('built-ins retrievable by debug name', () => {
      expect(getTopologyIdByName('ellipse')).toBe(0);
      expect(getTopologyIdByName('rect')).toBe(1);
    });

    test('built-ins have debug names', () => {
      expect(getTopologyDebugName(0)).toBe('ellipse');
      expect(getTopologyDebugName(1)).toBe('rect');
    });
  });

  describe('Dynamic Registration', () => {
    test('assigns IDs starting at 100', () => {
      const id = registerDynamicTopology({
        params: [],
        closed: true,
        verbs: [],
        pointsPerVerb: [],
        totalControlPoints: 0,
        render: () => {},
      } as Omit<PathTopologyDef, 'id'>, 'test-topology');

      expect(id).toBeGreaterThanOrEqual(100);
      expect(getTopology(id)).toBeDefined();
    });

    test('assigns sequential IDs', () => {
      const id1 = registerDynamicTopology({
        params: [],
        closed: true,
        verbs: [],
        pointsPerVerb: [],
        totalControlPoints: 0,
        render: () => {},
      } as Omit<PathTopologyDef, 'id'>, 'seq-1');

      const id2 = registerDynamicTopology({
        params: [],
        closed: true,
        verbs: [],
        pointsPerVerb: [],
        totalControlPoints: 0,
        render: () => {},
      } as Omit<PathTopologyDef, 'id'>, 'seq-2');

      expect(id2).toBe(id1 + 1);
    });

    test('stores debug name', () => {
      const id = registerDynamicTopology({
        params: [],
        closed: true,
        verbs: [],
        pointsPerVerb: [],
        totalControlPoints: 0,
        render: () => {},
      } as Omit<PathTopologyDef, 'id'>, 'named-topology');

      expect(getTopologyIdByName('named-topology')).toBe(id);
      expect(getTopologyDebugName(id)).toBe('named-topology');
    });

    test('works without debug name', () => {
      const id = registerDynamicTopology({
        params: [],
        closed: true,
        verbs: [],
        pointsPerVerb: [],
        totalControlPoints: 0,
        render: () => {},
      } as Omit<PathTopologyDef, 'id'>);

      expect(getTopology(id)).toBeDefined();
      expect(getTopologyDebugName(id)).toBeUndefined();
    });
  });

  describe('Lookup Operations', () => {
    test('getTopology throws on invalid ID', () => {
      expect(() => getTopology(999)).toThrow('out of bounds');
      expect(() => getTopology(-1)).toThrow();
    });

    test('getTopology throws on unassigned ID', () => {
      expect(() => getTopology(50)).toThrow('Unassigned topology');
    });

    test('hasTopology returns correct results', () => {
      expect(hasTopology(0)).toBe(true);  // ellipse
      expect(hasTopology(1)).toBe(true);  // rect
      expect(hasTopology(50)).toBe(false); // unassigned
      expect(hasTopology(-1)).toBe(false); // out of bounds
      expect(hasTopology(999)).toBe(false); // out of bounds
    });

    test('getAllTopologyIds returns only assigned IDs', () => {
      const ids = getAllTopologyIds();
      expect(ids).toContain(0); // ellipse
      expect(ids).toContain(1); // rect
      expect(ids.length).toBeGreaterThanOrEqual(2);

      // All returned IDs should be valid
      ids.forEach(id => {
        expect(hasTopology(id)).toBe(true);
      });
    });
  });

  describe('Debug Helpers', () => {
    test('getTopologyIdByName returns undefined for unknown name', () => {
      expect(getTopologyIdByName('nonexistent')).toBeUndefined();
    });

    test('getTopologyDebugName returns undefined for unknown ID', () => {
      expect(getTopologyDebugName(999)).toBeUndefined();
    });
  });
});
```

### Performance Benchmark (Optional)

**File**: `src/shapes/__tests__/registry.bench.ts`

```typescript
import { describe, test } from 'vitest';
import { getTopology, TOPOLOGY_ID_ELLIPSE, TOPOLOGY_ID_RECT } from '../registry';

describe('Topology Lookup Performance', () => {
  test('1M lookups complete quickly', () => {
    const iterations = 1_000_000;

    // Warm up
    for (let i = 0; i < 1000; i++) {
      getTopology(TOPOLOGY_ID_ELLIPSE);
    }

    const start = performance.now();
    for (let i = 0; i < iterations; i++) {
      getTopology(i % 2 === 0 ? TOPOLOGY_ID_ELLIPSE : TOPOLOGY_ID_RECT);
    }
    const duration = performance.now() - start;

    console.log(`${iterations} topology lookups in ${duration.toFixed(2)}ms`);
    console.log(`Average: ${(duration / iterations * 1000).toFixed(3)}µs per lookup`);

    // Baseline assertion: should be sub-millisecond average
    expect(duration).toBeLessThan(100);
  });
});
```

---

## Common Pitfalls

### 1. Forgetting to Capture Returned ID

**Wrong**:
```typescript
registerDynamicTopology(topology);
// ID lost!
```

**Right**:
```typescript
const topologyId = registerDynamicTopology(topology, 'debug-name');
// Store topologyId for later use
```

### 2. Sparse Array Assumptions

**Wrong**:
```typescript
for (let i = 0; i < TOPOLOGY_REGISTRY.length; i++) {
  processTopology(TOPOLOGY_REGISTRY[i]); // Might be undefined!
}
```

**Right**:
```typescript
for (let i = 0; i < TOPOLOGY_REGISTRY.length; i++) {
  const topology = TOPOLOGY_REGISTRY[i];
  if (topology !== undefined) {
    processTopology(topology);
  }
}
```

### 3. Hardcoded String Comparisons

**Wrong**:
```typescript
if (topology.id === 'ellipse') { ... }
```

**Right**:
```typescript
if (topology.id === TOPOLOGY_ID_ELLIPSE) { ... }
```

### 4. Type Escape Hatches

**Wrong**:
```typescript
const id = 'ellipse' as any as TopologyId; // NEVER DO THIS
```

**Right**: Let compilation fail and fix the root cause.

---

## Debug Techniques

### Inspect Registry State

```typescript
// In dev console or debug hook:
console.table(TOPOLOGY_REGISTRY.map((t, idx) => ({
  id: idx,
  defined: t !== undefined,
  name: t ? getTopologyDebugName(idx) : undefined,
})));
```

### Pretty-Print Topology ID

```typescript
function formatTopologyId(id: TopologyId): string {
  const name = getTopologyDebugName(id);
  return name ? `${id} (${name})` : `${id}`;
}

console.log(`Rendering shape with topology ${formatTopologyId(shape.topologyId)}`);
```

### Verify ID Stability

```typescript
// Before change:
const beforeTopology = getTopology('ellipse');

// After change:
const afterTopology = getTopology(TOPOLOGY_ID_ELLIPSE);

// Should be same definition
expect(beforeTopology.params).toEqual(afterTopology.params);
```

---

## Success Criteria Summary

1. **Type Safety**: All `TopologyId` usage is `number` (no escape hatches)
2. **Compilation**: `npm run typecheck` passes
3. **Tests**: `npm run test` passes with updated fixtures
4. **Rendering**: Visual output unchanged (shapes render correctly)
5. **Performance**: No regression (lookup faster or neutral)
6. **Debug Experience**: Error messages include both ID and name when available

---

## Additional Notes

### Why Not Use Enums?

**Considered**:
```typescript
enum TopologyId {
  ELLIPSE = 0,
  RECT = 1,
  // Dynamic IDs would need runtime extension...
}
```

**Rejected**: Enums don't support dynamic runtime extension. TypeScript enums are compile-time constructs.

### Why Start Dynamic IDs at 100?

- Reserves 0-99 for future built-in topologies
- Ensures no collision between built-ins and dynamics
- Leaves room for growth without breaking existing IDs

### Why Not Compact Array?

**Could compact** by tracking free slots and reusing IDs after unregistration.

**Don't compact** because:
- Topologies are never unregistered (lifetime = program execution)
- Sparse array overhead is negligible (few dozen topologies max)
- Simpler implementation (no free list management)

### Why Optional Debug Names?

**Could require** debug names for all topologies.

**Don't require** because:
- Built-in topologies have well-known IDs (can hardcode names in registry)
- Dynamic topologies may be internal/temporary
- Name collision handling adds complexity

### Future: Serialization Strategy

**When saving programs**:
- Serialize topology definitions (verbs, params, etc.)
- Use debug names as stable identifiers in JSON
- On load, reconstruct registry and assign new numeric IDs
- Update IR references to new IDs

**Not implemented yet** - defer to future work.

---

## Conclusion

This is a **type-safe, breaking change** that forces exhaustive updates via compilation errors. The implementation is mechanical:

1. Change type definition
2. Update registry storage
3. Follow type errors
4. Write tests
5. Verify rendering

The type system ensures completeness - if it compiles, it's correct.
