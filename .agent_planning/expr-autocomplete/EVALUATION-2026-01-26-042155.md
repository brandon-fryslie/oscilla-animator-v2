# Evaluation: IDE-Style Autocomplete for Expression Editor

**Timestamp:** 2026-01-26-042155
**Git Commit:** 21e77d1
**Evaluator:** project-evaluator

## Executive Summary

**Overall:** 0% complete (feature not started)
**Critical Issues:** 0 (greenfield feature)
**Tests Reliable:** N/A (no tests yet)
**Feasibility:** HIGH - all data sources exist, clear integration path

## Current State Analysis

### Expression DSL Infrastructure (EXISTING)

The expression DSL in `src/expr/` is mature and complete:

1. **Lexer** (`src/expr/lexer.ts:1-286`)
   - Full tokenization with position tracking
   - Token types: NUMBER, IDENT, operators, DOT (for member access)
   - Already supports incremental use (can tokenize partial input)

2. **Parser** (`src/expr/parser.ts`)
   - Recursive descent parser
   - AST includes position information for error reporting
   - Member access expressions: `Block.port` syntax

3. **Type Checker** (`src/expr/typecheck.ts:1-701`)
   - `FUNCTION_SIGNATURES` object at line 82 - contains ALL built-in functions
   - `TypeEnv` for input variables
   - `BlockReferenceContext` for resolving `Block.port` references
   - Already has `findClosestMatch()` function (line 656) for fuzzy matching

4. **Built-in Functions** (16 total, from `FUNCTIONS.md`)
   - Trigonometric: `sin`, `cos`, `tan`
   - Unary: `abs`, `sqrt`, `floor`, `ceil`, `round`
   - Binary: `min`, `max`
   - Interpolation: `lerp`, `mix`, `smoothstep`, `clamp`
   - Phase: `wrap`, `fract`

### Expression Block Integration (EXISTING)

From `src/blocks/expression-blocks.ts`:
- Fixed inputs: `in0`, `in1`, `in2`, `in3`, `in4`
- Expression text stored in `config.expression`
- Compilation happens during block lowering

### Current UI (`src/ui/components/BlockInspector.tsx`)

The `ExpressionEditor` component (lines 1778-1872):
- Basic `<textarea>` with monospace font
- Character limit (500)
- Error display from diagnostics
- NO autocomplete support

### Data Sources for Autocomplete (ALL AVAILABLE)

| Source | Location | Access Method |
|--------|----------|---------------|
| Built-in functions | `typecheck.ts:82` `FUNCTION_SIGNATURES` | Export object keys |
| Input variables | Expression block definition | `['in0', 'in1', 'in2', 'in3', 'in4']` |
| Block references | `AddressRegistry` | `resolveShorthand()` + iteration |
| Block ports | `Patch.blocks` | Iterate blocks, access outputPorts |

### Address Registry (EXISTING - Sprint 1 of varargs)

From `src/graph/address-registry.ts`:
```typescript
class AddressRegistry {
  resolve(address: string): ResolvedAddress | null
  resolveShorthand(shorthand: string): CanonicalAddress | null
  get size: number
  get shorthandCount: number
}
```

This provides O(1) lookup of `Block.port` references - perfect for autocomplete validation.

## Feature Requirements Breakdown

### R1: Suggestion Data Collection

**What to suggest:**

1. **Built-in Functions** (static, 16 items)
   - Source: `FUNCTION_SIGNATURES` keys
   - Format: `sin(`, `cos(`, `lerp(` (with opening paren)
   - Include: signature hints in tooltip

2. **Input Variables** (semi-static, 5 items)
   - Source: `['in0', 'in1', 'in2', 'in3', 'in4']`
   - Condition: Only show connected inputs (check edge state)
   - Format: `in0`, `in1`, etc.

3. **Block References** (dynamic from patch)
   - Source: Patch blocks with outputs
   - Format: `BlockName.` (trigger port completion)
   - After dot: `BlockName.portName`

4. **Operators** (optional, low priority)
   - `+`, `-`, `*`, `/`, `%`, `?:`, `&&`, `||`, etc.

**Confidence:** HIGH - All sources identified and accessible

### R2: Trigger Conditions

**When to show suggestions:**

| Trigger | Behavior | Priority |
|---------|----------|----------|
| After typing `[a-zA-Z]` | Start identifier completion | P0 |
| After typing `.` | Show port completion for block | P0 |
| On `Ctrl+Space` | Force show all suggestions | P1 |
| After `(` | Show argument hints for function | P2 |

**Implementation approach:** Keystroke-based with debounce (50-100ms)

**Confidence:** HIGH - Standard editor behavior

### R3: Suggestion Ranking

1. **Exact prefix match** - highest score
2. **Fuzzy match** - use existing `findClosestMatch()`
3. **Connected inputs** - boost over unconnected
4. **Recently used** - optional future enhancement

**Confidence:** HIGH - Existing fuzzy matching can be reused

### R4: UI Display

**Options analyzed:**

| Option | Pros | Cons | Effort |
|--------|------|------|--------|
| Custom dropdown | Full control, lightweight | Build from scratch | Medium |
| Monaco Editor | Rich features, proven | ~2MB bundle, overkill | Low-Medium |
| CodeMirror 6 | Modular, ~200KB | New dependency | Medium |
| Headless autocomplete lib | Tiny, composable | Still need UI | Low |

**Recommendation:** Custom dropdown component

Rationale:
- Expression syntax is simple (no highlighting needed beyond error underlines)
- Existing `<textarea>` works well
- Full control over styling (matches dark theme)
- No new dependencies
- ~200-300 lines of React code

**Confidence:** MEDIUM - UI work always has unknowns

### R5: Integration Points

1. **ExpressionEditor component** (`BlockInspector.tsx:1778`)
   - Add autocomplete state and handlers
   - Position dropdown relative to cursor

2. **Suggestion provider service** (NEW)
   - Collect and filter suggestions
   - Handle context (after dot, start of identifier, etc.)

3. **Patch subscription** (for dynamic blocks)
   - Re-collect block list when patch changes
   - MobX observable already available via stores

## Implementation Options

### Option A: Minimal Custom Implementation

**Components:**
1. `ExpressionAutocomplete.tsx` - Dropdown UI component
2. `suggestion-provider.ts` - Data collection and filtering
3. Modify `ExpressionEditor` - Add trigger handling

**Effort:** 1-2 sprints
**Risk:** LOW
**Bundle impact:** +5-10KB

### Option B: CodeMirror 6 Integration

**Components:**
1. Replace `<textarea>` with CodeMirror editor
2. Write CM6 completion source
3. Add Oscilla theme

**Effort:** 2-3 sprints
**Risk:** MEDIUM (new library integration)
**Bundle impact:** +150-300KB

### Option C: Monaco Editor Integration

**Components:**
1. Replace `<textarea>` with Monaco
2. Define Oscilla language
3. Write completion provider

**Effort:** 2-3 sprints
**Risk:** MEDIUM
**Bundle impact:** +2MB (!!)

## Recommended Approach

**Option A: Minimal Custom Implementation**

Why:
- Expression DSL is simple (no syntax highlighting needed)
- All data sources already exist
- Maintains lightweight bundle
- Full control over UX
- Can always migrate to CodeMirror later if needed

### Implementation Roadmap

**Sprint 1: Core Infrastructure (1 sprint)**
- Create `SuggestionProvider` service
- Export `FUNCTION_SIGNATURES` from typecheck.ts (add accessor)
- Build suggestion data model
- Unit tests for suggestion filtering

**Sprint 2: UI Component (1 sprint)**
- Create `AutocompleteDropdown` component
- Keyboard navigation (up/down/enter/escape)
- Position calculation relative to cursor
- Integration with ExpressionEditor

**Sprint 3: Context-Aware Completion (1 sprint)**
- After-dot completion for block ports
- Connected input detection
- Function argument hints (tooltip)

## Confidence Assessment

| Component | Confidence | Notes |
|-----------|------------|-------|
| Data collection | HIGH | All sources exist |
| Trigger detection | HIGH | Standard patterns |
| Filtering/ranking | HIGH | Existing fuzzy match |
| Dropdown UI | MEDIUM | React, but positioning tricky |
| Cursor position | MEDIUM | textarea cursor coords nontrivial |
| Block.port context | HIGH | AddressRegistry exists |
| Performance | HIGH | Small dataset (<100 items) |

**Overall Confidence:** 80%

## Risks and Mitigations

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Textarea cursor position | Medium | Medium | Use `selectionStart` + hidden measurement div |
| Dropdown focus management | Low | Medium | Standard React patterns exist |
| MobX reactivity conflicts | Low | Low | Use computed values, not effects |
| Performance with many blocks | Low | Low | Lazy filtering, debounce |

## Missing Checks / Future Work

1. **Accessibility** - Keyboard navigation, ARIA attributes
2. **Mobile support** - Touch-friendly dropdown (lower priority)
3. **Undo integration** - Ensure autocomplete insertions are undoable
4. **Multi-line expressions** - Current textarea supports this

## Ambiguities Found

| Area | Question | Suggested Resolution | Impact |
|------|----------|---------------------|--------|
| Unconnected inputs | Show `in0` even if not wired? | Show all, gray out unconnected | Low |
| Block filtering | Which blocks to show? | Only those with outputs, non-system | Low |
| Function signatures | Show full signature or just name? | Name in list, signature in tooltip | Low |
| Partial expressions | Complete `si` to `sin(`? | Yes, include opening paren | Low |

## Verdict

- [x] **CONTINUE** - Feature well-scoped, all prerequisites exist

## Recommendations

1. **Start with Sprint 1** - Build suggestion provider, validate data sources
2. **Export FUNCTION_SIGNATURES** - Add accessor in typecheck.ts
3. **Keep it simple** - Custom dropdown, not a full editor
4. **Test incrementally** - Unit tests for provider, integration tests for UI
5. **Consider future migration** - Design API so CodeMirror could slot in later

---

## Final Output

```
CHECKMARK project-evaluator complete
  Scope: expr-autocomplete | Completion: 0% | Gaps: 0 (greenfield)
  Workflow: CONTINUE
  -> Start Sprint 1: Build SuggestionProvider service, export FUNCTION_SIGNATURES
```
