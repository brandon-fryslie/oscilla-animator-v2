# Exploration Output: Hash-consing (I13)
Timestamp: 2026-01-28-064128
Agent: explore (haiku)

Perfect! Now I have all the information. Let me compile a comprehensive report:

## Hash-Consing (I13) — Structural Sharing via ExprId Canonicalization

### 1. SPEC REFERENCES

**File**: `/Users/bmf/code/oscilla-animator-v2/design-docs/CANONICAL-oscilla-v2.5-20260109/INVARIANTS.md`

**Lines 188-197** — I13 Specification:

```markdown
### I13: Structural Sharing / Hash-Consing

**Rule**: Identical FieldExpr/SignalExpr subtrees share an ExprId.

**Rationale**: Without canonicalization, compilation and runtime explode.

**Consequences of Violation**: Duplicate computation; memory bloat.

**Enforcement**: Hash-consing in expr construction.
```

**Requirement Level**: **MUST** (non-negotiable invariant)

---

### 2. CURRENT ExprId GENERATION

**File**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/IRBuilderImpl.ts`

**Lines 109-143** — Sequential ID generation (NO hash-consing):

```typescript
sigConst(value: number | string | boolean, type: CanonicalType): SigExprId {
  const id = sigExprId(this.sigExprs.length);  // Sequential: 0, 1, 2, ...
  this.sigExprs.push({ kind: 'const', value, type });
  return id;
}

sigTime(which: '...' , type: CanonicalType): SigExprId {
  const id = sigExprId(this.sigExprs.length);  // Sequential append
  this.sigExprs.push({ kind: 'time', which, type });
  return id;
}

sigMap(input: SigExprId, fn: PureFn, type: CanonicalType): SigExprId {
  const id = sigExprId(this.sigExprs.length);  // Sequential append
  this.sigExprs.push({ kind: 'map', input, fn, type });
  return id;
}

sigZip(inputs: readonly SigExprId[], fn: PureFn, type: CanonicalType): SigExprId {
  const id = sigExprId(this.sigExprs.length);  // Sequential append
  this.sigExprs.push({ kind: 'zip', inputs, fn, type });
  return id;
}
```

**Status**: IDs are **strictly sequential** by array length. No deduplication logic exists. Each `sig*()` or `field*()` call always creates a new entry.

---

### 3. EXPRESSION STRUCTURE

**File**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/types.ts`

**Lines 84-94** — SigExpr Union:

```typescript
export type SigExpr =
  | SigExprConst
  | SigExprSlot
  | SigExprTime
  | SigExprExternal
  | SigExprMap
  | SigExprZip
  | SigExprStateRead
  | SigExprShapeRef
  | SigExprReduceField
  | SigExprEventRead;

export interface SigExprConst {
  readonly kind: 'const';
  readonly value: number | string | boolean;
  readonly type: CanonicalType;
}

export interface SigExprMap {
  readonly kind: 'map';
  readonly input: SigExprId;           // Can reference another expr
  readonly fn: PureFn;                  // Function (opcode or kernel)
  readonly type: CanonicalType;
}

export interface SigExprZip {
  readonly kind: 'zip';
  readonly inputs: readonly SigExprId[];  // Multiple input exprs
  readonly fn: PureFn;
  readonly type: CanonicalType;
}
```

**Lines 213-223** — FieldExpr Union:

```typescript
export type FieldExpr =
  | FieldExprConst
  | FieldExprIntrinsic
  | FieldExprBroadcast
  | FieldExprMap
  | FieldExprZip
  | FieldExprZipSig
  | FieldExprArray
  | FieldExprStateRead
  | FieldExprPathDerivative
  | FieldExprPlacement;

export interface FieldExprZip {
  readonly kind: 'zip';
  readonly inputs: readonly FieldExprId[];  // Multiple field exprs
  readonly fn: PureFn;
  readonly type: CanonicalType;
  readonly instanceId?: InstanceId;
}
```

**Hashable Fields**: `kind`, `value`/`input`/`inputs`, `fn`, `type`, optional `instanceId`

---

### 4. DUPLICATE EXPRESSION EVIDENCE

**File**: `/Users/bmf/code/oscilla-animator-v2/.agent_planning/gap-analysis/unimplemented/topic-04-compilation.md`

**Lines 24-28** — Gap Analysis Report:

```markdown
### U-17: Hash-consing (I13)
**Spec requirement**: Structural sharing via ExprId canonicalization. 
Identical sub-expressions share evaluation.
**Evidence of absence**: No deduplication of expression IDs in IRBuilderImpl
```

**Example scenario**: Two blocks computing `sigConst(1.0, FLOAT)` will generate **two different SigExprIds** (sequential) even though they represent identical expressions.

```typescript
// Current behavior (no hash-consing):
const expr1 = builder.sigConst(1.0, FLOAT);  // id=5
const expr2 = builder.sigConst(1.0, FLOAT);  // id=6 (NEW, should be 5)
```

---

### 5. RELATED CODE

**No existing deduplication found** — Grep across `/src/compiler/ir/` returns:

- ✅ `FrameCache` exists for **signal evaluation caching** at runtime (memoization by frame)
- ✅ `Map<string, SigExprId>` used in expression compilation for variable lookups
- ✅ `sigValues` array stores computed scalar values per frame
- ❌ **No hash map of seen expressions**
- ❌ **No canonicalization pass**
- ❌ **No equality operators for Expr types**

**File**: `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/Indices.ts`

**Lines 28-35** — Dense Index Types (support structure exists):

```typescript
/** Dense index for signal expressions. */
export type SigExprId = number & { readonly __brand: 'SigExprId' };

/** Dense index for field expressions. */
export type FieldExprId = number & { readonly __brand: 'FieldExprId' };

/** Dense index for event expressions. */
export type EventExprId = number & { readonly __brand: 'EventExprId' };
```

These branded types are designed for dense arrays, perfect for hash-consing implementation.

---

### SUMMARY

| Aspect | Status |
|--------|--------|
| **Spec Requirement** | I13 MUST-level invariant in INVARIANTS.md |
| **Current Implementation** | Sequential assignment only; no canonicalization |
| **Deduplication Logic** | **NOT IMPLEMENTED** — U-17 in unimplemented gap list |
| **Hash/Equality Methods** | None exist for Expr types |
| **Memoization Pattern** | Only per-frame signal evaluation cache (runtime) |
| **Impact if Violated** | Duplicate computation, memory bloat |

**Next Step**: Implement hash-consing in `IRBuilderImpl` via expression memoization map before expr insertion into dense arrays.
