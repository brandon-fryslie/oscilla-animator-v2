# Sprint 3 Continuity Implementation Plan

**Created:** 2026-01-19
**Status:** IN PROGRESS
**Spec Reference:** design-docs/CANONICAL-oscilla-v2.5-20260109/topics/11-continuity-system.md

---

## Executive Summary

This sprint implements the three remaining continuity TODO items:

1. **continuityMapBuild step** (ScheduleExecutor.ts:237) - Domain change detection and mapping
2. **continuityApply step** (ScheduleExecutor.ts:244) - Gauge/slew application
3. **crossfade policy** (ContinuityApply.ts:312) - Buffer blending for unmappable cases

The foundational work is **already complete**:
- ✅ `ContinuityApply.ts` - gauge and slew algorithms fully tested
- ✅ `ContinuityMapping.ts` - byId and byPosition mapping algorithms
- ✅ `ContinuityState.ts` - state management and stable target IDs
- ✅ `DomainIdentity.ts` - element ID generation
- ✅ `ContinuityDefaults.ts` - policy defaults per semantic

We need to **wire up** the existing components in ScheduleExecutor and **implement crossfade**.

---

## Deliverables

### D1: Implement crossfade policy (ContinuityApply.ts)

**Spec:** §3.7 - Crossfade (Fallback When Identity Broken)

**Requirements:**
- Blend old effective buffer with new base buffer over time window
- Formula: `X_out[i] = lerp(X_old_eff[i], X_new_base[i], w(t))`
- Support smoothstep and linear curves
- Track crossfade start time per target
- Complete blending when w >= 1.0

**State additions needed:**
- `crossfadeStartMs?: number` in TargetContinuityState
- `oldEffectiveBuffer?: Float32Array` for blending source

### D2: Implement continuityMapBuild step (ScheduleExecutor.ts)

**Spec:** §5.1 - StepContinuityMapBuild

**Requirements:**
- Detect domain changes by comparing new domain to prevDomains
- Build mapping (byId, byPosition, or null for crossfade)
- Store mapping in `state.continuity.mappings`
- Set `state.continuity.domainChangeThisFrame = true` on change
- Update `state.continuity.prevDomains` for next frame

### D3: Implement continuityApply step (ScheduleExecutor.ts)

**Spec:** §5.1 - StepContinuityApply

**Requirements:**
- Get base buffer from materialized slot
- Call `applyContinuity()` with step parameters
- Handle timing (tModelMs, dtMs)

---

## Implementation Steps

### Step 1: Extend ContinuityState for crossfade

Add crossfade tracking fields to `TargetContinuityState`:

```typescript
interface TargetContinuityState {
  gaugeBuffer: Float32Array;
  slewBuffer: Float32Array;
  count: number;
  // NEW: Crossfade support
  crossfadeStartMs?: number;           // When crossfade began
  crossfadeOldBuffer?: Float32Array;   // Snapshot of old effective values
}
```

### Step 2: Implement crossfade in ContinuityApply.ts

Replace the stub with:

```typescript
case 'crossfade': {
  const { windowMs, curve } = policy;
  const tModelMs = state.time?.tMs ?? 0;

  // On domain change, snapshot the old effective values
  if (state.continuity.domainChangeThisFrame) {
    // Save old values and start crossfade
    targetState.crossfadeOldBuffer = new Float32Array(baseBuffer.length);
    // Copy current output (effective) to old buffer
    if (targetState.slewBuffer.length === baseBuffer.length) {
      targetState.crossfadeOldBuffer.set(targetState.slewBuffer);
    } else {
      targetState.crossfadeOldBuffer.set(baseBuffer);
    }
    targetState.crossfadeStartMs = tModelMs;
  }

  // Compute blend weight
  const startMs = targetState.crossfadeStartMs ?? tModelMs;
  const elapsed = tModelMs - startMs;
  const t = Math.min(1.0, elapsed / windowMs);
  const w = curve === 'smoothstep' ? smoothstep(t) : t;

  if (w >= 1.0 || !targetState.crossfadeOldBuffer) {
    // Crossfade complete or not initialized
    if (outputBuffer !== baseBuffer) {
      outputBuffer.set(baseBuffer);
    }
  } else {
    // Blend old and new
    const oldBuffer = targetState.crossfadeOldBuffer;
    for (let i = 0; i < count; i++) {
      outputBuffer[i] = lerp(oldBuffer[i], baseBuffer[i], w);
    }
  }
  break;
}
```

Add helper functions:
```typescript
function smoothstep(t: number): number {
  return t * t * (3 - 2 * t);
}

function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}
```

### Step 3: Wire up continuityMapBuild step

In ScheduleExecutor.ts:

```typescript
case 'continuityMapBuild': {
  const { instanceId } = step;

  // Get current domain from instances map
  const instance = instances.get(instanceId);
  if (!instance) break;

  // Create DomainInstance from InstanceDecl
  const newDomain: DomainInstance = {
    count: typeof instance.count === 'number' ? instance.count : 0,
    elementId: instance.elementId ?? new Uint32Array(0),
    identityMode: instance.identityMode ?? 'none',
    posHintXY: instance.posHintXY,
  };

  // Detect domain change and compute mapping
  const { changed, mapping } = detectDomainChange(
    instanceId,
    newDomain,
    state.continuity.prevDomains
  );

  if (changed) {
    // Store mapping (may be null for crossfade fallback)
    if (mapping) {
      state.continuity.mappings.set(instanceId, mapping);
    } else {
      state.continuity.mappings.delete(instanceId);
    }
    state.continuity.domainChangeThisFrame = true;
  }

  // Update prevDomains for next comparison
  state.continuity.prevDomains.set(instanceId, newDomain);
  break;
}
```

### Step 4: Wire up continuityApply step

In ScheduleExecutor.ts:

```typescript
case 'continuityApply': {
  const { targetKey, instanceId, policy, baseSlot, outputSlot, semantic } = step;

  // Skip if policy is 'none'
  if (policy.kind === 'none') break;

  // Get base buffer from materialized values
  const baseBuffer = state.values.objects.get(baseSlot) as Float32Array | undefined;
  if (!baseBuffer) {
    throw new Error(`Base buffer not found for slot ${baseSlot}`);
  }

  // Apply continuity
  applyContinuity(
    step,
    state,
    (slot: ValueSlot) => {
      const buffer = state.values.objects.get(slot) as Float32Array | undefined;
      if (!buffer) {
        throw new Error(`Buffer not found for slot ${slot}`);
      }
      return buffer;
    }
  );
  break;
}
```

### Step 5: Add finalizeContinuityFrame call

At the end of executeFrame (before returning):

```typescript
// Finalize continuity frame
finalizeContinuityFrame(state);
```

---

## Files to Modify

1. **src/runtime/ContinuityState.ts**
   - Add crossfade fields to TargetContinuityState

2. **src/runtime/ContinuityApply.ts**
   - Implement crossfade case
   - Add smoothstep and lerp helpers

3. **src/runtime/ScheduleExecutor.ts**
   - Implement continuityMapBuild case
   - Implement continuityApply case
   - Add finalizeContinuityFrame call
   - Add import for detectDomainChange
   - Add import for applyContinuity

4. **src/compiler/ir/types.ts** (if needed)
   - Ensure InstanceDecl has elementId, identityMode, posHintXY

---

## Test Plan

### Unit Tests (ContinuityApply.test.ts)

1. **Crossfade basic blend**
   - Verify lerp formula: `out = a + (b-a)*w`
   - Verify smoothstep curve

2. **Crossfade initialization on domain change**
   - domainChangeThisFrame=true triggers snapshot
   - Old buffer captured correctly

3. **Crossfade completion**
   - w >= 1.0 passes through base

4. **Crossfade multiple frames**
   - Blend progresses over windowMs

### Integration Tests

1. **Full pipeline with continuityMapBuild + continuityApply**
   - Domain change detected
   - Mapping computed
   - Policy applied
   - Output buffer updated

2. **Crossfade fallback when mapping null**
   - identityMode='none' triggers crossfade

---

## Verification Criteria

1. All existing continuity tests pass
2. New crossfade tests pass
3. No TypeScript errors
4. executeFrame with continuity steps produces smooth output
5. domainChangeThisFrame flag propagates correctly

---

## Dependencies

- InstanceDecl must have: elementId, identityMode, posHintXY
- ScheduleIR must include instances Map
- RuntimeState must have continuity state initialized
