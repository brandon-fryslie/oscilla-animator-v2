# Implementation Context: UI Features v2 - Phase 2

**For**: Implementing agent with write-only access
**Plan**: PLAN-20260110-001500.md

## Critical Understanding: Connection Matrix

The Table View is a **connection matrix**, NOT a list with columns.

```
           │ b0    │ b1     │ b2    │ b3    │ b4    │
───────────┼───────┼────────┼───────┼───────┼───────┤
b0 (Time)  │   -   │        │   ●   │       │       │  ← b0 outputs to b2
b1 (Domain)│       │   -    │   ●   │       │       │  ← b1 outputs to b2
b2 (Field) │       │        │   -   │       │       │
b3 (Const) │       │        │   ●   │   -   │       │  ← b3 outputs to b2
b4 (Const) │       │        │   ●   │       │   -   │
```

- **Rows** = source blocks (output)
- **Columns** = target blocks (input)
- **Cell[row][col]** = edges from row block to col block
- **Diagonal** = N/A (self-connection impossible)

## Key Files

### Type Definitions
- `src/types/index.ts` - Core types including DefaultSource (line 185-187), RailId (line 260-266)
- `src/graph/Patch.ts` - Block interface (line 14-20), Patch interface (line 68-71)

### UI Components
- `src/ui/components/TableView.ts` - REWRITE as connection matrix
- `src/ui/components/BlockInspector.ts` - Add default source + domain display
- `src/ui/components/BlockLibrary.ts` - Set preview type on click
- `src/ui/components/DomainsPanel.ts` - Add highlight/scroll method
- `src/ui/components/SplitPanel.ts` - NEW: horizontal split panel

### State & Registry
- `src/ui/state/selection.ts` - Add previewType field
- `src/ui/registry/blockTypes.ts` - Add defaultSource on ports

### Demo Patch
- `src/main.ts` - buildAndCompile() function builds demo patch (line 191-311)

## Type Changes

### Block (src/graph/Patch.ts:14-20)
```typescript
// BEFORE
export interface Block {
  readonly id: BlockId;
  readonly type: BlockType;
  readonly params: Readonly<Record<string, unknown>>;
  readonly label?: string;
}

// AFTER - domainId is REQUIRED (can be null, but property MUST exist)
export interface Block {
  readonly id: BlockId;
  readonly type: BlockType;
  readonly params: Readonly<Record<string, unknown>>;
  readonly label?: string;
  readonly domainId: string | null;  // REQUIRED - not optional
}
```

### DefaultSource (src/types/index.ts:185-187)
```typescript
// BEFORE
export interface DefaultSource {
  readonly value: unknown;
}

// AFTER
export interface DefaultSource {
  readonly kind: 'rail' | 'constant';
  readonly railId?: RailId;  // When kind='rail'
  readonly value?: unknown;   // When kind='constant'
}
```

### Selection State (src/ui/state/selection.ts)
```typescript
// BEFORE
interface SelectionState {
  selectedBlockId: BlockId | null;
}

// AFTER
interface SelectionState {
  selectedBlockId: BlockId | null;
  previewType: string | null;  // Block type name for preview
}
```

## PatchBuilder Changes

Must update addBlock() to require domainId:

```typescript
// BEFORE
addBlock(type: BlockType, params: Record<string, unknown> = {}, label?: string): BlockId

// AFTER
addBlock(type: BlockType, params: Record<string, unknown> = {}, domainId: string | null = null, label?: string): BlockId
```

Or alternative signature:
```typescript
addBlock(type: BlockType, options?: { params?: Record<string, unknown>; domainId?: string | null; label?: string }): BlockId
```

## Matrix Building Algorithm

```typescript
function buildAdjacencyMatrix(patch: Patch): Map<string, Map<string, Edge[]>> {
  const matrix = new Map<string, Map<string, Edge[]>>();

  // Initialize empty matrix
  for (const block of patch.blocks.values()) {
    matrix.set(block.id, new Map());
  }

  // Fill in edges
  for (const edge of patch.edges) {
    const sourceId = edge.from.blockId;
    const targetId = edge.to.blockId;

    const row = matrix.get(sourceId);
    if (row) {
      const existing = row.get(targetId) || [];
      row.set(targetId, [...existing, edge]);
    }
  }

  return matrix;
}
```

## Rails Identification

```typescript
const isRail = (block: Block) => block.type === 'Rail';

const regularBlocks = Array.from(patch.blocks.values()).filter(b => !isRail(b));
const railBlocks = Array.from(patch.blocks.values()).filter(isRail);

// Order: regular blocks first, then rails
const orderedBlocks = [...regularBlocks, ...railBlocks];
```

## Split Panel Component

```typescript
interface SplitPanelProps {
  topContent: (container: HTMLElement) => void;
  bottomContent: (container: HTMLElement) => void;
  initialSplit?: number; // 0-1, default 0.4 (40% top)
}

class SplitPanel {
  constructor(container: HTMLElement, props: SplitPanelProps);
}
```

Structure:
```html
<div class="split-panel">
  <div class="split-panel-top"><!-- Library --></div>
  <div class="split-panel-divider"></div>
  <div class="split-panel-bottom"><!-- Inspector --></div>
</div>
```

## Demo Patch Domain Assignment

In `main.ts`, when building the patch, the DomainN block becomes the "domain" for field blocks.

Signal blocks (Time, ConstFloat): `domainId: null`
Field blocks (FieldPulse, FieldAdd, etc.): `domainId: 'b1'` (the DomainN block)
Render blocks: `domainId: 'b1'`

## Domain Link Navigation

When clicking domain link in Inspector:
1. Find right sidebar Domains tab
2. Switch to Domains tab if not active
3. Call `domainsPanel.highlightDomain(domainId)`

DomainsPanel needs method:
```typescript
highlightDomain(domainId: string): void {
  // Scroll to domain card
  // Add highlight class
  // Maybe expand if collapsed
}
```

## RailId Values
```typescript
type RailId = 'time' | 'phaseA' | 'phaseB' | 'pulse' | 'palette' | 'energy';
```

## Common Default Sources

For block type registry:
- `phase` inputs → `{ kind: 'rail', railId: 'phaseA' }`
- `energy` inputs → `{ kind: 'rail', railId: 'energy' }`
- Numeric params like `base`, `amplitude` → `{ kind: 'constant', value: 0 }` or appropriate default
