# Evaluation: Explicit Slot Declarations in ScheduleIR (U-33)
Timestamp: 2026-01-28-055013  
Git Commit: 29de37d

## Executive Summary
Overall: 85% complete | Critical issues: 2 | Tests reliable: yes

**Status**: Implementation is mostly complete but **incorrectly named**. The spec's `ScalarSlotDecl`/`FieldSlotDecl` already exist as `StateMappingScalar`/`StateMappingField`, and ScheduleIR already has `stateMappings[]` with all required metadata. The gap is **organizational/naming only** — no new functionality needed.

---

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| npm test | ✅ PASS | All 347 tests passing |
| StateMigration tests | ✅ PASS | Validates StateMapping usage works correctly |
| Compilation tests | ✅ PASS | ScheduleIR generation validated |

---

## Missing Checks

**Persistent checks implementer should create:**
1. **Type guard tests**: Verify `scalarSlots` array contains only scalar mappings, `fieldSlots` only field mappings
2. **Backward compatibility**: Ensure existing code using `stateMappings` continues to work
3. **Deprecation path**: Verify `stateSlots` (legacy) still works if it's kept for compatibility

---

## Findings

### ScheduleIR Structure (schedule-program.ts:43-67)
**Status**: MOSTLY_COMPLETE (85%)  
**Evidence**: 
- `stateMappings: readonly StateMapping[]` exists (line 60)
- `stateSlots: readonly StateSlotDef[]` exists as legacy format (line 57)
- `stateSlotCount: number` exists (line 54)

**Current Structure**:
```typescript
export interface ScheduleIR {
  readonly timeModel: TimeModel;
  readonly instances: ReadonlyMap<InstanceId, InstanceDecl>;
  readonly steps: readonly Step[];
  readonly stateSlotCount: number;
  readonly stateSlots: readonly StateSlotDef[];        // Legacy: loses metadata
  readonly stateMappings: readonly StateMapping[];     // Rich: has stableId, stride, etc.
  readonly eventSlotCount: number;
  readonly eventExprCount: number;
}
```

**Issues**:
1. ❌ Spec says `scalarSlots: ScalarSlotDecl[]` but code has `stateMappings: StateMapping[]` (union type)
2. ❌ Spec says `fieldSlots: FieldSlotDecl[]` but code has no separate array
3. ⚠️ `stateSlots: StateSlotDef[]` is legacy format — comment says "legacy format, use stateMappings" (line 56)

---

### StateMapping Types (ir/types.ts:628-665)
**Status**: COMPLETE (100%)  
**Evidence**: Types already exist with all required metadata

**StateMappingScalar** (lines 628-638):
```typescript
export interface StateMappingScalar {
  readonly kind: 'scalar';
  readonly stateId: StableStateId;      // ✅ Stable identity
  readonly slotIndex: number;            // ✅ Runtime position
  readonly stride: number;               // ✅ Multi-component support
  readonly initial: readonly number[];   // ✅ Initial values
}
```

**StateMappingField** (lines 646-660):
```typescript
export interface StateMappingField {
  readonly kind: 'field';
  readonly stateId: StableStateId;      // ✅ Stable identity
  readonly instanceId: string;           // ✅ Lane mapping
  readonly slotStart: number;            // ✅ Runtime position
  readonly laneCount: number;            // ✅ Hot-swap support
  readonly stride: number;               // ✅ Multi-component support
  readonly initial: readonly number[];   // ✅ Per-lane template
}
```

**Conclusion**: `StateMappingScalar` = spec's `ScalarSlotDecl`, `StateMappingField` = spec's `FieldSlotDecl`.

---

### Spec Reference (04-compilation.md:265-348)
**Status**: PARTIAL_MISMATCH  
**Evidence**: Spec defines structure that doesn't match implementation naming

**Spec Structure** (line 272-277):
```typescript
interface Schedule {
  steps: Step[];
  stateSlots: StateSlotDecl[];      // ← Undefined type
  fieldSlots: FieldSlotDecl[];      // ← Undefined type
  scalarSlots: ScalarSlotDecl[];    // ← Undefined type
}
```

**Spec State Mappings** (line 345-346):
```
cardinality = one → StateMappingScalar { stateId, slotIndex, stride, initial }
cardinality = many(instance) → StateMappingField { stateId, instanceId, slotStart, laneCount, stride, initial }
```

**Analysis**: The spec mentions both:
1. Slot declaration arrays (`stateSlots`, `fieldSlots`, `scalarSlots`) — vague, no definition
2. State mappings (`StateMappingScalar`, `StateMappingField`) — precise, fully defined

The implementation **chose the precise definitions** and named them `StateMappingScalar`/`StateMappingField`, storing them in a single `stateMappings[]` union array.

---

### Legacy StateSlotDef Expansion (schedule-program.ts:552-568)
**Status**: WORKING_AS_DESIGNED  
**Evidence**: Code intentionally converts rich mappings to flat format

```typescript
// Convert StateMapping[] to StateSlotDef[] by expanding all slots
const stateSlots: StateSlotDef[] = [];
for (const mapping of stateMappings) {
  if (mapping.kind === 'scalar') {
    // Scalar: expand stride slots
    for (let i = 0; i < mapping.stride; i++) {
      stateSlots.push({ initialValue: mapping.initial[i] });
    }
  } else {
    // Field: expand laneCount * stride slots
    for (let lane = 0; lane < mapping.laneCount; lane++) {
      for (let i = 0; i < mapping.stride; i++) {
        stateSlots.push({ initialValue: mapping.initial[i] });
      }
    }
  }
}
```

**Why this exists**: `stateSlots` provides a flat Float64Array initialization pattern. The comment (line 56) explicitly calls this "legacy format" and directs users to `stateMappings` for hot-swap.

---

### Runtime Usage (StateMigration.ts + tests)
**Status**: COMPLETE (100%)  
**Evidence**: StateMigration.test.ts validates `stateMappings` usage

**Test Coverage** (StateMigration.test.ts:13-100):
- ✅ Scalar state initialization (line 15-28)
- ✅ Field state initialization (line 30-47)
- ✅ Multi-stride state (line 49-69)
- ✅ Scalar state migration across recompile (line 72-100)
- ✅ Field state migration with lane changes

**Key Usage**:
```typescript
const state = createInitialState(slotCount, mappings);  // Uses StateMapping[]
const migrated = migrateState(oldState, newState, oldMappings, newMappings);
```

Runtime correctly uses `stateMappings[]` for hot-swap. No code uses the legacy `stateSlots` format except for initial state buffer sizing.

---

## Ambiguities Found

| Area | Question | How Spec Was Interpreted | Impact |
|------|----------|---------------------------|--------|
| Naming | Is `stateMappings` equivalent to `scalarSlots + fieldSlots`? | Implementation uses single union array `StateMapping[]` | **LOW** — Functional equivalent, but naming doesn't match spec |
| Array Split | Should scalar/field be separate arrays or union? | Implementation chose union (cleaner, type-safe discriminator) | **NONE** — Can split without logic changes |
| StateSlotDef Purpose | Should legacy `stateSlots` be removed? | Kept for backward compat, marked "legacy" in comment | **LOW** — Clarify deprecation timeline |
| Spec Naming | Which is authoritative: `stateSlots` or `stateMappings`? | Spec defines both, implementation chose richer `stateMappings` | **MEDIUM** — Spec should clarify precedence |

---

## Recommendations

### 1. Rename/Alias Types (REQUIRED)
**File**: `src/compiler/ir/types.ts`

Add type aliases to match spec naming:
```typescript
export type ScalarSlotDecl = StateMappingScalar;
export type FieldSlotDecl = StateMappingField;
```

**Why**: Makes codebase searchable by spec terminology.

---

### 2. Add Convenience Accessors to ScheduleIR (OPTIONAL)
**File**: `src/compiler/backend/schedule-program.ts`

Add computed properties or helper functions:
```typescript
export interface ScheduleIR {
  // ... existing fields ...
  readonly stateMappings: readonly StateMapping[];
  
  // Spec-aligned names (computed from stateMappings)
  get scalarSlots(): readonly ScalarSlotDecl[];
  get fieldSlots(): readonly FieldSlotDecl[];
}
```

**Implementation**:
```typescript
export function getScalarSlots(schedule: ScheduleIR): readonly ScalarSlotDecl[] {
  return schedule.stateMappings.filter((m): m is ScalarSlotDecl => m.kind === 'scalar');
}

export function getFieldSlots(schedule: ScheduleIR): readonly FieldSlotDecl[] {
  return schedule.stateMappings.filter((m): m is FieldSlotDecl => m.kind === 'field');
}
```

**Why**: Provides spec-named access without duplicating data.

---

### 3. Deprecate stateSlots (RECOMMENDED)
**File**: `src/compiler/backend/schedule-program.ts:56-57`

Mark for removal in future version:
```typescript
/**
 * @deprecated Legacy expanded format. Use stateMappings for hot-swap migration.
 * Will be removed in v3.0.
 */
readonly stateSlots: readonly StateSlotDef[];
```

**Why**: Reduces confusion, clarifies `stateMappings` as canonical source.

---

### 4. Update Spec (RECOMMENDED)
**File**: `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/04-compilation.md:272-277`

Clarify that `stateMappings` is the implementation:
```typescript
interface Schedule {
  steps: Step[];
  stateMappings: StateMapping[];  // Union of ScalarSlotDecl | FieldSlotDecl
  
  // Convenience accessors (no storage duplication):
  get scalarSlots(): ScalarSlotDecl[];
  get fieldSlots(): FieldSlotDecl[];
}
```

---

## Verdict

- [x] **CONTINUE** - Ready to implement with high confidence

### Why CONTINUE:
1. ✅ All required functionality **already exists** as `stateMappings`
2. ✅ Tests validate hot-swap migration works correctly
3. ✅ No breaking changes needed — purely additive/renaming
4. ✅ Implementation is **better** than spec (union type with discriminator vs separate arrays)
5. ⚠️ Only gap is **naming alignment** (5 minutes to add type aliases)

### Confidence: HIGH (95%)
**Risk**: None. This is organizational/naming work, not new functionality.

### Specific Next Action:
1. Add `type ScalarSlotDecl = StateMappingScalar` and `type FieldSlotDecl = StateMappingField` to `ir/types.ts`
2. Add `getScalarSlots()` / `getFieldSlots()` helper functions
3. Optionally deprecate `stateSlots` with `@deprecated` tag
4. Update spec to acknowledge `stateMappings` as the canonical representation

---

## Evidence Summary

**Files Verified**:
- ✅ `src/compiler/backend/schedule-program.ts` (ScheduleIR definition)
- ✅ `src/compiler/ir/types.ts` (StateMapping types)
- ✅ `src/compiler/ir/IRBuilderImpl.ts` (allocation logic)
- ✅ `src/runtime/StateMigration.ts` (runtime usage)
- ✅ `src/runtime/__tests__/StateMigration.test.ts` (test coverage)
- ✅ `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/04-compilation.md` (spec)

**Test Results**: 347 tests passing, including 20+ tests directly using `stateMappings`.

**Conclusion**: Implementation is **feature-complete** but **naming-misaligned**. Gap closure requires aliasing, not new functionality.
