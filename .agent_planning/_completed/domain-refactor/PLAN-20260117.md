# Domain Refactor - Complete Implementation Plan

**Topic:** Complete and total domain refactor
**Created:** 2026-01-17
**Spec References:**
- `design-docs/WHAT-IS-A-DOMAIN.md` (1603 lines - conceptual foundation)
- `design-docs/WHAT-IS-A-DOMAIN-PART-4-REFACTOR.md` (789 lines - detailed refactor plan)

---

## Executive Summary

**The Core Problem:** The current codebase conflates **domain type** (what kind of thing: shape, circle, control) with **instantiation** (how many elements, what layout). This is a fundamental architectural error that affects ~50 files and 200+ direct usages.

**The Solution:** Separate into three distinct concepts:
1. **DomainTypeId** — Classification (ontological category: shape, circle, control)
2. **InstanceDecl** — Configuration (count, layout, lifecycle)
3. **InstanceId** — Reference to a specific instantiation

**Impact:**
- Type System Core: 3 files (MAJOR rewrite)
- IR Types: 4 files (MAJOR rewrite)
- Block Library: 11 files (pattern-based updates)
- Compiler Passes: 6+ files (moderate changes)
- Runtime: 4 files (moderate changes)
- Tests: 8+ files (rewrite to match new model)

---

## Current State Analysis

### What's Broken

| Component | Current State | Problem |
|-----------|---------------|---------|
| `DomainId` | String type | Conflates type AND instance reference |
| `DomainRef` | `{ kind: 'domain', id: DomainId }` | No distinction between type and instance |
| `DomainDef` | `{ id, kind: 'grid'|'n'|'path', count, params }` | Layout (grid) is NOT domain type |
| `FieldExprSource` | `{ domain: DomainId, sourceId: ... }` | Should be `instanceId`, not `domain` |
| `GridDomain` block | Creates "grid domain" | Grid is a LAYOUT, not a domain |
| `domainId('default')` | Hardcoded everywhere in blocks | Not instance-aware |

### What's Correct (Per Spec)

**Domain is classification, not instantiation:**
- Domain = "What kind of thing?" (shape, circle, control, event)
- Instance = "How many? What layout?" (100, grid, circular)

**Examples from spec:**
- 100 shapes in a grid → Domain: shape, Instance: {count: 100, layout: grid}
- 50 shapes in a circle → Domain: shape, Instance: {count: 50, layout: circular}
- Same domain, different instantiations

**Domain grants intrinsic properties:**
- `shape` domain: position, bounds, area, centroid
- `circle` domain (extends shape): radius, center
- `path` domain: t, tangent, normal, curvature

---

## Sprint Structure

### Sprint 1: Foundation Types [CONFIDENCE: 95%]

**Goal:** Add new type system alongside old, create domain registry

**Deliverables:**
1. Create `src/core/domain-registry.ts` with:
   - Domain type constants (`DOMAIN_SHAPE`, `DOMAIN_CIRCLE`, etc.)
   - Intrinsic property definitions
   - Domain hierarchy (circle extends shape)
   - Registry API (`getDomainType`, `isSubdomainOf`, `getIntrinsics`)

2. Add to `src/core/canonical-types.ts`:
   - `DomainTypeId` (branded string)
   - `InstanceId` (branded string)
   - `InstanceRef` (`{ kind: 'instance', domainType, instanceId }`)
   - `IntrinsicSpec` (`{ name, type, computation }`)
   - `DomainType` (`{ id, parent, intrinsics }`)
   - Keep old types temporarily (deprecate, don't delete)

3. Add to `src/compiler/ir/Indices.ts`:
   - `DomainTypeId` branded type with factory
   - `InstanceId` branded type with factory
   - Keep old `DomainId` temporarily

**Tests:**
- Domain type hierarchy tests
- InstanceRef creation tests
- Intrinsic lookup tests

**Verification:**
- TypeScript compiles with no errors
- All existing 275+ tests still pass
- New types are exported from `src/types/index.ts`

---

### Sprint 2: IR Types Migration [CONFIDENCE: 90%]

**Goal:** Update IR layer to use instance-based model

**Deliverables:**
1. Add to `src/compiler/ir/types.ts`:
   - `InstanceDecl` (`{ id, domainType, count, layout, lifecycle }`)
   - `LayoutSpec` (discriminated union: grid, circular, linear, random, custom)
   - Keep `DomainDef` temporarily

2. Update `FieldExprSource`:
   ```typescript
   // Add new variant
   interface FieldExprSource {
     readonly kind: 'source';
     readonly instanceId: InstanceId;     // NEW: instance reference
     readonly intrinsic: string;          // NEW: 'position', 'index', etc.
     readonly type: CanonicalType;
     // Deprecate: domain, sourceId
   }
   ```

3. Update `IRBuilder` interface:
   - ADD: `createInstance(domainType, count, layout, lifecycle?)` → `InstanceId`
   - ADD: `getInstances()` → `ReadonlyMap<InstanceId, InstanceDecl>`
   - ADD: `fieldIntrinsic(instanceId, intrinsic, type)` → `FieldExprId`
   - KEEP: Old methods temporarily

4. Update `IRBuilderImpl`:
   - ADD: `instances` map alongside `domains`
   - IMPLEMENT: New methods

**Tests:**
- Instance creation tests
- Field intrinsic access tests
- Instance lookup tests

**Verification:**
- IRBuilder correctly creates instances
- Field expressions reference instances
- Existing compilation still works (using old paths)

---

### Sprint 3: Block Library - Instance Blocks [CONFIDENCE: 85%]

**Goal:** Create new instance blocks that replace GridDomain/DomainN

**Deliverables:**
1. Create `src/blocks/instance-blocks.ts`:
   - `CircleInstance` block:
     - Inputs: count, layout
     - Outputs: position, radius, index, t (intrinsics)
   - `ShapeInstance` block (generic)
   - Layout blocks: `GridLayout`, `CircularLayout`, `RandomLayout`

2. Update lowering context (`LoweringContext`):
   ```typescript
   interface LoweringContext {
     b: IRBuilder;
     instance?: InstanceId;           // NEW: current instance context
     inferredInstance?: InstanceId;   // NEW: from connected inputs
   }
   ```

3. Update `pass6-block-lowering.ts` to propagate instance context

**Tests:**
- CircleInstance creates correct instance
- Layout blocks produce correct LayoutSpec
- Instance context propagates through lowering

**Verification:**
- New blocks compile correctly
- Instance is created with correct domain type
- Intrinsics are accessible as outputs

---

### Sprint 4: Block Library - Field Operations [CONFIDENCE: 80%]

**Goal:** Update all field operation blocks to use instance context

**Deliverables:**
1. Update `src/blocks/field-operations-blocks.ts`:
   - Replace `domainId('default')` with instance context
   - ~20 blocks: FieldAdd, FieldMultiply, FieldScale, FieldSin, FieldCos, FieldMod, FieldPolarToCartesian, FieldCartesianToPolar, FieldPulse, FieldGoldenAngle, FieldAngularOffset, FieldRadiusSqrt, FieldJitter2D, FieldHueFromPhase, etc.

2. Pattern for each block:
   ```typescript
   lower: ({ ctx, inputsById }) => {
     const instanceId = ctx.inferredInstance ?? ctx.instance;
     if (!instanceId) {
       throw new Error('Block requires instance context');
     }
     // Use instanceId instead of domainId('default')
   }
   ```

3. Update `signalTypeField()` calls to NOT embed domain/instance in type

4. Update other block files:
   - `identity-blocks.ts`
   - `geometry-blocks.ts`
   - `color-blocks.ts`
   - `math-blocks.ts`

**Tests:**
- Field operations work with instance context
- Instance mismatch is caught at compile time
- Field type no longer embeds instance

**Verification:**
- All field blocks use instance context
- No hardcoded `domainId('default')` remains
- Compilation still produces correct IR

---

### Sprint 5: Block Library - Render & Cleanup [CONFIDENCE: 80%]

**Goal:** Fix render blocks, delete old domain blocks

**Deliverables:**
1. Update `src/blocks/render-blocks.ts`:
   - Remove confusing "domain" input
   - Infer instance from field inputs
   - Emit proper render steps with `instanceId`

2. **DELETE** `src/blocks/domain-blocks.ts`:
   - Remove `GridDomain` block
   - Remove `DomainN` block
   - These embody the wrong model and cannot be fixed

3. Update block registration to remove deleted blocks

**Tests:**
- Render block infers instance correctly
- Render step has instanceId
- GridDomain/DomainN no longer exist

**Verification:**
- Domain blocks deleted
- Render blocks work with instance inference
- No references to deleted blocks

---

### Sprint 6: Compiler Passes [CONFIDENCE: 85%]

**Goal:** Update all compiler passes to use instance model

**Deliverables:**
1. Update `src/compiler/passes-v2/pass7-schedule.ts`:
   - Replace `DomainId` → `InstanceId`
   - Replace `DomainDef` → `InstanceDecl`
   - Update `ScheduleIR.domains` → `ScheduleIR.instances`

2. Update step types in `src/compiler/ir/types.ts`:
   - `StepMaterialize.domain` → `StepMaterialize.instanceId`
   - `StepRender.domain` → `StepRender.instanceId`

3. Update `IRProgram`:
   - `domains: ReadonlyMap<DomainId, DomainDef>` →
   - `instances: ReadonlyMap<InstanceId, InstanceDecl>`

4. Rename `domain-unification.test.ts` → `instance-unification.test.ts`
   - Update tests to verify instance compatibility

**Tests:**
- Schedule uses instance model
- Steps reference instances
- Instance unification works correctly

**Verification:**
- Full compilation pipeline works
- Steps have correct instance references
- All compiler tests pass

---

### Sprint 7: Runtime [CONFIDENCE: 85%]

**Goal:** Update runtime to use instance model

**Deliverables:**
1. Update `src/runtime/Materializer.ts`:
   ```typescript
   materialize(
     fieldId: FieldExprId,
     instanceId: InstanceId,     // Changed from domainId
     fields: readonly FieldExpr[],
     signals: readonly SigExpr[],
     instances: ReadonlyMap<InstanceId, InstanceDecl>,  // Changed from domains
     state: RuntimeState,
     pool: BufferPool
   ): ArrayBufferView
   ```

2. Update domain lookup:
   - `domains.get(domainId)` → `instances.get(instanceId)`
   - Handle instance count correctly

3. Update `RuntimeState.ts` if needed

4. Update execution loop to use instance model

**Tests:**
- Materialization works with instances
- Buffer sizing uses instance count
- Runtime execution works end-to-end

**Verification:**
- Runtime executes correctly
- Rendered output is correct
- Performance is unchanged

---

### Sprint 8: Cleanup & Tests [CONFIDENCE: 90%]

**Goal:** Delete old types, update all tests

**Deliverables:**
1. **DELETE** from `src/core/canonical-types.ts`:
   - Old `DomainId`, `DomainRef`, `DomainShape`, `DomainDecl`
   - Factory functions: `domainRef`, `domainDeclFixedCount`, etc.

2. **DELETE** from `src/compiler/ir/Indices.ts`:
   - Old `DomainId` (keep new `DomainTypeId`, `InstanceId`)

3. **DELETE** from `src/compiler/ir/types.ts`:
   - Old `DomainDef`

4. Update `src/types/index.ts`:
   - Remove old type exports
   - Add new type exports

5. Update all tests:
   - Delete tests for removed types
   - Add tests for new behavior
   - Test behavior, not structure:
     ```typescript
     // BAD:
     expect(ir.domains.get(domainId('0'))).toEqual({ kind: 'grid', ... });

     // GOOD:
     const result = executeFrame(program, { time: 0 });
     expect(result.renderedCircles).toHaveLength(100);
     ```

6. Update `steel-thread.test.ts` to use new model

**Tests:**
- All tests pass with new model
- No references to old types remain
- Steel-thread works end-to-end

**Verification:**
- No TypeScript errors
- All 275+ tests pass
- grep for old type names returns nothing

---

## Success Criteria

The refactor is complete when:

1. ✅ `DomainId` (old conflated type) no longer exists
2. ✅ `DomainDef` no longer exists
3. ✅ `GridDomain` and `DomainN` blocks are deleted
4. ✅ All blocks use instance-based model
5. ✅ All tests pass (275+ tests)
6. ✅ Steel-thread example compiles and runs
7. ✅ No "domain" in codebase refers to old conflated concept
8. ✅ Domain registry exists with correct hierarchy
9. ✅ Intrinsic properties are accessible per domain type

---

## Risk Analysis

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking existing compilation | Medium | High | Keep old types during migration, test continuously |
| Breaking existing tests | High | Medium | Update tests incrementally, test behavior not structure |
| Lowering context propagation complexity | Medium | Medium | Design carefully in Sprint 3 before touching blocks |
| Dynamic count handling | Low | Medium | Defer to future sprint if complex |
| Performance regression | Low | Low | Profile after refactor, optimize if needed |

---

## Dependencies

**Blocks on:**
- Phase 1 foundation work should be stable

**Unblocks:**
- domain-editor-ui (PLANNING) - can't design UI for broken model
- Future domain types (path, text, audio)
- Clean cross-domain operations

---

## Confidence Ratings

| Sprint | Confidence | Rationale |
|--------|------------|-----------|
| 1: Foundation Types | 95% | Pure additions, no breaking changes |
| 2: IR Types | 90% | Clear path, but touches core IR |
| 3: Instance Blocks | 85% | New blocks, needs design care |
| 4: Field Operations | 80% | 20+ blocks to update, pattern-based |
| 5: Render & Cleanup | 80% | Deleting code is reversible |
| 6: Compiler Passes | 85% | Clear mappings |
| 7: Runtime | 85% | Clear mappings |
| 8: Cleanup & Tests | 90% | Straightforward deletions |

**Overall Confidence: 85%** - Clear spec, detailed plan, known scope. Main risk is the breadth of changes across many files.

---

## Estimated Effort

| Sprint | Estimated Time |
|--------|----------------|
| 1: Foundation Types | 2-3 hours |
| 2: IR Types | 3-4 hours |
| 3: Instance Blocks | 3-4 hours |
| 4: Field Operations | 4-6 hours |
| 5: Render & Cleanup | 2-3 hours |
| 6: Compiler Passes | 3-4 hours |
| 7: Runtime | 2-3 hours |
| 8: Cleanup & Tests | 2-3 hours |

**Total: 21-30 hours** (3-4 focused days)

---

## Appendix: Key Files

### Category 1: Type System Core
- `src/core/canonical-types.ts` (617 lines) - MAJOR
- `src/core/__tests__/canonical-types.test.ts` - REWRITE
- `src/types/index.ts` (323 lines) - UPDATE

### Category 2: IR Types
- `src/compiler/ir/Indices.ts` (124 lines) - ADD types
- `src/compiler/ir/types.ts` (349 lines) - MAJOR
- `src/compiler/ir/IRBuilder.ts` (188 lines) - UPDATE
- `src/compiler/ir/IRBuilderImpl.ts` (616 lines) - MAJOR

### Category 3: Block Library
- `src/blocks/domain-blocks.ts` (86 lines) - **DELETE**
- `src/blocks/field-operations-blocks.ts` (710 lines) - MAJOR
- `src/blocks/render-blocks.ts` (100+ lines) - UPDATE
- `src/blocks/identity-blocks.ts` - UPDATE
- `src/blocks/geometry-blocks.ts` - UPDATE

### Category 4: Compiler
- `src/compiler/passes-v2/pass7-schedule.ts` (200+ lines) - UPDATE
- `src/compiler/passes-v2/pass6-block-lowering.ts` - UPDATE
- `src/compiler/__tests__/*.ts` - REWRITE

### Category 5: Runtime
- `src/runtime/Materializer.ts` (400+ lines) - UPDATE
- `src/runtime/RuntimeState.ts` - CHECK

### Category 7: New
- `src/core/domain-registry.ts` - CREATE

---

## Next Steps

Upon approval:
1. Create `.agent_planning/domain-refactor/DOD-20260117.md` with acceptance criteria
2. Execute Sprint 1: Foundation Types
3. Proceed through sprints sequentially
4. Update roadmap to reflect domain-refactor topic
