# Implementation Context: Animation Deferred Work

Generated: 2026-01-12

## P0: Signal Kernel Support

### Primary File to Modify

**`/Users/bmf/code/oscilla-animator-v2/src/runtime/SignalEvaluator.ts`**

Lines 154-161 - `applyPureFn` function:

```typescript
// CURRENT CODE (lines 154-161):
function applyPureFn(
  fn: { kind: 'opcode'; opcode: string } | { kind: 'expr'; expr: string } | { kind: 'kernel'; name: string },
  values: number[]
): number {
  if (fn.kind === 'opcode') {
    return applyOpcode(fn.opcode, values);
  }
  throw new Error(`PureFn kind ${fn.kind} not implemented`);
}

// SHOULD BECOME:
function applyPureFn(
  fn: { kind: 'opcode'; opcode: string } | { kind: 'expr'; expr: string } | { kind: 'kernel'; name: string },
  values: number[]
): number {
  if (fn.kind === 'opcode') {
    return applyOpcode(fn.opcode, values);
  }
  if (fn.kind === 'kernel') {
    return applySignalKernel(fn.name, values);
  }
  throw new Error(`PureFn kind ${fn.kind} not implemented`);
}

// NEW FUNCTION TO ADD:
function applySignalKernel(name: string, values: number[]): number {
  switch (name) {
    case 'sin':
      return Math.sin(values[0]);
    case 'cos':
      return Math.cos(values[0]);
    case 'tan':
      return Math.tan(values[0]);
    // vec2 kernels not supported at signal level yet
    case 'polarToCartesian':
    case 'offsetPosition':
      throw new Error(`Signal kernel '${name}' returns vec2 which is not yet supported at signal level. Use field-level version instead.`);
    default:
      throw new Error(`Unknown signal kernel: ${name}`);
  }
}
```

### Block Reference

**`/Users/bmf/code/oscilla-animator-v2/src/blocks/signal-blocks.ts`**

Lines 78-82 - Oscillator block lowering:
```typescript
// The waveform param is 'sin', 'cos', 'triangle', 'square', 'sawtooth'
const waveFn = ctx.b.kernel(waveform); // Creates { kind: 'kernel', name: waveform }
const result = ctx.b.sigZip([phaseSig], waveFn, canonicalType('float'));
```

### Test Pattern

After implementation, Oscillator should work:
```typescript
// In main.ts or test:
const osc = b.addBlock('Oscillator', { waveform: 'sin' });
b.wire(time, 'phaseA', osc, 'phase');
// osc.out should now produce sine wave values
```

---

## P0: Field Kernel Implementations

### Primary File to Modify

**`/Users/bmf/code/oscilla-animator-v2/src/runtime/Materializer.ts`**

Add to `applyKernelZipSig` function (starts at line 644):

```typescript
// ADD AFTER hsvToRgb kernel (around line 683):

} else if (kernelName === 'circleLayout') {
  // Circle layout: normalized index -> vec2 position on circle
  // Input field: normalizedIndex (0-1)
  // Signals: [radius, phase]
  if (sigValues.length !== 2) {
    throw new Error('circleLayout requires 2 signals (radius, phase)');
  }
  const outArr = out as Float32Array;
  const indexArr = fieldInput as Float32Array;
  const radius = sigValues[0];
  const phase = sigValues[1];
  const TWO_PI = Math.PI * 2;
  const cx = 0.5; // Center in normalized coords
  const cy = 0.5;

  for (let i = 0; i < N; i++) {
    const angle = TWO_PI * (indexArr[i] + phase);
    outArr[i * 2 + 0] = cx + radius * Math.cos(angle);
    outArr[i * 2 + 1] = cy + radius * Math.sin(angle);
  }
} else if (kernelName === 'circleAngle') {
  // Circle angle: normalized index -> angle in radians
  // Input field: normalizedIndex (0-1)
  // Signals: [phase]
  if (sigValues.length !== 1) {
    throw new Error('circleAngle requires 1 signal (phase)');
  }
  const outArr = out as Float32Array;
  const indexArr = fieldInput as Float32Array;
  const phase = sigValues[0];
  const TWO_PI = Math.PI * 2;

  for (let i = 0; i < N; i++) {
    outArr[i] = TWO_PI * (indexArr[i] + phase);
  }
}
```

### Block Reference

**`/Users/bmf/code/oscilla-animator-v2/src/blocks/geometry-blocks.ts`**

Lines 100-112 - Circle block lowering:
```typescript
// Creates normalized index field
const indexField = ctx.b.fieldSource('normalizedIndex', signalTypeField('float', 'default'));

// Uses circleLayout kernel with zipSig
const circleFn = ctx.b.kernel('circleLayout');
const posField = ctx.b.fieldZipSig(
  indexField,
  [radiusSig, phaseSig],  // signals
  circleFn,
  signalTypeField('vec2', 'default')
);

// Uses circleAngle kernel
const angleFn = ctx.b.kernel('circleAngle');
const angleField = ctx.b.fieldZipSig(
  indexField,
  [phaseSig],
  angleFn,
  signalTypeField('float', 'default')
);
```

---

## P1: Size Type Disambiguation

### File 1: Type Definition

**`/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/types.ts`**

Lines 305-310 - StepRender interface:

```typescript
// CURRENT (line 305-310):
export interface StepRender {
  readonly kind: 'render';
  readonly domain: DomainId;
  readonly position: FieldExprId;
  readonly color: FieldExprId;
  readonly size?: SigExprId | FieldExprId;
}

// SHOULD BECOME:
export interface StepRender {
  readonly kind: 'render';
  readonly domain: DomainId;
  readonly position: FieldExprId;
  readonly color: FieldExprId;
  readonly size?: { readonly k: 'sig'; readonly id: SigExprId } | { readonly k: 'field'; readonly id: FieldExprId };
}
```

### File 2: Pass 7 Schedule

**`/Users/bmf/code/oscilla-animator-v2/src/compiler/passes-v2/pass7-schedule.ts`**

Lines 155-158 - size assignment:

```typescript
// CURRENT (lines 155-158):
// P1: Add optional size if present
if (sizeRef?.k === 'field' || sizeRef?.k === 'sig') {
  (step as { size?: SigExprId | FieldExprId }).size = sizeRef.id;
}

// SHOULD BECOME:
// P1: Add optional size with type discriminator
if (sizeRef?.k === 'field') {
  (step as any).size = { k: 'field', id: sizeRef.id };
} else if (sizeRef?.k === 'sig') {
  (step as any).size = { k: 'sig', id: sizeRef.id };
}
```

### File 3: Schedule Executor

**`/Users/bmf/code/oscilla-animator-v2/src/runtime/ScheduleExecutor.ts`**

Lines 164-191 - size resolution:

```typescript
// CURRENT (lines 164-191):
// Size can be a signal (uniform) or field (per-particle)
let size: number | ArrayBufferView;
if (step.size !== undefined) {
  // Check if it's a signal or field ID by checking array bounds
  const isSignal = (step.size as number) < signals.length;
  const isField = (step.size as number) < fields.length;

  // Check field FIRST - fields take precedence for per-particle data
  if (isField) {
    // It's a field - materialize per-particle values
    size = materialize(
      step.size as any,
      step.domain,
      fields,
      signals,
      domains,
      state,
      pool
    );
  } else if (isSignal) {
    // It's a signal - evaluate once
    size = evaluateSignal(step.size as SigExprId, signals, state);
  } else {
    size = 10; // Fallback
  }
} else {
  size = 10;
}

// SHOULD BECOME:
// Size can be a signal (uniform) or field (per-particle)
let size: number | ArrayBufferView;
if (step.size !== undefined) {
  if (step.size.k === 'field') {
    // Field - materialize per-particle values
    size = materialize(
      step.size.id,
      step.domain,
      fields,
      signals,
      domains,
      state,
      pool
    );
  } else {
    // Signal - evaluate once for uniform size
    size = evaluateSignal(step.size.id, signals, state);
  }
} else {
  // Default size when no input connected
  size = 10;
}
```

---

## Test Verification

### Manual Test: Oscillator

Add to main.ts temporarily:
```typescript
// After time block
const osc = b.addBlock('Oscillator', { waveform: 'sin', frequency: 1.0, amplitude: 0.5, offset: 0.5 });
b.wire(time, 'phaseA', osc, 'phase');
// Wire osc.out to something visual (e.g., size)
b.wire(osc, 'out', render, 'size');
```

Expected: Size pulses smoothly with sine wave

### Manual Test: Circle

Replace demo patch with:
```typescript
const domain = b.addBlock('DomainN', { n: 100 });
const circle = b.addBlock('Circle', { radius: 0.3 });
const color = b.addBlock('ConstColor', { r: 255, g: 128, b: 0 });
const render = b.addBlock('RenderInstances2D', {});

b.wire(domain, 'domain', circle, 'domain');
b.wire(time, 'phaseA', circle, 'phase');
b.wire(circle, 'pos', render, 'pos');
b.wire(color, 'color', render, 'color');
b.wire(domain, 'domain', render, 'domain');
```

Expected: 100 particles arranged in circle, rotating with time

### Automated: Type Check

```bash
npm run typecheck
```

Must pass with no errors after StepRender type change.

---

## File Summary

| File | Lines | Change |
|------|-------|--------|
| `src/runtime/SignalEvaluator.ts` | 154-161 | Add kernel dispatch + applySignalKernel function |
| `src/runtime/Materializer.ts` | ~683+ | Add circleLayout, circleAngle kernels |
| `src/compiler/ir/types.ts` | 305-310 | Change StepRender.size to discriminated union |
| `src/compiler/passes-v2/pass7-schedule.ts` | 155-158 | Emit discriminated size object |
| `src/runtime/ScheduleExecutor.ts` | 164-191 | Use discriminator, remove heuristic |
