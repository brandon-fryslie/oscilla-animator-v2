# Diagnostics System - Sprint 1 Implementation Plan

**Sprint Goal**: Enable structured compile-time diagnostics with stable IDs, event-driven architecture, and basic UI display.

**Scope**: P0 items only - Core types, EventHub foundation, DiagnosticHub state manager, compiler integration, and basic UI.

**Deferred to Sprint 2+**: Runtime diagnostics, bus warnings, diagnostic actions/quick fixes, UI badges, muting.

---

## Sprint 1 Deliverables

### Deliverable 1: Core Type System & Event Infrastructure
**Files to Create**:
- `src/diagnostics/types.ts` - TargetRef, Diagnostic interface, DiagnosticCode enum, Severity, Domain
- `src/diagnostics/diagnosticId.ts` - Stable ID generation functions
- `src/events/EventHub.ts` - Typed event bus implementation
- `src/events/types.ts` - EditorEvent discriminated union (5 core events)

**Implementation Steps**:

1. **Create diagnostic types** (`src/diagnostics/types.ts`):
   ```typescript
   // TargetRef discriminated union (7 kinds)
   type TargetRef =
     | { kind: 'block'; blockId: string }
     | { kind: 'port'; blockId: string; portId: string }
     | { kind: 'bus'; busId: string }
     | { kind: 'binding'; bindingId: string; busId: string; blockId: string; direction: 'publish' | 'subscribe' }
     | { kind: 'timeRoot'; blockId: string }
     | { kind: 'graphSpan'; blockIds: string[]; spanKind?: 'cycle' | 'island' | 'subgraph' }
     | { kind: 'composite'; compositeDefId: string; instanceId?: string };

   // Severity levels
   type Severity = 'hint' | 'info' | 'warn' | 'error' | 'fatal';

   // Domain classification
   type Domain = 'authoring' | 'compile' | 'runtime' | 'perf';

   // DiagnosticCode enum (P0 subset - 15 codes for Sprint 1)
   type DiagnosticCode =
     | 'E_TIME_ROOT_MISSING'
     | 'E_TIME_ROOT_MULTIPLE'
     | 'E_TYPE_MISMATCH'
     | 'E_CYCLE_DETECTED'
     | 'E_MISSING_INPUT'
     | 'E_UNKNOWN_BLOCK_TYPE'
     | 'W_GRAPH_DISCONNECTED_BLOCK'
     | 'W_GRAPH_UNUSED_OUTPUT'
     | 'I_SILENT_VALUE_USED'
     // ... 6 more codes

   // Full Diagnostic interface (per spec lines 297-333)
   interface Diagnostic {
     id: string;
     code: DiagnosticCode;
     severity: Severity;
     domain: Domain;
     primaryTarget: TargetRef;
     affectedTargets?: TargetRef[];
     title: string;
     message: string;
     payload?: DiagnosticPayload; // Optional for Sprint 1
     actions?: DiagnosticAction[]; // Deferred to Sprint 2
     scope: {
       patchRevision: number;
       compileId?: string;
       runtimeSessionId?: string;
     };
     metadata: {
       firstSeenAt: number;
       lastSeenAt: number;
       occurrenceCount: number;
     };
   }
   ```

2. **Create stable ID generation** (`src/diagnostics/diagnosticId.ts`):
   ```typescript
   function serializeTargetRef(target: TargetRef): string {
     switch (target.kind) {
       case 'block': return `block-${target.blockId}`;
       case 'port': return `port-${target.blockId}:${target.portId}`;
       case 'bus': return `bus-${target.busId}`;
       // ... other cases
     }
   }

   function generateDiagnosticId(
     code: DiagnosticCode,
     primaryTarget: TargetRef,
     patchRevision: number,
     signature?: string
   ): string {
     const targetStr = serializeTargetRef(primaryTarget);
     const base = `${code}:${targetStr}:rev${patchRevision}`;
     return signature ? `${base}:${signature}` : base;
   }
   ```

3. **Create EventHub** (`src/events/EventHub.ts`):
   ```typescript
   class EventHub {
     private listeners = new Map<string, Set<(event: EditorEvent) => void>>();
     private globalListeners = new Set<(event: EditorEvent) => void>();

     emit(event: EditorEvent): void {
       // Call type-specific listeners
       const typeListeners = this.listeners.get(event.type);
       if (typeListeners) {
         for (const listener of typeListeners) {
           try {
             listener(event);
           } catch (err) {
             console.error(`EventHub listener failed for ${event.type}:`, err);
           }
         }
       }

       // Call global listeners
       for (const listener of this.globalListeners) {
         try {
           listener(event);
         } catch (err) {
           console.error('EventHub global listener failed:', err);
         }
       }
     }

     on<T extends EditorEvent['type']>(
       type: T,
       handler: (event: Extract<EditorEvent, { type: T }>) => void
     ): () => void {
       if (!this.listeners.has(type)) {
         this.listeners.set(type, new Set());
       }
       const typedHandler = handler as (event: EditorEvent) => void;
       this.listeners.get(type)!.add(typedHandler);

       // Return unsubscribe function
       return () => {
         this.listeners.get(type)?.delete(typedHandler);
       };
     }

     subscribe(handler: (event: EditorEvent) => void): () => void {
       this.globalListeners.add(handler);
       return () => {
         this.globalListeners.delete(handler);
       };
     }
   }
   ```

4. **Create event types** (`src/events/types.ts`):
   ```typescript
   // Five core events for Sprint 1
   interface GraphCommittedEvent {
     type: 'GraphCommitted';
     patchId: string;
     patchRevision: number;
     reason: 'userEdit' | 'macroExpand' | 'import' | 'undo' | 'redo';
     diffSummary: {
       blocksAdded: number;
       blocksRemoved: number;
       edgesChanged: number;
     };
     affectedBlockIds?: string[];
   }

   interface CompileBeginEvent {
     type: 'CompileBegin';
     compileId: string;
     patchId: string;
     patchRevision: number;
     trigger: 'graphCommitted' | 'manual' | 'startup';
   }

   interface CompileEndEvent {
     type: 'CompileEnd';
     compileId: string;
     patchId: string;
     patchRevision: number;
     status: 'success' | 'failure';
     durationMs: number;
     diagnostics: Diagnostic[];
   }

   interface ProgramSwappedEvent {
     type: 'ProgramSwapped';
     patchId: string;
     patchRevision: number;
     compileId: string;
     swapMode: 'hard' | 'soft';
   }

   interface RuntimeHealthSnapshotEvent {
     type: 'RuntimeHealthSnapshot';
     patchId: string;
     activePatchRevision: number;
     tMs: number;
     frameBudget: {
       fpsEstimate: number;
       avgFrameMs: number;
       worstFrameMs?: number;
     };
     evalStats: {
       fieldMaterializations: number;
       nanCount: number;
       infCount: number;
     };
     diagnosticsDelta?: {
       raised: Diagnostic[];
       resolved: string[];
     };
   }

   // Discriminated union
   type EditorEvent =
     | GraphCommittedEvent
     | CompileBeginEvent
     | CompileEndEvent
     | ProgramSwappedEvent
     | RuntimeHealthSnapshotEvent;
   ```

**Acceptance Criteria (Deliverable 1)**:
1. ✅ TargetRef can represent all 7 kinds with full type safety (compile-time exhaustiveness)
2. ✅ Diagnostic ID generation is deterministic: same code + target + revision → same ID
3. ✅ EventHub.emit() calls listeners synchronously, catches exceptions per listener
4. ✅ EventHub.on<T>() provides type-safe event filtering (TypeScript validates event shape)
5. ✅ All 5 event types have complete interface definitions with required fields

---

### Deliverable 2: DiagnosticHub State Manager
**Files to Create**:
- `src/diagnostics/DiagnosticHub.ts` - Central state manager
- `src/diagnostics/validators/authoringValidators.ts` - Fast synchronous validators
- `src/diagnostics/DiagnosticStore.ts` - MobX wrapper (replace existing)

**Implementation Steps**:

[Detailed implementation steps continue as in the original response...]

**Acceptance Criteria (Deliverable 2)**:
1. ✅ Authoring validator performance: <10ms for 50-block patch
2. ✅ Compile snapshot replacement: CompileEnd replaces (not merges) diagnostics
3. ✅ DiagnosticHub.getActive() returns union of compile + authoring diagnostics
4. ✅ Authoring validators detect missing TimeRoot and multiple TimeRoots
5. ✅ DiagnosticStore.revision increments when diagnostic set changes (triggers MobX reactivity)

---

### Deliverable 3: Compiler Integration & Basic UI
**Files to Modify**:
- `src/compiler/compile.ts` - Add event emissions
- `src/compiler/diagnosticConversion.ts` - Convert CompileError → Diagnostic
- `src/stores/RootStore.ts` - Wire EventHub and DiagnosticHub
- `src/ui/components/app/DiagnosticConsole.tsx` - New component

**Acceptance Criteria (Deliverable 3)**:
1. ✅ Compiler emits CompileBegin before compilation, CompileEnd after (with diagnostics payload)
2. ✅ Compile errors appear in DiagnosticConsole as structured diagnostics with stable IDs
3. ✅ UI updates reactively when diagnostics change (via MobX computed)
4. ✅ Diagnostic rows display severity icon, title, message, and target location
5. ✅ GraphCommitted events emit after PatchStore mutations (via MobX reaction)

---

## Implementation Order (Critical Path)

1. **Day 1-2**: Create type definitions (TargetRef, Diagnostic, DiagnosticCode, event types)
2. **Day 2-3**: Implement EventHub with type-safe subscriptions
3. **Day 3-4**: Build DiagnosticHub with five-event subscription contract
4. **Day 4-5**: Wire EventHub into RootStore, add GraphCommitted emissions
5. **Day 5-6**: Modify compiler to emit CompileBegin/CompileEnd events
6. **Day 6-7**: Create authoring validators (TimeRoot checks, disconnected blocks)
7. **Day 7-8**: Build DiagnosticConsole React component with MobX reactivity
8. **Day 8-9**: Integration testing, polish, and documentation

**Total Estimated Effort**: 40-50 hours for Sprint 1 (P0 only)

---

## Out of Scope (Sprint 1)

Explicitly deferred to Sprint 2+:
- Runtime diagnostics (NaN detection, performance monitoring)
- Bus warnings (empty buses, no publishers)
- Diagnostic actions/quick fixes
- UI badges on blocks/ports/buses
- Diagnostic grouping
- Muting (removed from requirements per EVAL doc)
- Semantic path resolution (IDs are stable per EVAL doc)

---

## Success Criteria (Sprint 1)

Sprint 1 is complete when:
1. ✅ Compiler errors appear as structured diagnostics in UI
2. ✅ Diagnostics have stable IDs (deterministic generation)
3. ✅ EventHub exists with 5 core event types, type-safe subscriptions
4. ✅ DiagnosticHub maintains separate compile/authoring snapshots
5. ✅ Authoring validators detect missing/multiple TimeRoots synchronously
6. ✅ UI shows diagnostic console with severity filtering
7. ✅ All P0 acceptance criteria pass (15 total across 3 deliverables)
8. ✅ Zero regressions in existing functionality
