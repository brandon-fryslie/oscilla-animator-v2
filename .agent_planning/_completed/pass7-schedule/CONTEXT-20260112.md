# Implementation Context: Pass 7 Schedule Construction

Generated: 2026-01-12

## Overview

This document provides comprehensive context for implementing Pass 7 Schedule Construction.

## File Locations

### Primary Implementation File
- **Path**: `src/compiler/passes-v2/pass7-schedule.ts`
- **Current Lines**: 1-107
- **Status**: Stub returning empty `steps` array

### Key Reference Files
| File | Purpose |
|------|---------|
| `src/compiler/passes-v2/pass6-block-lowering.ts` | UnlinkedIRFragments structure |
| `src/compiler/ir/types.ts:286-317` | Step type definitions |
| `src/blocks/registry.ts:132-134` | getBlockDefinition() |
| `src/blocks/render-blocks.ts` | Render block definitions |
| `src/runtime/ScheduleExecutor.ts:65-255` | Runtime step execution |

## Type Definitions

### Step Types (from `src/compiler/ir/types.ts`)

```typescript
// Line 286-290
export interface StepEvalSig {
  readonly kind: 'evalSig';
  readonly expr: SigExprId;
  readonly target: ValueSlot;
}

// Line 292-297
export interface StepMaterialize {
  readonly kind: 'materialize';
  readonly field: FieldExprId;
  readonly domain: DomainId;
  readonly target: ValueSlot;
}

// Line 299-305
export interface StepRender {
  readonly kind: 'render';
  readonly domain: DomainId;
  readonly position: FieldExprId;
  readonly color: FieldExprId;
  readonly size?: SigExprId | FieldExprId;
}

// Line 307-311
export interface StepStateWrite {
  readonly kind: 'stateWrite';
  readonly stateSlot: StateSlotId;
  readonly value: SigExprId;
}

// Line 313-317
export type Step = StepEvalSig | StepMaterialize | StepRender | StepStateWrite;
```

### ScheduleIR (from `src/compiler/passes-v2/pass7-schedule.ts:35-50`)

```typescript
export interface ScheduleIR {
  readonly timeModel: TimeModel;
  readonly domains: ReadonlyMap<DomainId, DomainDef>;
  readonly steps: readonly Step[];
  readonly stateSlotCount: number;
  readonly stateSlots: readonly StateSlotDef[];
}
```

### UnlinkedIRFragments (from `src/compiler/passes-v2/pass6-block-lowering.ts:37-46`)

```typescript
export interface UnlinkedIRFragments {
  builder: IRBuilder;
  blockOutputs: Map<BlockIndex, Map<string, ValueRefPacked>>;
  errors: CompileError[];
}
```

### ValueRefPacked (from `src/compiler/ir/lowerTypes.ts`)

```typescript
export type ValueRefPacked =
  | { k: 'sig'; id: SigExprId; slot: ValueSlot }
  | { k: 'field'; id: FieldExprId; slot: ValueSlot }
  | { k: 'const'; value: unknown };
```

## Available Data at Pass 7

### From `unlinkedIR.builder` (IRBuilder methods)

| Method | Returns | Usage |
|--------|---------|-------|
| `getDomains()` | `ReadonlyMap<DomainId, DomainDef>` | Get all registered domains |
| `getSigExprs()` | `readonly SigExpr[]` | All signal expressions |
| `getFieldExprs()` | `readonly FieldExpr[]` | All field expressions |
| `getSigSlots()` | `ReadonlyMap<SigExprId, ValueSlot>` | Signal slot mappings |
| `getFieldSlots()` | `ReadonlyMap<FieldExprId, ValueSlot>` | Field slot mappings |
| `getSlotCount()` | `number` | Total slots allocated |

### From `unlinkedIR.blockOutputs`

Structure: `Map<BlockIndex, Map<portId, ValueRefPacked>>`

Example access:
```typescript
// Get output 'pos' from block at index 14
const blockOutputMap = unlinkedIR.blockOutputs.get(14 as BlockIndex);
const posRef = blockOutputMap?.get('pos');
// posRef: { k: 'field', id: FieldExprId, slot: ValueSlot }
```

### From `validated` (AcyclicOrLegalGraph)

| Field | Type | Usage |
|-------|------|-------|
| `blocks` | `readonly Block[]` | All block instances |
| `edges` | `readonly NormalizedEdge[]` | All edges with block indices |
| `sccs` | `readonly SCC[]` | Topological order |
| `timeModel` | `TimeModelIR` | Time configuration |

### NormalizedEdge Structure

```typescript
interface NormalizedEdge {
  fromBlock: BlockIndex;  // Source block index
  fromPort: string;       // Source port ID (e.g., 'pos', 'out')
  toBlock: BlockIndex;    // Target block index
  toPort: string;         // Target port ID (e.g., 'pos', 'domain')
}
```

## Render Block Details

### RenderInstances2D Input Ports (from `src/blocks/render-blocks.ts:110-115`)

```typescript
inputs: [
  { id: 'domain', label: 'Domain', type: canonicalType('int') },
  { id: 'pos', label: 'Position', type: signalTypeField('vec2', 'default') },
  { id: 'color', label: 'Color', type: signalTypeField('color', 'default') },
  { id: 'size', label: 'Size', type: signalTypeField('float', 'default') },
],
outputs: [],
```

### Identifying Render Blocks

```typescript
import { getBlockDefinition } from '../../blocks/registry';

function isRenderBlock(block: Block): boolean {
  const def = getBlockDefinition(block.type);
  return def?.capability === 'render';
}
```

## Implementation Algorithm

### Step 1: Find Render Blocks

```typescript
function findRenderBlocks(
  blocks: readonly Block[]
): Array<{ block: Block; index: BlockIndex }> {
  const result: Array<{ block: Block; index: BlockIndex }> = [];

  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    const def = getBlockDefinition(block.type);
    if (def?.capability === 'render') {
      result.push({ block, index: i as BlockIndex });
    }
  }

  return result;
}
```

### Step 2: Get Input ValueRef for a Block Port

```typescript
function getInputRef(
  blockIndex: BlockIndex,
  portId: string,
  edges: readonly NormalizedEdge[],
  blockOutputs: Map<BlockIndex, Map<string, ValueRefPacked>>
): ValueRefPacked | undefined {
  // Find edge targeting this block.port
  const edge = edges.find(
    e => e.toBlock === blockIndex && e.toPort === portId
  );

  if (!edge) return undefined;

  // Look up source block's outputs
  const sourceOutputs = blockOutputs.get(edge.fromBlock);
  if (!sourceOutputs) return undefined;

  return sourceOutputs.get(edge.fromPort);
}
```

### Step 3: Build Render Steps

```typescript
function buildRenderSteps(
  blocks: readonly Block[],
  edges: readonly NormalizedEdge[],
  blockOutputs: Map<BlockIndex, Map<string, ValueRefPacked>>,
  domains: ReadonlyMap<DomainId, DomainDef>
): StepRender[] {
  const steps: StepRender[] = [];
  const renderBlocks = findRenderBlocks(blocks);

  // MVP: Use first domain
  const domainId = domains.keys().next().value;
  if (!domainId) return steps;

  for (const { block, index } of renderBlocks) {
    const posRef = getInputRef(index, 'pos', edges, blockOutputs);
    const colorRef = getInputRef(index, 'color', edges, blockOutputs);
    const sizeRef = getInputRef(index, 'size', edges, blockOutputs);

    if (posRef?.k !== 'field' || colorRef?.k !== 'field') {
      console.warn(`Render block ${block.id} missing pos or color input`);
      continue;
    }

    const step: StepRender = {
      kind: 'render',
      domain: domainId,
      position: posRef.id,
      color: colorRef.id,
    };

    // Add size if present
    if (sizeRef?.k === 'field') {
      (step as any).size = sizeRef.id;
    } else if (sizeRef?.k === 'sig') {
      (step as any).size = sizeRef.id;
    }

    steps.push(step);
  }

  return steps;
}
```

### Step 4: Complete pass7Schedule Implementation

```typescript
export function pass7Schedule(
  unlinkedIR: UnlinkedIRFragments,
  validated: AcyclicOrLegalGraph
): ScheduleIR {
  const timeModel: TimeModel = convertTimeModel(validated.timeModel);
  const domains = unlinkedIR.builder.getDomains();

  // Build render steps
  const renderSteps = buildRenderSteps(
    validated.blocks,
    validated.edges,
    unlinkedIR.blockOutputs,
    domains
  );

  // Combine all steps (MVP: just render steps)
  const steps: Step[] = [...renderSteps];

  return {
    timeModel,
    domains,
    steps,
    stateSlotCount: 0,
    stateSlots: [],
  };
}
```

## Runtime Expectations

### ScheduleExecutor Step Handling (lines 95-213)

The runtime expects:
1. `schedule.domains` contains domain definitions with `count`
2. `schedule.steps` contains executable steps
3. For `render` steps:
   - `step.domain` matches key in `schedule.domains`
   - `step.position` is valid FieldExprId
   - `step.color` is valid FieldExprId
   - `step.size` is optional SigExprId or FieldExprId

### Render Step Execution (lines 137-200)

```typescript
case 'render': {
  const domain = domains.get(step.domain);

  const position = materialize(step.position, step.domain, fields, ...);
  const color = materialize(step.color, step.domain, fields, ...);

  // Size handling...

  passes.push({
    kind: 'instances2d',
    count: domain.count,
    position,
    color,
    size,
  });
}
```

## Demo Patch Structure

From `src/main.ts` lines 52-172:

- **Time**: `InfiniteTimeRoot` (b0)
- **Domain**: `DomainN` with n=5000 (b1)
- **Field generation**: FieldFromDomainId, FieldPulse, FieldGoldenAngle, etc.
- **Render**: `RenderInstances2D` (b26)

Key wiring to render block:
- `jitter.pos` -> `render.pos` (line 169)
- `color.color` -> `render.color` (line 170)
- `sizePulse.value` -> `render.size` (line 171)
- `domain.domain` -> `render.domain` (line 117)

## Imports Needed

```typescript
import type { Step, StepRender, DomainId, DomainDef } from '../ir/types';
import type { UnlinkedIRFragments } from './pass6-block-lowering';
import type { AcyclicOrLegalGraph, NormalizedEdge, BlockIndex } from '../ir/patches';
import type { Block } from '../../graph/Patch';
import type { ValueRefPacked } from '../ir/lowerTypes';
import { getBlockDefinition } from '../../blocks/registry';
```

## Test Verification

After implementation, verify with:

```bash
npm run typecheck  # Should pass
npm run test       # Should pass
npm run dev        # Should render particles
```

Console should show:
```
[main] Compile result: ok
[info] Compiled: 17 signals, 27 fields, X slots
[info] Runtime initialized
[info] Starting animation loop...
```

Canvas should show animated particles (5000 colorful squares moving in a spiral pattern).
