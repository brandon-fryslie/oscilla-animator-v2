# Implementation Context: Compilation Pipeline - Wire passes-v2

Generated: 2026-01-11 15:00:00

This document provides all context needed to implement the plan without investigation.

---

## User Architectural Decisions

These decisions were made by the user and MUST be followed:

1. **Pass 7**: Implement full schedule construction logic (not stub)
2. **Edge Types**: Full compiler rewrite - all passes use NormalizedEdge (not Edge)
3. **Parameter Threading**: Store blocks/edges in intermediate patch types
4. **IR Conversion**: Implement convertLinkedIRToProgram fully
5. **TimeRoot Validation**: Add NoTimeRoot and MultipleTimeRoots validation in Pass 3
6. **Error Kinds**: Preserve specific error kinds through pipeline
7. **Error Strategy**: Hybrid - collect all errors in pass, throw at end if any

---

## File Locations and Current State

### Core Files to Modify

| File | Lines | Status |
|------|-------|--------|
| `src/compiler/compile.ts` | 207 | Orchestrates passes, has try/catch, stub IR conversion |
| `src/compiler/ir/patches.ts` | 173 | Patch type definitions, missing blocks/edges on some |
| `src/compiler/passes-v2/pass2-types.ts` | 201 | Works, uses wrong Edge properties |
| `src/compiler/passes-v2/pass3-time.ts` | 82 | Wrong signature, wrong property access |
| `src/compiler/passes-v2/pass4-depgraph.ts` | 130 | Uses `blockIndexMap` (wrong), uses Edge (wrong) |
| `src/compiler/passes-v2/pass5-scc.ts` | 270 | Needs separate blocks param, returns errors |
| `src/compiler/passes-v2/pass6-block-lowering.ts` | ~400 | Needs blocks/edges params, returns errors |
| `src/compiler/passes-v2/pass7-schedule.ts` | 55 | ONLY TYPES - no implementation |
| `src/compiler/passes-v2/pass8-link-resolution.ts` | ~300 | Needs blocks/edges params, returns errors |
| `src/compiler/passes-v2/index.ts` | 42 | Missing pass7Schedule export |

### Reference Files (Read-Only)

| File | Purpose |
|------|---------|
| `src/graph/normalize.ts` | NormalizedPatch, NormalizedEdge definitions |
| `src/compiler/ir/program.ts` | CompiledProgramIR definition |
| `src/compiler/ir/schedule.ts` | TimeModelIR definition |
| `src/compiler/ir/types.ts` | SigExpr, FieldExpr, Step definitions |
| `src/blocks/registry.ts` | Block definitions and getBlockDefinition() |

---

## Data Type Definitions

### NormalizedEdge (Canonical - from normalize.ts:34-39)

```typescript
export interface NormalizedEdge {
  readonly fromBlock: BlockIndex;  // Dense index, NOT block ID
  readonly fromPort: PortId;
  readonly toBlock: BlockIndex;
  readonly toPort: PortId;
}
```

### Edge (Legacy - DO NOT USE in passes)

```typescript
interface Edge {
  readonly id: string;
  readonly from: { blockId: string; slotId: string };
  readonly to: { blockId: string; slotId: string };
  readonly enabled?: boolean;
}
```

### NormalizedPatch (from normalize.ts:20-32)

```typescript
export interface NormalizedPatch {
  readonly patch: Patch;
  readonly blockIndex: ReadonlyMap<BlockId, BlockIndex>;  // Note: blockIndex NOT blockIndexMap
  readonly blocks: readonly Block[];
  readonly edges: readonly NormalizedEdge[];
}
```

### TypedPatch (patches.ts:67-70) - NEEDS MODIFICATION

Current:
```typescript
export interface TypedPatch extends NormalizedPatch {
  readonly blockOutputTypes: ReadonlyMap<string, ReadonlyMap<string, SignalType | DomainRef>>;
}
```

After: Inherits blocks/edges from NormalizedPatch (no change needed - already correct!)

### TimeResolvedPatch (patches.ts:81-87) - Already correct

```typescript
export interface TimeResolvedPatch extends TypedPatch {
  readonly timeModel: TimeModelIR;
  readonly timeSignals: TimeSignals;
}
```

### AcyclicOrLegalGraph (patches.ts:154-161) - NEEDS blocks/edges

Current:
```typescript
export interface AcyclicOrLegalGraph {
  readonly graph: DepGraph;
  readonly sccs: readonly SCC[];
  readonly errors: readonly IllegalCycleError[];
  readonly timeModel: TimeModelIR;
}
```

After: Add blocks and edges:
```typescript
export interface AcyclicOrLegalGraph {
  readonly graph: DepGraph;
  readonly sccs: readonly SCC[];
  readonly errors: readonly IllegalCycleError[];
  readonly timeModel: TimeModelIR;
  readonly blocks: readonly Block[];           // ADD
  readonly edges: readonly NormalizedEdge[];   // ADD
}
```

---

## Pass-by-Pass Changes

### Pass 2: pass2-types.ts

**Current signature (line 137):**
```typescript
export function pass2TypeGraph(normalized: NormalizedPatch): TypedPatch
```

**Changes needed:**
- Line 159: `patch.edges` returns `NormalizedEdge[]`, not `Edge[]`
- Line 163-164: Change `edge.from.blockId`/`edge.to.blockId` to use NormalizedEdge lookup:
  ```typescript
  // Before (WRONG):
  const fromType = getEndpointType(edge.from, normalized.blocks);

  // After (CORRECT):
  const fromBlock = normalized.blocks[edge.fromBlock];
  const toBlock = normalized.blocks[edge.toBlock];
  // Then get port types from block definitions
  ```

**Error handling:** Already correct (collect + throw at end)

---

### Pass 3: pass3-time.ts

**Current signature (line 14-17):**
```typescript
export function pass3TimeTopology(
  typed: TypedPatch,
  errors: string[]  // WRONG - remove this
): TimeResolvedPatch
```

**New signature:**
```typescript
export function pass3TimeTopology(typed: TypedPatch): TimeResolvedPatch
```

**Property access fix (line 19):**
```typescript
// Before (WRONG):
const timeRoot = typed.normalizedPatch.blocks.find(...)

// After (CORRECT):
const timeRoot = typed.blocks.find(...)
```

**Add TimeRoot validation:**
```typescript
// After finding timeRoot
const timeRoots = typed.blocks.filter(
  b => b.kind === "InfiniteTimeRoot" || b.kind === "FiniteTimeRoot" || b.kind === "TimeRoot"
);

if (timeRoots.length === 0) {
  throw new Error("NoTimeRoot: Patch must have exactly one TimeRoot block");
}

if (timeRoots.length > 1) {
  throw new Error("MultipleTimeRoots: Patch has " + timeRoots.length + " TimeRoot blocks");
}
```

---

### Pass 4: pass4-depgraph.ts

**Current issues:**
- Line 67: Uses `timeResolved.blockIndexMap` (should be `blockIndex`)
- Line 82-88: Uses Edge type with `edge.from.blockId` (should use NormalizedEdge)

**Property fix (line 67):**
```typescript
// Before (WRONG):
const blockIndex = timeResolved.blockIndexMap.get(block.id);

// After (CORRECT):
// Don't need lookup - blocks are already in index order
// blockIndex IS the array index
```

**Edge handling fix (lines 82-108):**
```typescript
// Before (WRONG - uses Edge type):
const patchEdges: readonly Edge[] = timeResolved.edges ?? [];
for (const edge of patchEdges) {
  if (!edge.enabled) continue;
  const fromBlockIndex = timeResolved.blockIndexMap.get(edge.from.blockId);
  ...
}

// After (CORRECT - uses NormalizedEdge):
for (const edge of timeResolved.edges) {
  // NormalizedEdge already has block indices, no lookup needed!
  depEdges.push({
    from: { kind: "BlockEval", blockIndex: edge.fromBlock },
    to: { kind: "BlockEval", blockIndex: edge.toBlock },
  });
}
```

---

### Pass 5: pass5-scc.ts

**Current signature (line 230-233):**
```typescript
export function pass5CycleValidation(
  depGraphWithTime: DepGraphWithTimeModel,
  blocks: readonly Block[]  // REMOVE - get from patch
): AcyclicOrLegalGraph
```

**New approach:**
The `DepGraphWithTimeModel` needs to carry blocks and edges through. Modify pass4 output type:

```typescript
// In pass4-depgraph.ts, update output type:
export interface DepGraphWithTimeModel {
  readonly graph: DepGraph;
  readonly timeModel: TimeModelIR;
  readonly blocks: readonly Block[];           // ADD
  readonly edges: readonly NormalizedEdge[];   // ADD
}
```

Then pass5 can access `depGraphWithTime.blocks`.

**New signature:**
```typescript
export function pass5CycleValidation(
  depGraphWithTime: DepGraphWithTimeModel
): AcyclicOrLegalGraph
```

**Error handling change:**
Current returns errors in result. Change to throw:
```typescript
// At end of function, before return:
if (errors.length > 0) {
  const errorSummary = errors.map(e => `IllegalCycle at blocks: ${e.nodes.join(', ')}`).join('\n');
  throw new Error(`Pass 5 (Cycle Validation) failed:\n${errorSummary}`);
}
```

---

### Pass 6: pass6-block-lowering.ts

**Current signature (around line 350):**
```typescript
export function pass6BlockLowering(
  validated: AcyclicOrLegalGraph,
  blocks: readonly Block[],      // REMOVE - in validated
  edges?: readonly Edge[]        // REMOVE - in validated, wrong type
): UnlinkedIRFragments
```

**New signature:**
```typescript
export function pass6BlockLowering(
  validated: AcyclicOrLegalGraph
): UnlinkedIRFragments
```

**Access blocks/edges from validated:**
```typescript
const blocks = validated.blocks;
const edges = validated.edges;  // Now NormalizedEdge[]
```

**Edge type handling throughout:**
All internal functions using `Edge` need to use `NormalizedEdge`:
- `resolveInputsWithMultiInput` (line 84-91)
- Update `Writer` type in resolveWriters.ts if needed

**Error handling change:**
Current returns errors in result. Change to throw at end.

---

### Pass 7: pass7-schedule.ts - NEW IMPLEMENTATION

**Current state:** Only types defined, no function.

**Add function:**
```typescript
import type { UnlinkedIRFragments } from "./pass6-block-lowering";
import type { AcyclicOrLegalGraph } from "../ir/patches";

export function pass7Schedule(
  unlinked: UnlinkedIRFragments,
  validated: AcyclicOrLegalGraph
): ScheduleIR {
  // 1. Get topological order from SCCs (reverse SCC order = valid execution order)
  const topoOrder = computeTopologicalOrder(validated.sccs, validated.graph);

  // 2. Build execution steps from block order
  const steps = buildExecutionSteps(topoOrder, validated.blocks, unlinked);

  // 3. Count state slots
  const stateSlotCount = countStateSlots(unlinked);

  // 4. Build domain map
  const domains = buildDomainMap(validated.blocks);

  return {
    timeModel: convertTimeModel(validated.timeModel),
    domains,
    steps,
    stateSlotCount,
    stateSlots: [],  // Initial values TBD
  };
}
```

**Export from index.ts:**
```typescript
export { pass7Schedule } from "./pass7-schedule";
export type { ScheduleIR, StateSlotDef } from "./pass7-schedule";
```

---

### Pass 8: pass8-link-resolution.ts

**Current signature (line 97-100):**
```typescript
export function pass8LinkResolution(
  fragments: UnlinkedIRFragments,
  blocks: readonly Block[],
  edges: readonly Edge[]
): LinkedGraphIR
```

**New signature:**
```typescript
export function pass8LinkResolution(
  fragments: UnlinkedIRFragments,
  validated: AcyclicOrLegalGraph
): LinkedGraphIR
```

Access `validated.blocks` and `validated.edges` instead.

**Edge handling:** All uses of `Edge` must change to `NormalizedEdge`.

**Error handling:** Change from returning errors to throwing at end.

---

### compile.ts Changes

**Line 103-121 - Fix pass invocations:**

```typescript
// Current (WRONG):
const typedPatch = pass2TypeGraph(normalized);
const timeResolvedPatch = pass3TimeTopology(typedPatch);
const depGraphPatch = pass4DepGraph(timeResolvedPatch);
const acyclicPatch = pass5CycleValidation(depGraphPatch);
const unlinkedIR = pass6BlockLowering(acyclicPatch);
const scheduleIR = pass7Schedule(unlinkedIR);
const linkedIR = pass8LinkResolution(scheduleIR);

// After (CORRECT):
const typedPatch = pass2TypeGraph(normalized);
const timeResolvedPatch = pass3TimeTopology(typedPatch);
const depGraphPatch = pass4DepGraph(timeResolvedPatch);
const acyclicPatch = pass5CycleValidation(depGraphPatch);
const unlinkedIR = pass6BlockLowering(acyclicPatch);
const scheduleIR = pass7Schedule(unlinkedIR, acyclicPatch);
const linkedIR = pass8LinkResolution(unlinkedIR, acyclicPatch);
```

**Line 144-153 - Remove try/catch:**
Each pass now throws on error with specific error kinds. Remove the giant try/catch and let errors propagate naturally.

**Line 198-206 - Implement convertLinkedIRToProgram:**

```typescript
function convertLinkedIRToProgram(
  linkedIR: LinkedGraphIR,
  scheduleIR: ScheduleIR
): CompiledProgramIR {
  return {
    irVersion: 1,
    signalExprs: { nodes: linkedIR.builder.getSignalExprs() },
    fieldExprs: { nodes: linkedIR.builder.getFieldExprs() },
    eventExprs: { nodes: linkedIR.builder.getEventExprs() },
    constants: { json: linkedIR.builder.getConstants() },
    schedule: scheduleIR,
    outputs: buildOutputSpecs(linkedIR),
    slotMeta: buildSlotMeta(linkedIR),
    debugIndex: buildDebugIndex(linkedIR),
  };
}
```

---

## Error Types to Preserve

These error kinds must propagate to compile.ts and be returned in CompileError:

| Pass | Error Kind | When |
|------|------------|------|
| 1 | DanglingEdge | Edge references missing block |
| 1 | DuplicateBlockId | Same block ID twice |
| 2 | PortTypeUnknown | Can't determine port type |
| 2 | NoConversionPath | Type mismatch on edge |
| 3 | NoTimeRoot | No TimeRoot block |
| 3 | MultipleTimeRoots | >1 TimeRoot block |
| 4 | DanglingConnection | Edge to missing block |
| 5 | IllegalCycle | Cycle without state boundary |
| 6 | UnknownBlockType | Block type not in registry |
| 8 | UnresolvedPort | Port has no value |

---

## Test File Reference

`src/compiler/__tests__/compile.test.ts` - 11 tests

Tests expect these behaviors:
1. `result.kind === 'error'` when validation fails
2. `result.errors[0].kind === 'NoTimeRoot'` for missing TimeRoot
3. `result.errors[0].kind === 'MultipleTimeRoots'` for multiple TimeRoots
4. `result.kind === 'ok'` for valid patches
5. `result.program.signalExprs` accessible on success

---

## Implementation Order

1. **patches.ts** - Add blocks/edges to AcyclicOrLegalGraph, DepGraphWithTimeModel
2. **pass4-depgraph.ts** - Fix blockIndex, use NormalizedEdge, thread blocks/edges
3. **pass3-time.ts** - Fix signature, property access, add validation
4. **pass5-scc.ts** - Remove blocks param, change error handling
5. **pass2-types.ts** - Fix NormalizedEdge handling
6. **pass6-block-lowering.ts** - Remove params, fix edge type
7. **pass7-schedule.ts** - Implement function
8. **pass8-link-resolution.ts** - Remove params, fix edge type
9. **index.ts** - Add pass7Schedule export
10. **compile.ts** - Fix invocations, implement IR conversion, error handling

Run `npm run typecheck` after each file to catch issues incrementally.
