# PLAN: IR and Normalization 5-Axes Implementation

**Generated**: 2026-01-09T19:55:00Z
**Spec Reference**: `design-docs/IR-and-normalization-5-axes.md`

---

## Sprint Goal

Implement complete CompiledProgramIR with 5-axis type metadata, 6-phase graph normalization, and DebugIndexIR with port bindings per spec.

**Estimated Effort**: 3-4 sprints

---

## Scope

**In scope:**
- P0: CompiledProgramIR schema foundation
- P1: SlotMeta with offsets + axes exposure
- P2: Runtime update (outputs, offset addressing)
- P3: Normalization Phases 1-3 (source sets, fan-in, desugaring)
- P4: Normalization Phase 4 (type-directed legalization)
- P5: Normalization Phases 5-6 (cycle detection, ordering)
- P6: DebugIndexIR with port bindings

**Out of scope:**
- Editor UI integration
- Performance optimization beyond baseline
- Advanced debug tooling beyond spec

---

## P0: CompiledProgramIR Schema Foundation

**Goal**: Single authoritative interface as source of truth.

### P0.1: Create CompiledProgramIR Interface
**File**: `src/compiler/ir/program.ts` (NEW)

```typescript
interface CompiledProgramIR {
  readonly irVersion: 1;
  readonly signalExprs: SignalExprTable;
  readonly fieldExprs: FieldExprTable;
  readonly eventExprs: EventExprTable;
  readonly constants: { readonly json: readonly unknown[] };
  readonly schedule: ScheduleIR;
  readonly outputs: readonly OutputSpecIR[];
  readonly slotMeta: readonly SlotMetaEntry[];
  readonly debugIndex: DebugIndexIR;
}
```

### P0.2: Bridge to Existing IRProgram
- Mark `IRProgram` as `@deprecated`
- Add conversion function
- Update exports

### P0.3: Runtime Import Update
- Import from new location
- Accept both types during migration

**Acceptance Criteria:**
- [ ] `CompiledProgramIR` matches spec exactly
- [ ] `irVersion: 1` is literal type
- [ ] Runtime accepts new schema
- [ ] 68 existing tests pass

---

## P1: SlotMeta with Offsets + Axes Exposure

**Goal**: Mandatory offset and axes on every slot.

### P1.1: SlotMetaEntry
```typescript
interface SlotMetaEntry {
  readonly slot: ValueSlot;
  readonly storage: "f64" | "f32" | "i32" | "u32" | "object";
  readonly offset: number;  // REQUIRED
  readonly type: TypeDesc;
  readonly debugName?: string;
}
```

### P1.2: AxesDescIR
```typescript
interface AxesDescIR {
  readonly domain: "signal" | "field" | "event" | "value";
  readonly temporality: "static" | "discrete" | "continuous" | "instant";
  readonly perspective: "frame" | "sample" | "global";
  readonly branch: "single" | "branched";
  readonly identity: { kind: "none" } | { kind: "keyed"; keySpace: string };
}
```

### P1.3: Bridge Functions
- `bridgeExtentToAxesDescIR()` - SignalType.extent → AxesDescIR
- `payloadTypeToShapeDescIR()` - PayloadType → ShapeDescIR

### P1.4: IRBuilder Update
- Track slotMeta during allocation
- Compute offsets per storage class
- Emit axes via bridge functions

**Acceptance Criteria:**
- [ ] `offset` is required (no `?`)
- [ ] All 5 axes defined
- [ ] Bridge functions handle all cases
- [ ] Builder emits complete slotMeta

---

## P2: Runtime Update

**Goal**: Use outputs and offset addressing.

### P2.1: Outputs Field
- Add `addOutput()` to builder
- Populate in `build()` result

### P2.2: ScheduleExecutor Update
- Read from `program.outputs[0].slot`
- No hardcoded slot references

### P2.3: Offset Addressing
- `ValueStore` uses offset-based access
- `resolveSlotAddress()` helper

### P2.4: Forbid Runtime Derivation
- Assertion: offset must be present
- No offset computation in runtime

**Acceptance Criteria:**
- [ ] Runtime reads from outputs[0].slot
- [ ] All slot access uses slotMeta.offset
- [ ] Runtime never derives offsets

---

## P3: Normalization Phases 1-3

**Goal**: Structural normalization before type evaluation.

### P3.1: Pipeline Architecture
```typescript
function normalizeGraph(patch: Patch): NormalizedGraph {
  let g = phase0Sanity(patch);
  g = phase1SourceSets(g);
  g = phase2FanIn(g);
  g = phase3Desugaring(g);
  // ... phases 4-6
  return g;
}
```

### P3.2: Phase 1 - Source Sets
- Collect user wires per input port
- Determine default source (only-when-unwired)
- Create DefaultSource nodes

### P3.3: Phase 2 - Fan-In
- Insert Combine nodes for |S(p)| > 1
- Direct connection for |S(p)| == 1
- Error for |S(p)| == 0
- Deterministic writer ordering

### P3.4: Phase 3 - Desugaring
- Multi-output blocks → Project nodes
- Port aliases → eliminated
- Semantics-preserving

**Acceptance Criteria:**
- [ ] Phase functions are pure (no mutation)
- [ ] DefaultSource nodes created
- [ ] Combine nodes inserted correctly
- [ ] Writer ordering is deterministic

---

## P4: Normalization Phase 4

**Goal**: Type-directed legalization with explicit conversions.

### P4.1: Type Evaluation
- Evaluate on structurally-normalized graph
- Propagate axes through edges
- Detect mismatches

### P4.2: Conversion Nodes
- CoerceNumber, Lift, SampleAndHold, Project, Pack
- Explicit semantics documented

### P4.3: Legalization
- Insert conversion nodes for mismatches
- Error with expected vs actual types
- Axes never guessed

**Acceptance Criteria:**
- [ ] Conversion nodes inserted
- [ ] Error messages include types
- [ ] No implicit conversions

---

## P5: Normalization Phases 5-6

**Goal**: Cycle validation and deterministic ordering.

### P5.1: Phase 5 - Cycle Check
- SCC detection on final graph
- Require delay-breaking in cycles
- Error with cycle trace

### P5.2: Phase 6 - Canonical Ordering
- Topological sort per domain
- Stable tie-breaking
- Idempotent: normalize(normalize(G)) == normalize(G)

**Acceptance Criteria:**
- [ ] Cycles without delays rejected
- [ ] Error includes cycle path
- [ ] Ordering is deterministic
- [ ] Idempotence verified

---

## P6: DebugIndexIR

**Goal**: Full debug traceability.

### P6.1: DebugIndexIR Structure
```typescript
interface DebugIndexIR {
  readonly stepToBlock: ReadonlyMap<StepId, BlockId>;
  readonly slotToBlock: ReadonlyMap<ValueSlot, BlockId>;
  readonly ports: readonly PortBindingIR[];
  readonly slotToPort: ReadonlyMap<ValueSlot, PortId>;
  readonly combines?: readonly CombineDebugIR[];
}
```

### P6.2: PortBindingIR
- port, block, portName, direction
- role: userWire | defaultSource | implicitCoerce | internalHelper

### P6.3: CombineDebugIR
- step, mode, dst, contributors[]

### P6.4: Population
- Track during lowering
- All slots have entries
- All ports have bindings

**Acceptance Criteria:**
- [ ] Debug index contains all slots
- [ ] Port bindings have accurate roles
- [ ] Combine contributors tracked

---

## Forbidden Items (Per Spec)

MUST NOT appear in CompiledProgramIR:
- `program.nodes`
- `program.buses`
- `program.constPool`
- `program.transforms`
- `program.meta` (except under debugIndex)

---

## Dependencies

- P0-P3 complete (SignalType with 5-axis)
- Existing normalize.ts Phase 0
- Existing passes-v2 SCC detection

---

## Risks

1. **Breaking runtime** - Mitigate with dual-type support during migration
2. **Determinism bugs** - Mitigate with extensive ordering tests
3. **Complexity** - Mitigate with phase-by-phase implementation
