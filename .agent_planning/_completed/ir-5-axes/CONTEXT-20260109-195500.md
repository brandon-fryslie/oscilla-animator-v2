# Implementation Context: IR and Normalization 5-Axes

**Generated**: 2026-01-09T19:55:00Z

---

## Critical Files

### Create
| File | Purpose |
|------|---------|
| `src/compiler/ir/program.ts` | Authoritative CompiledProgramIR schema |

### Modify
| File | Changes |
|------|---------|
| `src/compiler/ir/types.ts` | Deprecate IRProgram, add re-exports |
| `src/compiler/ir/index.ts` | Export new types |
| `src/compiler/ir/builder.ts` | Add slotMeta tracking |
| `src/compiler/ir/IRBuilderImpl.ts` | Implement slotMeta, outputs |
| `src/graph/normalize.ts` | Add phases 1-6 |
| `src/runtime/ScheduleExecutor.ts` | Offset addressing, outputs |
| `src/runtime/RuntimeState.ts` | Offset-based ValueStore |

### Reference (Read-Only)
| File | Purpose |
|------|---------|
| `src/core/canonical-types.ts` | CanonicalType, Extent (bridge source) |
| `design-docs/IR-and-normalization-5-axes.md` | Authoritative spec |
| `src/compiler/passes-v2/pass5-scc.ts` | Existing cycle detection |

---

## Key Type Mappings

### CanonicalType.extent → AxesDescIR

```typescript
// Source (canonical-types.ts)
interface Extent {
  cardinality: AxisTag<Cardinality>;  // zero | one | many
  temporality: AxisTag<Temporality>;  // continuous | discrete
  binding: AxisTag<Binding>;
  perspective: AxisTag<PerspectiveId>;
  branch: AxisTag<BranchId>;
}

// Target (spec)
interface AxesDescIR {
  domain: "signal" | "field" | "event" | "value";
  temporality: "static" | "discrete" | "continuous" | "instant";
  perspective: "frame" | "sample" | "global";
  branch: "single" | "branched";
  identity: { kind: "none" } | { kind: "keyed"; keySpace: string };
}

// Mapping:
// cardinality.zero → domain="value"
// cardinality.one + continuous → domain="signal"
// cardinality.many → domain="field"
// temporality.discrete → domain="event"
```

### PayloadType → ShapeDescIR

```typescript
// 'float' | 'int' | 'phase' | 'unit' → { kind: "number" }
// 'vec2' → { kind: "vec", lanes: 2, element: "number" }
// 'color' → { kind: "vec", lanes: 4, element: "number" }
// 'bool' → { kind: "bool" }
```

---

## Bridge Functions to Implement

```typescript
// src/compiler/ir/program.ts

export function bridgeExtentToAxesDescIR(extent: Extent): AxesDescIR {
  const card = getAxisValue(extent.cardinality, DEFAULTS_V0.cardinality);
  const temp = getAxisValue(extent.temporality, DEFAULTS_V0.temporality);

  // Derive domain from cardinality + temporality
  let domain: AxesDescIR['domain'];
  if (card.kind === 'zero') {
    domain = 'value';
  } else if (temp.kind === 'discrete') {
    domain = 'event';
  } else if (card.kind === 'many') {
    domain = 'field';
  } else {
    domain = 'signal';
  }

  return {
    domain,
    temporality: temp.kind === 'continuous' ? 'continuous' :
                 temp.kind === 'discrete' ? 'discrete' : 'static',
    perspective: getAxisValue(extent.perspective, 'global') as any,
    branch: 'single',  // v0 default
    identity: { kind: 'none' },  // v0 default
  };
}

export function payloadTypeToShapeDescIR(payload: PayloadType): ShapeDescIR {
  switch (payload) {
    case 'float':
    case 'int':
    case 'phase':
    case 'unit':
      return { kind: 'number' };
    case 'vec2':
      return { kind: 'vec', lanes: 2, element: 'number' };
    case 'color':
      return { kind: 'vec', lanes: 4, element: 'number' };
    case 'bool':
      return { kind: 'bool' };
  }
}
```

---

## Normalization Phase Functions

```typescript
// src/graph/normalize.ts

// Phase 0 (existing) - Sanity + canonical IDs
function phase0Sanity(patch: Patch): Phase0Result

// Phase 1 - Build per-input source sets
function phase1SourceSets(graph: Phase0Result): Phase1Result {
  // For each input port:
  // - S_user(p) = user wires connected
  // - S_default(p) = default if unwired
  // - Create DefaultSource nodes
}

// Phase 2 - Explicit fan-in via Combine
function phase2FanIn(graph: Phase1Result): Phase2Result {
  // |S(p)| == 0: error "missing required input"
  // |S(p)| == 1: direct connection
  // |S(p)| > 1: insert Combine node
}

// Phase 3 - Structural desugaring
function phase3Desugaring(graph: Phase2Result): Phase3Result {
  // Multi-output blocks → Project nodes
  // Port aliases → eliminated
}

// Phase 4 - Type-directed legalization
function phase4Legalization(graph: Phase3Result): Phase4Result {
  // For each edge where type(src) != expected(dst):
  // - If conversion exists: insert node
  // - Else: compile error
}

// Phase 5 - Cycle check
function phase5CycleCheck(graph: Phase4Result): Phase5Result {
  // SCC detection
  // Validate delay-breaking operators in cycles
}

// Phase 6 - Canonical ordering
function phase6CanonicalOrdering(graph: Phase5Result): FinalGraph {
  // Topological sort
  // Stable tie-breaking
}
```

---

## IRBuilder Updates

```typescript
// src/compiler/ir/IRBuilderImpl.ts

class IRBuilderImpl implements IRBuilder {
  private slotMeta: SlotMetaEntry[] = [];
  private outputs: OutputSpecIR[] = [];
  private storageOffsets = { f64: 0, f32: 0, i32: 0, u32: 0, object: 0 };

  allocSlot(type: CanonicalType, debugName?: string): ValueSlot {
    const slot = makeValueSlot(this.nextSlotId++);
    const storage = this.inferStorage(type);
    const offset = this.storageOffsets[storage]++;

    this.slotMeta.push({
      slot,
      storage,
      offset,
      type: {
        axes: bridgeExtentToAxesDescIR(type.extent),
        shape: payloadTypeToShapeDescIR(type.payload),
      },
      debugName,
    });

    return slot;
  }

  addOutput(slot: ValueSlot): void {
    this.outputs.push({ kind: 'renderFrame', slot });
  }

  build(): CompiledProgramIR {
    return {
      irVersion: 1,
      signalExprs: this.signals,
      fieldExprs: this.fields,
      eventExprs: this.events,
      constants: { json: this.constants },
      schedule: this.schedule,
      outputs: this.outputs,
      slotMeta: this.slotMeta,
      debugIndex: this.buildDebugIndex(),
    };
  }
}
```

---

## Runtime Updates

```typescript
// src/runtime/ScheduleExecutor.ts

function executeFrame(program: CompiledProgramIR, state: RuntimeState) {
  // Execute steps...

  // Extract render output from outputs contract
  const renderOutput = program.outputs.find(o => o.kind === 'renderFrame');
  if (!renderOutput) throw new Error('Missing render output');

  return readSlot(state, program.slotMeta, renderOutput.slot);
}

function readSlot(
  state: RuntimeState,
  slotMeta: readonly SlotMetaEntry[],
  slot: ValueSlot
): unknown {
  const meta = slotMeta.find(m => m.slot === slot);
  if (!meta) throw new Error(`Unknown slot: ${slot}`);
  if (meta.offset === undefined) throw new Error('Forbidden: missing offset');

  return state.stores[meta.storage][meta.offset];
}
```

---

## Invariants

1. **ONE SOURCE OF TRUTH**: CompiledProgramIR is authoritative
2. **SINGLE ENFORCER**: Offset computed only in compiler
3. **ONE-WAY DEPENDENCIES**: IR → Runtime (never reverse)
4. **No implicit defaults**: DefaultSource nodes are explicit
5. **Deterministic ordering**: Combine contributors have stable order
6. **Axes never guessed**: Conversions are explicit nodes

---

## Error Messages

```
Missing required input:
  Block "{blockId}" port "{portId}" has no connected source.

Type mismatch:
  Source: {sourceType} (from {block}.{port})
  Expected: {destType} (at {block}.{port})
  No automatic conversion exists.

Algebraic loop:
  Cycle: {block1} -> {block2} -> {block3} -> {block1}
  Insert a delay block to break the loop.
```
