# PLAN: Compiler & IR 5-Axes Implementation (Unified)

**Generated**: 2026-01-09T20:00:00Z
**Spec References**:
- `design-docs/IR-and-normalization-5-axes.md` - IR schema + normalization
- `design-docs/compiler-changes.md` - 10-pass compiler pipeline

---

## Sprint Goal

Implement the complete compiler pipeline with CompiledProgramIR schema, 6-phase graph normalization, type-directed lowering, and schedule construction per unified spec.

**Estimated Effort**: 3-4 sprints

---

## Scope

**In scope:**
- P0: CompiledProgramIR schema foundation
- P1: SlotMeta with offsets + axes exposure
- P2: Compiler passes 0-4 (validate, normalize, type, unify, resolve)
- P3: Compiler passes 5-6 (lower to execution classes, build program tables)
- P4: Compiler passes 7-8 (schedule construction, slot planning)
- P5: Runtime update (offset addressing, outputs contract)
- P6: DebugIndexIR (pass 10)

**Out of scope:**
- Editor UI integration
- Incremental compilation
- Performance optimization beyond baseline

---

## Architecture Overview (from compiler-changes.md)

### Compiler Pipeline (10 Passes)

| Pass | Name | Purpose |
|------|------|---------|
| 0 | Parse/Validate | Validate graph, block kinds, ports |
| 1 | Normalize | Default sources, buses, combine points, domains |
| 2 | Type Assignment | Assign SignalType with AxisTag per port |
| 3 | Unification | Strict axis unification across edges |
| 4 | Resolve Defaults | Apply canonical defaults (v0) |
| 5 | Lower | Type-directed lowering to execution classes |
| 6 | Build Tables | Dense program tables per class |
| 7 | Schedule | Topological + phase ordering |
| 8 | Slot Planning | Emit slotMeta with offsets |
| 9 | Constants | JSON-only constant pool |
| 10 | Debug Index | Provenance mapping |

### Execution Classes

- **Scalar continuous**: `one + continuous` → scalar expr node
- **Field continuous**: `many(domain) + continuous` → field expr node (looped)
- **Scalar discrete**: `one + discrete` → event stream ops
- **Sink**: render/write endpoints

---

## P0: CompiledProgramIR Schema Foundation

**Goal**: Single authoritative interface.

### P0.1: Create CompiledProgramIR Interface
**File**: `src/compiler/ir/program.ts` (NEW)

```typescript
interface CompiledProgramIR {
  readonly irVersion: 1;
  readonly signalExprs: SignalExprTable;
  readonly fieldExprs: FieldExprTable;
  readonly eventExprs: EventExprTable;
  readonly constants: { readonly json: readonly unknown[] };
  readonly schedule: ScheduleIR;
  readonly outputs: readonly OutputSpecIR[];
  readonly slotMeta: readonly SlotMetaEntry[];
  readonly debugIndex: DebugIndexIR;
}
```

### P0.2: Execution Table Types
```typescript
// Dense, cache-friendly tables per execution class
interface SignalExprTable {
  readonly nodes: readonly SignalExprNode[];
}

interface FieldExprTable {
  readonly nodes: readonly FieldExprNode[];
}

interface EventExprTable {
  readonly nodes: readonly EventExprNode[];
}
```

**Acceptance Criteria:**
- [ ] `CompiledProgramIR` matches spec exactly
- [ ] `irVersion: 1` is literal type
- [ ] Execution tables are dense arrays
- [ ] 68 existing tests pass

---

## P1: SlotMeta with Offsets + Axes

**Goal**: Mandatory offset and axes on every slot.

### P1.1: SlotMetaEntry
```typescript
interface SlotMetaEntry {
  readonly slot: ValueSlot;
  readonly storage: "f64" | "f32" | "i32" | "u32" | "object";
  readonly offset: number;  // REQUIRED, per-storage index
  readonly type: TypeDesc;
  readonly debugName?: string;
}

interface TypeDesc {
  readonly axes: AxesDescIR;
  readonly shape: ShapeDescIR;
}
```

### P1.2: AxesDescIR (from IR spec)
```typescript
interface AxesDescIR {
  readonly domain: "signal" | "field" | "event" | "value";
  readonly temporality: "static" | "discrete" | "continuous" | "instant";
  readonly perspective: "frame" | "sample" | "global";
  readonly branch: "single" | "branched";
  readonly identity:
    | { readonly kind: "none" }
    | { readonly kind: "keyed"; readonly keySpace: string };
}
```

### P1.3: Bridge Functions
- `bridgeExtentToAxesDescIR()` - SignalType.extent → AxesDescIR
- `payloadTypeToShapeDescIR()` - PayloadType → ShapeDescIR

**Acceptance Criteria:**
- [ ] `offset` is required (no `?`)
- [ ] All 5 axes defined
- [ ] Bridge functions handle all SignalType variants
- [ ] Shape covers all PayloadTypes

---

## P2: Compiler Passes 0-4 (Type System)

**Goal**: Validate, normalize, and prove types.

### P2.1: Pass 0 - Parse/Validate
- Validate graph connectivity
- Check missing ports, unknown block kinds
- Validate DomainDecl parameters

### P2.2: Pass 1 - Normalize (already partial)
- Materialize default sources
- Materialize buses as explicit nodes
- Normalize combine points on input ports
- Canonicalize node IDs

### P2.3: Pass 2 - Type Assignment
- Assign `SignalType = { payload, extent }` per port
- Ports use AxisTag (mostly default)
- Blocks declare port type schemas as constraints

### P2.4: Pass 3 - Unification
- Strict v0 unification: `default + instantiated → instantiated`
- Unify per-edge (output → input)
- Unify per-combine (all writers → port)
- Domain alignment is identity (A == B required)

### P2.5: Pass 4 - Resolve Defaults
- Apply `AxisDefaults` + `EvalFrame` resolution
- v0: canonical defaults only (global/main/unbound)
- Produce fully-instantiated `ResolvedType` per port

**Acceptance Criteria:**
- [ ] Pass 0 rejects invalid graphs with clear errors
- [ ] Pass 1 produces ClosedNormalizedGraph
- [ ] Pass 2 assigns SignalType to all ports
- [ ] Pass 3 detects all type mismatches
- [ ] Pass 4 resolves all AxisTag.default

---

## P3: Compiler Passes 5-6 (Lowering)

**Goal**: Type-directed lowering to execution classes.

### P3.1: Pass 5 - Lower to Execution Forms
Lower each node based on resolved extent:

| Extent Pattern | Execution Class |
|----------------|-----------------|
| `one + continuous` | Scalar continuous |
| `many(domain) + continuous` | Field continuous (looped) |
| `one + discrete` | Scalar discrete (event) |
| `many(domain) + discrete` | Field discrete (event) |
| sinks | Render endpoints |

Each lowered node declares:
- Slots it reads/writes
- Whether it requires state slots
- Which domain loop it belongs to (if field)

### P3.2: Pass 6 - Build Program Tables
Create dense, cache-friendly tables:
- `signalExprs.nodes[]`
- `fieldExprs.nodes[]`
- `eventOps.nodes[]`
- `renderSinks.nodes[]`

**Acceptance Criteria:**
- [ ] Each node lowered to correct execution class
- [ ] Field nodes tagged with domain
- [ ] Tables are dense arrays (no gaps)
- [ ] State slots tracked per node

---

## P4: Compiler Passes 7-8 (Schedule + Slots)

**Goal**: Deterministic schedule and slot layout.

### P4.1: Pass 7 - Schedule Construction
Scheduling constraints:
1. Respect data dependencies
2. Respect state update ordering
3. Separate phases:
   - Update rails/time inputs
   - Execute continuous scalars
   - Execute continuous fields (domain loops)
   - Apply discrete ops (events)
   - Sinks

Schedule ops are coarse:
- "execute all scalar expr nodes"
- "execute field expr nodes per domain"
- Not "execute arbitrary graph node with dynamic dispatch"

### P4.2: Pass 8 - Slot Planning (slotMeta)
Inputs:
- All slots referenced by tables/schedule
- Storage class requirements
- Payload type widths
- Per-domain cardinality (for field/state arrays)

Output:
- `program.slotMeta[]` with per-slot:
  - slotId
  - storage class
  - offset (index within storage array)
  - shape (scalar vs field with laneCount)

**Critical**: Offsets are per-storage and stable-ordered (slotId ascending).

**Acceptance Criteria:**
- [ ] Schedule respects all dependencies
- [ ] Phase ordering is deterministic
- [ ] Slot offsets are per-storage
- [ ] No runtime offset derivation needed

---

## P5: Runtime Update

**Goal**: Runtime uses offset addressing and outputs contract.

### P5.1: Outputs Contract
- `program.outputs[0].slot` is the only output mechanism
- Exactly one output with `kind: "renderFrame"` required

### P5.2: Offset Addressing
```typescript
function readSlot(state: RuntimeState, meta: SlotMetaEntry): unknown {
  return state.stores[meta.storage][meta.offset];
}
```

### P5.3: Execution Model
- Runtime executes `schedule` steps
- No node tables, no dynamic dispatch
- Delete `executeNodeEval.ts` concept

**Acceptance Criteria:**
- [ ] Runtime reads from outputs[0].slot
- [ ] All slot access uses slotMeta.offset
- [ ] Runtime is O(work) with predictable loops
- [ ] No runtime type checks or inference

---

## P6: DebugIndexIR (Pass 9-10)

**Goal**: Full debug traceability.

### P6.1: Pass 9 - Constants Pool
- `program.constants = { json: unknown[] }`
- No typed-array const pools

### P6.2: Pass 10 - Debug Index
```typescript
interface DebugIndexIR {
  readonly stepToBlock: ReadonlyMap<StepId, BlockId>;
  readonly slotToBlock: ReadonlyMap<ValueSlot, BlockId>;
  readonly ports: readonly PortBindingIR[];
  readonly slotToPort: ReadonlyMap<ValueSlot, PortId>;
  readonly combines?: readonly CombineDebugIR[];
}
```

### P6.3: Port Binding
```typescript
interface PortBindingIR {
  readonly port: PortId;
  readonly block: BlockId;
  readonly portName: string;
  readonly direction: "in" | "out";
  readonly domain: "signal" | "field" | "event" | "value";
  readonly role: "userWire" | "defaultSource" | "implicitCoerce" | "internalHelper";
}
```

**Acceptance Criteria:**
- [ ] Debug index contains all slots
- [ ] Port bindings have accurate roles
- [ ] Combine contributors tracked
- [ ] Provenance enables "click value → see port"

---

## Forbidden Items (Per Spec)

MUST NOT appear in CompiledProgramIR:
- `program.nodes`
- `program.buses`
- `program.constPool` (use constants.json only)
- `program.transforms`
- `program.meta` (except under debugIndex)

---

## Dependencies

- P0-P3 complete (SignalType with 5-axis) ✓
- Existing normalize.ts Phase 0 ✓
- Existing passes-v2 SCC detection

---

## Sprint Allocation

### Sprint 1 (Foundation)
- P0: CompiledProgramIR schema
- P1: SlotMeta + axes bridging

### Sprint 2 (Type System)
- P2: Compiler passes 0-4

### Sprint 3 (Lowering + Schedule)
- P3: Passes 5-6 (lowering, tables)
- P4: Passes 7-8 (schedule, slots)

### Sprint 4 (Runtime + Debug)
- P5: Runtime update
- P6: DebugIndexIR

---

## Risks

1. **Breaking runtime** - Mitigate with dual-type support during migration
2. **Determinism bugs** - Mitigate with extensive ordering tests
3. **Performance** - Mitigate by keeping runtime O(work) with no inference
