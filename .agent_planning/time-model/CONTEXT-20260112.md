# Implementation Context: TimeRoot Complete Outputs

**Generated:** 2026-01-12
**Topic:** time-model

This document provides all context needed to implement the plan.

---

## File Locations

### Primary Files to Modify

1. **`src/blocks/time-blocks.ts`** (~95 lines)
   - Contains `InfiniteTimeRoot` block definition
   - Each has `outputs` object with signal types
   - Each has `params` object for configuration

2. **`src/compiler/passes-v2/pass3-time.ts`** (~132 lines)
   - Extracts TimeModel from patch
   - Generates TimeSignals with SigExprIds
   - Interface `TimeSignals` defines signal IDs

3. **`src/runtime/timeResolution.ts`** (~118 lines)
   - `TimeState` interface holds computed time values
   - `resolveTime()` function computes all time values
   - Already has phaseA, phaseB, dt, pulse, progress

4. **`src/runtime/SignalEvaluator.ts`**
   - Switch statement evaluates time signals
   - Returns values from `state.time`

---

## Current Code Patterns

### time-blocks.ts Pattern

```typescript
export const InfiniteTimeRoot: BlockDef = {
  kind: 'infinite_time_root',
  inputs: {},
  outputs: {
    tMs: signalTypeSignal('float'),
    dt: signalTypeSignal('float'),
    phaseA: signalTypeSignal('float'),  // Change to 'phase'
    phaseB: signalTypeSignal('float'),  // Change to 'phase'
    pulse: signalTypeSignal('bool'),
    // ADD: palette: signalTypeSignal('color'),
    // ADD: energy: signalTypeSignal('float'),
  },
  params: {
    periodMs: { type: 'float', default: 1000 },
    // CHANGE TO: periodAMs, periodBMs
  },
  // ...
};
```

### pass3-time.ts Pattern

```typescript
interface TimeSignals {
  tMs: SigExprId;
  dt: SigExprId;
  phaseA: SigExprId;
  phaseB: SigExprId;
  pulse: SigExprId;
  progress: SigExprId | undefined;
  // ADD: palette: SigExprId;
  // ADD: energy: SigExprId;
}
```

### timeResolution.ts Pattern

```typescript
export interface TimeState {
  tMs: number;
  dt: number;
  phaseA: number;
  phaseB: number;
  pulse: boolean;
  progress: number | undefined;
  // ADD: palette: { r: number; g: number; b: number; a: number };
  // ADD: energy: number;
}

export function resolveTime(/* ... */): TimeState {
  // Existing phase computation
  const phaseA = wrapPhase((tMs / periodAMs) + offsetA);
  const phaseB = wrapPhase((tMs / periodBMs) + offsetB);

  // ADD: Palette computation (HSV to RGB)
  // hue = phaseA (0..1), sat = 1.0, val = 0.5

  // ADD: Energy computation
  // energy = 0.5 + 0.5 * Math.sin(phaseA * 2 * Math.PI)
}
```

---

## HSV to RGB Conversion

Standard formula for HSV to RGB (all values 0..1):

```typescript
function hsvToRgb(h: number, s: number, v: number): { r: number; g: number; b: number; a: number } {
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);

  let r: number, g: number, b: number;
  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
    default: r = 0; g = 0; b = 0;
  }

  return { r, g, b, a: 1.0 };
}
```

---

## Energy Computation

```typescript
const energy = 0.5 + 0.5 * Math.sin(phaseA * 2 * Math.PI);
// At phaseA = 0:    sin(0) = 0      → energy = 0.5
// At phaseA = 0.25: sin(π/2) = 1    → energy = 1.0
// At phaseA = 0.5:  sin(π) = 0      → energy = 0.5
// At phaseA = 0.75: sin(3π/2) = -1  → energy = 0.0
```

---

## Import Statements

### time-blocks.ts
```typescript
import { signalTypeSignal } from '../core/canonical-types';
// 'color' and 'phase' are valid PayloadTypes
```

### timeResolution.ts
```typescript
// No new imports needed, just add hsvToRgb helper function
```

---

## Type Definitions

### PayloadType (already includes 'phase' and 'color')
```typescript
// src/core/canonical-types.ts
export type PayloadType =
  | 'float'
  | 'int'
  | 'vec2'
  | 'color'  // RGBA color
  | 'phase'  // [0, 1) with wrap semantics
  | 'bool'
  | 'unit';
```

---

## Test Expectations

### Palette Test Values
- phaseA = 0.0 → Red (h=0) → RGB ≈ (0.5, 0, 0) with val=0.5
- phaseA = 0.33 → Green (h=120°) → RGB ≈ (0, 0.5, 0)
- phaseA = 0.66 → Blue (h=240°) → RGB ≈ (0, 0, 0.5)

### Energy Test Values
- phaseA = 0.0 → energy = 0.5
- phaseA = 0.25 → energy = 1.0
- phaseA = 0.5 → energy = 0.5
- phaseA = 0.75 → energy = 0.0

### Period Independence
- With periodAMs=1000, periodBMs=2000
- At t=1000ms: phaseA wraps, phaseB at 0.5
- At t=2000ms: phaseA wraps twice, phaseB wraps once
