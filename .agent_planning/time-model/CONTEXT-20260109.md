# Implementation Context: Time Model - Dual-Phase System

Generated: 2026-01-09T07:30:00Z

This document provides comprehensive context for write-only implementation of the time-model sprint.

---

## Canonical Spec Reference

**Source of Truth**: `design-docs/CANONICAL-oscilla-v2.5-20260109/topics/03-time-system.md`

### Key Spec Excerpts

**TimeRoot Outputs (§57-66):**
| Output | Cardinality | Temporality | Payload |
|--------|-------------|-------------|---------|
| `tMs` | one | continuous | int |
| `phaseA` | one | continuous | phase |
| `phaseB` | one | continuous | phase |
| `progress` | one | continuous | unit (finite only) |
| `pulse` | one | discrete | unit |

**Phase Wrap Semantics (§165-168):**
- Phase values in range [0, 1) with automatic wrap
- `0.9 + 0.2 = 0.1` (wrapped)
- `1.0 → 0.0` (normalized)

**Hot-Swap Behavior (§273-289):**
- `tMs` continues unchanged
- Phase continuity formula: `new_phase = old_phase + (new_speed - old_speed) * elapsed_time`
- State cells preserved by StateId matching

---

## Current Implementation State

### File: `src/compiler/blocks/time/InfiniteTimeRoot.ts` (52 lines)

**Current outputs:**
```typescript
{
  t: { kind: 'sig', id: t, type: sigType('float') },
  dt: { kind: 'sig', id: dt, type: sigType('float') },
  phase: { kind: 'sig', id: phase, type: sigType('phase') },
  pulse: { kind: 'event', id: pulse },
  energy: { kind: 'sig', id: energy, type: sigType('float') },
}
```

**Current config:**
```typescript
const periodMs = typeof config.periodMs === 'number' ? config.periodMs : 4000;
```

**Required changes:**
1. Rename `t` → `tMs`, change type to `sigType('int')` (spec says int)
2. Replace single `phase` with `phaseA` and `phaseB`
3. Add `periodAMs` and `periodBMs` config
4. Remove `energy` output (not in spec)
5. Register updated output ports

### File: `src/compiler/blocks/time/FiniteTimeRoot.ts` (65 lines)

**Current outputs:** Same as InfiniteTimeRoot + `progress`

**Required changes:** Same as InfiniteTimeRoot

### File: `src/compiler/ir/types.ts` (320 lines)

**Current `SigExprTime`:**
```typescript
export interface SigExprTime {
  readonly kind: 'time';
  readonly which: 't' | 'dt' | 'phase' | 'pulse' | 'energy';
  readonly type: SignalType;
}
```

**Required change:**
```typescript
export interface SigExprTime {
  readonly kind: 'time';
  readonly which: 'tMs' | 'phaseA' | 'phaseB' | 'dt' | 'pulse' | 'progress';
  readonly type: SignalType;
}
```

**Current `TimeModel`:**
```typescript
export type TimeModel =
  | { kind: 'finite'; durationMs: number }
  | { kind: 'infinite'; windowMs?: number }
  | { kind: 'cyclic'; periodMs: number };
```

**Required change:**
```typescript
export type TimeModel =
  | { kind: 'finite'; durationMs: number; periodAMs?: number; periodBMs?: number }
  | { kind: 'infinite'; windowMs?: number; periodAMs?: number; periodBMs?: number }
  | { kind: 'cyclic'; periodAMs: number; periodBMs: number };
```

### File: `src/runtime/timeResolution.ts` (144 lines)

**Current `EffectiveTime`:**
```typescript
export interface EffectiveTime {
  tAbsMs: number;
  tModelMs: number;
  dt: number;
  phase?: number;
  pulse?: number;
  progress?: number;
  energy?: number;
}
```

**Required change:**
```typescript
export interface EffectiveTime {
  tAbsMs: number;      // Absolute time (input)
  tMs: number;         // Model time (tModelMs renamed for spec compliance)
  dt: number;          // Delta time
  phaseA: number;      // Primary phase [0,1) from periodAMs
  phaseB: number;      // Secondary phase [0,1) from periodBMs
  pulse: number;       // 1.0 on wrap, 0.0 otherwise
  progress?: number;   // Finite only, 0..1
}
```

**Current `TimeState`:**
```typescript
export interface TimeState {
  prevTAbsMs: number | null;
  prevTModelMs: number | null;
  wrapCount: number;
}
```

**Required change:**
```typescript
export interface TimeState {
  prevTAbsMs: number | null;
  prevTModelMs: number | null;
  // Dual phase tracking
  prevPhaseA: number | null;
  prevPhaseB: number | null;
  wrapCountA: number;
  wrapCountB: number;
  // Phase continuity offsets (for hot-swap)
  offsetA: number;
  offsetB: number;
}
```

**Current `resolveTime` (cyclic case):**
```typescript
case 'cyclic': {
  const periodMs = timeModel.periodMs;
  const tModelMs = ((tAbsMs % periodMs) + periodMs) % periodMs;
  const phase = periodMs > 0 ? tModelMs / periodMs : 0;
  // ... wrap detection
}
```

**Required change (cyclic case):**
```typescript
case 'cyclic': {
  const { periodAMs, periodBMs } = timeModel;
  const tMs = tAbsMs; // Monotonic, no wrapping

  // Phase A with offset for continuity
  const rawPhaseA = periodAMs > 0 ? (tAbsMs / periodAMs) % 1.0 : 0;
  const phaseA = (rawPhaseA + timeState.offsetA + 1.0) % 1.0;

  // Phase B with offset for continuity
  const rawPhaseB = periodBMs > 0 ? (tAbsMs / periodBMs) % 1.0 : 0;
  const phaseB = (rawPhaseB + timeState.offsetB + 1.0) % 1.0;

  // Wrap detection for pulse
  const wrapA = timeState.prevPhaseA !== null && phaseA < timeState.prevPhaseA - 0.5;
  const wrapB = timeState.prevPhaseB !== null && phaseB < timeState.prevPhaseB - 0.5;
  const pulse = (wrapA || wrapB) ? 1.0 : 0.0;

  // Update state
  timeState.prevPhaseA = phaseA;
  timeState.prevPhaseB = phaseB;
  if (wrapA) timeState.wrapCountA++;
  if (wrapB) timeState.wrapCountB++;

  return { tAbsMs, tMs, dt, phaseA, phaseB, pulse };
}
```

### File: `src/runtime/SignalEvaluator.ts` (142 lines)

**Current time handling:**
```typescript
case 'time': {
  const timeExpr = expr as { which: 't' | 'dt' | 'phase' | 'pulse' | 'energy' };
  switch (timeExpr.which) {
    case 't': return state.time.tModelMs;
    case 'dt': return state.time.dt;
    case 'phase': return state.time.phase ?? 0;
    case 'pulse': return state.time.pulse ?? 0;
    case 'energy': return state.time.energy ?? 0;
  }
}
```

**Required change:**
```typescript
case 'time': {
  const timeExpr = expr as { which: 'tMs' | 'phaseA' | 'phaseB' | 'dt' | 'pulse' | 'progress' };
  switch (timeExpr.which) {
    case 'tMs': return state.time.tMs;
    case 'dt': return state.time.dt;
    case 'phaseA': return state.time.phaseA;
    case 'phaseB': return state.time.phaseB;
    case 'pulse': return state.time.pulse;
    case 'progress': return state.time.progress ?? 0;
  }
}
```

---

## Phase Continuity Algorithm

When the period changes (hot-swap), calculate new offset to preserve phase continuity:

```typescript
/**
 * Calculate phase offset to preserve continuity when period changes.
 *
 * @param currentPhase - Current phase value [0,1)
 * @param tAbsMs - Current absolute time
 * @param newPeriodMs - New period after hot-swap
 * @returns New offset to apply
 */
function calculateContinuityOffset(
  currentPhase: number,
  tAbsMs: number,
  newPeriodMs: number
): number {
  // What would the phase be without offset?
  const rawPhase = newPeriodMs > 0 ? (tAbsMs / newPeriodMs) % 1.0 : 0;

  // Offset = current - raw (wrapped to [0,1))
  const offset = (currentPhase - rawPhase + 1.0) % 1.0;

  return offset;
}
```

**Usage in hot-swap:**
```typescript
// Before swap: save current phases
const savedPhaseA = currentTimeState.phaseA;
const savedPhaseB = currentTimeState.phaseB;
const swapTime = currentTimeState.tAbsMs;

// After swap: calculate new offsets
newTimeState.offsetA = calculateContinuityOffset(savedPhaseA, swapTime, newTimeModel.periodAMs);
newTimeState.offsetB = calculateContinuityOffset(savedPhaseB, swapTime, newTimeModel.periodBMs);
```

---

## Registry Updates

### InfiniteTimeRoot Registration

**Current:**
```typescript
registerBlock({
  type: 'InfiniteTimeRoot',
  inputs: [],
  outputs: [
    { portId: portId('t'), type: sigType('float') },
    { portId: portId('dt'), type: sigType('float') },
    { portId: portId('phase'), type: sigType('phase') },
    { portId: portId('pulse'), type: eventType('float') },
    { portId: portId('energy'), type: sigType('float') },
  ],
  lower: lowerInfiniteTimeRoot,
});
```

**Required:**
```typescript
registerBlock({
  type: 'InfiniteTimeRoot',
  inputs: [],
  outputs: [
    { portId: portId('tMs'), type: sigType('int') },
    { portId: portId('dt'), type: sigType('float') },
    { portId: portId('phaseA'), type: sigType('phase') },
    { portId: portId('phaseB'), type: sigType('phase') },
    { portId: portId('pulse'), type: eventType('unit') },
  ],
  lower: lowerInfiniteTimeRoot,
});
```

---

## Test Cases to Add

### Unit Tests (`src/runtime/__tests__/timeResolution.test.ts`)

```typescript
describe('resolveTime dual-phase', () => {
  it('computes independent phases at different rates', () => {
    const state = createTimeState();
    const model: TimeModel = { kind: 'cyclic', periodAMs: 4000, periodBMs: 8000 };

    const time = resolveTime(2000, model, state);

    expect(time.phaseA).toBeCloseTo(0.5);  // 2000/4000
    expect(time.phaseB).toBeCloseTo(0.25); // 2000/8000
  });

  it('preserves phase continuity on period change', () => {
    const state = createTimeState();

    // Run at 4000ms period
    resolveTime(5000, { kind: 'cyclic', periodAMs: 4000, periodBMs: 4000 }, state);
    const phaseBefore = state.phaseA;

    // Simulate hot-swap: save offset for new period
    state.offsetA = calculateContinuityOffset(phaseBefore, 5000, 2000);

    // Resolve with new period
    const time = resolveTime(5000, { kind: 'cyclic', periodAMs: 2000, periodBMs: 4000 }, state);

    // Phase should be continuous
    expect(Math.abs(time.phaseA - phaseBefore)).toBeLessThan(0.01);
  });
});
```

### Integration Tests (`src/runtime/__tests__/integration.test.ts`)

```typescript
describe('dual-phase TimeRoot integration', () => {
  it('compiles and executes with dual phases', () => {
    const patch = {
      blocks: [
        { type: 'InfiniteTimeRoot', id: 'time', config: { periodAMs: 1000, periodBMs: 2000 } },
        // ... other blocks referencing phaseA, phaseB
      ],
      edges: [],
    };

    const program = compile(patch);
    expect(program.timeModel.periodAMs).toBe(1000);
    expect(program.timeModel.periodBMs).toBe(2000);

    // Execute and verify
    const state = createRuntimeState(program);
    tick(state, 500);

    expect(state.time.phaseA).toBeCloseTo(0.5);  // 500/1000
    expect(state.time.phaseB).toBeCloseTo(0.25); // 500/2000
  });
});
```

---

## Backward Compatibility

To avoid breaking existing patches:

1. **Config fallback**: If only `periodMs` provided, use it for both periodAMs and periodBMs:
   ```typescript
   const periodAMs = config.periodAMs ?? config.periodMs ?? 4000;
   const periodBMs = config.periodBMs ?? config.periodMs ?? 8000;
   ```

2. **SigExprTime fallback**: During transition, accept both old and new variants:
   ```typescript
   // In evaluator, temporarily:
   case 't': return state.time.tMs;  // Legacy alias
   case 'phase': return state.time.phaseA;  // Legacy alias
   ```

3. **Deprecation warnings**: Log warning when legacy names used.

---

## Invariants to Maintain

From `design-docs/CANONICAL-oscilla-v2.5-20260109/INVARIANTS.md`:

1. **I1: Time is Monotonic and Unbounded** - tMs never wraps, resets, or clamps
2. **I2: Transport Continuity Across Hot-Swap** - tMs continues; derived values continue unless explicitly reset
3. **I5: Single Time Authority** - One TimeRoot produces time; everything else derives

---

## Symbol Reference

| Symbol | File | Line | Purpose |
|--------|------|------|---------|
| `InfiniteTimeRoot` | `src/compiler/blocks/time/InfiniteTimeRoot.ts` | 41 | Block registration |
| `FiniteTimeRoot` | `src/compiler/blocks/time/FiniteTimeRoot.ts` | 52 | Block registration |
| `SigExprTime` | `src/compiler/ir/types.ts` | 93 | Time signal expression type |
| `TimeModel` | `src/compiler/ir/types.ts` | 261 | Time model discriminated union |
| `EffectiveTime` | `src/runtime/timeResolution.ts` | 14 | Resolved time interface |
| `TimeState` | `src/runtime/timeResolution.ts` | 40 | Persistent time state |
| `resolveTime` | `src/runtime/timeResolution.ts` | 75 | Main time resolution function |
| `evaluateSigExpr` | `src/runtime/SignalEvaluator.ts` | 59 | Signal evaluation (time case at 84) |
| `sigType` | `src/compiler/blocks/registry.ts` | - | SignalType helper |
| `portId` | `src/compiler/blocks/registry.ts` | - | PortId helper |
