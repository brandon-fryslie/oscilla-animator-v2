# Definition of Done: Time Model - Dual-Phase System

Generated: 2026-01-09T07:30:00Z

## P0: Dual-Phase TimeRoot

### Required Acceptance Criteria

- [ ] **AC-P0-1**: `InfiniteTimeRoot` outputs exactly: `tMs` (int, continuous), `phaseA` (phase, continuous), `phaseB` (phase, continuous), `dt` (float), `pulse` (unit, discrete)
- [ ] **AC-P0-2**: `FiniteTimeRoot` outputs above PLUS `progress` (unit, continuous)
- [ ] **AC-P0-3**: Both TimeRoots accept config: `{ periodAMs?: number, periodBMs?: number }`
- [ ] **AC-P0-4**: Default periods: periodAMs=4000ms, periodBMs=8000ms
- [ ] **AC-P0-5**: `SigExprTime.which` supports: `'tMs' | 'phaseA' | 'phaseB' | 'dt' | 'pulse' | 'progress'`
- [ ] **AC-P0-6**: All existing compile tests pass (backward compatibility)
- [ ] **AC-P0-7**: Output port names match spec exactly (no `t`, `phase`, `energy`)

### Test Verification

```typescript
// Expected: InfiniteTimeRoot compiles with dual phase outputs
const program = compile(patchWithInfiniteTimeRoot);
expect(program.timeModel.periodAMs).toBe(4000);
expect(program.timeModel.periodBMs).toBe(8000);
// phaseA and phaseB available in signal expressions
```

---

## P1: Runtime Dual-Phase Tracking

### Required Acceptance Criteria

- [ ] **AC-P1-1**: `EffectiveTime` interface has: `tMs: number`, `phaseA: number`, `phaseB: number`, `dt: number`, `pulse: number`, `progress?: number`
- [ ] **AC-P1-2**: `TimeModel` includes `periodAMs` and `periodBMs` fields
- [ ] **AC-P1-3**: `resolveTime(tAbsMs, timeModel, timeState)` returns correct phaseA and phaseB
- [ ] **AC-P1-4**: phaseA cycles at periodAMs rate, phaseB cycles at periodBMs rate (independent)
- [ ] **AC-P1-5**: `SignalEvaluator` returns correct values for `'tMs'`, `'phaseA'`, `'phaseB'`
- [ ] **AC-P1-6**: Pulse fires when EITHER phase wraps

### Test Verification

```typescript
// At t=2000ms with periodAMs=4000, periodBMs=8000:
// phaseA = 2000/4000 = 0.5
// phaseB = 2000/8000 = 0.25
const time = resolveTime(2000, { kind: 'cyclic', periodAMs: 4000, periodBMs: 8000 }, state);
expect(time.phaseA).toBeCloseTo(0.5);
expect(time.phaseB).toBeCloseTo(0.25);
```

---

## P2: Phase Continuity (Hot-Swap)

### Required Acceptance Criteria

- [ ] **AC-P2-1**: `tMs` is monotonic across hot-swap (never resets or decreases)
- [ ] **AC-P2-2**: Phase offset preserved: if patch recompiles at t=T, phases continue from their current value
- [ ] **AC-P2-3**: Formula verified: `new_phase = ((T / newPeriod) + offset) % 1.0` where offset preserves continuity
- [ ] **AC-P2-4**: StateId matching: state cells with matching StateId are preserved
- [ ] **AC-P2-5**: No visual discontinuity test: phase values before/after hot-swap differ by < 0.01
- [ ] **AC-P2-6**: Offset storage: `TimeState` includes `offsetA: number` and `offsetB: number`

### Test Verification

```typescript
// Scenario: Patch running at t=5000ms, period changes from 4000 to 2000
// Before: phase = 5000 % 4000 / 4000 = 0.25
// After: phase should still be ~0.25 at the moment of change
// Then continues from there with new period
const stateBefore = resolveTime(5000, { periodAMs: 4000 }, timeState);
// Simulate hot-swap: change period
const stateAfter = resolveTime(5000, { periodAMs: 2000 }, timeState);
expect(Math.abs(stateBefore.phaseA - stateAfter.phaseA)).toBeLessThan(0.01);
```

---

## Sprint Complete Criteria

All items must be checked:

- [ ] All P0 acceptance criteria met
- [ ] All P1 acceptance criteria met
- [ ] All P2 acceptance criteria met
- [ ] All existing tests pass (`npm test`)
- [ ] No TypeScript errors (`npm run typecheck`)
- [ ] Manual verification: animation continues smoothly on hot-swap
