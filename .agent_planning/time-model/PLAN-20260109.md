# Sprint Plan: Time Model - Dual-Phase System

Generated: 2026-01-09T07:30:00Z

## Sprint Goal

Implement dual-phase TimeRoot with independent periods and phase continuity across hot-swap recompilation.

## Scope

**In scope (this sprint):**
1. P0: Dual-phase TimeRoot outputs (phaseA, phaseB with independent periods)
2. P1: Runtime dual-phase tracking (EffectiveTime, resolveTime updates)
3. P2: Phase continuity across hot-swap (phase offset preservation)

**Explicitly out of scope (future sprints):**
- Rail blocks (time, phaseA, phaseB, pulse, palette) - deferred to buses-and-rails topic
- Phase arithmetic type checking (phase + float OK, phase + phase ERROR) - deferred to type-system topic
- Phase helper functions (PhaseToFloat, FloatToPhase, PhaseDistance) - lower priority
- Palette rail implementation

## Work Items

### P0: Dual-Phase TimeRoot

**Goal:** TimeRoot outputs phaseA and phaseB with independent configurable periods

**Acceptance Criteria (REQUIRED):**
- [ ] `InfiniteTimeRoot` outputs: `tMs` (int), `phaseA` (phase), `phaseB` (phase), `pulse` (unit discrete)
- [ ] `FiniteTimeRoot` adds: `progress` (unit) to above outputs
- [ ] Both roots accept `periodAMs` and `periodBMs` configuration (default: 4000ms, 8000ms)
- [ ] `SigExprTime.which` enum extended: `'tMs' | 'phaseA' | 'phaseB' | 'dt' | 'pulse' | 'progress'`
- [ ] Existing tests continue to pass with backward-compatible defaults
- [ ] Spec compliance: output names match `03-time-system.md` exactly

**Files to Modify:**
| File | Change |
|------|--------|
| `src/compiler/blocks/time/InfiniteTimeRoot.ts` | Add phaseA, phaseB outputs with periodAMs/periodBMs |
| `src/compiler/blocks/time/FiniteTimeRoot.ts` | Add phaseA, phaseB outputs with periodAMs/periodBMs |
| `src/compiler/ir/types.ts` | Extend `SigExprTime.which` enum |

**Technical Notes:**
- Rename `t` output to `tMs` for spec compliance
- Keep `dt` output (derivable but convenient)
- Remove `energy` output (not in spec)
- Default periods: periodAMs=4000, periodBMs=8000 (staggered for visual variety)

### P1: Runtime Dual-Phase Tracking

**Goal:** Runtime evaluates both phases independently per their configured periods

**Acceptance Criteria (REQUIRED):**
- [ ] `EffectiveTime` interface includes: `tMs`, `phaseA`, `phaseB`, `dt`, `pulse`, `progress?`
- [ ] `TimeModel` supports dual periods: `periodAMs` and `periodBMs`
- [ ] `resolveTime()` computes both phases from their respective periods
- [ ] `SignalEvaluator` handles new time signals (`'tMs'`, `'phaseA'`, `'phaseB'`)
- [ ] Integration tests verify both phases cycle at correct rates

**Files to Modify:**
| File | Change |
|------|--------|
| `src/runtime/timeResolution.ts` | Add phaseA, phaseB to EffectiveTime; dual-phase resolveTime |
| `src/runtime/SignalEvaluator.ts` | Handle 'tMs', 'phaseA', 'phaseB' in time switch |
| `src/compiler/ir/types.ts` | Update TimeModel with periodAMs, periodBMs |

**Technical Notes:**
- `TimeState` needs dual wrap tracking (prevPhaseA, prevPhaseB, wrapCountA, wrapCountB)
- Pulse detection: fire on wrap of EITHER phase (combined pulse event)
- Backward compat: if only periodMs specified, both phases use same period

### P2: Phase Continuity (Hot-Swap)

**Goal:** Phase values continue smoothly across recompilation without visual discontinuity

**Acceptance Criteria (REQUIRED):**
- [ ] `tMs` continues unchanged across hot-swap (monotonic, never resets)
- [ ] Phase offsets preserved: `new_phase = old_phase + (new_speed - old_speed) * elapsed_time`
- [ ] State cells matched by StateId (if StateId matches, state preserved)
- [ ] Test: phase at t=1000ms before hot-swap equals phase at t=1000ms after
- [ ] No visual flicker during recompilation

**Files to Modify:**
| File | Change |
|------|--------|
| `src/runtime/timeResolution.ts` | Add phase offset tracking and continuity calculation |
| `src/runtime/RuntimeState.ts` | Add phase offsets to persistent state |
| `src/runtime/ScheduleExecutor.ts` | Preserve offsets during hot-swap |

**Technical Notes:**
- Phase continuity formula: When period changes from P1 to P2 at time T:
  ```
  offset_new = (phase_current * P1 - T % P2) / P2
  phase_continuous = ((T / P2) + offset_new) % 1.0
  ```
- Store offsets per phase (offsetA, offsetB) in TimeState
- Offsets applied after base phase calculation

## Dependencies

**Prerequisites (satisfied):**
- IR-5-Axes complete (canonical types available)
- Block registry pattern working
- SignalType system in place

**Blocked by:**
- None

**Blocking:**
- buses-and-rails topic depends on this (rails will reference TimeRoot outputs)

## Risks

1. **Breaking change risk**: Renaming `t` to `tMs` and `phase` to `phaseA` may break existing patches
   - Mitigation: Add backward-compat aliases initially, deprecation warning

2. **Complexity in hot-swap continuity**: Phase offset math can introduce bugs
   - Mitigation: Comprehensive unit tests for edge cases (period doubling, halving, etc.)

3. **TimeModel type changes**: Updating TimeModel discriminated union may break pattern matches
   - Mitigation: Keep `cyclic` kind, add optional `periodBMs` field

## Test Strategy

1. **Unit tests** (timeResolution.test.ts):
   - Dual phase independent cycling
   - Phase wrap detection per phase
   - Phase offset preservation on period change

2. **Integration tests** (integration.test.ts):
   - Full patch compile with dual-phase TimeRoot
   - Runtime execution sampling both phases
   - Hot-swap phase continuity

3. **Manual verification**:
   - Visual check that animation doesn't "jump" on recompile
