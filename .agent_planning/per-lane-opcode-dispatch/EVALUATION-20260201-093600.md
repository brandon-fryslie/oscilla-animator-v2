# Evaluation: Per-Lane Opcode Dispatch (Q30 Option B)
Generated: 2026-02-01T09:36:00Z
Verdict: CONTINUE

## Context

Q30 Option B: Field evaluation reuses scalar opcodes by looping over buffer lanes, eliminating duplicated field-arithmetic kernels.

## Current State Assessment

### Already Done (the per-lane loop exists)

| Component | Status | Evidence |
|-----------|--------|----------|
| OpcodeInterpreter (scalar) | COMPLETE | `OpcodeInterpreter.ts` — single enforcer for scalar math |
| ValueExprMaterializer per-lane opcode dispatch | COMPLETE | `applyMap/applyZip/applyZipSig` all have `fn.kind === 'opcode'` paths that loop `for i in N, for c in stride` calling `applyOpcode()` |
| ValueExprSignalEvaluator opcode dispatch | COMPLETE | `evaluateKernelSignal()` calls `applyPureFn()` which delegates to `applyOpcode()` |
| PureFn discriminated union | COMPLETE | `{ kind: 'opcode' } | { kind: 'kernel' } | { kind: 'expr' } | { kind: 'composed' }` |

### Still Broken: Block Lowering Uses Named Field Kernels for Arithmetic

7 block lower() functions emit `fn.kind: 'kernel'` with names that NO LONGER EXIST in FieldKernels.ts:

| Block | Kernel Name | Opcode Equivalent | File:Line |
|-------|-------------|-------------------|-----------|
| Add | `fieldAdd` | `OpCode.Add` | math-blocks.ts:89 |
| Subtract | `fieldSubtract` | `OpCode.Sub` | math-blocks.ts:181 |
| Multiply | `fieldMultiply` | `OpCode.Mul` | math-blocks.ts:273 |
| Divide | `fieldDivide` | `OpCode.Div` | math-blocks.ts:365 |
| Modulo | `fieldModulo` | `OpCode.Mod` | math-blocks.ts:457 |
| FieldSin | `fieldSin` | `OpCode.Sin` | field-operations-blocks.ts:111 |
| FieldCos | `fieldCos` | `OpCode.Cos` | field-operations-blocks.ts:176 |

**CRITICAL BUG**: These named kernels were deleted from FieldKernels.ts but the block lowering still references them. Any graph with field-cardinality math will throw `Unknown field kernel: fieldAdd` at runtime. Tests don't cover field paths for math blocks.

### Still Broken: Unnecessary Signal/Field Branching in Block Lowering

All 7 math blocks (Add, Sub, Mul, Div, Mod, Sin, Cos) have explicit `if (isField) { ... } else { ... }` branching in their `lower()` functions. Both branches do the same thing conceptually (zip + opcode), but:
- Signal path: `ctx.b.opcode(OpCode.Add)` (correct)
- Field path: `ctx.b.kernel('fieldAdd')` (broken, should be same opcode)

The broadcast logic (signal→field promotion) is the only legitimate reason to check cardinality, and it's needed regardless.

### Not Broken: Structural/Domain Field Kernels

These kernels are NOT expressible as per-lane opcodes and should remain as specialized kernels:

| Kernel | Why It's Special | File |
|--------|-----------------|------|
| makeVec2 | Stride-changing: 2x float → vec2 | FieldKernels.ts |
| makeVec3 | Stride-changing: 2x float → vec3 | FieldKernels.ts |
| hsvToRgb | Multi-component correlated: 3x float → RGBA | FieldKernels.ts |
| vec2ToVec3 | Stride-changing: vec2 → vec3 | FieldKernels.ts |
| fieldSetZ | Cross-stride: vec3 + float → vec3 | FieldKernels.ts |
| polygonVertex | Geometry: index + params → vec2 | FieldKernels.ts |
| starVertex | Geometry: index + params → vec2 | FieldKernels.ts |
| circleLayoutUV | Layout: uv + params → vec3 | FieldKernels.ts |
| lineLayoutUV | Layout: uv + params → vec3 | FieldKernels.ts |
| gridLayoutUV | Layout: uv + params → vec3 | FieldKernels.ts |

## Architecture Analysis

### Target State

```
Block lower() → always emits opcode-based PureFn for arithmetic
                → emits kernel-based PureFn ONLY for structural/domain ops
                → broadcast nodes handle signal→field promotion

ValueExprMaterializer → per-lane opcode loop (already works)
                      → kernel dispatch (only for structural ops)

FieldKernels.ts → ONLY structural/domain kernels (makeVec2, hsvToRgb, layouts)
                → NO arithmetic kernels
```

### What Changes

1. **Block lowering**: Remove signal/field branching for pure math. Single path: always emit opcode, add broadcast if needed.
2. **Enforcement**: Add test/lint that no `fn.kind: 'kernel'` with arithmetic names can be emitted.
3. **Optional perf**: Pre-resolve opcode functions to avoid per-lane `applyOpcode` string dispatch overhead.

## Risk Assessment

| Risk | Severity | Mitigation |
|------|----------|------------|
| Field math already broken | HIGH (existing bug) | This fix REPAIRS it |
| Broadcast logic incorrect | MEDIUM | Existing broadcast tests + new field math tests |
| Missing test coverage | HIGH | Add field-path tests for all 7 blocks |

## Verdict: CONTINUE

The per-lane opcode dispatch already works in the materializer. The remaining work is:
1. Fix block lowering to use opcodes instead of dead kernel names (bug fix)
2. Remove unnecessary signal/field branching in block lowering (simplification)
3. Add field-path test coverage (missing)
4. Add enforcement to prevent regression
