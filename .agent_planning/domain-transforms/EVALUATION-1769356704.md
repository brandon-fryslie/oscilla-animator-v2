# Evaluation: Domain Transformation System (Adapters)

Generated: 2026-01-25T17:18:24Z
Epic: oscilla-animator-v2-8m2

## Summary

**Verdict**: PAUSE → REFRAME → PROCEED

The epic description is incomplete. The actual work is to implement **6 core domain-transforming adapter blocks** that extend beyond the existing Broadcast block. Each adapter must be:
- Explicit (not implicit compiler insertion)
- Policy-bearing (semantics clearly defined)
- Spec-compliant (represented in normalized graph and IR)

## Current State

**What exists:**
- Broadcast block: one+continuous → many+continuous (signal to field)
- 10 unit conversion adapters (degrees↔radians, etc.) fully working
- Adapter insertion compiler pass (pass2-adapters.ts)
- UI type validation stub (canTransformDomain) - currently always returns false

**What's missing:**
- The 6 core domain-transforming blocks (Reduce, SampleFieldAt, ScatterToField, EventToSignalHold, SignalToEventCrossing, Clock)
- Proper type signatures for each
- Definition of payload/temporality/cardinality for each adapter type
- Runtime semantics and schedule integration

## Work Breakdown

### The 6 Core Adapter Blocks

1. **Reduce** (many→one, continuous)
   - Field → Signal via op: mean|sum|min|max|rms|any|all
   - Enables control flow loops

2. **SampleFieldAt** (many→one with index selection)
   - Picks one lane's value by index
   - Enables UI-driven field selection

3. **ScatterToField** (one→many with index writing)
   - Injects signal into specific lane of field
   - Enables per-lane overrides

4. **EventToSignalHold** (discrete→continuous)
   - Holds last event value as continuous signal
   - Bridges events to modulation

5. **SignalToEventCrossing** (continuous→discrete)
   - Emits event on signal threshold crossing
   - Bridges continuous animation to triggers

6. **Clock** (time→events)
   - Time-domain primitive: emits events at intervals
   - Source of discrete structure

## Implementation Strategy

### Phase 1: Foundation (blocks 1-3) - Reduce, SampleFieldAt, ScatterToField
- All operate on Field types (cardinality: many)
- No new temporality axes
- ~3-4 days effort
- **Confidence: HIGH** - clear semantics, straightforward implementation

### Phase 2: Temporality Bridges (blocks 4-5) - EventToSignalHold, SignalToEventCrossing
- Introduce temporality domain transforms (discrete ↔ continuous)
- Requires schedule integration (when does event fire relative to continuous?)
- Needs careful state management
- ~3-4 days effort
- **Confidence: MEDIUM** - needs schedule coordination spec details

### Phase 3: Time Primitives (block 6) - Clock
- New time-domain primitive
- Requires state (accumulating phase)
- Integration with continuous time
- ~1-2 days effort
- **Confidence: MEDIUM** - depends on TimeRoot design decisions

## UI Impact

Once blocks exist, `canTransformDomain()` in typeValidation.ts will automatically work:
- Check if a transformation path exists (e.g., many→one via Reduce)
- Highlight compatible ports
- Show available adapter options when connecting

## Spec Gaps

All blocks are now spec'd via user guidance. Need to document in canonical spec:
- `XX-domain-transformation-blocks.md` with all 6 block definitions
- Integration with schedule system (temporality transforms)
- State management for Clock block

## Risks

1. **Schedule coordination** (Phase 2): When discrete events fire relative to continuous evaluation
2. **Instance identity** (Phase 2-3): How remapping affects continuity tracking
3. **State persistence** (Phase 3): Clock phase accumulation across hot reload

## Next Steps

1. Create detailed sprint plans for each phase
2. Start Phase 1: Reduce block (smallest, clearest semantics)
3. Get spec sign-off before Phase 2 (temporality bridges)
