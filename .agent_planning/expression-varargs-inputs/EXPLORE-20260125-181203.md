# Explore: expression-varargs-inputs

**Timestamp:** 2026-01-25-181203
**Topic:** Expression block varargs input system for referencing any float output in the patch

## Current Expression Block Implementation

### Block Definition (`src/blocks/expression-blocks.ts`)
- **Fixed inputs**: in0, in1, in2, in3, in4 (5 optional input ports)
- **All inputs are payload-generic**: Accept any concrete payload type
- **Expression config parameter**: `expression` (exposedAsPort: false) - text string, not wirable
- **Lowering**: Calls `compileExpression()` from `src/expr/` DSL

### Architecture Comment from Code
```typescript
/**
 * Architecture:
 * - Fixed inputs (in0-in4): Simplifies v1, avoids dynamic port complexity
 * - Payload-Generic inputs: Accept any concrete payload type
 * - Expression config parameter: Text string, not wirable
 * - Compilation: Delegated to Expression DSL (src/expr/)
 */
```

### Planning History (`SPRINT-20260120-164354-integration-PLAN.md`)
Sprint 3 explicitly chose fixed inputs over dynamic ports:
- "Simplest to implement - no dynamic port creation"
- "Avoids complexity in graph normalization"
- "Future: Sprint 4 can add dynamic port creation if user feedback demands it"

Dynamic inputs were explicitly **deferred to Sprint 4 or later**.

## Current Input System Analysis

### Input Port Definition (`src/blocks/registry.ts`)
```typescript
interface InputDef {
  readonly label?: string;
  readonly type: SignalType;
  readonly value?: unknown;
  readonly defaultSource?: DefaultSource;
  readonly uiHint?: UIControlHint;
  readonly exposedAsPort?: boolean;  // Default: true
  readonly optional?: boolean;
}
```

Key observation: Input ports are defined statically per block type. There is NO varargs concept.

### Patch Model (`src/graph/Patch.ts`)
```typescript
interface InputPort {
  readonly id: string;
  readonly defaultSource?: DefaultSource;
  readonly combineMode?: CombineMode;  // For multiple inputs
}

interface Block {
  readonly inputPorts: ReadonlyMap<string, InputPort>;
  readonly outputPorts: ReadonlyMap<string, OutputPort>;
}
```

InputPorts are a fixed map keyed by port ID. Not variable-length.

### Combine Mode System (`src/types/index.ts`)
CombineMode handles multiple edges to the SAME port:
- 'last', 'first', 'sum', 'average', 'max', 'min', 'mul', 'layer', 'or', 'and'

This is NOT varargs - it's multi-writer to a single port. Varargs would be a single input that accepts N values from different sources.

## Expression DSL Analysis

### Input Mapping (`src/expr/index.ts`)
```typescript
function compileExpression(
  exprText: string,
  inputs: ReadonlyMap<string, SignalType>,  // name -> type
  builder: IRBuilder,
  inputSignals: ReadonlyMap<string, SigExprId>  // name -> signal
): CompileResult
```

The DSL expects a Map of named inputs. Current implementation uses fixed names: in0, in1, in2, in3, in4.

### Type Environment (`src/expr/typecheck.ts`)
```typescript
type TypeEnv = ReadonlyMap<string, PayloadType>;
```

Identifiers in expressions are resolved against this environment. User types `in0`, `in1`, etc.

### AST Identifier (`src/expr/ast.ts`)
```typescript
interface IdentifierNode {
  readonly kind: 'identifier';
  readonly name: string;  // e.g., "in0", "phase", "myInput"
  readonly pos: Position;
  readonly type?: PayloadType;
}
```

No structural requirement that names be fixed. Could use any naming scheme.

## Block Lowering Analysis

### Current Expression Block Lowering
```typescript
lower: ({ ctx, inputsById, config }) => {
  // Process fixed input ports (in0-in4)
  for (const key of ['in0', 'in1', 'in2', 'in3', 'in4'] as const) {
    const input = inputsById[key];
    if (input && input.k === 'sig') {
      const inputType = getSigType(input.id as SigExprId);
      inputs.set(key, inputType);
      inputSignals.set(key, input.id as SigExprId);
    }
  }

  const result = compileExpression(exprText, inputs, ctx.b, inputSignals);
  // ...
}
```

Hardcoded iteration over in0-in4. Would need to change for varargs.

### Pass 6 Block Lowering (`src/compiler/passes-v2/pass6-block-lowering.ts`)
Multi-input resolution already exists for combining multiple writers to one port:
```typescript
function resolveInputsWithMultiInput(
  block: Block,
  edges: readonly NormalizedEdge[],
  blocks: readonly Block[],
  builder: IRBuilder,
  errors: CompileError[],
  blockOutputs?: Map<BlockIndex, Map<string, ValueRefPacked>>,
  blockIdToIndex?: Map<string, BlockIndex>
): Map<string, ValueRefPacked>
```

This handles edges targeting a port. Not designed for "gather all outputs matching a pattern."

## Varargs Patterns in Codebase

### Search Results
No existing varargs patterns found in the codebase. The term "varargs" does not appear.

### Closest Analogues
1. **CombineMode multi-input**: Multiple edges to same port, combined via mode
2. **FieldExpr arrays**: Fields are variable-length, but this is cardinality, not input count
3. **Instance intrinsics**: Per-element access to index, position, etc.

## Design Questions Identified

### 1. How would varargs input be defined in BlockDef?
Current: `inputs: Record<string, InputDef>` - fixed keys
Options:
- New field `varargInput?: VarargInputDef`
- Special InputDef flag `isVararg: true`
- Entirely new block definition structure

### 2. How would expression DSL reference varargs?
Current syntax uses fixed names: `sin(in0 * 2)`
Options:
- Array syntax: `inputs[0]`, `inputs[n]`
- Named references: `Circle1.radius`, `Osc.out`
- Index-based: `$0`, `$1`, `$2`

### 3. How would the graph editor show varargs?
Current UI shows fixed ports. Options:
- Single "multi-input" port with list of connections
- Auto-expanding port list
- Connection picker/browser

### 4. How would type resolution work?
Current: Fixed port types resolve via constraint solver
Varargs: All inputs must be float? Or heterogeneous with type tracking?

### 5. What's the cardinality story?
Feature says "any float output from any block" - this is Signal cardinality
What about Field outputs? Need to constrain to one:float or allow fields?

### 6. How does this interact with combine modes?
Varargs input passes "all inputs through without a combine mode"
This is fundamentally different from current multi-input combining

## Spec Alignment Check

### ESSENTIAL-SPEC.md Combine System
"CombineMode: Strategy for multi-writer inputs"
- Numeric: sum, avg, min, max, mul
- Any: last, first, layer
- Boolean: or, and

Varargs bypasses this - it's NOT combining, it's passing through.

### ESSENTIAL-SPEC.md Port Model
```typescript
interface PortBinding {
  id: PortId;
  dir: { kind: 'in' } | { kind: 'out' };
  type: SignalType;
  combine: CombineMode;
}
```

No varargs concept in spec. This is a spec extension.

## Files Examined

1. `/Users/bmf/code/oscilla-animator-v2/src/blocks/expression-blocks.ts` - Current Expression block
2. `/Users/bmf/code/oscilla-animator-v2/src/blocks/registry.ts` - Block definition types
3. `/Users/bmf/code/oscilla-animator-v2/src/graph/Patch.ts` - Patch/Block/Port model
4. `/Users/bmf/code/oscilla-animator-v2/src/types/index.ts` - CombineMode, InputDef, etc.
5. `/Users/bmf/code/oscilla-animator-v2/src/expr/index.ts` - Expression DSL API
6. `/Users/bmf/code/oscilla-animator-v2/src/expr/typecheck.ts` - Type environment
7. `/Users/bmf/code/oscilla-animator-v2/src/expr/compile.ts` - IR compilation
8. `/Users/bmf/code/oscilla-animator-v2/src/expr/ast.ts` - AST types
9. `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes-v2/pass6-block-lowering.ts` - Block lowering
10. `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes-v2/combine-utils.ts` - Combine logic
11. `/Users/bmf/code/oscilla-animator-v2/.agent_planning/expression-dsl/SPRINT-20260120-164354-integration-PLAN.md` - Planning history
12. `/Users/bmf/code/oscilla-animator-v2/design-docs/CANONICAL-oscilla-v2.5-20260109/ESSENTIAL-SPEC.md` - Spec reference

## Key Observations

1. **No varargs infrastructure exists** - This is a greenfield feature
2. **Current design explicitly deferred dynamic inputs** - Known debt from Sprint 3
3. **Expression DSL is agnostic to input naming** - Could support any naming scheme
4. **Combine modes are orthogonal** - Varargs is passthrough, not combining
5. **Type system supports constraint solving** - Could extend for varargs type inference
6. **Graph editor UI would need significant work** - No precedent for variable-length ports
