# Evaluation: expression-varargs-inputs

**Timestamp:** 2026-01-25-181203
**Git Commit:** d312108

## Executive Summary

**Overall: 0% complete | Critical issues: 5 | Tests reliable: N/A**

This feature does not exist in the codebase. The Expression block currently uses fixed inputs (in0-in4), and the planning history shows dynamic/varargs inputs were explicitly deferred to "Sprint 4 or later." There is no varargs infrastructure anywhere in the system.

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| Expression block exists | PASS | `src/blocks/expression-blocks.ts` registered |
| Varargs input type exists | FAIL | No `VarargInputDef` or similar in registry |
| Dynamic port creation | FAIL | Not implemented |
| Expression DSL reference syntax | FAIL | Only fixed names (in0-in4) supported |
| Combine mode bypass | FAIL | No "passthrough" combine mode exists |

## Missing Checks

The following checks cannot be performed because the feature does not exist:
- Varargs type inference verification
- Dynamic port UI rendering
- Block output reference syntax parsing
- Passthrough combine mode validation

## Findings

### 1. Expression Block Definition
**Status**: PARTIAL (fixed inputs only)
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/expression-blocks.ts:57-89`
- 5 fixed optional inputs: in0, in1, in2, in3, in4
- Architecture comment at line 8: "Fixed inputs (in0-in4): Simplifies v1, avoids dynamic port complexity"

**Issues**:
- No varargs capability
- No mechanism to accept arbitrary number of inputs
- Expression identifiers hardcoded to fixed port names

### 2. Block Registry InputDef
**Status**: NOT_STARTED for varargs
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/registry.ts:214-223`
```typescript
interface InputDef {
  readonly label?: string;
  readonly type: CanonicalType;
  readonly value?: unknown;
  readonly defaultSource?: DefaultSource;
  readonly uiHint?: UIControlHint;
  readonly exposedAsPort?: boolean;
  readonly optional?: boolean;
  readonly hidden?: boolean;
}
```

**Issues**:
- No `isVararg` flag
- No `minInputs`/`maxInputs` cardinality fields
- Inputs are static Record keys, not dynamic

### 3. Patch Model Port Structure
**Status**: NOT_STARTED for varargs
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/graph/Patch.ts:60-72`
```typescript
interface InputPort {
  readonly id: string;
  readonly defaultSource?: DefaultSource;
  readonly combineMode?: CombineMode;
}
```
- `Block.inputPorts` is `ReadonlyMap<string, InputPort>` with fixed keys

**Issues**:
- No mechanism for variable-length input port list
- Port IDs are static identifiers, not computed

### 4. Expression DSL Identifier Resolution
**Status**: PARTIAL (flexible naming, but not connected to varargs)
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/expr/typecheck.ts:38`
```typescript
type TypeEnv = ReadonlyMap<string, PayloadType>;
```
- Type checker resolves identifiers against environment map
- Any string name works if present in environment

**Issues**:
- Environment is built from fixed port names in expression-blocks.ts:157
- No syntax for referencing external block outputs (e.g., `Circle1.radius`)
- No array indexing syntax (`inputs[0]`)

### 5. Combine Mode System
**Status**: NOT_STARTED for passthrough
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/types/index.ts:150-161`
```typescript
type CombineMode =
  | 'last'      // any: Last value wins
  | 'first'     // any: First value wins
  | 'sum'       // numeric: Additive
  | 'average'   // numeric: Arithmetic mean
  | 'max'       // numeric: Maximum
  | 'min'       // numeric: Minimum
  | 'mul'       // numeric: Multiplicative
  | 'layer'     // any: Layer composition
  | 'or'        // boolean: Logical OR
  | 'and';      // boolean: Logical AND
```

**Issues**:
- No "passthrough" or "varargs" mode
- All modes assume combining N values into 1 value
- Varargs needs N values passed through as separate signals

### 6. Block Lowering Multi-Input Resolution
**Status**: NOT_STARTED for varargs passthrough
**Evidence**:
- `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes-v2/pass6-block-lowering.ts:103-192`
- `resolveInputsWithMultiInput` handles multiple edges to one port
- Creates combine nodes via `createCombineNode()`

**Issues**:
- Designed for combining, not passthrough
- Returns single `ValueRefPacked` per port, not array
- No mechanism to enumerate all connected sources

## Ambiguities Found

| Area | Question | How LLM Would Guess | Impact |
|------|----------|---------------------|--------|
| **Input Reference Syntax** | How do users reference arbitrary block outputs in expressions? | Implement `BlockName.portName` syntax like `Circle1.radius` | Major - requires lexer/parser changes, type system extension |
| **Type Constraints** | Are varargs limited to float, or any payload type? | Feature says "float output" - limit to float | Major - determines type system scope |
| **Cardinality Mixing** | Can varargs include both Signal and Field outputs? | Feature says "float output from any block" - implies Signal only | Major - Field support adds significant complexity |
| **Combine Mode Bypass** | What does "passes all inputs through without a combine mode" mean for IR? | Pass array of SigExprIds, not combined value | Major - requires IR changes |
| **Graph Editor UI** | How does user wire to a varargs input? | Single port with expandable connection list | Major - requires ReactFlow customization |
| **Default Sources** | Do varargs inputs have default sources? | No - varargs are explicit, not auto-filled | Medium - affects normalization |

## Architectural Considerations

### 1. Spec Extension Required
The ESSENTIAL-SPEC.md has no concept of varargs inputs. This feature requires:
- New `PortBinding` variant for varargs
- New combine mode or entirely new input category
- Extension to type resolution for variable-length constraints

### 2. Expression DSL Syntax Options

**Option A: Positional Index**
```
inputs[0] * inputs[1] + inputs[2]
```
- Pro: Simple
- Con: No semantic meaning, fragile to reordering

**Option B: Block Reference**
```
Circle1.radius * Oscillator.out
```
- Pro: Semantic, readable
- Con: Requires global scope, name resolution

**Option C: Named Varargs**
```
@radius * @phase + @offset
```
- Pro: User-assigned names
- Con: Extra naming step in UI

### 3. Block Lowering Refactor

Current lowering:
```typescript
const inputRefs = resolveInputsWithMultiInput(...);
// inputRefs: Map<string, ValueRefPacked> - single value per port
```

Needed for varargs:
```typescript
const varargRefs = resolveVarargsInput(...);
// varargRefs: ValueRefPacked[] - array of all connected values
```

### 4. IR Representation

No current IR node represents "array of signals passed to expression." Would need:
- New `SigExpr` variant: `{ kind: 'vararg'; sources: SigExprId[] }`
- Or expression compiler receives array and expands inline

## Blockers and Dependencies

### Hard Blockers
1. **No spec definition** - Feature needs spec before implementation
2. **No UI pattern** - Graph editor has no variable-port precedent
3. **Syntax undefined** - How users reference outputs is fundamental

### Soft Dependencies
1. Expression DSL is stable and can be extended
2. Type system supports constraint solving (reusable)
3. Block registry can add new InputDef fields

## Recommendations

1. **HIGHEST PRIORITY**: Define the syntax for referencing block outputs in expressions. This is the user-facing contract that drives all other decisions.

2. **Write a mini-spec** covering:
   - Input reference syntax (how to name/access varargs inputs)
   - Type constraints (float only? any numeric?)
   - Cardinality constraints (Signal only? Fields too?)
   - UI interaction model (how to wire varargs)

3. **Prototype the DSL extension first** - Add block reference syntax to lexer/parser/typechecker before touching the rest of the system.

4. **Defer graph editor UI** - Use text-based connection specification initially (e.g., expression block has text field listing source blocks).

## Verdict

- [x] **PAUSE** - Ambiguities need clarification

The feature request is conceptually clear ("Expression block should accept any float output") but architecturally undefined. The following questions MUST be answered before implementation:

1. **Syntax**: How does the expression DSL reference varargs inputs? (e.g., `$0`, `inputs[n]`, `BlockName.port`)
2. **Cardinality**: Signal outputs only, or also Field outputs?
3. **Type constraint**: Float only, or any numeric payload?
4. **UI model**: How does user establish connections to a varargs input?

Without these answers, implementation would require arbitrary guesses that could be wrong and expensive to fix.

---

```
[checkmark] project-evaluator complete
  Scope: expression-varargs-inputs | Completion: 0% | Gaps: 5 critical
  Workflow: PAUSE (4 questions need answers first)
  -> Answer syntax and cardinality questions before proceeding
```
