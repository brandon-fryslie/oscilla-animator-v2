# Renderer Local-Space Migration Plan

**Generated**: 2026-01-22
**Bead ID**: oscilla-animator-v2-46m
**Priority**: P1 (High)
**Status**: Blocked by oscilla-animator-v2-583 (RenderAssembler v2)

## Executive Summary

Migrate Canvas2DRenderer from normalized world-space coordinate scaling to local-space geometry with instance transforms. This change aligns the renderer with the canonical local-space specification, eliminates viewport-dependent geometry scaling, and enables geometry reuse patterns for future SVG renderer.

**Current State**: Control points scaled by viewport dimensions (width/height multiplication)
**Target State**: Local-space control points with instance transforms (translate, rotate, scale)

## Dependencies

### Blocking Dependencies
- **oscilla-animator-v2-583**: RenderAssembler v2 must be complete
  - Status: IN_PROGRESS
  - Provides DrawPathInstancesOp with separated geometry/instance/style
  - Materializes local-space control points

### Downstream Impacts
This work unblocks:
- **oscilla-animator-v2-4lm**: Use size parameter for instance scaling
- **oscilla-animator-v2-qch**: Update polygon default radius from 0.1 to 1.0
- **oscilla-animator-v2-0uk**: SVG renderer with defs/use geometry reuse
- **oscilla-animator-v2-ry2**: Remove v1 RenderPassIR code path

## Specification References

### Primary Specs
1. `.agent_planning/_future/2-local-space-end-to-end-spec.md`
   - Lines 143-160: "Your current renderer: remove viewport scaling"
   - Canonical transform equation: translate → rotate → scale → draw

2. `.agent_planning/_future/3-local-space-spec-deeper.md`
   - Section 7: Backend Mapping: Canvas2D (lines 424-475)
   - Explicit algorithm with code examples

### Current Implementation
- `src/render/Canvas2DRenderer.ts` (lines 180-259)
  - `renderPathAtParticle()` function
  - Currently: `px = controlPoints[pointIndex * 2] * width`
  - Target: `ctx.scale(sizePx, sizePx)` with direct local points

## Work Items

### 1. Update renderPathAtParticle Signature (P0)

**Current**:
```typescript
function renderPathAtParticle(
  ctx: CanvasRenderingContext2D,
  topology: PathTopologyDef,
  controlPoints: Float32Array,
  _size: number,     // Currently unused
  width: number,     // Remove - not needed in local space
  height: number     // Remove - not needed in local space
): void
```

**Target**:
```typescript
function renderPathAtParticle(
  ctx: CanvasRenderingContext2D,
  topology: PathTopologyDef,
  controlPoints: Float32Array,
  size: number,           // Now used for scaling
  rotation: number,       // New: instance rotation
  scale2?: [number, number] // New: optional anisotropic scale
): void
```

**Changes**:
- Remove `width` and `height` parameters
- Make `size` parameter active (rename from `_size`)
- Add `rotation` parameter (default 0)
- Add optional `scale2` parameter for anisotropic scaling

**Rationale**: Local-space rendering requires instance transforms, not viewport dimensions.

### 2. Remove Viewport Scaling from Path Drawing (P0)

**Current Code** (lines 196-211):
```typescript
case 0: { // PathVerb.MOVE
  const px = controlPoints[pointIndex * 2] * width;
  const py = controlPoints[pointIndex * 2 + 1] * height;
  ctx.moveTo(px, py);
  pointIndex++;
  break;
}
```

**Target Code**:
```typescript
case 0: { // PathVerb.MOVE
  const x = controlPoints[pointIndex * 2];
  const y = controlPoints[pointIndex * 2 + 1];
  ctx.moveTo(x, y);
  pointIndex++;
  break;
}
```

**Apply to all path verbs**:
- MOVE (case 0)
- LINE (case 1)
- CUBIC (case 2)
- QUAD (case 3)
- CLOSE (case 4) - no changes needed

**Rationale**: Control points are now in local space centered at (0,0), not normalized world coordinates.

### 3. Apply Instance Transforms Before Drawing (P0)

**Insert before ctx.beginPath()** in renderPathAtParticle:

```typescript
function renderPathAtParticle(
  ctx: CanvasRenderingContext2D,
  topology: PathTopologyDef,
  controlPoints: Float32Array,
  size: number,
  rotation: number,
  scale2?: [number, number]
): void {
  // Apply instance transform: translate is already applied by caller
  // Caller does: ctx.translate(xPx, yPx) before calling this function

  // Apply rotation
  if (rotation !== 0) {
    ctx.rotate(rotation);
  }

  // Apply scale (isotropic or anisotropic)
  if (scale2) {
    ctx.scale(scale2[0], scale2[1]);
  } else {
    ctx.scale(size, size);
  }

  ctx.beginPath();
  // ... rest of path drawing with local-space points
}
```

**Transform ordering** (per spec):
1. `ctx.translate(xPx, yPx)` - done by caller in renderInstances2D
2. `ctx.rotate(rotation)` - done here
3. `ctx.scale(sizePx, sizePx)` or `ctx.scale(sxPx, syPx)` - done here
4. Draw local geometry

**Rationale**: Canonical transform equation from spec section 2.1.

### 4. Update renderInstances2D Call Site (P0)

**Current call** (line 135):
```typescript
renderPathAtParticle(ctx, topology, controlPoints, scale, width, height);
```

**Target call**:
```typescript
// Compute reference dimension for size scaling
const D = Math.min(width, height);
const sizePx = scale * D;
const rotation = 0; // TODO: Get from instance data when available

renderPathAtParticle(ctx, topology, controlPoints, sizePx, rotation);
```

**Add viewport dimension computation** at top of renderInstances2D:
```typescript
const D = Math.min(width, height); // Reference dimension for isotropic scaling
```

**Rationale**: sizePx = size * D preserves isotropy across non-square viewports (spec section 1.3).

### 5. Update Documentation Comments (P1)

**Remove obsolete comments**:
- Lines 154-178: Old "ROADMAP PHASE 6 - COORDINATE SPACE ISSUE" block
- Line 184: "_size: number, // Currently unused..."

**Add new documentation**:
```typescript
/**
 * Render a path shape at a particle position using local-space geometry.
 *
 * Assumes ctx.translate(xPx, yPx) has been applied by caller.
 *
 * Transform sequence:
 * 1. Rotate by instance rotation (if non-zero)
 * 2. Scale by instance size (isotropic) or scale2 (anisotropic)
 * 3. Draw path with local-space control points
 *
 * Control points are in local space:
 * - Centered at origin (0, 0)
 * - Typical magnitude |p| ≈ O(1)
 * - NOT scaled by viewport dimensions
 *
 * @param ctx - Canvas rendering context (already translated to instance position)
 * @param topology - Path topology definition (verbs)
 * @param controlPoints - Local-space control point buffer
 * @param size - Isotropic scale factor in viewport pixels
 * @param rotation - Instance rotation in radians (clockwise positive)
 * @param scale2 - Optional anisotropic scale [sx, sy] in viewport pixels
 */
```

**Rationale**: Clear documentation of local-space semantics and transform ordering.

### 6. Add Rotation Support to RenderPassIR (P2)

**Future work** (not in this bead):
- RenderPassIR needs `rotation` field
- RenderAssembler needs to materialize rotation from instance data
- For now, use rotation = 0 as placeholder

**This bead only**:
- Add rotation parameter to renderPathAtParticle
- Default to 0 at call site
- Document as "TODO: Get from instance data"

**Rationale**: Unblock local-space migration without waiting for full rotation support.

## Testing Strategy

### Manual Visual Testing
1. **Verify existing polygon rendering still works**
   - Run dev server: `npm run dev`
   - Check that existing demos render correctly
   - Shapes should appear at correct positions and sizes

2. **Verify isotropic scaling**
   - Resize viewport (make non-square)
   - Verify circles remain circular (not elliptical)
   - D = min(width, height) should preserve aspect ratio

### Unit Tests (Future)
After RenderAssembler v2 is complete:
- Test local-space to viewport mapping
- Test rotation transform application
- Test anisotropic scaling with scale2

### Integration Tests (Future)
- Compare Canvas2D output against SVG output (when available)
- Verify geometry reuse patterns work correctly

## Rollout Plan

### Phase 1: Implement (This Bead)
1. Update renderPathAtParticle signature
2. Remove width/height scaling from path drawing
3. Apply instance transforms (rotation, scale)
4. Update call site with D computation
5. Update documentation

### Phase 2: Integration (Next Bead)
- Enable size parameter usage (oscilla-animator-v2-4lm)
- Update polygon defaults to 1.0 (oscilla-animator-v2-qch)

### Phase 3: Validation (Future)
- Implement SVG renderer (oscilla-animator-v2-0uk)
- Verify geometry reuse works
- Remove v1 RenderPassIR (oscilla-animator-v2-ry2)

## Risks and Mitigations

### Risk 1: RenderAssembler v2 Not Complete
**Impact**: Cannot test changes without DrawPathInstancesOp
**Mitigation**:
- Wait for oscilla-animator-v2-583 to complete
- Work can be prepared but not tested until RenderAssembler ready

### Risk 2: Breaking Existing Rendering
**Impact**: Visible shapes may appear incorrect or at wrong scale
**Mitigation**:
- Manual visual testing on dev server
- Keep transform ordering exactly per spec
- Verify D = min(width, height) calculation

### Risk 3: Rotation Not Available Yet
**Impact**: Cannot fully test rotation transform
**Mitigation**:
- Add rotation parameter with default 0
- Document as placeholder for future instance data
- Unblocks local-space migration without waiting

### Risk 4: Anisotropic Scaling Not Defined
**Impact**: scale2 parameter might change
**Mitigation**:
- Make scale2 optional
- Document as "future extension"
- Isotropic scaling is primary use case

## Success Criteria

### Must Have
- [ ] renderPathAtParticle uses local-space control points (no * width/height)
- [ ] Instance transforms applied in correct order (rotate → scale)
- [ ] sizePx computed as size * min(width, height)
- [ ] Existing polygon demos render correctly
- [ ] No visual regressions on resize

### Should Have
- [ ] Documentation updated with local-space semantics
- [ ] Rotation parameter added (even if unused)
- [ ] Code comments removed that reference old world-space approach

### Nice to Have
- [ ] scale2 parameter defined for future anisotropic scaling
- [ ] Helper function for D computation
- [ ] Type-safe PathVerb enum usage

## Future Considerations

### After This Bead
1. **Enable size modulation** (oscilla-animator-v2-4lm)
   - size parameter will control instance scaling
   - Currently control points include radius

2. **Update polygon defaults** (oscilla-animator-v2-qch)
   - Change radiusX/radiusY defaults from 0.1 to 1.0
   - Aligns with local-space "unit geometry" convention

3. **SVG renderer** (oscilla-animator-v2-0uk)
   - Leverage local-space for <defs>/<use> reuse
   - One geometry definition, many instance transforms

4. **Remove v1 code path** (oscilla-animator-v2-ry2)
   - Delete old RenderPassIR handling
   - DrawPathInstancesOp becomes only path

## Implementation Checklist

- [ ] Update renderPathAtParticle signature (remove width/height, add rotation/scale2)
- [ ] Remove * width and * height from all path verb cases
- [ ] Add rotation and scale transforms before ctx.beginPath()
- [ ] Update renderInstances2D call site with D computation
- [ ] Update documentation comments (remove obsolete, add local-space docs)
- [ ] Add rotation parameter to call site (default 0)
- [ ] Test on dev server - verify shapes render correctly
- [ ] Test viewport resize - verify circles stay circular
- [ ] Update ROADMAP.md comment blocks (remove old phase 6 notes)

## Notes

- This is a **blocking prerequisite** for SVG renderer and size modulation
- **ONE SOURCE OF TRUTH**: Control points are local-space (canonical spec)
- **SINGLE ENFORCER**: Renderer applies transforms, materializer outputs local geometry
- **ONE-WAY DEPENDENCIES**: Renderer depends on RenderAssembler, not vice versa
