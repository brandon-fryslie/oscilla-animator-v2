# Implementation Context: Renderer Local-Space Migration

**Generated**: 2026-01-22
**Bead ID**: oscilla-animator-v2-46m
**Source**: PLAN-20260122.md

## Purpose

This document provides comprehensive context for implementing the renderer local-space migration. An agent with ONLY this document should be able to complete the implementation without additional research.

## Background

### The Problem

Current Canvas2DRenderer scales control points by viewport dimensions (width × height), treating them as normalized world coordinates [0,1]. This approach:

1. **Breaks geometry reuse**: Control points depend on viewport size, preventing SVG defs/use patterns
2. **Violates local-space spec**: Spec defines control points as local-space (centered at origin, magnitude O(1))
3. **Confuses coordinate spaces**: Mixing world-normalized and viewport-pixel coordinates in same code
4. **Makes size parameter unused**: Size should control scaling, but control points already include it

### The Solution

Treat control points as **local-space geometry** (centered at origin, unit scale), and apply **instance transforms** (translate, rotate, scale) to position and size them in viewport space.

This enables:
- Geometry reuse (same control points, different transforms)
- Clear coordinate space separation (local vs world vs viewport)
- Size/rotation modulation (transform parameters, not geometry mutation)
- SVG defs/use patterns (future)

## Coordinate Spaces

### 1. Local Space (L)
- **Where**: Control point buffers
- **Origin**: Shape center at (0, 0)
- **Units**: Dimensionless, typically O(1)
- **Example**: Unit circle vertex = (cos θ, sin θ), radius 1

### 2. World Space (W)
- **Where**: Instance position, size
- **Origin**: Scene space
- **Units**: Normalized [0, 1] relative to viewport
- **Example**: Center of screen = (0.5, 0.5)

### 3. Viewport Space (V)
- **Where**: Canvas pixel coordinates
- **Origin**: Top-left corner
- **Units**: Pixels
- **Mapping**: xPx = xW * width, yPx = yW * height

### Reference Dimension (D)
For isotropic scaling that preserves circles across non-square viewports:

```typescript
D = Math.min(viewportWidth, viewportHeight)
sizePx = sizeW * D
```

This ensures a shape with size=0.1 appears as 10% of the smaller dimension, staying circular.

## Canonical Transform Equation

From spec section 2.1 (`.agent_planning/_future/3-local-space-spec-deeper.md`):

```
pViewport = translate(xPx, yPx) → rotate(θ) → scale(sizePx) → pLocal
```

In Canvas2D API:
```typescript
ctx.translate(xPx, yPx);   // Instance position in pixels
ctx.rotate(θ);              // Instance rotation in radians
ctx.scale(sizePx, sizePx);  // Instance size in pixels (isotropic)
// OR
ctx.scale(sxPx, syPx);      // Instance size in pixels (anisotropic)

// Now draw with local-space points
ctx.moveTo(localX, localY); // NO * width or * height
```

## File Structure

### Primary File
**Path**: `src/render/Canvas2DRenderer.ts`

**Key Functions**:
1. `renderFrame()` (lines 50-64) - Entry point, clears canvas, iterates passes
2. `renderPass()` (lines 69-81) - Dispatches pass kinds
3. `renderInstances2D()` (lines 96-144) - Iterates instances, handles shape dispatch
4. `renderPathAtParticle()` (lines 180-259) - **TARGET FUNCTION** - Draws path for one instance

**Key Types**:
- `RenderFrameIR` - Frame structure from ScheduleExecutor
- `RenderPassIR` - Single pass (kind='instances2d')
- `PathTopologyDef` - Topology definition with verbs array
- `PathVerb` - Enum (0=MOVE, 1=LINE, 2=CUBIC, 3=QUAD, 4=CLOSE)

### Related Files
- `src/runtime/ScheduleExecutor.ts` - Produces RenderFrameIR (will change with RenderAssembler v2)
- `src/runtime/RenderAssembler.ts` - **NOT YET EXISTS** - Will produce DrawPathInstancesOp
- `src/shapes/types.ts` - PathTopologyDef, PathVerb definitions
- `src/shapes/registry.ts` - getTopology() function

## Current Implementation Details

### renderPathAtParticle Function (Lines 180-259)

**Current Signature**:
```typescript
function renderPathAtParticle(
  ctx: CanvasRenderingContext2D,
  topology: PathTopologyDef,
  controlPoints: Float32Array,
  _size: number,     // UNUSED - note the underscore
  width: number,     // Used for scaling - WRONG
  height: number     // Used for scaling - WRONG
): void
```

**Current Logic** (WRONG):
```typescript
case 0: { // PathVerb.MOVE
  const px = controlPoints[pointIndex * 2] * width;   // ❌ Scales by viewport
  const py = controlPoints[pointIndex * 2 + 1] * height; // ❌ Scales by viewport
  ctx.moveTo(px, py);
  pointIndex++;
  break;
}
```

This is repeated for LINE, CUBIC, QUAD verbs (CLOSE has no points).

**Why It's Wrong**:
- Control points should be local-space, not world-normalized
- Scaling should be via ctx.scale(), not point multiplication
- Size parameter unused (geometry already includes it)

### Call Site in renderInstances2D (Line 135)

**Current Call**:
```typescript
renderPathAtParticle(ctx, topology, controlPoints, scale, width, height);
```

**Context**:
- Inside a save/restore block (ctx.save() line 121, ctx.restore() line 143)
- Already has ctx.translate(x, y) applied (line 122)
- `scale` comes from pass.scale (currently a global uniform, future: per-instance field)

## Implementation Steps

### Step 1: Update renderPathAtParticle Signature

**Target Signature**:
```typescript
function renderPathAtParticle(
  ctx: CanvasRenderingContext2D,
  topology: PathTopologyDef,
  controlPoints: Float32Array,
  size: number,              // CHANGED: No underscore, now active
  rotation: number,          // NEW: Instance rotation (radians)
  scale2?: [number, number]  // NEW: Optional anisotropic scale
): void
```

**Changes**:
- Remove `width: number` parameter
- Remove `height: number` parameter
- Rename `_size` to `size`
- Add `rotation: number` parameter
- Add `scale2?: [number, number]` parameter

### Step 2: Apply Instance Transforms

**Insert at start of function body** (before ctx.beginPath() on line 188):

```typescript
function renderPathAtParticle(
  ctx: CanvasRenderingContext2D,
  topology: PathTopologyDef,
  controlPoints: Float32Array,
  size: number,
  rotation: number,
  scale2?: [number, number]
): void {
  // Note: ctx.translate(xPx, yPx) already applied by caller

  // Apply rotation (if non-zero)
  if (rotation !== 0) {
    ctx.rotate(rotation);
  }

  // Apply scale (anisotropic if scale2 present, otherwise isotropic)
  if (scale2) {
    ctx.scale(scale2[0], scale2[1]);
  } else {
    ctx.scale(size, size);
  }

  ctx.beginPath();
  // ... rest of function
}
```

**Rationale**:
- Transform order per spec: translate (done by caller) → rotate → scale
- Optimization: Only call ctx.rotate() if rotation !== 0
- Flexibility: Anisotropic scale via scale2, fallback to isotropic size

### Step 3: Remove Viewport Scaling from All Path Verbs

**For MOVE verb** (lines 196-203):

**Current**:
```typescript
case 0: { // PathVerb.MOVE
  const px = controlPoints[pointIndex * 2] * width;
  const py = controlPoints[pointIndex * 2 + 1] * height;
  ctx.moveTo(px, py);
  pointIndex++;
  break;
}
```

**Target**:
```typescript
case 0: { // PathVerb.MOVE
  const x = controlPoints[pointIndex * 2];
  const y = controlPoints[pointIndex * 2 + 1];
  ctx.moveTo(x, y);
  pointIndex++;
  break;
}
```

**For LINE verb** (lines 205-211):

**Current**:
```typescript
case 1: { // PathVerb.LINE
  const px = controlPoints[pointIndex * 2] * width;
  const py = controlPoints[pointIndex * 2 + 1] * height;
  ctx.lineTo(px, py);
  pointIndex++;
  break;
}
```

**Target**:
```typescript
case 1: { // PathVerb.LINE
  const x = controlPoints[pointIndex * 2];
  const y = controlPoints[pointIndex * 2 + 1];
  ctx.lineTo(x, y);
  pointIndex++;
  break;
}
```

**For CUBIC verb** (lines 213-229):

**Current**:
```typescript
case 2: { // PathVerb.CUBIC
  const cp1x = controlPoints[pointIndex * 2] * width;
  const cp1y = controlPoints[pointIndex * 2 + 1] * height;
  pointIndex++;

  const cp2x = controlPoints[pointIndex * 2] * width;
  const cp2y = controlPoints[pointIndex * 2 + 1] * height;
  pointIndex++;

  const endx = controlPoints[pointIndex * 2] * width;
  const endy = controlPoints[pointIndex * 2 + 1] * height;
  pointIndex++;

  ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endx, endy);
  break;
}
```

**Target**:
```typescript
case 2: { // PathVerb.CUBIC
  const cp1x = controlPoints[pointIndex * 2];
  const cp1y = controlPoints[pointIndex * 2 + 1];
  pointIndex++;

  const cp2x = controlPoints[pointIndex * 2];
  const cp2y = controlPoints[pointIndex * 2 + 1];
  pointIndex++;

  const endx = controlPoints[pointIndex * 2];
  const endy = controlPoints[pointIndex * 2 + 1];
  pointIndex++;

  ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endx, endy);
  break;
}
```

**For QUAD verb** (lines 231-244):

**Current**:
```typescript
case 3: { // PathVerb.QUAD
  const cpx = controlPoints[pointIndex * 2] * width;
  const cpy = controlPoints[pointIndex * 2 + 1] * height;
  pointIndex++;

  const endx = controlPoints[pointIndex * 2] * width;
  const endy = controlPoints[pointIndex * 2 + 1] * height;
  pointIndex++;

  ctx.quadraticCurveTo(cpx, cpy, endx, endy);
  break;
}
```

**Target**:
```typescript
case 3: { // PathVerb.QUAD
  const cpx = controlPoints[pointIndex * 2];
  const cpy = controlPoints[pointIndex * 2 + 1];
  pointIndex++;

  const endx = controlPoints[pointIndex * 2];
  const endy = controlPoints[pointIndex * 2 + 1];
  pointIndex++;

  ctx.quadraticCurveTo(cpx, cpy, endx, endy);
  break;
}
```

**For CLOSE verb** (lines 246-249):
```typescript
case 4: { // PathVerb.CLOSE
  ctx.closePath();
  break;
}
```
**No changes needed** - CLOSE has no control points.

**Summary**: Remove `* width` and `* height` from all control point reads. Points are now local-space.

### Step 4: Update Call Site in renderInstances2D

**Find call site** (line 135):
```typescript
renderPathAtParticle(ctx, topology, controlPoints, scale, width, height);
```

**Update to**:
```typescript
// Compute reference dimension for isotropic scaling
const D = Math.min(width, height);
const sizePx = scale * D;

// For now, rotation is always 0 (future: get from instance data)
const rotation = 0;

renderPathAtParticle(ctx, topology, controlPoints, sizePx, rotation);
```

**Add D computation at top of renderInstances2D** (after line 102):
```typescript
function renderInstances2D(
  ctx: CanvasRenderingContext2D,
  pass: RenderPassIR,
  width: number,
  height: number
): void {
  const position = pass.position as Float32Array;
  const color = pass.color as Uint8ClampedArray;
  const scale = pass.scale;

  // Reference dimension for isotropic scaling (preserves circles in non-square viewports)
  const D = Math.min(width, height);

  // ... rest of function
}
```

**Rationale**:
- D = min(width, height) per spec section 1.3
- sizePx = scale * D converts world-normalized size to viewport pixels
- rotation = 0 as placeholder (future: materialize from instance data)

### Step 5: Update Documentation

**Remove obsolete comment block** (lines 154-178):
```typescript
/**
 * ROADMAP PHASE 6 - COORDINATE SPACE ISSUE:
 * Current: Control points are in normalized [0,1] world space, scaled by width/height
 * Future: Control points in LOCAL SPACE (centered at origin, |p|≈O(1))
 * ... [entire block]
 */
```

**Remove unused parameter comment** (line 184):
```typescript
_size: number, // Currently unused - control points already include radius
```

**Add new JSDoc** (replace lines 180-179):
```typescript
/**
 * Render a path shape at a particle position using local-space geometry.
 *
 * Assumes ctx.translate(xPx, yPx) has been applied by caller to position
 * the shape at the instance location.
 *
 * Transform sequence (canonical per spec):
 * 1. Translate to instance position (done by caller)
 * 2. Rotate by instance rotation (applied here if non-zero)
 * 3. Scale by instance size or scale2 (applied here)
 * 4. Draw path with local-space control points
 *
 * Control points are in local space:
 * - Centered at origin (0, 0)
 * - Typical magnitude |p| ≈ O(1) (e.g., unit circle has radius 1)
 * - NOT scaled by viewport dimensions
 * - NOT in normalized world [0,1] coordinates
 *
 * @param ctx - Canvas rendering context (already translated to instance position)
 * @param topology - Path topology definition with verb sequence
 * @param controlPoints - Local-space control point buffer (interleaved x,y pairs)
 * @param size - Isotropic scale factor in viewport pixels (sizePx = sizeW * D)
 * @param rotation - Instance rotation in radians (clockwise positive, Canvas2D convention)
 * @param scale2 - Optional anisotropic scale [sx, sy] in viewport pixels (overrides isotropic size)
 *
 * @see .agent_planning/_future/3-local-space-spec-deeper.md section 7 (Canvas2D backend)
 */
```

## Verification Steps

### 1. Type Check
```bash
npm run typecheck
```
Expected: No errors

### 2. Visual Test
```bash
npm run dev
```

Open browser, check:
- Shapes render at correct positions
- Shapes have reasonable sizes
- No console errors
- Resize to non-square viewport → circles stay circular

### 3. Code Review Checklist
- [ ] All `* width` and `* height` removed from path verb cases
- [ ] Transform order is: rotate → scale (translate done by caller)
- [ ] rotation !== 0 check present (optimization)
- [ ] D = Math.min(width, height) computed
- [ ] sizePx = scale * D computed
- [ ] Call site updated with new signature
- [ ] Documentation updated (obsolete comments removed, new JSDoc added)

## Edge Cases and Gotchas

### 1. Empty Control Points Buffer
**Scenario**: controlPoints.length < pointsCount * 2
**Current behavior**: Will read undefined values, NaN in rendering
**Future**: RenderAssembler should validate before calling renderer

**Mitigation**: Add assertion at start of renderPathAtParticle (optional):
```typescript
if (controlPoints.length < topology.pointCount * 2) {
  throw new Error(`Control points buffer too small: expected ${topology.pointCount * 2}, got ${controlPoints.length}`);
}
```

### 2. Non-Zero Default Rotation
**Scenario**: What if rotation comes from upstream later?
**Current**: Default to 0 at call site
**Future**: RenderAssembler will provide rotation from instance data

**No action needed now** - placeholder is correct.

### 3. scale2 and size Both Present
**Scenario**: How do they combine?
**Spec answer** (section 2.3): componentwise multiply `finalScale = size * scale2`

**Current code**:
```typescript
if (scale2) {
  ctx.scale(scale2[0], scale2[1]);
} else {
  ctx.scale(size, size);
}
```

**Future refinement** (when scale2 available):
```typescript
if (scale2) {
  ctx.scale(size * scale2[0], size * scale2[1]);
} else {
  ctx.scale(size, size);
}
```

**Action**: Document in code comment that scale2 should be combined with size (future enhancement).

### 4. Rotation Direction
**Question**: Clockwise or counter-clockwise?
**Answer**: Canvas2D ctx.rotate() is **clockwise positive** (standard canvas convention)

**Action**: Document in JSDoc: "clockwise positive, Canvas2D convention"

### 5. Transform State Management
**Critical**: Transform stack must be balanced

**Current code** (correct):
```typescript
ctx.save();
ctx.translate(x, y);
// renderPathAtParticle adds rotate + scale
ctx.restore(); // ✅ Restores to saved state
```

**Verify**: No extra save/restore inside renderPathAtParticle - caller handles it.

## Dependencies

### Blocking Dependency
**Bead**: oscilla-animator-v2-583 (RenderAssembler v2)
**Status**: IN_PROGRESS (as of 2026-01-22)
**Impact**: Cannot fully test until RenderAssembler produces local-space control points

**What This Bead Needs**:
- DrawPathInstancesOp type definition (may already exist in future-types.ts)
- RenderAssembler to materialize local-space control points
- RenderAssembler to provide sizePx correctly

**What Can Be Done Now**:
- Code changes can be implemented
- Type checking can pass
- Visual testing may show incorrect results (if control points still world-normalized)

### Downstream Dependents
These beads are blocked by this work:
1. **oscilla-animator-v2-4lm**: Use size parameter for instance scaling
2. **oscilla-animator-v2-qch**: Update polygon defaults 0.1 → 1.0
3. **oscilla-animator-v2-0uk**: SVG renderer with defs/use reuse

## Spec References

### Primary Specs
1. **End-to-end local-space spec**
   - Path: `.agent_planning/_future/2-local-space-end-to-end-spec.md`
   - Key sections: Lines 143-160 (remove viewport scaling), Lines 1-58 (canonical transform)

2. **Deeper local-space spec**
   - Path: `.agent_planning/_future/3-local-space-spec-deeper.md`
   - Key sections: Section 7 (Canvas2D backend, lines 424-513), Section 2 (transform model, lines 54-161)

### Architecture Principles
From `~/.claude/CLAUDE.md`:

**ONE SOURCE OF TRUTH**: Control points in local space is the canonical representation. Viewport-scaled points would be a derived representation.

**SINGLE ENFORCER**: Renderer is the single enforcer of transform application. Materializer produces local geometry, renderer applies transforms.

**ONE-WAY DEPENDENCIES**: Renderer depends on RenderAssembler, not vice versa.

## Testing Notes

### Current Testing Limitations
- No unit tests for Canvas2DRenderer yet
- Visual testing only
- No automated regression detection

### Manual Test Cases
1. **Basic rendering**: Polygon appears at correct position
2. **Isotropic scaling**: Resize viewport, circles stay circular
3. **Multiple instances**: All instances render correctly
4. **Different topologies**: Test with different path shapes (circle, square, star)

### Future Test Cases (After Full Integration)
1. **Rotation modulation**: Rotate instances, verify direction
2. **Size modulation**: Scale instances, verify relative sizes
3. **Anisotropic scaling**: Apply scale2, verify ellipse formation
4. **Geometry reuse**: Same control points, different transforms

## Implementation Timeline

### Phase 1: Code Changes (This Bead)
- Update signature
- Remove viewport scaling
- Apply transforms
- Update call site
- Update documentation

### Phase 2: Integration Testing (After RenderAssembler v2)
- Verify local-space control points correct
- Verify size parameter works
- Verify visual output matches expectations

### Phase 3: Enable Features (Downstream Beads)
- Enable size modulation (4lm)
- Update polygon defaults (qch)
- Implement SVG renderer (0uk)
- Remove v1 code path (ry2)

## Success Criteria

Implementation is successful when:
1. ✅ Code compiles without TypeScript errors
2. ✅ No `* width` or `* height` in path verb cases
3. ✅ Transform order matches spec (rotate → scale)
4. ✅ D = min(width, height) used for isotropic scaling
5. ✅ Documentation clearly explains local-space semantics
6. ✅ Dev server runs without console errors
7. ✅ Shapes render at approximately correct positions/sizes
8. ✅ Circles remain circular in non-square viewports

## Rollback Plan

If rendering breaks:
1. Keep new signature
2. Add temporary viewport scaling back:
   ```typescript
   const xScaled = x * viewportWidthFromSomewhere;
   const yScaled = y * viewportHeightFromSomewhere;
   ```
3. Investigate why control points not local-space
4. Fix upstream (Materializer or RenderAssembler)
5. Remove scaling shim

**Note**: Do NOT rollback to old signature - that breaks RenderAssembler v2 integration.
