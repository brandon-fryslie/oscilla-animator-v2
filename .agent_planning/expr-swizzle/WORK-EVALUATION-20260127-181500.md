# Work Evaluation - 2026-01-27-181500
Scope: expr-swizzle/component-access
Confidence: FRESH

## Goals Under Evaluation
From SPRINT-2026-01-27-180000-component-access-DOD.md:
1. Component Extraction Signal Kernels (vec3Extract*, colorExtract*)
2. Swizzle Type Utilities (swizzle.ts)
3. Type Checker Extension (member access on vectors)
4. Compiler Extension (IR generation for swizzle)
5. Field-Level Kernels (fieldExtract*, fieldSwizzle_*)
6. Testing coverage (parser, typecheck, compilation, integration)
7. Documentation updates

## Previous Evaluation Reference
Last evaluation: EVALUATION-2026-01-27-180000.md (this is the first work evaluation)

## Persistent Check Results
| Check | Status | Output Summary |
|-------|--------|----------------|
| `npm run test` | PASS | 1800/1800 tests pass |
| `npm run test src/expr` | PASS | 115/115 |
| `npm run test src/runtime/__tests__/signal-kernel-contracts.test.ts` | PASS | 53/53 |
| `npm run test src/runtime/__tests__/field-kernel-contracts.test.ts` | PASS | 32/32 |

## Manual Code Review

### Implementation Files Verified

1. **src/expr/swizzle.ts** - EXISTS and COMPLETE
   - `POSITION_COMPONENTS` and `COLOR_COMPONENTS` constants defined
   - `componentIndex(char)` correctly maps x=0, y=1, z=2, w=3 and r=0, g=1, b=2, a=3
   - `isValidSwizzle(pattern, sourceType)` validates correctly
   - `swizzleResultType(pattern)` returns correct PayloadType
   - `validateSwizzle()` produces helpful error messages
   - Cross-access works: .r on vec3 returns float (via componentIndex)
   - JSDoc comments explain swizzle semantics

2. **src/expr/typecheck.ts** - MODIFIED and COMPLETE
   - Imports swizzle utilities from './swizzle'
   - `typecheckMemberAccess` handles both component access AND block references
   - Validates swizzle patterns against source type
   - Returns correct result types (FLOAT, VEC2, VEC3, COLOR based on pattern length)
   - Good error messages with suggestions

3. **src/expr/compile.ts** - MODIFIED and COMPLETE
   - `compileMemberAccess` handles component access
   - Single component: uses sigMap with extraction kernel
   - Multi-component: extracts each, combines with sigZip
   - `getExtractionKernel()` and `getCombineKernel()` helper functions present

4. **src/runtime/SignalEvaluator.ts** - MODIFIED and COMPLETE
   - vec3ExtractX, vec3ExtractY, vec3ExtractZ kernels implemented (lines 484-503)
   - colorExtractR, colorExtractG, colorExtractB, colorExtractA kernels (lines 505-531)
   - All kernels throw on incorrect arity (3 for vec3, 4 for color)
   - makeVec2Sig, makeVec3Sig, makeColorSig present but throw "not yet supported"

5. **src/runtime/FieldKernels.ts** - MODIFIED and COMPLETE
   - fieldExtractX, fieldExtractY, fieldExtractZ implemented (lines 479-511)
   - fieldExtractR, fieldExtractG, fieldExtractB, fieldExtractA implemented (lines 512-548)
   - fieldSwizzle_xy implemented (lines 549-561)
   - fieldSwizzle_rgb implemented (lines 562-576)
   - All throw on wrong arity

6. **src/expr/index.ts** - MODIFIED and COMPLETE
   - Exports swizzle utilities: isValidSwizzle, swizzleResultType, validateSwizzle, componentIndex

## Assessment

### Component Extraction Signal Kernels

| Criterion | Status | Evidence |
|-----------|--------|----------|
| vec3ExtractX kernel extracts component 0 | PRESENT | SignalEvaluator.ts:484-489 |
| vec3ExtractY kernel extracts component 1 | PRESENT | SignalEvaluator.ts:491-496 |
| vec3ExtractZ kernel extracts component 2 | PRESENT | SignalEvaluator.ts:498-503 |
| colorExtractR kernel extracts component 0 | PRESENT | SignalEvaluator.ts:505-510 |
| colorExtractG kernel extracts component 1 | PRESENT | SignalEvaluator.ts:512-517 |
| colorExtractB kernel extracts component 2 | PRESENT | SignalEvaluator.ts:519-524 |
| colorExtractA kernel extracts component 3 | PRESENT | SignalEvaluator.ts:526-531 |
| All kernels throw on incorrect input arity | PRESENT | Each has arity check |
| Unit tests pass for all kernels | **MISSING** | No explicit swizzle kernel tests |

### Swizzle Type Utilities

| Criterion | Status | Evidence |
|-----------|--------|----------|
| POSITION_COMPONENTS and COLOR_COMPONENTS constants | PASS | swizzle.ts:22,25 |
| componentIndex(char) returns correct index | PASS | swizzle.ts:34-42 |
| isValidSwizzle(pattern, sourceType) validates correctly | PASS | swizzle.ts:108-110 |
| swizzleResultType(pattern, sourceType) returns correct PayloadType | PASS | swizzle.ts:95-103 |
| Cross-access works: .r on vec3 returns float | PASS | componentIndex maps r=0 |
| Cross-access error: .a on vec3 throws | PASS | validateSwizzle returns error |
| Unit tests cover all validation cases | **MISSING** | No swizzle.test.ts file |

### Type Checker Extension

| Criterion | Status | Evidence |
|-----------|--------|----------|
| vec3Input.x type-checks to FLOAT | PASS (code review) | typecheck.ts:487-497 |
| vec3Input.y type-checks to FLOAT | PASS (code review) | swizzleResultType handles |
| vec3Input.z type-checks to FLOAT | PASS (code review) | swizzleResultType handles |
| vec3Input.xy type-checks to VEC2 | PASS (code review) | pattern.length=2 -> VEC2 |
| vec3Input.xz type-checks to VEC2 | PASS (code review) | pattern.length=2 -> VEC2 |
| vec3Input.xyz type-checks to VEC3 | PASS (code review) | pattern.length=3 -> VEC3 |
| vec3Input.zyx type-checks to VEC3 | PASS (code review) | pattern.length=3 -> VEC3 |
| colorInput.r type-checks to FLOAT | PASS (code review) | pattern.length=1 -> FLOAT |
| colorInput.rgb type-checks to VEC3 | PASS (code review) | pattern.length=3 -> VEC3 |
| colorInput.rgba type-checks to COLOR | PASS (code review) | pattern.length=4 -> COLOR |
| colorInput.bgra type-checks to COLOR | PASS (code review) | pattern.length=4 -> COLOR |
| vec3Input.w throws error | PASS (code review) | validateSwizzle returns error |
| vec3Input.a throws error | PASS (code review) | validateSwizzle returns error |
| floatInput.x throws error | PASS (code review) | isVectorType returns false |
| Block reference tests still pass | PASS | npm test passes all 1800 tests |
| Member access on literal works | PASS (code review) | parser allows, typecheck validates |

### Compiler Extension

| Criterion | Status | Evidence |
|-----------|--------|----------|
| vec.x compiles to sigMap with vec3ExtractX kernel | PASS (code review) | compile.ts:331-340 |
| vec.xy compiles to sigZip constructing VEC2 | PASS (code review) | compile.ts:341-354 |
| color.r compiles to sigMap with colorExtractR kernel | PASS (code review) | compile.ts:337-339 |
| color.rgb compiles to sigZip constructing VEC3 | PASS (code review) | compile.ts:341-354 |
| Block reference compilation still works | PASS | All existing tests pass |
| Integration test: expression with swizzle evaluates correctly | **MISSING** | No runtime evaluation test |

### Field-Level Kernels

| Criterion | Status | Evidence |
|-----------|--------|----------|
| fieldExtractX, fieldExtractY, fieldExtractZ implemented | PASS | FieldKernels.ts:479-511 |
| fieldExtractR, fieldExtractG, fieldExtractB, fieldExtractA implemented | PASS | FieldKernels.ts:512-548 |
| fieldSwizzle_xy implemented for vec3 -> vec2 | PASS | FieldKernels.ts:549-561 |
| fieldSwizzle_rgb implemented for color -> vec3 | PASS | FieldKernels.ts:562-576 |
| Unit tests verify per-element extraction correctness | **MISSING** | No field extraction tests |

### Testing

| Criterion | Status | Evidence |
|-----------|--------|----------|
| At least 5 parser tests for swizzle patterns | **PARTIAL** | parser.test.ts has member access tests but not swizzle-specific |
| At least 10 type checker tests (valid and invalid patterns) | **MISSING** | typecheck.test.ts has no swizzle tests |
| At least 5 compilation tests | **MISSING** | No swizzle compilation tests |
| At least 3 integration tests (end-to-end value verification) | **MISSING** | No e2e swizzle tests |
| All existing tests pass | PASS | 1800/1800 |
| npm run test passes | PASS | Confirmed |

### Documentation

| Criterion | Status | Evidence |
|-----------|--------|----------|
| swizzle.ts has JSDoc comments | PASS | Lines 1-17 explain semantics |
| FUNCTIONS.md updated to document component access | **MISSING** | No swizzle/component access section |
| Inline comments explain type checker and compiler changes | PASS | Code has explanatory comments |

## Tautology Check

The existing tests do NOT exercise the swizzle functionality:
- parser.test.ts tests member access but only for `Circle1.radius` patterns (block reference), not swizzle patterns like `.x` or `.rgb`
- typecheck.test.ts has no vector type tests at all
- integration.test.ts has no vector type or swizzle tests

This means **no tests actually verify the swizzle implementation works**. The code exists and appears correct by code review, but there is no runtime evidence that:
1. `vec3Input.x` actually extracts the X component
2. `colorInput.rgb` actually produces a vec3
3. The kernels actually return correct values

## Missing Checks (Implementer Should Create)

### 1. src/expr/__tests__/swizzle.test.ts (NEW FILE)
Test swizzle utilities:
```typescript
describe('swizzle utilities', () => {
  it('componentIndex returns correct values', () => {
    expect(componentIndex('x')).toBe(0);
    expect(componentIndex('r')).toBe(0);
    expect(componentIndex('w')).toBe(3);
    expect(componentIndex('invalid')).toBe(-1);
  });

  it('isValidSwizzle validates vec3 patterns', () => {
    expect(isValidSwizzle('x', VEC3)).toBe(true);
    expect(isValidSwizzle('xyz', VEC3)).toBe(true);
    expect(isValidSwizzle('w', VEC3)).toBe(false); // No 4th component
    expect(isValidSwizzle('a', VEC3)).toBe(false); // No 4th component
  });

  it('swizzleResultType returns correct types', () => {
    expect(swizzleResultType('x')).toEqual(FLOAT);
    expect(swizzleResultType('xy')).toEqual(VEC2);
    expect(swizzleResultType('xyz')).toEqual(VEC3);
    expect(swizzleResultType('rgba')).toEqual(COLOR);
  });
});
```

### 2. src/expr/__tests__/typecheck.test.ts (ADD TESTS)
Add swizzle type checking tests:
```typescript
describe('Component Access Type Checking', () => {
  it('vec3Input.x type-checks to FLOAT', () => {
    const ast = parse(tokenize('v.x'));
    const env = new Map([['v', VEC3]]);
    const typed = typecheck(ast, { inputs: env });
    expect(typed.type).toBe(FLOAT);
  });

  it('vec3Input.xyz type-checks to VEC3', () => {
    const ast = parse(tokenize('v.xyz'));
    const env = new Map([['v', VEC3]]);
    const typed = typecheck(ast, { inputs: env });
    expect(typed.type).toBe(VEC3);
  });

  it('vec3Input.w throws error', () => {
    const ast = parse(tokenize('v.w'));
    const env = new Map([['v', VEC3]]);
    expect(() => typecheck(ast, { inputs: env })).toThrow(/has no component 'w'/);
  });

  it('floatInput.x throws error', () => {
    const ast = parse(tokenize('f.x'));
    const env = new Map([['f', FLOAT]]);
    expect(() => typecheck(ast, { inputs: env })).toThrow(/not a vector type/);
  });
});
```

### 3. src/runtime/__tests__/signal-kernel-contracts.test.ts (ADD TESTS)
Add extraction kernel tests:
```typescript
describe('Component Extraction Kernels', () => {
  it('vec3ExtractX extracts first component', () => {
    expect(testApplySignalKernel('vec3ExtractX', [1, 2, 3])).toBe(1);
  });
  it('vec3ExtractY extracts second component', () => {
    expect(testApplySignalKernel('vec3ExtractY', [1, 2, 3])).toBe(2);
  });
  it('vec3ExtractZ extracts third component', () => {
    expect(testApplySignalKernel('vec3ExtractZ', [1, 2, 3])).toBe(3);
  });
  it('colorExtractR extracts first component', () => {
    expect(testApplySignalKernel('colorExtractR', [0.1, 0.2, 0.3, 0.4])).toBe(0.1);
  });
  it('vec3ExtractX throws on wrong arity', () => {
    expect(() => testApplySignalKernel('vec3ExtractX', [1, 2])).toThrow(/expects 3 inputs/);
  });
});
```

### 4. src/expr/__tests__/integration.test.ts (ADD TESTS)
Add end-to-end swizzle tests:
```typescript
describe('Swizzle Integration', () => {
  it('compiles vec.x to extraction kernel', () => {
    const vSig = builder.sigConst([1, 2, 3], canonicalType(VEC3)); // hypothetical
    const result = compileExpression('v.x', new Map([['v', canonicalType(VEC3)]]), builder, new Map([['v', vSig]]));
    expect(result.ok).toBe(true);
    // Verify IR structure
  });
});
```

## Known Issue: Multi-component Signal Returns Not Supported

The signal kernels `makeVec2Sig`, `makeVec3Sig`, and `makeColorSig` throw "not yet supported" errors. This means **multi-component swizzle patterns (like `.xy`, `.rgb`) will fail at runtime** even though they compile correctly.

This is a significant gap - the implementation compiles swizzle patterns but the runtime cannot execute them.

## Verdict: INCOMPLETE

### What's Complete
- All kernel implementations exist and appear correct
- Type checking logic is implemented
- Compiler IR generation is implemented
- All existing tests pass (no regressions)
- Documentation in swizzle.ts is good

### What's Missing (BLOCKING)
1. **No tests for swizzle functionality** - DoD requires:
   - At least 5 parser tests (have 0 swizzle-specific)
   - At least 10 type checker tests (have 0)
   - At least 5 compilation tests (have 0)
   - At least 3 integration tests (have 0)

2. **FUNCTIONS.md not updated** - DoD requires documentation of component access

3. **Multi-component swizzle runtime not working** - `makeVec*Sig` kernels throw "not yet supported"

### What Needs to Change

1. **Create `src/expr/__tests__/swizzle.test.ts`** with swizzle utility tests
2. **Add to `src/expr/__tests__/typecheck.test.ts`** at least 10 swizzle type checking tests
3. **Add to `src/expr/__tests__/integration.test.ts`** at least 3 swizzle compilation tests
4. **Update `src/expr/FUNCTIONS.md`** to document component access syntax and semantics
5. **Either implement multi-component signal returns OR document this as a known limitation and adjust DoD**

## Questions Needing Answers

1. **Should multi-component swizzle (e.g., `.xy`, `.rgb`) be supported at signal level?** The kernels exist but throw "not yet supported". Is this a blocker or acceptable for v1?

2. **Is the field-level implementation sufficient for current use cases?** The field kernels work, so swizzle would work for field operations but not signal operations.
