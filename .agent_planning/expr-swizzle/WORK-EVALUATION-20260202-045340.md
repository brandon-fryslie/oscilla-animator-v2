# Work Evaluation - 20260202-045340
Scope: expr-swizzle/extract-construct-ir-ops
Confidence: FRESH

## Goals Under Evaluation
From SPRINT-20260202-swizzle-extract-construct-DOD.md:
1. Fix Expression Compiler to emit extract/construct instead of dead kernel calls
2. Fix Expression Block Lowering for multi-component outputs
3. Fix Signal Evaluator Extract for strided slot reads
4. Update Tests for swizzle compilation
5. Update Documentation (FUNCTIONS.md)

## Previous Evaluation Reference
Last evaluation: WORK-EVALUATION-20260127-181500.md (prior sprint on component access)
No direct overlap to compare.

## Persistent Check Results
| Check | Status | Output Summary |
|-------|--------|----------------|
| `npm run typecheck` | PASS | Clean |
| `npm run test` | PASS | 2105 passed, 22 skipped, 2 todo (139 files) |
| Expression tests | PASS | 176/176 |
| Runtime tests | PASS | (no worker crash in expr subset) |

Note: 1 unhandled worker crash error in full test suite (Vitest tinypool issue, not test failure).

## Manual Runtime Testing

### What I Tried
1. Verified `compileExpression('v.x', ...)` produces extract IR node with componentIndex 0
2. Verified `compileExpression('v.xy', ...)` produces construct IR with 2 extract inputs
3. Verified `compileExpression('c.rgb', ...)` produces construct IR with 3 extract inputs
4. Verified error cases: `v.w` on vec3, `f.x` on float
5. Checked dead code removal: `getExtractionKernel` and `getCombineKernel` no longer exist

### What Actually Happened
All compilation tests pass and produce correct IR structure.

## Data Flow Verification
| Step | Expected | Actual | Status |
|------|----------|--------|--------|
| Expression `v.x` parsed | member access node | Correct | PASS |
| Type check passes | vec3 allows .x | Correct | PASS |
| Compiler emits extract | extract(input, 0, float) | Correct | PASS |
| Compiler emits construct for .xy | construct([extract0, extract1], vec2) | Correct | PASS |
| Block lowering: stride > 1 | stepSlotWriteStrided emitted | Correct (code review) | PASS |
| Signal evaluator: extract from slotRead | Reads f64[baseSlot + componentIndex] | Correct (code review) | NOT TESTED AT RUNTIME |
| Signal evaluator: extract from const vec3 | Should work | Throws error | BUG |

## Break-It Testing
| Attack | Expected | Actual | Severity |
|--------|----------|--------|----------|
| `v.x` on vec3 | float result | Correct IR | OK |
| `v.w` on vec3 | Type error | Type error with good message | OK |
| `f.x` on float | Type error | Type error: "not a vector type" | OK |
| Empty swizzle | Error | validateSwizzle catches it | OK |
| Swizzle > 4 chars | Error | validateSwizzle catches it | OK |
| Extract from const vec3 input (not slotRead) | Should extract component | Throws: "Cannot convert vec3 const value to scalar number" | LOW (edge case) |

## Evidence

### Compilation IR Verification
The integration tests at `src/expr/__tests__/integration.test.ts:78-146` exercise the real `compileExpression()` entry point and verify IR structure. These are NOT tautological -- they call the real compilation pipeline.

### Placeholder Test
`src/expr/__tests__/integration.test.ts:22-25` contains a tautological placeholder: `expect(true).toBe(true)`. Pre-existing, not introduced by this sprint, but should be cleaned up.

### Cast Inconsistency
`src/runtime/ValueExprSignalEvaluator.ts:172` uses `expr.input as unknown as number` while the rest of the file uses `as number`. Both work since ValueExprId is `number & { __brand }`, but the inconsistency suggests the author was uncertain.

## Assessment

### PASS Working
- **Criterion 1 (Expression Compiler)**: `compileMemberAccess` correctly emits `builder.extract()` for single-component and `builder.construct([extracts...])` for multi-component. Dead functions deleted. Verified via tests at `src/expr/__tests__/integration.test.ts:78-146`.
- **Criterion 2 (Block Lowering)**: Multi-component output handling at `src/blocks/math/expression.ts:160-189` correctly decomposes construct into strided slot writes. Also handles the case where the result is NOT a construct (extracts components).
- **Criterion 3 (Signal Evaluator)**: Extract case at `src/runtime/ValueExprSignalEvaluator.ts:168-186` reads from strided slots when input is slotRead. Construct correctly throws (decomposed at lowering time).
- **Criterion 5 (Documentation)**: `src/expr/FUNCTIONS.md` updated with IR mapping details for extract/construct.

### INCOMPLETE Not Working
- **Criterion 4 (Tests)**: DOD explicitly requires "Add test: single-component swizzle works in signal evaluation context." This test does not exist. All tests verify compilation only, not runtime evaluation of extract.

### Ambiguities Found
| Decision | What Was Assumed | Should Have Asked | Impact |
|----------|------------------|-------------------|--------|
| Extract fallback for non-slotRead inputs | Only slotRead inputs will reach extract at runtime | What about const vec3 inputs? | LOW - edge case, but throws confusing error |
| `as unknown as number` cast | Needed double cast for branded type | Just `as number` works (rest of file proves it) | NONE - cosmetic |

## Missing Checks (implementer should create)

1. **Signal evaluation test for extract** (`src/runtime/__tests__/signal-evaluator-extract.test.ts` or similar):
   - Create a runtime state with a vec3 value in strided slots (f64[slot], f64[slot+1], f64[slot+2])
   - Build ValueExpr nodes: a slotRead and an extract(slotRead, 1, float)
   - Call `evaluateValueExprSignal` and verify it returns the second component
   - This is the DOD item: "single-component swizzle works in signal evaluation context"

2. **Extract from non-slotRead input** (optional, LOW priority):
   - If `extract` on a `const` vec3 should work, the evaluator needs to handle the case (e.g., read from const value components directly)
   - If it should NOT work (all vec3 constants go through slotWriteStrided first), document this invariant

## Verdict: INCOMPLETE

### What Needs to Change

1. `src/runtime/__tests__/` - Add runtime evaluation test for `extract` from strided slot. DOD criterion 4 explicitly requires this: "Add test: single-component swizzle works in signal evaluation context." The test should call `evaluateValueExprSignal` with an extract node pointing to a slotRead-backed vec3 and verify the correct component value is returned.

2. `src/runtime/ValueExprSignalEvaluator.ts:172` - Change `expr.input as unknown as number` to `expr.input as number` for consistency with the rest of the file.

3. (Optional) `src/expr/__tests__/integration.test.ts:22-25` - Remove placeholder tautological test `_placeholder_compiles_identifier_expression` that asserts `expect(true).toBe(true)`.
