# Evaluation: Expression DSL Component Access and Swizzling

**Generated:** 2026-01-27T18:00:00
**Topic:** expr-swizzle
**Status:** INITIAL EVALUATION

## Executive Summary

The Expression DSL currently supports member access (e.g., `Circle1.radius`) for block output references but lacks support for component access on vector types (vec3, color). This evaluation analyzes the current state and identifies the work required to add GLSL-style component access (`.x`, `.y`, `.z` for vec3; `.r`, `.g`, `.b`, `.a` for color) and swizzle patterns (`.xy`, `.rgb`, `.zyx`, etc.).

## Current State Analysis

### 1. Type System (src/core/canonical-types.ts)

**VEC3 and COLOR types already exist:**
- `VEC3`: `{ kind: 'vec3', stride: 3 }`
- `COLOR`: `{ kind: 'color', stride: 4 }`
- Both are concrete `PayloadType` values with defined strides
- VEC2 also exists: `{ kind: 'vec2', stride: 2 }`

**Gap:** No component accessor types defined. Need to define what types result from component access.

### 2. AST (src/expr/ast.ts)

**Current member access node:**
```typescript
export interface MemberAccessNode {
  readonly kind: 'member';
  readonly object: ExprNode;
  readonly member: string;  // Currently: port name like "radius"
  readonly pos: Position;
  readonly type?: PayloadType;
}
```

**Gap:** The `member` field is just a string. For swizzling, we need to distinguish:
- Block output references: `Circle1.radius`
- Component access: `myVec3.x`, `myColor.r`
- Swizzle patterns: `myVec3.xy`, `myColor.rgb`

**Options:**
1. Keep single `MemberAccessNode`, disambiguate in type checker
2. Add new `ComponentAccessNode` and `SwizzleNode` AST types
3. Add new `SwizzleNode` only (component access is 1-char swizzle)

### 3. Lexer (src/expr/lexer.ts)

**Current state:** Lexer already produces `DOT` and `IDENT` tokens correctly.
- `vec.xyz` lexes as: `IDENT("vec")`, `DOT`, `IDENT("xyz")`

**Gap:** None. Lexer handles this correctly already.

### 4. Parser (src/expr/parser.ts)

**Current member() method:**
```typescript
private member(): ExprNode {
  let expr = this.primary();
  while (this.match(TokenKind.DOT)) {
    if (!this.check(TokenKind.IDENT)) {
      throw new ParseError('Expected identifier after "."', ...);
    }
    const memberToken = this.advance();
    expr = astMemberAccess(expr, memberToken.value, ...);
  }
  return expr;
}
```

**Gap:** Parser produces the same AST for all member access patterns. This is fine - type checker can disambiguate.

### 5. Type Checker (src/expr/typecheck.ts)

**Current `typecheckMemberAccess`:**
- Only handles block output references (e.g., `Circle1.radius`)
- Requires `blockRefs` context to be present
- Validates object is an identifier (block name)
- Looks up port in address registry

**Gap:** This is where component access and swizzling logic must be added:
1. Check if object is a vector/color type
2. Validate accessor pattern (x/y/z, r/g/b/a, or combination)
3. Determine result type based on swizzle length

### 6. Compile (src/expr/compile.ts)

**Current `compileMemberAccess`:**
- Builds shorthand string `BlockName.portName`
- Looks up pre-compiled signal from `blockRefs` map

**Gap:** Need to add component extraction/swizzle IR generation:
- For single component: extract scalar from vector
- For multi-component swizzle: construct new vector from components

### 7. IR System (src/compiler/ir/)

**Gap:** Need to verify what opcodes exist for component extraction:
- May need `OpCode.ExtractX`, `OpCode.ExtractY`, `OpCode.ExtractZ`, `OpCode.ExtractW`
- Or a generic `OpCode.Swizzle` with component mask
- Or synthesis via sigMap with custom kernel

## Requirements Analysis

### Functional Requirements

1. **Single component access for vec3:**
   - `.x` returns float (component 0)
   - `.y` returns float (component 1)
   - `.z` returns float (component 2)

2. **Single component access for color:**
   - `.r` returns float (component 0)
   - `.g` returns float (component 1)
   - `.b` returns float (component 2)
   - `.a` returns float (component 3)

3. **Multi-component swizzle for vec3:**
   - `.xy` returns vec2
   - `.xz`, `.yz` return vec2
   - `.zyx`, `.xyz` return vec3
   - Any valid combination of x/y/z

4. **Multi-component swizzle for color:**
   - `.rgb` returns vec3
   - `.rg`, `.rb`, `.gb` return vec2
   - `.bgra` returns color (4 components)
   - Any valid combination of r/g/b/a

5. **GLSL-style cross-access:**
   - Allow `.r` on vec3 (alias for `.x`)
   - Allow `.x` on color (alias for `.r`)
   - Allow `.rgba` on vec3 (error - vec3 has no 4th component)

6. **Chained access:**
   - `vec.xy.x` should work (extract x from vec2 result)
   - But probably low priority

### Non-Functional Requirements

1. **Backward compatibility:** Existing member access for block outputs must continue working
2. **Error messages:** Clear errors for invalid patterns (e.g., `.w` on vec3)
3. **Type safety:** Result types must be correctly inferred

## Technical Approach

### Phase 1: Type System Foundation

1. Define component accessor validation logic
2. Define swizzle result type computation
3. Add constants for valid component sets

### Phase 2: AST Enhancement (Minimal)

Option A (Recommended): Keep `MemberAccessNode` but add semantic annotation:
```typescript
interface MemberAccessNode {
  // ... existing fields
  readonly semantics?: 'block_ref' | 'component' | 'swizzle';
}
```

Option B: Separate AST nodes - more explicit but more code.

### Phase 3: Type Checker Enhancement

1. Before checking block reference, check if object type is vec2/vec3/color
2. If vector type, validate member string as component pattern
3. Compute result type from swizzle length:
   - 1 component -> float
   - 2 components -> vec2
   - 3 components -> vec3
   - 4 components -> color

### Phase 4: IR Compilation

1. For single component: Use component extraction opcode or kernel
2. For swizzle: Use swizzle opcode or synthesize with extracts

### Phase 5: Testing

1. Parser tests for swizzle patterns
2. Type checker tests for valid/invalid patterns
3. Compilation tests for IR generation
4. Integration tests end-to-end

## Risk Assessment

### Low Risk
- Lexer changes: None needed
- Parser changes: Minimal to none
- AST changes: Minimal

### Medium Risk
- Type checker changes: Moderate complexity, well-defined scope
- Need to handle edge cases (invalid patterns, out-of-range components)

### High Risk
- IR compilation: Depends on available opcodes
- May need to add new opcodes if component extraction doesn't exist

## Metrics

| Dimension | Current | Target |
|-----------|---------|--------|
| Vec3 component access | Not supported | `.x`, `.y`, `.z` working |
| Color component access | Not supported | `.r`, `.g`, `.b`, `.a` working |
| Multi-component swizzle | Not supported | All valid patterns working |
| Test coverage | N/A | >90% for new code paths |

## Recommendations

1. **Start with single component access** - simpler, immediately useful
2. **Add multi-component swizzle in separate sprint** - more complex, less urgent
3. **Verify IR opcodes exist** before starting implementation
4. **Keep grammar frozen** - these changes don't require grammar modification
