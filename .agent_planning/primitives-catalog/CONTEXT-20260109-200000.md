# Implementation Context: Primitives Catalog - MVP Stateful Blocks

**Sprint:** primitives-catalog
**Generated:** 2026-01-09T20:00:00Z

This document provides all context needed to implement the sprint deliverables.

---

## 1. Codebase Overview

### Project Structure
```
/Users/bmf/code/oscilla-animator-v2/
├── src/
│   ├── compiler/
│   │   ├── blocks/           # Block implementations
│   │   │   ├── registry.ts   # Block registry (MODIFY)
│   │   │   ├── signal/       # Signal blocks (ADD HERE)
│   │   │   │   ├── index.ts
│   │   │   │   ├── AddSignal.ts
│   │   │   │   ├── MulSignal.ts
│   │   │   │   ├── ConstFloat.ts
│   │   │   │   └── Oscillator.ts
│   │   │   ├── time/
│   │   │   ├── domain/
│   │   │   └── render/
│   │   ├── ir/
│   │   │   ├── builder.ts    # IRBuilder (MODIFY)
│   │   │   ├── types.ts      # IR types (MODIFY)
│   │   │   ├── Indices.ts    # Branded IDs (MODIFY)
│   │   │   └── program.ts    # CompiledProgramIR
│   │   └── __tests__/
│   ├── runtime/
│   │   ├── RuntimeState.ts   # Runtime state (MODIFY)
│   │   ├── SignalEvaluator.ts # Signal evaluation (MODIFY)
│   │   ├── OpcodeInterpreter.ts # Opcode impl (MODIFY)
│   │   └── ScheduleExecutor.ts
│   ├── core/
│   │   └── canonical-types.ts # Type system
│   └── types/
│       └── index.ts          # Type exports
└── .agent_planning/
    └── primitives-catalog/   # This planning directory
```

---

## 2. Existing Patterns to Follow

### Block Registration Pattern
From `/src/compiler/blocks/signal/AddSignal.ts`:

```typescript
import { OpCode } from '../../ir';
import {
  registerBlock,
  portId,
  sigType,
  type BlockLower,
} from '../registry';

const lowerAddSignal: BlockLower = ({ b, inputsById }) => {
  const a = inputsById.a;
  const b_ = inputsById.b;

  if (!a || !b_ || a.kind !== 'sig' || b_.kind !== 'sig') {
    throw new Error('AddSignal requires two signal inputs');
  }

  const id = b.sigBinOp(a.id, b_.id, OpCode.Add, sigType('float'));
  return {
    out: { kind: 'sig', id, type: sigType('float') },
  };
};

registerBlock({
  type: 'AddSignal',
  inputs: [
    { portId: portId('a'), type: sigType('float') },
    { portId: portId('b'), type: sigType('float') },
  ],
  outputs: [{ portId: portId('out'), type: sigType('float') }],
  lower: lowerAddSignal,
});
```

### Key Points:
1. Import `registerBlock`, `portId`, `sigType` from `../registry`
2. Define `lower` function with signature `BlockLower`
3. Access inputs via `inputsById` with kind checking
4. Use `b` (IRBuilder) to emit IR nodes
5. Return outputs as `Record<string, ValueRef>`
6. Call `registerBlock()` at module load

### Input Extraction Helpers
From `/src/compiler/blocks/registry.ts`:

```typescript
/** Extract required signal input - throws if missing or wrong type */
export function sig(inputs: Record<string, ValueRef | undefined>, port: string): SigRef {
  const v = inputs[port];
  if (!v || v.kind !== 'sig') throw new Error(`Missing signal input: ${port}`);
  return v;
}
```

### IRBuilder API
From `/src/compiler/ir/builder.ts`:

```typescript
// Slot allocation
allocSlot(): ValueSlot;
allocTypedSlot(type: SignalType, label?: string): ValueSlot;

// Signal expressions
sigConst(value: number | string | boolean, type: SignalType): SigExprId;
sigSlot(slot: ValueSlot, type: SignalType): SigExprId;
sigBinOp(a: SigExprId, b: SigExprId, op: OpCode, type: SignalType): SigExprId;
sigUnaryOp(input: SigExprId, op: OpCode, type: SignalType): SigExprId;

// Steps
stepEvalSig(expr: SigExprId, target: ValueSlot, sourceBlock?: BlockId): void;
```

---

## 3. Current IR Types

From `/src/compiler/ir/types.ts`:

```typescript
export type SigExpr =
  | SigExprConst    // { kind: 'const', value, type }
  | SigExprSlot     // { kind: 'slot', slot, type }
  | SigExprTime     // { kind: 'time', which, type }
  | SigExprExternal // { kind: 'external', which, type }
  | SigExprMap      // { kind: 'map', input, fn, type }
  | SigExprZip;     // { kind: 'zip', inputs, fn, type }

export enum OpCode {
  Add = 'add',
  Sub = 'sub',
  Mul = 'mul',
  Div = 'div',
  // ... etc
}
```

---

## 4. Current Runtime State

From `/src/runtime/RuntimeState.ts`:

```typescript
export interface RuntimeState {
  values: ValueStore;
  cache: FrameCache;
  timeState: TimeState;
  time: EffectiveTime | null;
  external: ExternalInputs;
}

export interface ValueStore {
  f64: Float64Array;
  objects: Map<ValueSlot, unknown>;
}
```

**Note:** There is currently NO persistent state array. This must be added for UnitDelay.

---

## 5. Implementation Strategy

### Phase 1: IR Infrastructure (UnitDelay prerequisite)

**1. Add StateSlotId to Indices.ts:**
```typescript
declare const StateSlotIdBrand: unique symbol;
export type StateSlotId = number & { readonly [StateSlotIdBrand]: never };

export function stateSlotId(n: number): StateSlotId {
  return n as StateSlotId;
}
```

**2. Add SigExpr variants to types.ts:**
```typescript
export interface SigExprStateRead {
  readonly kind: 'stateRead';
  readonly stateSlot: StateSlotId;
  readonly type: SignalType;
}

export interface StepStateWrite {
  readonly kind: 'stateWrite';
  readonly stateSlot: StateSlotId;
  readonly value: SigExprId;
}

// Update unions
export type SigExpr = ... | SigExprStateRead;
export type Step = ... | StepStateWrite;
```

**3. Add state slot allocation to IRBuilder:**
```typescript
private stateSlots: { initialValue: number }[] = [];
private nextStateSlotId = 0;

allocStateSlot(initialValue: number = 0): StateSlotId {
  const id = stateSlotId(this.nextStateSlotId++);
  this.stateSlots.push({ initialValue });
  return id;
}

sigStateRead(slot: StateSlotId, type: SignalType): SigExprId {
  const id = makeSigExprId(this.nextSigId++);
  this.signals.set(id, { kind: 'stateRead', stateSlot: slot, type });
  return id;
}

stepStateWrite(slot: StateSlotId, value: SigExprId): void {
  this.steps.push({ kind: 'stateWrite', stateSlot: slot, value });
}
```

**4. Add state array to RuntimeState:**
```typescript
export interface RuntimeState {
  // ... existing
  state: Float64Array;  // Persistent across frames
}
```

**5. Update SignalEvaluator:**
```typescript
case 'stateRead': {
  return state.state[expr.stateSlot as number];
}
```

**6. Update ScheduleExecutor:**
```typescript
case 'stateWrite': {
  const value = evaluateSignal(step.value, signals, state);
  state.state[step.stateSlot as number] = value;
  break;
}
```

### Phase 2: UnitDelay Block

```typescript
// /src/compiler/blocks/signal/UnitDelay.ts
import {
  registerBlock,
  portId,
  sigType,
  sig,
  type BlockLower,
} from '../registry';

const lowerUnitDelay: BlockLower = ({ b, inputsById }) => {
  const input = sig(inputsById, 'in');

  // Allocate persistent state slot (initialized to 0)
  const stateSlot = b.allocStateSlot(0);

  // Read previous value FIRST
  const prevId = b.sigStateRead(stateSlot, sigType('float'));

  // Schedule write of current input for end of frame
  b.stepStateWrite(stateSlot, input.id);

  return {
    out: { kind: 'sig', id: prevId, type: sigType('float') },
  };
};

registerBlock({
  type: 'UnitDelay',
  inputs: [{ portId: portId('in'), type: sigType('float') }],
  outputs: [{ portId: portId('out'), type: sigType('float') }],
  lower: lowerUnitDelay,
});
```

### Phase 3: Hash Block

```typescript
// /src/compiler/blocks/signal/Hash.ts
const lowerHash: BlockLower = ({ b, inputsById }) => {
  const value = sig(inputsById, 'value');

  const seedInput = inputsById.seed;
  let seedId;
  if (seedInput && seedInput.kind === 'sig') {
    seedId = seedInput.id;
  } else {
    seedId = b.sigConst(0, sigType('float'));
  }

  const hashId = b.sigBinOp(value.id, seedId, OpCode.Hash, sigType('float'));

  return {
    out: { kind: 'sig', id: hashId, type: sigType('float') },
  };
};

registerBlock({
  type: 'Hash',
  inputs: [
    { portId: portId('value'), type: sigType('float') },
    { portId: portId('seed'), type: sigType('float'), optional: true },
  ],
  outputs: [{ portId: portId('out'), type: sigType('float') }],
  lower: lowerHash,
});
```

**Add to OpcodeInterpreter:**
```typescript
case 'hash': {
  const [value, seed = 0] = values;
  let h = Math.floor(value * 2654435761) ^ Math.floor(seed * 2246822519);
  h = Math.imul(h ^ (h >>> 15), 2246822519);
  h = Math.imul(h ^ (h >>> 13), 3266489917);
  return ((h ^ (h >>> 16)) >>> 0) / 0xffffffff;
}
```

### Phase 4: Id01 Block

```typescript
// /src/compiler/blocks/signal/Id01.ts
const lowerId01: BlockLower = ({ b, inputsById }) => {
  const index = sig(inputsById, 'index');
  const count = sig(inputsById, 'count');

  // Safe division: index / max(count, 1)
  const one = b.sigConst(1, sigType('float'));
  const safeCount = b.sigBinOp(count.id, one, OpCode.Max, sigType('float'));
  const normalized = b.sigBinOp(index.id, safeCount, OpCode.Div, sigType('float'));

  return {
    out: { kind: 'sig', id: normalized, type: sigType('float') },
  };
};

registerBlock({
  type: 'Id01',
  inputs: [
    { portId: portId('index'), type: sigType('float') },
    { portId: portId('count'), type: sigType('float') },
  ],
  outputs: [{ portId: portId('out'), type: sigType('float') }],
  lower: lowerId01,
});
```

---

## 6. File Modification Checklist

| File | Change Type | Description |
|------|-------------|-------------|
| `/src/compiler/ir/Indices.ts` | MODIFY | Add StateSlotId branded type |
| `/src/compiler/ir/types.ts` | MODIFY | Add SigExprStateRead, StepStateWrite, OpCode.Hash |
| `/src/compiler/ir/builder.ts` | MODIFY | Add allocStateSlot, sigStateRead, stepStateWrite |
| `/src/runtime/RuntimeState.ts` | MODIFY | Add state array, update createRuntimeState |
| `/src/runtime/SignalEvaluator.ts` | MODIFY | Handle stateRead expr kind |
| `/src/runtime/ScheduleExecutor.ts` | MODIFY | Handle stateWrite step kind |
| `/src/runtime/OpcodeInterpreter.ts` | MODIFY | Add hash opcode implementation |
| `/src/compiler/blocks/signal/UnitDelay.ts` | CREATE | UnitDelay block |
| `/src/compiler/blocks/signal/Hash.ts` | CREATE | Hash block |
| `/src/compiler/blocks/signal/Id01.ts` | CREATE | Id01 block |
| `/src/compiler/blocks/signal/index.ts` | MODIFY | Export new blocks |
| `/src/compiler/blocks/__tests__/stateful.test.ts` | CREATE | Tests |

---

## 7. Commands Reference

```bash
# TypeScript check
npm run typecheck

# Run tests
npm run test

# Run specific test file
npm run test -- src/compiler/blocks/__tests__/stateful.test.ts

# Build
npm run build
```

---

## 8. Architectural Laws to Follow

From CLAUDE.md:

1. **ONE SOURCE OF TRUTH**: State slot allocation is the single place where persistent state is managed
2. **SINGLE ENFORCER**: RuntimeState is the only place that holds state; blocks just declare needs
3. **NO BACK-EDGES**: IR read happens before write within a frame; state is for cross-frame communication
4. **TESTS ASSERT BEHAVIOR**: Test the delay behavior, not the implementation details

---

## 9. Known Gotchas

1. **State initialization**: Must initialize state arrays to correct initial values (0 for UnitDelay)
2. **Evaluation order**: `stateRead` must happen before `stateWrite` within a frame
3. **Hot-swap**: Current implementation doesn't preserve state across hot-swap (deferred)
4. **State count**: Need to track stateSlotCount and pass to createRuntimeState
