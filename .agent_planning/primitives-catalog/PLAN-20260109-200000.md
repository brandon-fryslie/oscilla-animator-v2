# Sprint Plan: Primitives Catalog - MVP Stateful Blocks

**Generated:** 2026-01-09T20:00:00Z
**Topic:** primitives-catalog
**Status:** Ready for Implementation

---

## Sprint Goal

Implement the foundational stateful primitive `UnitDelay` and add two missing "Basic 12" blocks (`Hash` and `Id01`) to enable feedback loops and deterministic per-element operations.

---

## Scope

**In scope (this sprint):**
1. **UnitDelay** - z^-1 delay block (foundation for all feedback)
2. **Hash** - Deterministic hash function for seeded randomness
3. **Id01** - Normalized element ID [0, 1) from domain

**Explicitly out of scope (future sprints):**
- Other stateful primitives (Lag, Phasor, SampleAndHold)
- Rail system implementation
- Block metadata/category system
- Block registry consolidation
- Noise, Length, Normalize blocks

---

## Work Items

### P0: Implement UnitDelay Block (Critical Path)

**Rationale:** UnitDelay is the foundation for ALL feedback loops. Without it, no stateful modulation is possible. This is the single most important missing primitive.

**Acceptance Criteria (REQUIRED):**
- [ ] `UnitDelay` block exists at `/src/compiler/blocks/signal/UnitDelay.ts`
- [ ] Block implements `y(t) = x(t-1)` semantics
- [ ] Block has input port `in` (signal:float) and output port `out` (signal:float)
- [ ] Block allocates a persistent state slot that survives across frames
- [ ] Block's `lower()` function emits IR that:
  - Reads previous value from state slot
  - Stores current input to state slot for next frame
  - Returns previous value as output
- [ ] Block registered in registry via `registerBlock()`
- [ ] Initial state value is 0.0
- [ ] Unit test verifies delay-by-one-frame behavior

**Technical Notes:**

The key challenge is state slot allocation. Current architecture uses `ValueSlot` for inter-step communication within a frame, but UnitDelay needs **persistent state** that survives frame boundaries.

**Proposed implementation approach:**

1. **Extend IRBuilder** with state slot allocation:
   ```typescript
   allocStateSlot(initialValue: number): StateSlotId;
   ```

2. **Add new IR expression kinds** to `SigExpr`:
   ```typescript
   | SigExprStateRead  // Read from persistent state
   | SigExprStateWrite // Write to persistent state (side effect)
   ```

3. **Extend RuntimeState** with persistent state array:
   ```typescript
   interface RuntimeState {
     state: Float64Array;  // Persistent across frames
   }
   ```

4. **Block implementation pattern:**
   ```typescript
   const lowerUnitDelay: BlockLower = ({ b, inputsById }) => {
     const input = sig(inputsById, 'in');
     const stateSlot = b.allocStateSlot(0);
     const prevId = b.sigStateRead(stateSlot, sigType('float'));
     b.sigStateWrite(stateSlot, input.id);
     return {
       out: { kind: 'sig', id: prevId, type: sigType('float') },
     };
   };
   ```

**Files to modify:**
- `/src/compiler/blocks/signal/UnitDelay.ts` (create)
- `/src/compiler/ir/builder.ts` (add state slot allocation)
- `/src/compiler/ir/types.ts` (add SigExprStateRead, StepStateWrite)
- `/src/runtime/RuntimeState.ts` (add persistent state array)
- `/src/runtime/SignalEvaluator.ts` (handle new expr kinds)
- `/src/compiler/blocks/signal/index.ts` (export)

**Risks:**
- State slot allocation needs careful coordination with slotMeta
- Order of evaluation matters: read before write within same frame
- Hot-swap must preserve state slots when possible

---

### P1: Implement Hash Block

**Rationale:** Hash is essential for deterministic per-element variation. Currently blocks use ad-hoc methods; a proper hash primitive ensures reproducibility.

**Acceptance Criteria (REQUIRED):**
- [ ] `Hash` block exists at `/src/compiler/blocks/signal/Hash.ts`
- [ ] Block has inputs: `value` (signal:float), `seed` (signal:float, optional, default=0)
- [ ] Block has output: `out` (signal:float) in range [0, 1)
- [ ] Hash function is deterministic: same (value, seed) always produces same output
- [ ] Hash has good distribution (passes basic chi-squared test)
- [ ] Block's `lower()` function emits IR using a pure function
- [ ] Block registered in registry via `registerBlock()`
- [ ] Unit test verifies determinism and distribution

**Technical Notes:**

Use a fast, high-quality hash function. Recommended: xxHash-style mixing.

**Implementation approach:**

1. **Add OpCode for hash operation**:
   ```typescript
   enum OpCode {
     Hash = 'hash',  // (value, seed) -> [0,1)
   }
   ```

2. **Implement hash in OpcodeInterpreter**:
   ```typescript
   case 'hash': {
     const [value, seed = 0] = values;
     let h = Math.floor(value * 2654435761) ^ Math.floor(seed * 2246822519);
     h = Math.imul(h ^ (h >>> 15), 2246822519);
     h = Math.imul(h ^ (h >>> 13), 3266489917);
     return ((h ^ (h >>> 16)) >>> 0) / 0xffffffff;
   }
   ```

**Files to modify:**
- `/src/compiler/blocks/signal/Hash.ts` (create)
- `/src/compiler/ir/types.ts` (add OpCode.Hash)
- `/src/runtime/OpcodeInterpreter.ts` (implement hash)
- `/src/compiler/blocks/signal/index.ts` (export)

---

### P2: Implement Id01 Block (Signal Variant)

**Rationale:** `FieldFromDomainId` exists for fields, but we need a signal-level normalized ID accessor for single-element operations and config-level identity.

**Acceptance Criteria (REQUIRED):**
- [ ] `Id01` block exists at `/src/compiler/blocks/signal/Id01.ts`
- [ ] Block has input: `index` (signal:float)
- [ ] Block has input: `count` (signal:float)
- [ ] Block has output: `out` (signal:float) = index / count, clamped to [0, 1)
- [ ] Block handles edge cases: count=0 returns 0, count=1 returns 0
- [ ] Block registered in registry via `registerBlock()`
- [ ] Unit test verifies normalization

**Technical Notes:**

This is simpler than UnitDelay - pure computation, no state.

**Implementation:**
```typescript
const lowerId01: BlockLower = ({ b, inputsById }) => {
  const index = sig(inputsById, 'index');
  const count = sig(inputsById, 'count');
  const one = b.sigConst(1, sigType('float'));
  const safeCount = b.sigBinOp(count.id, one, OpCode.Max, sigType('float'));
  const normalized = b.sigBinOp(index.id, safeCount, OpCode.Div, sigType('float'));
  return {
    out: { kind: 'sig', id: normalized, type: sigType('float') },
  };
};
```

**Files to modify:**
- `/src/compiler/blocks/signal/Id01.ts` (create)
- `/src/compiler/blocks/signal/index.ts` (export)

---

### P3: Add Unit Tests

**Acceptance Criteria (REQUIRED):**
- [ ] Test file exists at `/src/compiler/blocks/__tests__/stateful.test.ts`
- [ ] Test: UnitDelay outputs 0 on first frame, input value on second frame
- [ ] Test: UnitDelay correctly delays by exactly one frame over 10 frames
- [ ] Test: Hash is deterministic (same input = same output)
- [ ] Test: Hash has reasonable distribution (visual inspection acceptable for MVP)
- [ ] Test: Id01 normalizes correctly (index=5, count=10 -> 0.5)
- [ ] Test: Id01 handles edge cases (count=0, count=1)
- [ ] All tests pass with `npm run test`

**Files to create:**
- `/src/compiler/blocks/__tests__/stateful.test.ts`

---

## Dependencies

**Prerequisites:**
- IRBuilder exists and works (verified)
- Block registry pattern established (verified)
- SignalEvaluator handles all current SigExpr kinds (verified)
- Test infrastructure (vitest) configured (verified)

**External Dependencies:**
- None

**Blockers:**
- None identified, but P0 requires IR/runtime changes before block implementation

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| State slot allocation breaks existing IR | Medium | High | Add state as orthogonal concept, don't modify ValueSlot |
| Hot-swap doesn't preserve state | Medium | Medium | Defer hot-swap state continuity to future sprint |
| Hash distribution is poor | Low | Low | Use well-known algorithm (xxHash mixing) |
| UnitDelay order-of-evaluation bugs | Medium | High | Document clearly: read happens before write within frame |

---

## Architecture Decision: State Slot Strategy

**Decision:** Option A - Separate State Array (Recommended)
- Add `state: Float64Array` to RuntimeState
- Add `StateSlotId` branded type separate from `ValueSlot`
- State slots survive frame boundaries; value slots are per-frame
- Pros: Clean separation of concerns, easy to reason about

---

## Success Criteria

- [ ] UnitDelay block compiles and registers
- [ ] UnitDelay correctly delays signals by one frame (verified by test)
- [ ] Hash block produces deterministic, well-distributed values
- [ ] Id01 normalizes indices correctly
- [ ] All new tests pass
- [ ] No regression in existing tests
- [ ] TypeScript compilation succeeds with zero errors
