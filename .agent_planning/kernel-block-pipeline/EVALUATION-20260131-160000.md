# Evaluation: Kernel & Block Pipeline — Single ValueExpr Path
Timestamp: 2026-01-31-160000 (Updated after review)
Git Commit: 44c04ae (bmf_type_system_refactor)

## Executive Summary
Overall: 40% toward goal state | Critical blockers: 0 | Architecture: sound foundation exists

**Goal state**: Exactly one execution path (Typed IR → ValueExpr → evaluator → buffers), kernels/blocks are registry-backed intrinsics, missing kernels fail loudly **at program load**.

The ValueExpr cutover in ScheduleExecutor is COMPLETE (commit 8692f40). Legacy evaluators are dead in the main frame loop. However, the "kernel as typed intrinsic" and "block lowering decoupled from legacy" goals are NOT yet achieved — kernels are still string-dispatched switch statements, and block lowering still emits legacy SigExpr/FieldExpr that get lowered to ValueExpr in a second pass.

## Current State Assessment

### What's Done (the foundation)
| Component | Status | Evidence |
|-----------|--------|----------|
| ValueExpr IR type system | COMPLETE | `value-expr.ts` — 10 kinds, CanonicalType on all |
| Lowering pass (legacy IR → ValueExpr) | COMPLETE | `lowerToValueExprs.ts` — 4-phase, exhaustive |
| ValueExprSignalEvaluator | PRODUCTION | `ScheduleExecutor.ts` uses exclusively |
| ValueExprEventEvaluator | PRODUCTION | `ScheduleExecutor.ts` uses exclusively |
| ValueExprMaterializer | PRODUCTION | `ScheduleExecutor.ts` uses exclusively |
| SignalKernelLibrary extraction | COMPLETE | `SignalKernelLibrary.ts` — shared, both evaluators use it |
| OpcodeInterpreter (single enforcer) | COMPLETE | Scalar math centralized |
| FieldKernels (buffer ops) | COMPLETE | Field materialization centralized |
| KernelRegistryDual (lowering helper) | COMPLETE | Block lowering dispatch centralized |

### What's Still Legacy (must die)
| Component | File | Status | Why It Survives |
|-----------|------|--------|-----------------|
| SignalEvaluator | `SignalEvaluator.ts` | ACTIVE in RenderAssembler | Scale/param resolution calls `evaluateSignal()` |
| EventEvaluator | `EventEvaluator.ts` | DEAD CODE | Never called from production |
| Materializer | `Materializer.ts` | DEAD CODE | Exported but unused |
| Legacy IR (SigExpr/FieldExpr) | `ir/types.ts` | ACTIVE in compiler | Block lowering emits legacy IR, then lowerToValueExprs converts |
| Shadow mode wiring | removed | ALREADY DELETED | Cutover flags removed in 8692f40 |

### What Doesn't Exist Yet (the plan target)
| Component | Status | Description |
|-----------|--------|-------------|
| KernelIntrinsic discriminated union | NOT STARTED | Typed kernel ABI with per-category function signatures |
| KernelRegistry with handle resolution | NOT STARTED | Registry resolves KernelId→handle at load, not per-call |
| Program-load kernel validation | NOT STARTED | Fail before first frame if kernels missing |
| Direct ValueExpr emission from blocks | NOT STARTED | DEFERRED — blocks lowering directly to ValueExpr (skip legacy IR) |
| Legacy execution tripwire | NOT STARTED | Test + runtime enforcement that legacy code never runs |
| RenderAssembler cache-only reads | NOT STARTED | Remove evaluateSignal() calls |

## Architecture Analysis

### Current Evaluation Call Graph
```
executeFrame()
 ├─ evalSig → evaluateValueExprSignal() → applyPureFn() → [applyOpcode | applySignalKernel]
 ├─ materialize → materializeValueExpr() → [applyFieldKernel | applyFieldKernelZipSig]
 ├─ evalEvent → evaluateValueExprEvent()
 └─ assembleRenderFrame()
     └─ evaluateSignal() ← LEGACY (scale/params only)
```

### Kernel Dispatch (current: string-based switches)
- `applySignalKernel(name, values)` — ~40 cases in switch statement
- `applyFieldKernel(out, inputs, fieldOp, N, type)` — ~30 cases
- `applyFieldKernelZipSig(out, field, sigs, op, N, type)` — ~20 cases
- `applyOpcode(opcode, values)` — ~20 cases

**No typing**: kernel contracts (arg count, arg types, result type) are implicit in switch cases, not declared.

**Performance risk**: String dispatch in hot loop will regret. Must resolve to handles at compile time.

### Block Lowering (current: two-hop)
```
Block definitions (registry)
  → pass6-block-lowering → SigExpr/FieldExpr/EventExpr (legacy IR)
    → lowerToValueExprs → ValueExpr (new IR)
      → evaluators (production)
```

The legacy IR is an unnecessary intermediate BUT not on critical path. **Decision: DEFER** elimination until kernel layer is stable.

## Phase-by-Phase Feasibility (Revised Ordering)

### Sprint 1: Kill legacy surfaces
- **WI-1.1**: RenderAssembler's `evaluateSignal()` calls (lines 428, 470) — read from already-materialized slot cache
- **WI-1.2**: Add schedule-order assertion — slot reads must happen after writes (DEV-mode stamp validation)
- **WI-1.3**: Tripwire test (static + runtime) — module-level throw in legacy modules in non-test builds
- **WI-1.4**: Delete dead files after validation
- **Risk**: LOW. The signals RenderAssembler reads MUST already be in slots.

### Sprint 2: Kernel registry with handle resolution
- **WI-2.1**: KernelIntrinsic discriminated union — 5 kinds (scalar, field, zipSig, reduce, pathDerivative), each with specific function type
- **WI-2.2**: KernelRegistry — resolves KernelId → KernelHandle (integer index) at registration
- **WI-2.3**: Store KernelHandle in ValueExpr (or side table), not string
- **WI-2.4**: Evaluator uses `kernels[handle]` array, not Map.get()
- **Risk**: MEDIUM. Changing dispatch affects hot-loop performance + ABI shape decisions.

### Sprint 2.5: Kernel validation at program load (NEW)
- **WI-2.5.1**: After lowering, validate all KernelIds referenced by ValueExpr nodes
- **WI-2.5.2**: Check each is registered, arity matches, invariants hold
- **WI-2.5.3**: Fail before first frame if any kernel missing
- **Risk**: LOW. Pure validation, no runtime changes.

### Sprint 3: Block lowering decoupling (DEFERRED)
- **Decision**: DEFER until after Sprint 2+2.5+4 are stable
- **When resumed**: Incremental migration (1-3 blocks at a time), not big-bang
- **Guardrails while deferred**:
  - No new legacy expr kinds (unit test freeze)
  - lowerToValueExprs remains total/exhaustive
  - Legacy IR documented as transitional
- **Risk**: HIGH if done now. MEDIUM if deferred and approached incrementally.

### Sprint 4: New kernel library with metadata-driven tests
- **WI-4.1**: Add metadata to KernelIntrinsic: `guaranteesFiniteForFiniteInputs`, `range?`, `deterministic`
- **WI-4.2**: Canonical kernel set registered with metadata
- **WI-4.3**: Property tests driven by metadata (not hardcoded assertions)
- **Risk**: MEDIUM. Metadata design must be right.

### Sprint 5: Legacy deletion with dependency enforcement
- **WI-5.1**: Delete legacy evaluator files
- **WI-5.2**: Check no compiler packages re-export legacy
- **WI-5.3**: Add dependency DAG snapshot test (runtime must not import compiler)
- **Risk**: LOW (assuming Sprint 1 tripwires + Sprint 2.5 validation are strong).

## Verdict
- [x] CONTINUE - Clear path, no blockers
- [ ] PAUSE
- [ ] BLOCKED

The foundation is solid. The revised ordering addresses the key architectural concern: **pay dispatch costs once at program load, not per-call at runtime**. The kernel registry becomes a compile-time resolution layer, not a runtime lookup layer.
