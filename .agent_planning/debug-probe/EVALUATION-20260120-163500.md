# EVALUATION-20260120-163500 for Debug Probe Feature

## WHAT EXISTS: Current Infrastructure Analysis

### 1. **Graph Editor & Edge Infrastructure** ✓ PRESENT
- **ReactFlow Integration**: `/src/ui/reactFlowEditor/ReactFlowEditor.tsx` - Full node editor with pan/zoom/controls
- **OscillaNode Component**: `/src/ui/reactFlowEditor/OscillaNode.tsx` - Custom node renderer with port handles
- **Edge Context Menu**: `/src/ui/reactFlowEditor/menus/EdgeContextMenu.tsx` - Right-click context menu exists
- **Edge Event Handling**: ReactFlow `onEdgeMouseEnter`, `onEdgeMouseLeave` available (standard API)
- **Issue**: No hover tooltip or value display infrastructure on edges currently

### 2. **Runtime Value Access Mechanisms** ✓ PARTIALLY EXISTS
- **ValueStore**: `/src/runtime/RuntimeState.ts` - Slot-based value storage with Float64Array + object Map
- **Health Metrics**: `/src/runtime/HealthMonitor.ts` - Ring buffers for frame times, NaN/Inf batching (throttled to 5Hz/200ms)
- **Frame Execution**: Core execution loop exists but NOT exposed for real-time value probing
- **Issue**: No API layer for querying current slot values from UI during render

### 3. **Observation Infrastructure** ⚠️ PARTIALLY EXISTS (Spec-Defined But Not Implemented)
**From spec** (`08-observation-system.md`):
- `DebugGraph` - Compile-time topology metadata (DEFINED in spec, NOT implemented in code)
- `DebugSnapshot` - Runtime value samples at 10-15Hz (DEFINED in spec, NOT implemented in code)
- `DebugService` - Query API for UI (DEFINED in spec, NOT implemented in code)
- **ValueSummary** tagged union for type-safe value representation (spec only)

**In Codebase:**
- HealthMonitor exists but serves diagnostics only, not general observation
- No DebugGraph builder in compiler
- No DebugTap instrumentation interface
- No ring buffers per bus for timeseries data

### 4. **Type System** ✓ PRESENT
**Canonical Types** (`/src/core/canonical-types.ts`):
- PayloadType: `float | int | vec2 | vec2 | color | phase | bool | unit | shape`
- Cardinality: `zero | one | many(instance)`
- Temporality: `continuous | discrete`
- **4 Value types actually exist beyond "4 mentioned"**: signals flow through typed slots with multiple representable types

### 5. **Debug UI Components** ⚠️ MINIMAL
- `DiagnosticsStore` + `DiagnosticConsole` exist (for compilation diagnostics)
- No popover/tooltip components for edge probing
- No value renderers (meters, phase rings, color swatches, etc.)
- No timeseries visualization

### 6. **Performance Throttling** ✓ PRESENT
- HealthMonitor: 5Hz throttling (200ms interval) for health snapshots
- Frame delta recording in ring buffers (60-frame history)
- NaN/Inf batching (100ms windows)
- **Ready to extend**: Same pattern can wrap value observation at 1Hz

---

## WHAT'S MISSING: Critical Gaps

### 1. **Service Layer for Runtime Value Observation** ❌ MISSING
**Needed:**
- `DebugService` singleton to manage observation lifecycle
- `setDebugGraph(graph)` - Compiler output integration
- `pushSnapshot(snapshot)` - Runtime value injection at sample rate
- Query methods: `probePort(portKey)`, `probeBus(busId)`, `getBusSeries(busId, windowMs)`
- Ring buffers per bus (150 samples @ 15Hz = 10 seconds history)
- Slot-to-bus resolution from DebugGraph

**Current State**: Does not exist. UI has no way to query current runtime values.

### 2. **Compiler Integration for DebugGraph** ❌ MISSING
**Needed:**
- End of `compileBusAwarePatch()` builds DebugGraph with:
  - `buses: Record<BusId, DebugBusNode>`
  - `publishers: Record<PublisherId, DebugPublisherNode>`
  - `listeners: Record<ListenerId, DebugListenerNode>`
  - `byPort` reverse-lookup index (what feeds each input)
  - `pipelines` - Pre-rendered transformation chains
  - `busIndexById` / `bindingIndexById` for array-based snapshots

**Current State**: Compilation works but produces no debug metadata. Compiler doesn't distinguish buses/publishers/listeners in output IR.

### 3. **React Hooks for Edge-to-Bus Resolution** ❌ MISSING
**Needed:**
- `useDebugProbe(edgeId)` - Returns PortProbeResult for an edge
- `useBusTimeseries(busId, windowMs)` - Returns Series for plotting
- Memoization layer to prevent excessive queries
- React context for DebugService injection

**Current State**: No hooks layer. OscillaNode has access to port data but no value stream access.

### 4. **Popover & Tooltip Components** ❌ MISSING
**Needed:**
- Popover component anchored to edge (cursor position or edge center)
- Four-section layout:
  - Header (identity badge)
  - "Now" section (type-specific value renderer)
  - "Where It Comes From" (trace summary)
  - "Fixes" (diagnostic actions)
- Type-specific renderers:
  - Number: Horizontal meter + numeric readout
  - Phase: Circular ring with wrap indicator + pulse status
  - Color: Swatch + palette strip (if applicable)
  - Vec2: XY dot plot
  - Event/Trigger: Pulse lamp + history strip

**Current State**: DiagnosticConsole exists but entirely different (compile-time diagnostics, not runtime values).

### 5. **Value Type Renderers** ❌ MISSING
**Needed:**
- `formatValueSummary(value: ValueSummary)` for different types
- No existing utilities for phase visualization, color display formatting
- No sparkline/timeseries visualization component

**Current State**: Blocks render themselves (Canvas2DRenderer) but no generic value display utilities.

### 6. **Runtime Instrumentation for Value Capture** ⚠️ PARTIALLY COMPLETE
**In place:**
- HealthMonitor.ts has throttling pattern
- RuntimeState.ts tracks frame execution

**Missing:**
- `DebugTap` interface implementation (spec defines it, code doesn't use it)
- Injection point in OpcodeInterpreter to call `tap?.recordBusNow?.()`
- No integration in ScheduleExecutor to emit snapshots
- ValueSummary type not used in runtime (only defined in spec)

---

## WHAT NEEDS CHANGES: Modifications Required

### 1. **Compiler Changes** (Moderate)
- **File**: `src/compiler/compileBusAwarePatch.ts` or equivalent
- **Change**: After bus/publisher/listener resolution, build DebugGraph
- **Effort**: ~100-150 lines to add DebugGraph builder
- **Risk**: Low (read-only output, no change to execution semantics)

### 2. **Runtime Changes** (Moderate)
- **Files**:
  - `src/runtime/ScheduleExecutor.ts` - Add DebugTap injection
  - `src/runtime/OpcodeInterpreter.ts` - Record values after bus evaluation
  - `src/runtime/RuntimeState.ts` - Add tap field to RuntimeState
- **Changes**:
  - Call `tap?.recordBusNow?.(busId, valueSummary)` after each bus combines
  - Emit snapshots at ~15Hz (or configurable rate)
  - Keep all recording gated by DebugLevel (OFF/BASIC/TRACE/PERF/FULL)
- **Effort**: ~200 lines total
- **Risk**: Medium (touch frame loop, but guarded by level checks)

### 3. **New Service Layer** (Low)
- **File**: `src/services/DebugService.ts` (new)
- **Scope**: ~300 lines
  - Singleton or injected
  - Holds DebugGraph + ring buffers
  - Implements query API
- **Risk**: Low (isolated, no coupling to execution)

### 4. **UI Integration** (Moderate)
- **Files**:
  - `src/ui/reactFlowEditor/ReactFlowEditor.tsx` - Add edge hover handler
  - `src/ui/components/DebugProbePopover.tsx` (new) - Popover component
  - `src/ui/hooks/useDebugProbe.ts` (new) - Hook for queries
- **Changes**:
  - Wire edge `onMouseEnter` to show popover at cursor
  - Throttle updates to 1Hz from DebugService
  - Render type-specific value visualizations
- **Effort**: ~400-500 lines (React components)
- **Risk**: Low (purely additive UI, no existing changes)

### 5. **Type System** ✓ NO CHANGES NEEDED
- PayloadType already defined (`float | vec2 | color | phase` etc.)
- ValueSummary tagged union fits the types
- Cardinality system ready

---

## DEPENDENCIES & RISKS

### 1. **Runtime Performance Impact** ⚠️ MEDIUM RISK
- **Issue**: Value recording on every bus evaluation could exceed frame budget if not throttled
- **Mitigation**:
  - `DebugLevel` gates: OFF by default, only sample at 15Hz (not 60fps)
  - Ring buffers pre-allocated, no per-sample allocation
  - HealthMonitor already proves 5Hz throttling works (<1% overhead)
- **Verification**: Frame budget tests with FULL debug level enabled

### 2. **Coupling to Scheduler Internals** ⚠️ MEDIUM RISK
- **Issue**: Recording calls injected into ScheduleExecutor tight loop
- **Mitigation**:
  - Use DebugTap interface (indirect coupling)
  - No DebugService imported in runtime code
  - Optional parameter pattern (`tap?: DebugTap`)
- **Invariant**: Runtime must work identically with `tap = undefined`

### 3. **UI Positioning Complexity** ⚠️ LOW-MEDIUM RISK
- **Issue**: Popover must not obscure graph, follow viewport
- **Mitigation**:
  - Use ReactFlow's coordinate system (screen → canvas space)
  - Popover library handles edge-of-viewport repositioning
  - Defer advanced positioning to Phase 2
- **Phase 1 scope**: Anchor to cursor/edge center, simple repositioning

### 4. **Type Safety for Value Access** ✓ MANAGEABLE
- **Issue**: ValueSummary is tagged union; must match payload type
- **Mitigation**:
  - Spec defines ValueSummary with exhaustive pattern matching
  - Renderers use `switch (value.t)` not `value.v`
  - Compile-time exhaustiveness checking

### 5. **Observation Storage Bounds** ✓ GUARANTEED
- Ring buffers sized at init time: `150 samples @ 15Hz = 10 seconds`
- Bounded TopK for perf counters (N=8)
- No unbounded maps per bus
- Same pattern as HealthMonitor (proven)

### 6. **Type Definition at Runtime** ✓ RESOLVED
- SignalType available from DebugGraph (compile-time)
- UI queries like `probePort(portKey)` return pre-formatted PortProbeResult with type
- No type inference at runtime needed

---

## AMBIGUITIES & UNKNOWNS (CRITICAL)

### 1. **❓ How are runtime values currently accessed?**
**Current State**:
- Values stored in `RuntimeState.valueStore.f64` (typed array)
- Slot IDs used for indexing
- No public API to query values from UI layer

**Question**: Is there an existing mechanism to get slot value at a given frame? Or do we create `DebugService.getSlotValue(slotId): number` as new API?

**Impact**: Determines whether to wrap ScheduleExecutor or inject new query interface.

---

### 2. **❓ What's the slot resolution mechanism from edge → runtime slot?**
**Current State**:
- PatchStore knows edges (from.portId, to.portId)
- Compiler produces slot IDs
- **Gap**: No mapping exposed: `edge (blockId.portId) → slot ID`

**Question**: Does DebugGraph need to provide `byPort: Record<PortKey, slotIds>` reverse lookup? Or is this in compiled IR already?

**Impact**: If missing, must build it in DebugGraph builder. Affects DebugGraph scope (~30-50 lines).

---

### 3. **❓ How to observe values without affecting performance?**
**Current State**:
- HealthMonitor throttles at 5Hz
- Frame loop runs at 60fps
- No per-slot recording without batching

**Question**: Should each value tap call happen on every frame (gated by level), or batch at sample rate like NaN detection?

**Spec says**: "Sample at 10-15 Hz, not every frame"

**Answer**: Record on every frame internally, emit snapshots at 15Hz. Same as HealthMonitor pattern.

**Impact**: Slightly higher CPU (per-frame recording) but still bounded. Verify in profiling.

---

### 4. **❓ Where do edges get rendered and handle events in ReactFlow?**
**Current State**:
- OscillaNode renders ports with `<Handle />`
- EdgeContextMenu exists for right-click
- No built-in edge mouse tracking

**Question**: ReactFlow has `onEdgeMouseEnter` / `onEdgeMouseLeave`—should we use those, or render custom edge component?

**Standard pattern**: Use event handlers on `<ReactFlow />`, not custom Edge component.

**Impact**: Use ReactFlow event handlers (lower effort). Custom Edge component deferred to Phase 2.

---

### 5. **❓ What value types exist beyond the 4 mentioned (Signal, Field, Shape, Event)?**
**Spec says**: "Display different value types (Signals, Fields, Shapes, Events)"

**Actual Types**:
- PayloadType: `float | int | vec2 | color | phase | bool | unit | shape`
- Cardinality: `zero | one | many` (defines # of lanes, not "type")
- Temporality: `continuous | discrete` (timing, not value type)

**Clarification**:
- **Signal**: Payload + Cardinality.one + Temporality.continuous
- **Field**: Payload + Cardinality.many + Temporality.continuous
- **Event**: Any Payload + Temporality.discrete
- **Shape**: Payload.shape (special case)

**So**: Not 4 types but combinations. PayloadType has 8 variants, Cardinality has 3.

**Impact**: Probe must render based on SignalType (derived from PayloadType + Cardinality), not hardcoded 4.

---

### 6. **❓ Is there existing observation infrastructure we're unaware of?**
**Searched for**: `observe`, `probe`, `inspect`, `DebugGraph`, `DebugService`

**Finding**: Only HealthMonitor for diagnostics, nothing for general value observation.

**Spec Status**: Observation system is **SPECIFIED** but **NOT IMPLEMENTED** in code.

**Answer**: We're building it from scratch. Spec is the source of truth.

**Impact**: Full implementation scope, not incremental work.

---

### 7. **❓ Does the current compiler output support DebugGraph generation?**
**Current State**:
- Compiler handles bus normalization
- Buses/publishers/listeners resolved during compilation
- But: No structured export of this topology

**Question**: Can we extract DebugGraph data from existing compiler state, or must we refactor compilation output?

**Answer**: Refactor is minimal—add one line `tap?.onDebugGraph?.(debugGraph)` at end of `compileBusAwarePatch()`. DebugGraph builder is new (~100 lines).

**Impact**: Low coupling, isolated change.

---

### 8. **❓ Should Probe mode be a global toggle or per-edge?**
**Spec says**: "A toggle button in the main UI. When enabled, cursor changes to crosshair"

**Current UI**: Has Toolbar in CanvasTab.tsx

**Question**: Do we add a "Probe" button to Toolbar, or implement phase 1 without global toggle (always-on hover)?

**Phase 1 Recommendation**: No toggle needed. Just hover edge → show popover (simpler MVP).

**Phase 2**: Add global Probe mode + cursor change + keyboard shortcuts.

**Impact**: Phase 1 scope reduced by ~50 lines (no toggle logic).

---

## VERDICT: **CONTINUE (WITH CLARIFICATIONS)**

### Recommendation
**START IMPLEMENTATION** with conditions:

1. **Resolve Ambiguity #2 First**: Understand slot resolution from edge to runtime value
   - Read compiler output structures
   - Verify DebugGraph can provide `byPort` reverse lookup
   - **Est. time**: 30 min investigation

2. **Implement in This Order**:
   - Phase 1A: DebugGraph builder in compiler (~150 lines, low risk)
   - Phase 1B: DebugService singleton (~300 lines, isolated)
   - Phase 1C: Runtime instrumentation + DebugTap (~200 lines, medium risk—test frame budget)
   - Phase 1D: React hooks + popover UI (~500 lines, low risk)

3. **Frame Budget Gate**: Before Phase 1C, verify HealthMonitor throttling on test patch
   - Measure frame time with FULL debug level
   - Ensure <5% overhead at 1Hz sample rate
   - Baseline: HealthMonitor already proven <1% at 5Hz

4. **MVP Scope**: No Phase 2 features
   - ✅ Hover edge → show popover
   - ✅ Four sections (identity, now, trace, fixes)
   - ✅ Type-specific renderers (meter, phase ring, color swatch)
   - ✅ Throttle to ~1Hz
   - ❌ Global Probe toggle (Phase 2)
   - ❌ Expanded Trace View (Phase 2)
   - ❌ Diagnostics integration in popover (Phase 2—use static text only)

### Remaining Unknowns to Resolve Before Implementation
1. **Slot resolution**: Can DebugGraph provide edge → slot ID mapping?
2. **Sample rate**: Confirm 1Hz is target (spec says 10-15Hz, UI needs ~1Hz max)
3. **Value access API**: New `getSlotValue()` or leverage existing `valueStore` API?

### Confidence Level
- **Spec alignment**: HIGH ✓ (08-observation-system.md is authoritative)
- **Technical feasibility**: HIGH ✓ (no architectural blockers, HealthMonitor pattern proven)
- **Implementation complexity**: MEDIUM (isolated pieces, but value recording in hot loop needs care)
- **Risk to existing code**: LOW ✓ (optional/gated, no forced changes)

---

**Estimated Sprint Allocation**: 2-3 days with investigation, implementation, and testing
- Investigation: 4-6 hours
- Implementation: 8-12 hours
- Testing + frame budget validation: 4-6 hours

**Go/No-Go**: **CONTINUE** — no blockers identified, path is clear.
