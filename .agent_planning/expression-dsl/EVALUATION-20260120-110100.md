# Expression DSL - Current State Evaluation

**Generated:** 2026-01-20 11:01:00
**Topic:** expression-dsl
**Agent:** status-planner

## Executive Summary

This is a **greenfield feature** - the Expression DSL does not currently exist in the codebase. This evaluation documents the current state of the system and identifies integration points for the new DSL.

## Current State

### What Exists

**Block System Infrastructure:**
- ✅ Block registry system (`src/blocks/registry.ts`)
- ✅ Block definition interface with `lower` function
- ✅ IR builder interface (`src/compiler/ir/IRBuilder.ts`)
- ✅ Signal expression primitives (`sigConst`, `sigMap`, `sigZip`)
- ✅ Type system with `PayloadType` and `SignalType`
- ✅ OpCode enumeration for primitive operations
- ✅ Compilation pipeline that transforms blocks to IR

**Math Operations:**
- ✅ Primitive math blocks (Add, Subtract, Multiply, Divide)
- ✅ OpCode support for arithmetic operations
- ✅ Function blocks (Sin, Cos, etc.)

**UI Infrastructure:**
- ✅ Block parameter UI system with `UIControlHint`
- ✅ Config-based parameter storage
- ✅ Port binding system

### What Does NOT Exist

**Expression DSL Components:**
- ❌ No expression parser
- ❌ No expression lexer/tokenizer
- ❌ No expression AST types
- ❌ No expression type checker
- ❌ No expression-to-IR compiler
- ❌ No Expression block (the user-facing block)
- ❌ No expression validation/error reporting
- ❌ No expression syntax documentation

## Integration Points Identified

### 1. Block Registry
**Location:** `src/blocks/registry.ts`
**Status:** Ready for integration

The Expression block will register using the existing `registerBlock()` API:
- Type: `'Expression'`
- Form: `'primitive'`
- Capability: `'pure'`
- Inputs: Text input for expression string + named inputs for variables
- Lower function: Calls expression compiler to generate IR

### 2. IR Builder
**Location:** `src/compiler/ir/IRBuilder.ts`, `src/compiler/ir/IRBuilderImpl.ts`
**Status:** Ready for integration

Expression compiler will use existing IR primitives:
- `sigConst(value, type)` - for numeric literals
- `sigMap(input, fn, type)` - for unary operations
- `sigZip(inputs, fn, type)` - for binary/n-ary operations
- `opcode(OpCode)` - for primitive operations

### 3. Type System
**Location:** `src/core/canonical-types.ts`
**Status:** Ready for integration

Expression type checker will work with:
- PayloadType: `'float' | 'int' | 'bool' | 'phase' | 'unit' | 'vec2' | 'color'`
- SignalType: Full type including extent
- Type resolution for polymorphic expressions

### 4. Compilation Pipeline
**Location:** `src/compiler/passes-v2/`
**Status:** Ready for integration

Expression compilation happens during block lowering:
- Input: Expression string + input port types
- Output: SigExprId (IR expression ID)
- Errors: Compile errors via existing error reporting

## Architectural Constraints

### From Spec (ESSENTIAL-SPEC.md)

**Invariants:**
- I6: Compiler never mutates the graph (expression compiler is pure)
- I19: First-class error taxonomy (expression errors must be typed)
- I20: Traceability by stable IDs (expression AST nodes should be traceable)

**Architecture Laws (CLAUDE.md):**
- ONE SOURCE OF TRUTH: Expression grammar is frozen and documented once
- SINGLE ENFORCER: Expression type checking happens once in the compiler
- ONE-WAY DEPENDENCIES: Expression DSL → IR (never reverse)
- LOCALITY: Expression DSL changes must not affect rest of system

### Isolation Requirements

**Module Boundary:**
- Expression DSL lives in `src/expr/` (isolated module)
- Rest of system only sees: `compileExpression(text, inputs) → Result<SigExprId, Error>`
- No expression types leak into block system, compiler, or runtime
- Grammar is frozen - documented in module, never changed

**No Runtime Interpreter:**
- Expressions compile to IR at block lowering time
- No expression evaluation at runtime
- No expression AST in runtime state
- Runtime only executes IR opcodes

## Dependencies

### External Dependencies
- **None required** - can use built-in TypeScript/JavaScript for parsing
- **Option:** Could use a parser combinator library for cleaner code (e.g., Parsimmon)
- **Decision:** Defer to implementation sprint

### Internal Dependencies
- IR builder interface (exists)
- OpCode enumeration (exists)
- Type system (exists)
- Error reporting (exists)

## Risk Assessment

### Low Risk
- ✅ Clear integration points
- ✅ Isolated module design
- ✅ No new IR primitives needed
- ✅ Frozen grammar (no scope creep)

### Medium Risk
- ⚠️ Expression error messages (need good UX)
- ⚠️ Type inference for complex expressions
- ⚠️ Parser complexity (depending on implementation approach)

### High Risk
- ❌ None identified

## Known Unknowns

1. **Parser Implementation Approach**
   - Hand-written recursive descent?
   - Parser combinator library?
   - Generated parser (e.g., PEG.js)?
   - **Research needed:** Compare approaches for size/complexity tradeoff

2. **Error Recovery Strategy**
   - Fail-fast on first error?
   - Collect multiple errors?
   - Partial compilation for diagnostics?
   - **Research needed:** What UX do we want for expression errors?

3. **Type Inference Scope**
   - Infer types bottom-up from literals?
   - Require explicit input types?
   - Support polymorphic literals (e.g., `0` could be int or float)?
   - **Research needed:** Define type checking rules precisely

## Quantitative Metrics

**Code Size Estimate:**
- Parser: ~300-500 LOC
- AST types: ~100-150 LOC
- Type checker: ~200-300 LOC
- IR compiler: ~200-300 LOC
- Expression block: ~100 LOC
- Tests: ~500-800 LOC
- **Total:** ~1400-2150 LOC

**File Count:**
- `src/expr/parser.ts`
- `src/expr/ast.ts`
- `src/expr/typecheck.ts`
- `src/expr/compile.ts`
- `src/expr/index.ts`
- `src/blocks/expression-block.ts`
- `src/expr/__tests__/parser.test.ts`
- `src/expr/__tests__/typecheck.test.ts`
- `src/expr/__tests__/compile.test.ts`
- `src/expr/__tests__/integration.test.ts`
- **Total:** ~10 files

## Gaps Summary

| Category | Gap | Priority |
|----------|-----|----------|
| Core DSL | Expression parser | P0 |
| Core DSL | AST type definitions | P0 |
| Core DSL | Type checker | P0 |
| Core DSL | IR compiler | P0 |
| Integration | Expression block | P0 |
| Validation | Unit tests | P0 |
| Documentation | Grammar spec | P1 |
| Documentation | Error catalog | P1 |
| UX | Error messages | P1 |

## Next Steps

1. **Research Sprint (MEDIUM confidence):** Resolve unknowns about parser approach and type inference
2. **Core Implementation Sprint (HIGH confidence after research):** Implement parser, AST, type checker, compiler
3. **Integration Sprint (HIGH confidence):** Create Expression block and wire to UI
4. **Validation Sprint (HIGH confidence):** Comprehensive testing and error handling

## Files Referenced

- `src/blocks/registry.ts` - Block registration
- `src/blocks/signal-blocks.ts` - Example block implementation
- `src/blocks/math-blocks.ts` - Example math blocks
- `src/compiler/ir/IRBuilder.ts` - IR builder interface
- `src/compiler/ir/signalExpr.ts` - Signal expression types
- `src/compiler/types.ts` - Compiler error types
- `src/core/canonical-types.ts` - Type system
- `design-docs/CANONICAL-oscilla-v2.5-20260109/ESSENTIAL-SPEC.md` - System spec
