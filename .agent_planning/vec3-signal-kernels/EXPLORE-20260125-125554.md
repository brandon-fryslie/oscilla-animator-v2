# Exploration: vec3 Signal Kernels
Timestamp: 2026-01-25-125554
Git Commit: defd697

## Exploration Summary

This exploration investigated the need for vec3 signal kernels as discovered during the vec2-to-vec3 migration.

## Files Examined

### Runtime Kernel Files
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/SignalEvaluator.ts` - Signal-level kernel evaluation
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/FieldKernels.ts` - Field-level kernel implementations
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/kernels/KernelRegistryDual.ts` - Dual kernel dispatch abstraction
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/kernel-signatures.ts` - Kernel signatures and unit annotations
- `/Users/bmf/code/oscilla-animator-v2/src/runtime/Materializer.ts` - Field materialization orchestration

### Block Files Using vec3 Signal Kernels
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/geometry-blocks.ts` - Uses `vec3FromComponents` and `jitterVecSig`
- `/Users/bmf/code/oscilla-animator-v2/src/blocks/field-operations-blocks.ts` - Uses `jitterVecSig` and `setZSig`

## Key Findings

### 1. Signal Kernel Architecture (SignalEvaluator.ts)

Signal kernels are explicitly documented as **scalar-only functions** (lines 13-26):
```typescript
/**
 * WHAT BELONGS HERE:
 * - Oscillators (phase [0,1) → value [-1,1])
 * - Easing functions (t [0,1] → u [0,1])
 * - Shaping functions (smoothstep, step)
 * - Noise (deterministic, seeded)
 *
 * WHAT DOES NOT BELONG HERE:
 * - Generic math (abs, floor, sqrt, pow) → use OpcodeInterpreter
 * - Vec2/geometry operations → use Materializer field kernels
 * - Field-level operations → use Materializer
 */
```

Lines 259-269 explicitly reject vec2 kernels at signal level:
```typescript
// vec2 kernels not supported at signal level
case 'polarToCartesian':
case 'offsetPosition':
case 'circleLayout':
case 'circleAngle':
  throw new Error(
    `Signal kernel '${name}' returns vec2 which is not yet supported at signal level. ` +
    `Use field-level version instead (fieldZipSig or fieldMap).`
  );
```

### 2. Missing Signal Kernels Referenced in Blocks

**geometry-blocks.ts** references these signal kernels that don't exist:

1. **`vec3FromComponents`** (line 78-79):
```typescript
// Package as vec3 using the vec3FromComponents kernel
const vec3Fn = ctx.b.kernel('vec3FromComponents');
const result = ctx.b.sigZip([x, y, z], vec3Fn, signalType('vec3', unitWorld3()));
```

2. **`jitterVecSig`** (lines 199-200):
```typescript
// Signal path - use kernel to build jittered vec3
const jitterFn = ctx.b.kernel('jitterVecSig');
const result = ctx.b.sigZip([pos.id, rand.id, amountXSig, amountYSig, amountZSig], jitterFn, signalType('vec3', unitWorld3()));
```

**field-operations-blocks.ts** also references:

3. **`setZSig`** (lines 1030-1031):
```typescript
// Signal path - use kernel to set z component
const setZFn = ctx.b.kernel('setZSig');
const result = ctx.b.sigZip([pos.id, z.id], setZFn, signalType('vec3'));
```

### 3. Field Kernel Equivalents Already Exist

The field-level versions exist in FieldKernels.ts:
- `makeVec3` (lines 82-101) - combines x, y floats into vec3 with z=0
- `fieldJitterVec` (lines 341-373) - applies jitter to vec3 field
- `fieldSetZ` (lines 419-439) - sets Z component of vec3 field

### 4. Architecture Constraint

The architecture explicitly separates:
- **Signal kernels** (SignalEvaluator.ts): scalar-only, single values
- **Field kernels** (FieldKernels.ts): array operations on typed buffers

Vec3 values at signal level would need to be stored/passed somehow. The current RuntimeState stores signals in Float64Array (`state.values.f64`), which expects scalar values per slot.

### 5. KernelRegistryDual.ts Observation

This new file provides a dual-kernel dispatch surface (lines 46-104) for cardinality-polymorphic blocks. It has helpers `emitUnary` and `emitBinary` that dispatch to either:
- Signal path: `sigMap`/`sigZip` with opcodes
- Field path: `fieldMap`/`fieldZip` with field kernels

However, this abstraction only supports scalar operations, not vector operations.

### 6. Slot Storage Architecture

From RuntimeState.ts (line 96):
```typescript
export interface ValueStore {
  /** Numeric values (most signals) */
  f64: Float64Array;

  /** Object values (colors, complex types) */
  objects: Map<ValueSlot, unknown>;
  ...
}
```

Vec3 values at signal level would need either:
- 3 separate f64 slots (stride 3)
- Object storage (Map-based, slower)

The scheduler (ScheduleExecutor.ts) validates stride (line 86):
```typescript
if (lookup.stride !== 1) {
  throw new Error(`writeF64Scalar: expected stride=1 for slot ${lookup.slot}, got stride=${lookup.stride}`);
}
```

### 7. Test Coverage

Signal kernel tests exist in `/Users/bmf/code/oscilla-animator-v2/src/runtime/__tests__/signal-kernel-contracts.test.ts` but only test scalar kernels (oscillators, easing, noise).

No tests exist for vec3 signal operations because the architecture doesn't support them yet.

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| npm run test | PARTIAL | 21 failed / 67 passed (24 tests failed, unrelated to vec3 kernels) |
| grep 'vec3FromComponents' in SignalEvaluator | MISSING | Not implemented |
| grep 'jitterVecSig' in SignalEvaluator | MISSING | Not implemented |
| grep 'setZSig' in SignalEvaluator | MISSING | Not implemented |

## Summary

The vec3 signal kernels (`vec3FromComponents`, `jitterVecSig`, `setZSig`) are referenced in block lower() functions but **do not exist** in SignalEvaluator.ts. The architecture explicitly states vec2/vec3 operations should use field kernels, not signal kernels.

This creates a code path that will throw runtime errors when:
1. PolarToCartesian block is used with all-signal inputs
2. OffsetVec/JitterVec block is used with all-signal inputs
3. SetZ block is used with all-signal inputs
