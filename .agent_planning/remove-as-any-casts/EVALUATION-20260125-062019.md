# Evaluation: Remove 'as any' Casts from Test Files
Timestamp: 2026-01-25-062019
Git Commit: 4243c1d

## Executive Summary
Overall: 85% feasible without production changes | Critical issues: 0 | Tests reliable: yes

The task is well-scoped and mostly mechanical. Most categories can be fixed with simple refactoring using existing factory functions. Two categories (mock patterns, IRBuilder access) may require either test infrastructure additions or acceptance of limited `as any` usage.

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| grep 'as any' count | PASS | 210 total (not 145 as stated) |
| Factory functions exist | PASS | All branded types have factories |
| ScheduleIR type exported | PASS | Exported from pass7-schedule.ts |
| canonicalType factory | PASS | Available in canonical-types |

## Missing Checks

1. **Type inference test**: Run `npm run typecheck` after each category to verify no new errors
2. **Test pass verification**: Run `npm run test` after each category to verify tests still pass
3. **Category isolation test**: Verify each category can be fixed independently

## Findings

### Category 1: Schedule Access Pattern
**Status**: FIXABLE (low effort)
**Count**: ~60 occurrences across 6 files
**Evidence**:
- `program.schedule` typed as generic `Schedule`
- `ScheduleIR` interface at `/Users/bmf/code/oscilla-animator-v2/src/compiler/passes-v2/pass7-schedule.ts:43` has all needed fields
**Issues**:
- Need to verify `CompiledProgram.schedule` can be typed as `ScheduleIR`
- May need type assertion in one place instead of many

**Fix approach**:
```typescript
// Instead of: const schedule = program.schedule as any;
import type { ScheduleIR } from '../../compiler/passes-v2/pass7-schedule';
const schedule = program.schedule as ScheduleIR;
// Now schedule.stateSlotCount, schedule.steps, etc. are typed
```

### Category 2: Branded Type Literals
**Status**: FIXABLE (trivial)
**Count**: ~35 occurrences across 3 files
**Evidence**: Factory functions exist in `/Users/bmf/code/oscilla-animator-v2/src/compiler/ir/Indices.ts:80-151` and `/Users/bmf/code/oscilla-animator-v2/src/types/index.ts:130-136`
**Issues**: None

**Fix approach**:
```typescript
// Instead of: 'b0' as any
import { blockId } from '../../types';
blockId('b0')

// Instead of: 0 as any (for SigExprId)
import { sigExprId } from '../../compiler/ir/Indices';
sigExprId(0)
```

### Category 3: Parser AST Access
**Status**: FIXABLE (medium effort)
**Count**: ~48 occurrences in 2 files
**Evidence**: Parser returns discriminated union based on `kind` field
**Issues**: Requires type narrowing patterns throughout tests

**Fix approach** (two options):

Option A - Inline narrowing:
```typescript
const ast = parse(tokens);
expect(ast.kind).toBe('literal');
if (ast.kind === 'literal') {
  expect(ast.value).toBe(42);
}
```

Option B - Assertion helpers (recommended):
```typescript
// Create test/helpers/ast.ts
function assertLiteral(ast: ASTNode): asserts ast is LiteralNode {
  if (ast.kind !== 'literal') throw new Error(`Expected literal, got ${ast.kind}`);
}

// In test:
const ast = parse(tokens);
assertLiteral(ast);
expect(ast.value).toBe(42);
```

### Category 4: Field Kernel Type Params
**Status**: FIXABLE (low effort)
**Count**: ~30 occurrences in 1 file
**Evidence**: `canonicalType()` factory at `/Users/bmf/code/oscilla-animator-v2/src/core/canonical-types.ts`
**Issues**: Need to verify canonicalType can produce all needed configurations

**Fix approach**:
```typescript
// Instead of: { payload: 'vec2', cardinality: 'many' } as const ... type as any
import { signalTypeField } from '../../core/canonical-types';
const type = signalTypeField('vec2');  // Creates proper CanonicalType for fields
```

### Category 5: Mock/Stub Patterns
**Status**: PARTIAL - Some acceptable, some fixable
**Count**: ~20 occurrences across 4 files
**Evidence**: Canvas mocks, partial RuntimeState
**Issues**:
- Canvas context mock: acceptable `as any` (browser API)
- Partial state mocks: need proper factory or Partial<T>

**Fix approach**:
- Canvas context: Keep `as any` with comment explaining why
- State mocks: Create `createTestRuntimeState(overrides)` helper
- Or use `satisfies Partial<RuntimeState>` pattern

### Category 6: IRBuilder Access
**Status**: TECHNICAL DEBT - Accept with documentation
**Count**: ~15 occurrences in 1 file
**Evidence**: Tests access `builder['sigExprs']` (private array)
**Issues**:
- These are implementation tests, not contract tests
- Exposing internals via test API adds maintenance burden
- Alternative: Mock the builder and verify calls

**Recommendation**:
- Accept `as any` for these specific cases
- Add comment: `// Implementation test: accessing private sigExprs array`
- OR refactor tests to assert on outputs rather than internal state

## Ambiguities Found

| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| Schedule type | Is program.schedule typed as ScheduleIR? | Assumed yes based on exports | Low - easy to verify |
| Parser AST | Which narrowing pattern preferred? | None - both options presented | Medium - affects code style |
| Mock patterns | Should all be removed or some acceptable? | Some acceptable (browser APIs) | Low - documented exceptions |
| IRBuilder tests | Keep as implementation tests? | Yes, with documentation | Low - isolated to 1 file |

## Recommendations

### Execution Order (by dependency and difficulty)

1. **Category 2: Branded Type Literals** (FIRST)
   - No dependencies
   - Trivial mechanical replacement
   - 35 occurrences, ~15 minutes

2. **Category 1: Schedule Access Pattern** (SECOND)
   - Depends on verifying ScheduleIR type fits
   - Single assertion type solves many casts
   - 60 occurrences, ~30 minutes

3. **Category 4: Field Kernel Type Params** (THIRD)
   - No dependencies
   - Uses existing canonicalType factory
   - 30 occurrences, ~20 minutes

4. **Category 3: Parser AST Access** (FOURTH)
   - May want to create test helper first
   - Most verbose changes
   - 48 occurrences, ~45 minutes

5. **Category 5: Mock Patterns** (FIFTH)
   - Some acceptable, document those
   - May want shared test utilities
   - 20 occurrences, ~30 minutes

6. **Category 6: IRBuilder Access** (LAST/OPTIONAL)
   - Decide: fix or document as acceptable
   - If fix: may need production API changes
   - 15 occurrences, ~varies

### Risk Mitigation

1. **After each category**: Run `npm run typecheck && npm run test`
2. **Create atomic commits**: One commit per category for easy rollback
3. **Document exceptions**: Any remaining `as any` gets a comment explaining why
4. **Consider test helpers**: For repeated patterns (AST assertions, mock factories)

## Verdict

- [x] CONTINUE - Issues clear, implementer can fix

No blocking ambiguities. All categories have clear fix approaches. The count discrepancy (210 vs 145) is a scope difference, not a blocker. Implementation order is clear and categories are independent enough to parallelize if desired.

## Suggested Starting Point

Begin with Category 2 (branded types) - it's the simplest and provides immediate confidence that the approach works. Sample fix for PatchStore.test.ts:

```typescript
// Before
'b0' as any
'nonexistent' as any

// After
import { blockId } from '../../types';
blockId('b0')
blockId('nonexistent')  // Error cases still need proper type
```
