# Explore: Remove 'as any' Casts from Test Files
Timestamp: 2026-01-25-062019

## Exploration Summary

Searched test files for 'as any' patterns and categorized the findings.

## Actual Count

Total 'as any' occurrences in test files: **210** (not 145 as stated in context)

## File-by-File Breakdown

| File | Count | Primary Category |
|------|-------|------------------|
| parser.test.ts | 44 | Parser AST access |
| field-kernel-contracts.test.ts | 30 | Field kernel type params |
| stateful-primitives.test.ts | 18 | Schedule access pattern |
| expression-blocks.test.ts | 15 | Branded type literals + IRBuilder access |
| event-blocks.test.ts | 12 | Schedule access pattern |
| math-utility-blocks.test.ts | 11 | Schedule access pattern |
| exportFormats.test.ts | 9 | Unknown |
| EventEvaluator.test.ts | 8 | Schedule access + branded IDs |
| continuity-integration.test.ts | 8 | Mock state patterns |
| PatchStore.test.ts | 7 | Branded type literals (BlockId) |
| local-space-sanity.test.ts | 6 | Schedule access |
| level6-mode-toggle.test.ts | 4 | Unknown |
| expr/integration.test.ts | 4 | Parser AST |
| stroke-rendering.test.ts | 3 | Mock patterns |
| SelectionStore.test.ts | 2 | Branded type literals |
| compile.test.ts | 2 | Unknown |
| stores/integration.test.ts | 1 | Unknown |
| runtime/integration.test.ts | 1 | Unknown |
| level10-golden-tests.test.ts | 1 | Unknown |
| steel-thread-rect.test.ts | 1 | Unknown |

Plus additional TSX files (DebugMiniView.test.tsx, Sparkline.test.tsx, etc.) with mock patterns.

## Category Analysis

### Category 1: Schedule Access Pattern (~60+ occurrences)

**Files**: event-blocks.test.ts, stateful-primitives.test.ts, EventEvaluator.test.ts, integration.test.ts, math-utility-blocks.test.ts, local-space-sanity.test.ts

**Pattern**:
```typescript
const schedule = program.schedule as any;
schedule.stateSlotCount
schedule.stateSlots
schedule.steps.filter((s: any) => s.kind === 'evalSig')
```

**Root cause**: `program.schedule` type doesn't expose internal properties. Tests need access to:
- `stateSlotCount: number`
- `stateSlots: { initialValue: number }[]`
- `steps: Step[]` with typed step access
- `eventSlotCount: number`
- `eventExprCount: number`
- `stateMappings: StateMapping[]`

**Evidence from pass7-schedule.ts**: `ScheduleIR` interface IS exported with all these fields typed.

**Fix approach**: Ensure `CompiledProgram.schedule` uses `ScheduleIR` type (currently typed as `Schedule` which may be different).

### Category 2: Branded Type Literals (~35 occurrences)

**Files**: PatchStore.test.ts, SelectionStore.test.ts, expression-blocks.test.ts

**Pattern**:
```typescript
'b0' as any  // should be BlockId
0 as any     // should be ValueSlot, SigExprId, etc.
'nonexistent' as any  // error case testing
```

**Root cause**: Branded types require factory functions, but tests hardcode values.

**Evidence from Indices.ts**: Factory functions exist:
- `blockId(s: string): BlockId`
- `valueSlot(n: number): ValueSlot`
- `sigExprId(n: number): SigExprId`
- `slotId(s: string): SlotId`

**Fix approach**: Replace `'b0' as any` with `blockId('b0')`. Import factory functions.

### Category 3: Parser AST Access (~48 occurrences)

**Files**: parser.test.ts, expr/integration.test.ts

**Pattern**:
```typescript
expect((ast as any).value).toBe(42);
expect((ast as any).left.name).toBe('a');
expect((ast as any).op).toBe('+');
```

**Root cause**: `parse()` returns union type `ASTNode`, but tests need to access variant-specific properties.

**Fix approach**: Either:
1. Use type guards: `if (ast.kind === 'literal') { expect(ast.value).toBe(42); }`
2. Create assertion helpers: `function assertLiteral(ast: ASTNode): asserts ast is LiteralNode`
3. Narrow with `expect()` then access: Use Vitest's type narrowing after `expect(ast.kind).toBe('literal')`

### Category 4: Field Kernel Type Params (~30 occurrences)

**Files**: field-kernel-contracts.test.ts

**Pattern**:
```typescript
const type = { payload: 'vec2', cardinality: 'many' } as const;
applyFieldKernel(out, [x, y], 'makeVec2', 3, type as any);
```

**Root cause**: `applyFieldKernel` expects a specific type, but tests create minimal objects.

**Evidence**: The `as const` is correct for literal types, but the resulting object may not match the expected `CanonicalType` shape.

**Fix approach**: Use `canonicalType()` factory from canonical-types:
```typescript
import { canonicalType } from '../../core/canonical-types';
const type = canonicalType('vec2');  // or with cardinality
```

### Category 5: Mock/Stub Patterns (~20 occurrences)

**Files**: DebugMiniView.test.tsx, Sparkline.test.tsx, stroke-rendering.test.ts, continuity-integration.test.ts

**Pattern**:
```typescript
HTMLCanvasElement.prototype.getContext = vi.fn().mockReturnValue({...}) as any;
const state = {...} as any;  // Partial mock of RuntimeState
```

**Root cause**: Creating partial mocks that don't implement full interface.

**Fix approach**:
1. For canvas: Use `satisfies CanvasRenderingContext2D` with partial type
2. For state: Create factory functions that return properly typed partial objects
3. Consider `Partial<T>` or `Pick<T, K>` for intentionally partial mocks

### Category 6: IRBuilder/LowerCtx Access (~15 occurrences)

**Files**: expression-blocks.test.ts

**Pattern**:
```typescript
const sigId = (outputRef as any).id;
const sigExpr = builder['sigExprs'][sigId as any];
```

**Root cause**: Accessing private/internal properties of IRBuilder for verification.

**Fix approach**:
1. Expose test-only inspection methods on IRBuilder
2. Or use a spy/mock approach to verify calls
3. Or accept that some internals tests need `as any` (document why)

## Type Infrastructure Check

### Available Factory Functions

From `/src/compiler/ir/Indices.ts`:
- `sigExprId(n)`, `fieldExprId(n)`, `eventExprId(n)`
- `valueSlot(n)`, `stateSlotId(n)`, `eventSlotId(n)`
- `nodeId(s)`, `stepId(s)`, `slotId(s)`, `instanceId(s)`

From `/src/types/index.ts`:
- `blockId(s)`, `portId(s)`, `wireId(s)`
- `canonicalType(...)` and related

### Missing Factory Functions

None identified - all branded types have factory functions.

## Test Infrastructure

Tests currently import:
- vitest (describe, it, expect, beforeEach, vi)
- Production code modules
- No shared test utilities for type construction

## Risk Assessment

1. **Low risk**: Branded type literals - mechanical replacement
2. **Low risk**: Schedule access - type assertion, not structural change
3. **Medium risk**: Parser AST - requires type narrowing patterns
4. **Medium risk**: Field kernel params - may need CanonicalType construction
5. **Medium risk**: Mock patterns - may expose missing types for partial objects
6. **Higher risk**: IRBuilder access - may need API changes or accept technical debt

## Dependencies

- Category 2 (branded types) has no dependencies, can be done first
- Category 1 (schedule) depends on CompiledProgram type alignment
- Category 3 (parser AST) may benefit from shared test helpers
- Category 4 (field kernel) depends on canonicalType factory coverage
- Category 5 (mocks) may need new test utility types
- Category 6 (IRBuilder) may need production code changes
