# Exploration Output: vec2 to vec3 Migration
Timestamp: 2026-01-25T10:48:00

## Search Results

### Blocks Using canonicalType('vec2')

| File | Line | Context |
|------|------|---------|
| geometry-blocks.ts | 34 | PolarToCartesian output: `pos: { label: 'Position', type: canonicalType('vec2') }` |
| geometry-blocks.ts | 55 | PolarToCartesian lower: `ctx.b.sigZip(inputs, polarFn, canonicalType('vec2'))` |
| geometry-blocks.ts | 151 | OffsetPosition input: `posIn: { label: 'Position In', type: canonicalType('vec2') }` |
| geometry-blocks.ts | 157 | OffsetPosition output: `posOut: { label: 'Position Out', type: canonicalType('vec2') }` |
| geometry-blocks.ts | 177 | OffsetPosition lower: `ctx.b.sigZip(inputs, offsetFn, canonicalType('vec2'))` |
| signal-blocks.ts | 128 | Const vec2 lowering: `sigId = ctx.b.sigZip([xSig, ySig], packFn, canonicalType('vec2'))` |
| field-operations-blocks.ts | 420 | FieldCartesianToPolar: `ctx.b.sigMap(pos.id, extractFn, canonicalType('vec2'))` - intermediate extraction |

### Blocks Using signalTypeField('vec2', ...)

| File | Line | Context |
|------|------|---------|
| path-operators-blocks.ts | 56 | PathField input: `type: signalTypeField('vec2', 'control')` |
| path-operators-blocks.ts | 60 | PathField output: `position: signalTypeField('vec2', 'control')` |
| path-operators-blocks.ts | 162 | LayoutAlongPath output: `positions: signalTypeField('vec2', 'default')` |
| path-operators-blocks.ts | 163 | LayoutAlongPath output: `tangents: signalTypeField('vec2', 'default')` |
| path-operators-blocks.ts | 204 | LayoutAlongPath lower: `signalTypeField('vec2', 'default')` for positions |
| path-operators-blocks.ts | 217 | LayoutAlongPath lower: `signalTypeField('vec2', 'default')` for tangents |
| geometry-blocks.ts | 88 | CircularLayout output: `pos: signalTypeField('vec2', 'default')` |
| geometry-blocks.ts | 114 | CircularLayout lower: `signalTypeField('vec2', 'default')` |
| path-blocks.ts | 126 | ProceduralPolygon output: `controlPoints: signalTypeField('vec2', 'control')` |
| path-blocks.ts | 176 | ProceduralPolygon lower: `signalTypeField('vec2', 'control')` |
| path-blocks.ts | 317 | ProceduralStar output: `controlPoints: signalTypeField('vec2', 'control')` |
| path-blocks.ts | 370 | ProceduralStar lower: `signalTypeField('vec2', 'control')` |

### Blocks Already Using vec3

| File | Block | Port |
|------|-------|------|
| instance-blocks.ts | GridLayout | position output: signalTypeField('vec3', 'default') |
| instance-blocks.ts | LinearLayout | position output: signalTypeField('vec3', 'default') |
| instance-blocks.ts | CircleLayout | position output: signalTypeField('vec3', 'default') |
| instance-blocks.ts | LineLayout | position output: signalTypeField('vec3', 'default') |
| field-operations-blocks.ts | FieldPolarToCartesian | pos output: canonicalType('vec3') |
| field-operations-blocks.ts | FieldCartesianToPolar | pos input: canonicalType('vec3') |
| field-operations-blocks.ts | JitterVec | pos input/output: canonicalType('vec3') |
| field-operations-blocks.ts | SetZ | pos input, out output: canonicalType('vec3') |
| render-blocks.ts | RenderInstances2D | pos input: signalTypeField('vec3', 'default') |

### Field Kernels - vec2 Operations

| Kernel | Purpose | Input/Output |
|--------|---------|--------------|
| makeVec2 | Combine x,y floats | Output: vec2 (stride 2) |
| jitter2d | Add jitter to vec2 | Input: vec2, Output: vec2 |
| attract2d | Drift vec2 to target | Input: vec2, Output: vec2 |
| polygonVertex | Generate polygon control points | Output: vec2 (stride 2) |
| starVertex | Generate star control points | Output: vec2 (stride 2) |

### Field Kernels - vec3 Operations

| Kernel | Purpose | Input/Output |
|--------|---------|--------------|
| makeVec3 | Combine x,y floats (z=0) | Output: vec3 (stride 3) |
| fieldJitterVec | Add jitter to vec3 | Input: vec3, Output: vec3 |
| circleLayout | Circle positions | Output: vec3 (stride 3) |
| gridLayout | Grid positions | Output: vec3 (stride 3) |
| lineLayout | Line positions | Output: vec3 (stride 3) |
| fieldPolarToCartesian | Polar to cartesian | Output: vec3 (stride 3) |
| fieldSetZ | Set Z component | Input: vec3, Output: vec3 |

### RenderAssembler Position Expectations

From RenderAssembler.ts:
- Line 283: `worldPositions - World-space vec3 positions (Float32Array, stride 3). READ-ONLY.`
- Line 768: Error message explicitly says "pos2â†’pos3 adapter" is NOT auto-promoted
- Line 1185-1189: Validates `positionBuffer.length !== count * 3` and throws if stride is wrong

### Current Test Status

24 test files failing with 36 test failures.
Key issues seem unrelated to vec2/vec3 migration (continuity, pass0 resolution, connection validation).

## Domain Registry Intrinsics

From domain-registry.ts:77-78:
```typescript
position: { name: 'position', type: 'vec2' as PayloadType, computation: 'inherent' as const },
bounds: { name: 'bounds', type: 'vec2' as PayloadType, computation: 'derived' as const },
```

These intrinsics still use vec2!

## Type System

From canonical-types.ts:
- vec2 is a valid PayloadType
- vec2 has units: ['ndc2', 'world2']
- vec3 has units: ['ndc3', 'world3']
- Default unit for vec2: unitWorld2()
- Default unit for vec3: unitWorld3()
- PAYLOAD_STRIDE: vec2 = 2, vec3 = 3

## Const Block vec2 Support

signal-blocks.ts:117-129 shows Const block supports vec2:
```typescript
case 'vec2': {
  const val = rawValue as { x?: number; y?: number };
  // ... validation ...
  const xSig = ctx.b.sigConst(val.x, canonicalType('float'));
  const ySig = ctx.b.sigConst(val.y, canonicalType('float'));
  const packFn = ctx.b.kernel('packVec2');
  sigId = ctx.b.sigZip([xSig, ySig], packFn, canonicalType('vec2'));
  break;
}
```
