/**
 * Expression Block
 *
 * User-defined mathematical expressions compiled to IR via Expression DSL.
 */

import { registerBlock, ALL_CONCRETE_PAYLOADS } from '../registry';
import { canonicalType, payloadStride, floatConst, requireInst } from '../../core/canonical-types';
import { FLOAT } from '../../core/canonical-types';
import type { CanonicalType, PayloadType } from '../../core/canonical-types';
import { compileExpression } from '../../expr';
import type { ValueExprId } from '../../compiler/ir/Indices';

registerBlock({
  type: 'Expression',
  label: 'Expression',
  category: 'math',
  description: 'Compute signal from mathematical expression',
  form: 'primitive',
  capability: 'pure',
  cardinality: {
    cardinalityMode: 'preserve',
    laneCoupling: 'laneLocal',
    broadcastPolicy: 'allowZipSig',
  },
  payload: {
    allowedPayloads: {
      in0: ALL_CONCRETE_PAYLOADS,
      in1: ALL_CONCRETE_PAYLOADS,
      refs: ALL_CONCRETE_PAYLOADS,
      out: ALL_CONCRETE_PAYLOADS,
    },
    // Expression block has dynamic type resolution based on expression text
    // The output type depends on the expression, not a fixed combination
    semantics: 'typeSpecific',
  },

  // Inputs include both wirable ports AND config parameters
  // Config parameters have exposedAsPort: false
  inputs: {
    // Legacy fixed input ports (2 optional inputs)
    // Kept for backward compatibility - internally processed same as varargs
    // defaultSource auto-generated by registry (architectural law: all ports get defaults)
    in0: {
      label: 'In 0',
      type: canonicalType(FLOAT), // Default type - actual type inferred during lowering
      optional: true,            // Unwired inputs are unavailable in expression
      exposedAsPort: true,
    },
    in1: {
      label: 'In 1',
      type: canonicalType(FLOAT),
      optional: true,
      exposedAsPort: true,
    },
    // Varargs input port for block references (NEW 2026-01-26)
    // Accepts variable-length connections with aliases
    // Varargs cannot have defaultSource (explicit connections only)
    refs: {
      label: 'Block Refs',
      type: canonicalType(FLOAT),  // Base type for validation
      optional: true,
      exposedAsPort: true,
      isVararg: true,
      varargConstraint: {
        payloadType: FLOAT,
        cardinalityConstraint: 'any',  // Accept Signal or Field
      },
    },
    // Config parameter (not a port - cannot be wired)
    // Note: Inspector UI will detect Expression block and render this as multiline
    expression: {
      label: 'Expression',
      type: canonicalType(FLOAT),  // Config-only, type not used
      exposedAsPort: false,       // Config-only, not wirable
      defaultValue: '',            // Default: empty expression
      uiHint: { kind: 'text' },   // Text input (Inspector will make it multiline)
    },
  },

  outputs: {
    out: {
      label: 'Output',
      type: canonicalType(FLOAT), // Default - actual type inferred during lowering
    },
  },

  lower: ({ ctx, inputsById, varargInputsById, config }) => {
    // Step 1: Extract expression text from config
    const exprText = (config?.expression as string | undefined) ?? '';

    // Step 2: Handle empty expression (output constant 0)
    if (exprText.trim() === '') {
      const sigId = ctx.b.constant(floatConst(0), canonicalType(FLOAT));
      const outType = ctx.outTypes[0];
      const slot = ctx.b.allocSlot();
      return {
        outputsById: {
          out: { id: sigId, slot, type: outType, stride: payloadStride(outType.payload) },
        },
      };
    }

    // Helper: Get actual type from ValueExpr using unified getValueExpr()
    const getExprType = (exprId: ValueExprId): CanonicalType => {
      const expr = ctx.b.getValueExpr(exprId);
      if (!expr) {
        throw new Error(`ValueExpr ${exprId} not found - this indicates a compiler bug`);
      }
      return expr.type;
    };

    // Step 3: Build unified input list
    // SHIM: Convert legacy inputs to synthetic vararg-style entries
    const allInputEntries: Array<{ alias: string; signal: ValueExprId }> = [];

    // Legacy inputs (in0, in1) become synthetic vararg entries
    for (const key of ['in0', 'in1'] as const) {
      const input = inputsById[key];
      const isSignal = input && 'type' in input && requireInst(input.type.extent.cardinality, 'cardinality').kind !== 'many';
      if (input && isSignal) {
        allInputEntries.push({ alias: key, signal: input.id });
      }
    }

    // Actual vararg refs - get alias from varargConnections metadata
    const refsValues = varargInputsById?.refs ?? [];
    const refsConnections = ctx.varargConnections?.get('refs') ?? [];
    for (let i = 0; i < refsValues.length; i++) {
      const value = refsValues[i];
      const conn = refsConnections[i];
      const isSignal = value && 'type' in value && requireInst(value.type.extent.cardinality, 'cardinality').kind !== 'many';
      if (value && isSignal && conn) {
        // Use alias if available, otherwise fall back to sourceAddress
        const alias = conn.alias ?? conn.sourceAddress;
        allInputEntries.push({ alias, signal: value.id });
      }
    }

    // Step 4: SINGLE PROCESSING LOOP - the ONE code path
    // Process ALL inputs (legacy via shim + actual varargs) identically
    const inputs = new Map<string, CanonicalType>();
    const inputSignals = new Map<string, ValueExprId>();

    for (const { alias, signal } of allInputEntries) {
      const inputType = getExprType(signal);
      inputs.set(alias, inputType);
      inputSignals.set(alias, signal);
    }

    // Step 5: Compile expression using Expression DSL
    const result = compileExpression(exprText, inputs, ctx.b, inputSignals);

    // Step 6 & 7: Handle compilation result
    if (!result.ok) {
      // Compilation failed - format error message
      const err = result.error;
      const positionInfo = err.position
        ? ` at position ${err.position.start}`
        : '';
      const suggestionInfo = err.suggestion
        ? `\nSuggestion: ${err.suggestion}`
        : '';

      throw new Error(
        `Expression ${err.code}: ${err.message}${positionInfo}${suggestionInfo}`
      );
    }

    // Compilation succeeded - return output signal
    const sigId = result.value;
    const outType = ctx.outTypes[0];
    const slot = ctx.b.allocSlot();

    return {
      outputsById: {
        out: { id: sigId, slot, type: outType, stride: payloadStride(outType.payload) },
      },
    };
  },
});
