/**
 * @DEPRECATED
 * Tests for Type System → IR Bridge Functions
 *
 * These tests verify that all canonical type system variants
 * map correctly to IR schema format (unwrapped axis values).
 */

import { describe, it, expect } from 'vitest';
import {
  bridgeExtentToAxesDescIR,
  bridgeCardinalityToIR,
  bridgeTemporalityToIR,
  bridgePerspectiveToIR,
  bridgeBranchToIR,
  bridgeBindingToIdentityIR,
  payloadTypeToShapeDescIR,
} from '../bridges';
import type {
  CardinalityValue,
  TemporalityValue,
  BindingValue,
  Extent,
  CanonicalType,
  PayloadType,
} from '../../../core/canonical-types';
import { axisInst } from '../../../core/canonical-types';
import {
  cardinalityOne,
  cardinalityMany,
  temporalityContinuous,
  temporalityDiscrete,
  testInstanceRef,
} from '../../../__tests__/type-test-helpers';
import {
  FLOAT,
  INT,
  VEC2,
  COLOR,
  BOOL,
  SHAPE,
} from '../../../core/canonical-types';
import { instanceId, domainTypeId } from '../../../core/ids';

// Type aliases for backward compat
type Cardinality = CardinalityValue;
type Temporality = TemporalityValue;
type Binding = BindingValue;

// =============================================================================
// Cardinality → Domain Axis
// =============================================================================

describe('bridgeCardinalityToIR', () => {
//   it('maps zero cardinality to "value" domain', () => {
//     const card: Cardinality = cardinalityZero();
//     expect(bridgeCardinalityToIR(card)).toBe('value');
//   });

  it('maps one cardinality to "signal" domain', () => {
    const card: Cardinality = cardinalityOne();
    expect(bridgeCardinalityToIR(card)).toBe('signal');
  });

  it('maps many cardinality to "field" domain', () => {
    const card: Cardinality = cardinalityMany(testInstanceRef(instanceId('particles'), domainTypeId('circle')));
    expect(bridgeCardinalityToIR(card)).toBe('field');
  });
});

// =============================================================================
// Temporality → Temporality Axis
// =============================================================================

describe('bridgeTemporalityToIR', () => {
  it('maps continuous temporality to "continuous"', () => {
    const temp: Temporality = temporalityContinuous();
    expect(bridgeTemporalityToIR(temp)).toBe('continuous');
  });

  it('maps discrete temporality to "discrete"', () => {
    const temp: Temporality = temporalityDiscrete();
    expect(bridgeTemporalityToIR(temp)).toBe('discrete');
  });
});

// =============================================================================
// Perspective → Perspective Axis
// =============================================================================

describe('bridgePerspectiveToIR', () => {
  it('maps global perspective to "global"', () => {
    expect(bridgePerspectiveToIR('global')).toBe('global');
  });

  it('maps frame perspective to "global" (v0 canonicalization)', () => {
    expect(bridgePerspectiveToIR('frame')).toBe('global');
  });

  it('maps sample perspective to "global" (v0 canonicalization)', () => {
    expect(bridgePerspectiveToIR('sample')).toBe('global');
  });
});

// =============================================================================
// Branch → Branch Axis
// =============================================================================

describe('bridgeBranchToIR', () => {
  it('maps main branch to "single" (v0 canonicalization)', () => {
    expect(bridgeBranchToIR('main')).toBe('single');
  });

  it('maps any branch to "single" (v0 canonicalization)', () => {
    expect(bridgeBranchToIR('branched')).toBe('single');
  });
});

// =============================================================================
// Binding → Identity Axis
// =============================================================================

describe('bridgeBindingToIdentityIR', () => {
//   it('maps unbound binding to identity.none', () => {
//     const binding: Binding = bindingUnbound();
//     const result = bridgeBindingToIdentityIR(binding);
//     expect(result).toEqual({ kind: 'none' });
//   });

//   it('maps identity binding to keyed entity', () => {
//     const binding: Binding = { kind: 'identity' };
//     const result = bridgeBindingToIdentityIR(binding);
//     expect(result).toEqual({
//       kind: 'keyed',
//       keySpace: 'entity',
//     });
//   });

//   it('maps weak binding to keyed custom', () => {
//     const binding: Binding = { kind: 'weak' };
//     const result = bridgeBindingToIdentityIR(binding);
//     expect(result).toEqual({
//       kind: 'keyed',
//       keySpace: 'custom',
//     });
//   });

//   it('maps strong binding to keyed custom', () => {
//     const binding: Binding = { kind: 'strong' };
//     const result = bridgeBindingToIdentityIR(binding);
//     expect(result).toEqual({
//       kind: 'keyed',
//       keySpace: 'custom',
//     });
//   });
});

// =============================================================================
// PayloadType → ShapeDescIR
// =============================================================================

describe('payloadTypeToShapeDescIR', () => {
  it('maps float to number shape', () => {
    expect(payloadTypeToShapeDescIR(FLOAT)).toEqual({ kind: 'number' });
  });

  it('maps int to number shape', () => {
    expect(payloadTypeToShapeDescIR(INT)).toEqual({ kind: 'number' });
  });

  it('maps shape to shape kind', () => {
    expect(payloadTypeToShapeDescIR(SHAPE)).toEqual({ kind: 'shape' });
  });

  it('maps bool to bool shape', () => {
    expect(payloadTypeToShapeDescIR(BOOL)).toEqual({ kind: 'bool' });
  });

  it('maps vec2 to vec shape with 2 lanes', () => {
    expect(payloadTypeToShapeDescIR(VEC2)).toEqual({
      kind: 'vec',
      lanes: 2,
      element: 'number',
    });
  });

//   it('maps color to vec shape with 4 lanes (RGBA)', () => {
//     expect(payloadTypeToShapeDescIR(COLOR)).toEqual({
//       kind: 'vec',
//       lanes: 4,
//       element: 'number',
//     });
  });
});

// =============================================================================
// Complete Extent → Unwrapped Values
// =============================================================================

describe('bridgeExtentToAxesDescIR', () => {
//   it('bridges signal extent (one + continuous)', () => {
//     const extent: Extent = {
//       cardinality: axisInst(cardinalityOne()),
//       temporality: axisInst(temporalityContinuous()),
//       binding: axisInst(bindingUnbound()),
//       perspective: axisInst({ kind: 'default' }),
//       branch: axisInst({ kind: 'default' }),
//     };
// 
//     const resolved = bridgeExtentToAxesDescIR(extent);
// 
//     expect(resolved.cardinality).toEqual({ kind: 'one' });
//     expect(resolved.temporality).toEqual({ kind: 'continuous' });
//     expect(resolved.binding).toEqual({ kind: 'unbound' });
//     expect(resolved.perspective).toBe('global');
//     expect(resolved.branch).toBe('main');
//   });

//   it('bridges field extent (many + continuous)', () => {
//     const extent: Extent = {
//       cardinality: axisInst(cardinalityMany(testInstanceRef(instanceId('particles'), domainTypeId('circle')))),
//       temporality: axisInst(temporalityContinuous()),
//       binding: axisInst(bindingUnbound()),
//       perspective: axisInst({ kind: 'default' }),
//       branch: axisInst({ kind: 'default' }),
//     };
// 
//     const resolved = bridgeExtentToAxesDescIR(extent);
// 
//     expect(resolved.cardinality).toEqual({
//       kind: 'many',
//       instance: { kind: 'instance', domainType: 'circle', instanceId: 'particles' },
//     });
    expect(resolved.temporality).toEqual({ kind: 'continuous' });
    expect(resolved.binding).toEqual({ kind: 'unbound' });
    expect(resolved.perspective).toBe('global');
    expect(resolved.branch).toBe('main');
  });

//   it('bridges event extent (one + discrete)', () => {
//     const extent: Extent = {
//       cardinality: axisInst(cardinalityOne()),
//       temporality: axisInst(temporalityDiscrete()),
//       binding: axisInst(bindingUnbound()),
//       perspective: axisInst({ kind: 'default' }),
//       branch: axisInst({ kind: 'default' }),
//     };
// 
//     const resolved = bridgeExtentToAxesDescIR(extent);
// 
//     expect(resolved.cardinality).toEqual({ kind: 'one' });
//     expect(resolved.temporality).toEqual({ kind: 'discrete' });
//     expect(resolved.binding).toEqual({ kind: 'unbound' });
//     expect(resolved.perspective).toBe('global');
//     expect(resolved.branch).toBe('main');
//   });

//   it('bridges value extent (zero + continuous)', () => {
//     const extent: Extent = {
//       cardinality: axisInst(cardinalityZero()),
//       temporality: axisInst(temporalityContinuous()),
//       binding: axisInst(bindingUnbound()),
//       perspective: axisInst({ kind: 'default' }),
//       branch: axisInst({ kind: 'default' }),
//     };
// 
//     const resolved = bridgeExtentToAxesDescIR(extent);
// 
//     expect(resolved.cardinality).toEqual({ kind: 'zero' });
//     expect(resolved.temporality).toEqual({ kind: 'continuous' });
//     expect(resolved.binding).toEqual({ kind: 'unbound' });
//     expect(resolved.perspective).toEqual({ kind: 'default' });
//     expect(resolved.branch).toEqual({ kind: 'default' });
//   });

//   it('preserves identity binding through bridging', () => {
//     const extent: Extent = {
//       cardinality: axisInst(cardinalityMany(testInstanceRef(instanceId('particles'), domainTypeId('circle')))),
//       temporality: axisInst(temporalityContinuous()),
//       binding: axisInst({ kind: 'identity' }),
//       perspective: axisInst({ kind: 'default' }),
//       branch: axisInst({ kind: 'default' }),
//     };
// 
//     const resolved = bridgeExtentToAxesDescIR(extent);
// 
//     // Per Decision D1: BindingValue has NO referent field
//     // Referents belong in continuity policies, NOT in type lattice
//     expect(resolved.binding).toEqual({ kind: 'identity' });
//   });
});

// =============================================================================
// Edge Cases and Combinations
// =============================================================================

describe('bridging edge cases', () => {
//   it('handles all cardinality × temporality combinations', () => {
//     const cardinalities: Cardinality[] = [
//       cardinalityZero(),
//       cardinalityOne(),
//       cardinalityMany(testInstanceRef(instanceId('test'), domainTypeId('circle'))),
//     ];
//     const temporalities: Temporality[] = [
//       temporalityContinuous(),
//       temporalityDiscrete(),
//     ];
// 
//     // All combinations should bridge without error
//     for (const card of cardinalities) {
//       for (const temp of temporalities) {
//         const extent: Extent = {
//           cardinality: axisInst(card),
//           temporality: axisInst(temp),
//           binding: axisInst(bindingUnbound()),
//           perspective: axisInst({ kind: 'default' }),
//           branch: axisInst({ kind: 'default' }),
//         };
// 
//         expect(() => bridgeExtentToAxesDescIR(extent)).not.toThrow();
//       }
//     }
//   });

  it('handles all payload types', () => {
    const payloads: PayloadType[] = [
      FLOAT,
      INT,
      VEC2,
      COLOR,
      BOOL,
      SHAPE,
    ];

    for (const payload of payloads) {
      expect(() => payloadTypeToShapeDescIR(payload)).not.toThrow();
    }
  });

  it('handles all binding variants', () => {
    const bindings: Binding[] = [
      bindingUnbound(),
      {kind: 'weak'},
      {kind: 'strong'},
      {kind: 'identity'},
    ];

    for (const binding of bindings) {
      expect(() => bridgeBindingToIdentityIR(binding)).not.toThrow();
    }
  });
});
