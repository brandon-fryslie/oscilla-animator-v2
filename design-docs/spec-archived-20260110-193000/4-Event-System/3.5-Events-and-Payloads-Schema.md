Below is the minimal, coherent set of EditorEvent additions that make a DiagnosticHub work cleanly without bloating EventHub or creating high-frequency spam. This is intentionally opinionated: one path, long-term sane.

⸻

Design principle

Diagnostics need three kinds of information sources:
	1.	Graph mutation boundaries (so validators know when to recompute)
	2.	Compiler results (so compile diagnostics are authoritative snapshots)
	3.	Throttled runtime health snapshots (so runtime diagnostics are updated without 60fps events)

Everything else can be derived or handled locally.

⸻

The minimal EditorEvent union (spec)

1) Graph mutation boundary event

GraphCommitted
Emitted exactly once after any user operation that changes the patch graph (blocks/buses/bindings/time root/composites), after the mutation is fully applied and undo state is committed.

Payload:
	•	patchId
	•	patchRevision (monotonic integer; increments on every committed graph edit)
	•	reason (enum; helps diagnostics + UX)
	•	userEdit | macroExpand | compositeSave | migration | import | undo | redo
	•	diffSummary (small, not the full diff)
	•	counts: blocksAdded/Removed, busesAdded/Removed, bindingsChanged, timeRootChanged? boolean
	•	optional lists: affectedBlockIds[], affectedBusIds[] (bounded, best effort)

Why this event exists:
It gives DiagnosticHub one stable “recompute point” without needing 20 different tiny events. You can still have other UI-specific events, but diagnostics only needs this boundary.

⸻

2) Compile lifecycle events

CompileStarted
Emitted when compilation begins for a specific graph revision.

Payload:
	•	compileId (UUID)
	•	patchId
	•	patchRevision (the revision being compiled)
	•	trigger:
	•	graphCommitted | manual | startup | hotReload

Diagnostic use: clears/marks “stale compile diagnostics” state for that revision, shows “compiling…” badges.

⸻

CompileFinished (single event, not success/fail split)
Emitted when compilation completes.

Payload:
	•	compileId
	•	patchId
	•	patchRevision
	•	status: ok | failed
	•	durationMs
	•	diagnostics: compile-snapshot diagnostics list (structured, typed)
	•	programMeta (only if ok; tiny metadata)
	•	timelineHint (finite/infinite + window)
	•	timeRootKind (CycleRoot / TransportRoot / AmbientRoot etc.)
	•	optional: busUsageSummary (counts by busId: publishers/listeners, empty buses)

Why a single event:
DiagnosticHub wants to “replace compile snapshot” regardless of success. A single event makes downstream logic simpler and prevents branching duplication.

⸻

3) Program swap event (important for no-jank + runtime diag)

ProgramSwapped
Emitted when the runtime actually begins using the new compiled program.

Payload:
	•	patchId
	•	patchRevision
	•	compileId
	•	swapMode:
	•	hard (immediate)
	•	soft (crossfade / state-bridge)
	•	deferred (applied on boundary: pulse/loop seam)
	•	swapLatencyMs (time between CompileFinished and swap)
	•	optional: stateBridgeUsed: boolean

Diagnostic use: runtime diagnostics should attach to the active program revision; this event marks that boundary.

⸻

4) Runtime health snapshot event (throttled)

RuntimeHealthSnapshot
Emitted at a fixed low frequency (e.g. 2–5 Hz), not per frame.

Payload:
	•	patchId
	•	activePatchRevision
	•	tMs (current runtime time, if meaningful)
	•	frameBudget:
	•	fpsEstimate
	•	avgFrameMs over last window
	•	optional: worstFrameMs
	•	evalStats (bounded summary)
	•	fieldMaterializations: count + worst offenders (top K with target ids)
	•	allocBytesEstimate (optional)
	•	nanCount / infCount (aggregate)
	•	diagnosticsDelta (optional but powerful)
	•	either: full runtime diagnostics snapshot (small) OR
	•	a delta list (raised/resolved ids)

Diagnostic use: update runtime diagnostic state without spamming EventHub.

⸻

Events you do not need for diagnostics
	•	Per-frame tick events
	•	Per-block “evaluated” events
	•	Per-bus “value changed” events

Those are for internal profiling tools, not the core event spine.

⸻

Recommended existing events to keep (for other UI), but diagnostics can ignore

You may already have or want:
	•	SelectionChanged
	•	HoverChanged
	•	ViewportChanged
These are UI-level and should not feed DiagnosticHub.

⸻

How DiagnosticHub uses these (contract)

DiagnosticHub is an EventHub subscriber with exactly this logic:
	1.	On GraphCommitted:
	•	run fast authoring validators against the new graph revision
	•	update authoring diagnostics snapshot keyed by patchRevision
	2.	On CompileStarted:
	•	mark compile diagnostics for that revision as “pending”
	•	optionally surface “stale compile snapshot” warnings
	3.	On CompileFinished:
	•	replace compile diagnostics snapshot for that patchRevision with payload list
	4.	On ProgramSwapped:
	•	set “active revision” pointer
	•	move runtime diagnostics attachment to the active revision
	5.	On RuntimeHealthSnapshot:
	•	update runtime diagnostics (dedupe/expire) and perf warnings
	•	never blocks; never emits more events except maybe a debounced DiagnosticsChanged

⸻

Why this is minimal and future-proof
	•	Only 5 events are required for a complete diagnostic system.
	•	They are low frequency and semantically strong.
	•	They align with your no-async EventHub rule.
	•	They are stable under:
	•	server-authoritative runtime
	•	multi-client editing
	•	future WASM runtime components
	•	richer time roots and export constraints
