# Default Sources Insertion in Final Normalization Fixpoint
Version: defaultSources.v1
Scope: compiler frontend normalization only

IMPORTANT: This specification is illustrative in detail, but authoritative in concept.
Code examples, file paths, and types may need minor adjustments to conform to our project.  
Do NOT duplicate functionality in parallel systems.

DATAFLOW, NOT CONTROL FLOW
All phases execute every iteration in the same order. Variability is represented as data:
- obligations may or may not exist
- obligations may or may not have satisfied deps
- plans may be empty
  No phase is skipped via control flow guards; phases consume empty collections.

---

## 0. Purpose

Default source insertion fills unconnected input ports with deterministic implicit producers so that:
- every required input has a source
- default behavior is stable and reproducible
- the insertion is type-dependent (payload, unit, extent including cardinality)
- insertion happens inside the fixpoint loop (Solve -> Derive -> Plan -> Apply) so that inserted blocks participate in later solving and later elaboration.

Default sources are inserted ONLY by discharging `missingInputSource` obligations.

---

## 1. Non-negotiable invariants (Concrete)

1. CanonicalType is never partial
    - Default source planning requires `PortTypeHint.status === 'ok'` for the target port.
2. InferenceCanonicalType is the only var-bearing type
    - Default source policy reads CanonicalType only (from TypeFacts).
3. Solve is pure
    - Default source insertion never runs during Solve. It is planned and applied as elaboration.
4. Elaboration is monotone
    - A discharge adds blocks/edges or rewires an edge. It does not delete user blocks.
5. Convergence on graph structure
    - The fixpoint stops when no plans apply (plans.length == 0), not when facts stabilize.
6. Stable IDs deterministic
    - Block/edge IDs created by default sources are deterministic functions of the obligation ID.

Note: these invariants are not up for discussion and MUST be followed to avoid significant additional costs/problems.

---

## 2. Data model dependencies

This spec assumes the following already exist (from the normalization engine spec):

### 2.1 DraftGraph

- `DraftGraph { blocks: DraftBlock[], edges: DraftEdge[], obligations: Obligation[], meta: DraftGraphMeta }`
- `DraftEdge { id, from: PortRef, to: PortRef, role: EdgeRole, origin: EdgeOrigin }`
- `EdgeRole` includes: `userWire`, `defaultWire`, `internalHelper`, `implicitCoerce`
- `EdgeOrigin` includes: `user`, `compositeInternal`, `{ kind:'elaboration', obligationId, role }`
- `DraftBlock.origin` includes `{ kind:'elaboration', obligationId, role }`

### 2.2 TypeFacts

- `PortTypeHint { status:'ok'|'unknown'|'conflict', canonical?: CanonicalType, inference?: InferenceCanonicalType, diagIds }`
- `TypeFacts.ports: Map<PortKey, PortTypeHint>`
- `PortKey` is derived deterministically from `(PortRef)`.

### 2.3 Obligations

- `MissingInputSourceObligation`:
    - `kind: 'missingInputSource'`
    - `anchor: { port: PortRef, blockId }`
    - `deps: FactDependency[]`
    - `policy: { name:'defaultSources.v1', version:1 }`
    - `status: open|discharged|blocked`

### 2.4 Policy interface

- `PolicyContext { graph, registry, facts, getHint(port): PortTypeHint }`
- `PolicyResult = { kind:'plan', plan: ElaborationPlan } | { kind:'blocked', reason, diagIds }`

### 2.5 ElaborationPlan and application

- `ElaborationPlan` supports:
    - `obligationId`
    - `role: 'defaultSource'`
    - `addBlocks: DraftBlock[]`
    - `addEdges: DraftEdge[]`
    - `replaceEdges: { remove: EdgeId, add: DraftEdge[] }[]`
- `applyElaborationPlan(graph, plan)`:
    - adds blocks/edges with proper origin
    - performs replaceEdges deterministically
    - is idempotent: applying same plan again is no-op

---

## 3. Obligation creation

### 3.1 When created

`buildDraftGraph(patch)` creates a `missingInputSource` obligation for each unconnected input port that is eligible for defaulting.

Eligibility rule:
- Port direction must be input.
- Port must be present in the block definition inputs.
- Port must not already have an incoming edge in DraftGraph after composite expansion and lens expansion.
- Port must not be explicitly marked "required with no default" by metadata (see 3.3).

### 3.2 Deterministic obligation IDs (example)

Obligation ID is a pure function of semantic target:
- `missingInput:${blockId}:${portName}`

This is stable across graph edits that do not change the semantic identity of the target hole.

### 3.3 Ports that must never get defaults (example)

Add a required, unconditional metadata hook to BlockDef/InputDef:
- `InputDef.defaulting: 'allowed' | 'forbidden'`

Rules:
- If `defaulting === 'forbidden'`, DO NOT create a missingInputSource obligation.
- Instead, create a frontend diagnostic immediately during `buildDraftGraph`:
    - `MissingRequiredInput { blockId, portName }`
      This keeps variability in values, not in phase ordering.

---

## 4. Dependency model for missingInputSource

### 4.1 Dependencies

A missing input source can only be planned when the target port is canonicalized.

Set deps to exactly:
- `{ kind:'portCanonicalizable', port: targetPortRef }`

No other deps exist. The canonicalizable predicate implies payload/unit/axes resolution.

### 4.2 Status semantics

- `open` means "not yet discharged, waiting for deps or planning"
- `blocked` means "permanently unsupported by policy" (not "waiting")

No other meanings exist.

---

## 5. Default source policy

### 5.1 File and export

**File:** `src/compiler/frontend/policies/default-source-policy.ts`

Export:
- `DEFAULT_SOURCE_POLICY_V1: DefaultSourcePolicy`

Where:
- `name === 'defaultSources.v1'`
- `version === 1`

### 5.2 Required planning behavior

`plan(obligation, ctx)` always executes the same steps in the same order.

Inputs:
- the `MissingInputSourceObligation`
- `PolicyContext` with access to `graph`, `registry`, and `facts`

Outputs:
- `PolicyResult.kind === 'plan'` with an ElaborationPlan
- OR `PolicyResult.kind === 'blocked'` with diagnostics

No other output.

### 5.3 Planning steps

Steps (always executed; decisions encoded as data):
1. Read the anchor port `p = obligation.anchor.port`.
2. Read `hint = ctx.getHint(p)`.
3. If `hint.status !== 'ok'`, return:
    - `{ kind:'blocked', reason:'missing facts', diagIds:[...] }`
      This is a permanent block ONLY if the engine guarantees the port can never become ok.
      In this engine, ports can become ok in later iterations, so this MUST NOT be blocked.
      Therefore:
    - The policy returns a sentinel "not ready" as a blocked is forbidden.
      Replace with:
    - `PolicyResult` is still only plan|blocked, so we encode "not ready" as:
        - `{ kind:'blocked', reason:'waiting', diagIds:[] }`
          And the discharge planner MUST treat `reason:'waiting'` as "remain open".
          (This preserves the PolicyResult shape and keeps the engine data-driven.)

4. Extract `targetType = hint.canonical`.
5. Determine the default source strategy using the registry and port metadata:
    - `strategy = resolveDefaultStrategy(blockId, portName, targetType, registry)`
6. Produce a deterministic ElaborationPlan according to the chosen strategy.
7. Return `{ kind:'plan', plan }`.

### 5.4 Strategy resolution (resolveDefaultStrategy)

Resolution order (strict):
1. Input-level override on the block definition:
    - `InputDef.defaultSourceSpec` if present
2. Domain-wide registry default for payload/unit/extent category:
    - registry lookup keyed by canonical type shape
3. Fallback polymorphic DefaultSource block:
    - emits a value of the requested CanonicalType

If none exist, return "unsupported":
- policy returns `{ kind:'blocked', reason:'unsupported default source', diagIds:[...] }`
- obligation becomes permanently blocked with that reason.

---

## 6. Elaboration plan construction

### 6.1 Deterministic IDs Example

Derived IDs are functions of `obligation.id`:
- Default source block id: `__ds__${obligationId}`
- Edge id from DS to target: `__ds_edge__${obligationId}`

If TimeRoot uses existing singleton, no DS block is created and edge id is:
- `__ds_edge__${obligationId}`

These strings are ASCII and stable.

### 6.2 Graph mutation shape

Case A: Block-based default
- Add one block `b`:
    - `DraftBlock.id = __ds__${obligationId}`
    - `DraftBlock.type = chosen default block type`
    - `DraftBlock.params = params derived from strategy and targetType`
    - `origin = { kind:'elaboration', obligationId, role:'defaultSource' }`
- Add one edge `e`:
    - `from = { blockId: b.id, port: 'out' (or mapped), dir:'out' }`
    - `to = target port`
    - `role = 'defaultWire'`
    - `origin = { kind:'elaboration', obligationId, role:'defaultSource' }`

Case B: Existing-source default (TimeRoot)
- Add no blocks (unless singleton absent)
- Add one edge as above.

### 6.3 No rewiring required

Default source obligations only occur when the target input has no incoming edge, so plans do not use replaceEdges.

If the graph has an incoming edge anyway (corrupt state), the plan returns blocked with diagnostic `UnexpectedConnectedInput`.

---

## 7. Integration into fixpoint loop

Default sources insertion is implemented in the "Plan Discharge" phase and the "Apply" phase.

### 7.1 Plan Discharge phase

The phase processes obligations in stable sorted order.

For each obligation `o`:
1. If `o.status.kind !== 'open'`, continue.
2. If `o.kind !== 'missingInputSource'`, continue.
3. Evaluate deps:
    - `depsSatisfied = allDepsSatisfied(o.deps, facts)`
4. If deps not satisfied:
    - do not plan
    - obligation stays open
5. If deps satisfied:
    - call `DEFAULT_SOURCE_POLICY_V1.plan(o, ctx)`
    - If result is `{ kind:'plan' }`, append plan
    - If result is `{ kind:'blocked', reason:'waiting' }`, keep open (do not change status)
    - Else blocked unsupported: mark obligation blocked

The output of Plan Discharge is `plans[]`.

### 7.2 Apply phase

Apply phase takes `plans[]` in stable order (by obligationId) and applies each plan:
- `g = applyElaborationPlan(g, plan)`
- update obligation status to discharged with `ElaboratedArtifactRefs` returned by apply

Because apply is monotone, revisions strictly increase if any plan applied.

---

## 8. Convergence guarantees

Default sources elaboration satisfies monotonicity and structural convergence:

- Each `missingInputSource` obligation can discharge at most once.
- The number of eligible unconnected inputs is finite.
- Therefore the number of default-source plans is finite.
- Therefore default source insertion cannot cause infinite elaboration.

Fixpoint termination:
- The engine stops when no plans apply (plans.length == 0).
- Default sources contribute to plans only when their deps are satisfied.
- Once discharged, the obligation is no longer eligible.

---

## 9. Diagnostics

### 9.1 Diagnostic IDs and shapes

Diagnostics are stable, deterministic, and refer to stable graph ids and obligation ids.

Minimum required diagnostics for default sources (example):
- `MissingRequiredInput { blockId, portName }` (buildDraftGraph time)
- `DefaultSourceUnsupported { obligationId, blockId, portName, targetTypeSummary }`
- `MultipleTimeRoots { obligationId, count, blockIds[] }`
- `UnexpectedConnectedInput { obligationId, edgeIds[] }`

Diagnostics are stored in the frontend result and optionally in trace.

---

## 10. Test requirements

### 10.1 Unit tests: policy

Example tests:
1. Not ready:
    - Port hint status unknown -> policy returns blocked waiting (and planner keeps open)
2. Const strategy:
    - Given InputDef.defaultSourceSpec const, plan adds block+edge with deterministic ids
3. Block strategy:
    - Plan uses blockType+params and correct origin/role
4. TimeRoot:
    - No existing TimeRoot -> creates singleton and connects
    - Existing one -> connects without adding a DS block
    - Multiple -> returns blocked unsupported
5. Unsupported:
    - No spec + no registry default + no polymorphic fallback -> blocked unsupported

### 10.2 Integration tests: fixpoint

Example tests:
1. Missing input obligation created for each eligible unconnected input
2. When type becomes ok, default source is inserted and obligation discharged
3. Re-run normalization on result produces no additional changes (idempotent)
4. Strict finalization only succeeds when no open obligations remain

### 10.3 Snapshot dumps on failure

All tests must use the normalization test harness so failures print:
- final graph pretty print
- facts pretty print
- obligations table
- trace last frame

---

## 11. Required debug tooling hooks

Default source planning and application must emit trace events when trace enabled:
- `PlanDefaultSource { obligationId, targetPortKey, strategyKind }`
- `ApplyDefaultSource { obligationId, addedBlocks, addedEdges }`

Trace is a value produced by the run, not a side effect.

---

## 12. Implementation checklist (example)

1. Add `InputDef.defaulting` and `InputDef.defaultSourceSpec` (explicit nulls).
2. Implement obligation creation in `buildDraftGraph`.
3. Implement `default-source-policy.ts`.
4. Integrate planning and discharge semantics in fixpoint loop.
5. Ensure apply is idempotent and deterministic.
6. Add diagnostics and tests.

End.