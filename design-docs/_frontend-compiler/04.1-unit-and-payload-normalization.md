Spec: Payload + Unit Unification for Final Normalization Fixpoint

Purpose

Implement payload and unit solving as a pure, deterministic unification system inside the final-normalization fixpoint engine, producing substitutions that (a) resolve all inference vars, and (b) expose incorrect or legacy-“worked” port typings (eg accidental float-scalar lock-in) as either diagnostics or forced refactors. This spec explicitly directs implementation agents to correct bad static types when discovered rather than encoding workarounds.

Definitions

Payload

The data shape/kind carried by a value (eg float, vec2, vec3, color, path, shapeHandle, etc). Payloads may include nominal domain-ish payloads.

Unit

A measurement/semantic unit layer (eg scalar, px, deg, ms, unitless, etc). Units unify independently from payloads but are coupled via contracts and default sources.

InferenceCanonicalType

The only var-bearing type representation. CanonicalType must never contain vars.

Assume existing core types:
•	InferenceCanonicalType = { payload: InferencePayloadType, unit: InferenceUnitType, extent: Extent, contract? }
•	InferencePayloadType is either {kind:'inst', payload: PayloadTypeId} or {kind:'var', id: PayloadVarId}
•	InferenceUnitType is either {kind:'inst', unit: UnitTypeId} or {kind:'var', id: UnitVarId}
•	Substitution includes payloads, units maps (and axis maps separately).

Architectural invariants
1.	Pure solve: solvePayloadUnit(graph, constraints, registry) -> { subst, errors } has no side effects and depends only on inputs.
2.	No CanonicalType until strict finalization: solver outputs substitutions and inference refinements only.
3.	Edges impose equality: any edge implies payload equality + unit equality (unless an adapter exists on that edge).
4.	BlockDefs are not law: if a block’s declared port payload/unit is wrong relative to actual behavior, the solver must not contort to fit it; instead it must surface diagnostics and push refactors.
5.	Deterministic outcomes: stable iteration order, stable var IDs, stable constraint keys.
6.	Unknowns must be vars: do not encode “default float/scalar” as inst(float) unless it is truly fixed; represent unknown as var.

What “wrong types” means and how to handle it

Common failure modes
•	Ports declared as float because it “worked” historically, but behavior is vector-preserving (should be generic).
•	Ports declared scalar unit, but actually preserve units (should be generic).
•	Blocks that should be polymorphic but are accidentally monomorphic due to outdated port typing.

Required policy

When implementing constraints and seeing conflicts/unexpected monomorphism:
•	Prefer making ports polymorphic (vars + constraints) over adding adapters or coercions.
•	Prefer unit-preserving (unit vars) over unitless scalars unless the operation is dimensioned (eg sin requires unitless input).
•	Emit diagnostics that point to the BlockDef as the likely defect (“port type too specific”) when a conflict can be resolved by generalizing.
•	Add a “type audit” work item whenever a new conflict points at a block definition mismatch.

This is enforced mechanically by the constraint extraction rules below.

Scope and responsibilities

Payload/unit unification consists of:
1.	Port base inference types: for every port, create an InferenceCanonicalType that is either fully instantiated or contains vars where polymorphism is intended.
2.	Constraint extraction: derive a set of payload/unit constraints from:
•	edges (equality),
•	block internal rules,
•	port contracts (unitless requirements, etc),
•	domain metadata (if any).
3.	Solving: unify vars with insts/vars; detect conflicts; produce substitutions.
4.	Facts production: compute per-port hints: ok/unknown/conflict + canonicalizable check.
5.	Refactor encouragement: diagnostics classify “likely BlockDef too specific” vs “real user patch type error”.

Data model for constraints

Create in src/compiler/frontend/payload-unit/constraints.ts (or fold into existing extract-constraints module):

type PUVar =
| { kind: 'payloadVar'; id: PayloadVarId }
| { kind: 'unitVar'; id: UnitVarId };

type PayloadTerm =
| { kind: 'inst'; payload: PayloadTypeId }
| { kind: 'var'; id: PayloadVarId };

type UnitTerm =
| { kind: 'inst'; unit: UnitTypeId }
| { kind: 'var'; id: UnitVarId };

type PUEqConstraint =
| { kind: 'payloadEq'; a: PayloadTerm; b: PayloadTerm; origin: ConstraintOrigin }
| { kind: 'unitEq'; a: UnitTerm; b: UnitTerm; origin: ConstraintOrigin };

type PURequireConstraint =
| { kind: 'requireUnitless'; term: UnitTerm; origin: ConstraintOrigin }
| { kind: 'requirePayloadIn'; term: PayloadTerm; allowed: readonly PayloadTypeId[]; origin: ConstraintOrigin };

type PUConstraint = PUEqConstraint | PURequireConstraint;

type ConstraintOrigin =
| { kind: 'edge'; edgeId: EdgeId }
| { kind: 'block'; blockId: BlockId; rule: string }
| { kind: 'portDef'; blockType: string; port: PortName; dir: PortDir }
| { kind: 'defaultSource'; obligationId: ObligationId }
| { kind: 'adapter'; obligationId: ObligationId };

All constraints must be stably sortable by a deterministic key derived from origin.

Port base type construction (critical)

Rule: base types come from BlockDef, but are “de-monomorphized” where appropriate

When building port base InferenceCanonicalType from the registry’s BlockDef, apply the following normalization:

1) Explicit inst stays inst
   If the block definition explicitly requires a concrete payload or unit (eg timeMs is float+ms), keep it inst.

2) Any “generic pass-through” port MUST be var
   If a port is intended to pass data through (identity-like), it must be var, not float. This includes:
   •	many math ops that preserve payload shape (component-wise ops),
   •	adapters you intend to insert later,
   •	delay blocks (UnitDelay) should preserve payload/unit.

Mechanism: require block defs to declare whether a port is “polymorphic” vs fixed.

Add (or use existing) metadata to BlockDef ports:

interface PortTypeTemplate {
payload: PayloadTemplate; // inst or var template
unit: UnitTemplate;       // inst or var template
}

type PayloadTemplate =
| { kind:'inst'; payload: PayloadTypeId }
| { kind:'var'; name: string }         // local var name scoped to block instance
| { kind:'anyScalar' }                 // sugar expands to var + allowed set
| { kind:'anyVectorOrScalar' }         // sugar expands to var + allowed set

type UnitTemplate =
| { kind:'inst'; unit: UnitTypeId }
| { kind:'var'; name: string }
| { kind:'preserve' }                  // sugar for var with equality constraints
| { kind:'unitless' };                 // shorthand for inst(unitless)

Agents implementing this must update incorrect blocks by changing their templates rather than adding solver hacks.

3) Unit default must be var unless dimension is required
   If a unit is not dimensionally constrained by the operation, it should be a var (preserve). Examples:
   •	Add/Subtract: same unit in/out, unit var U with equalities.
   •	Multiply: units combine (if you model that), otherwise require unitless or preserve? If you do not support unit algebra yet, constrain multiply/divide inputs to unitless to avoid nonsense.
   •	Trig (sin, cos): require unitless input and unitless output.

If unit algebra is not implemented, do not fake it; use requireUnitless constraints for ops that would otherwise be ambiguous.

Stable var IDs

All payload/unit vars must be deterministically derived.

For per-port vars:

payloadVarId(`p:${blockId}:${port}:${dir}`)
unitVarId(`u:${blockId}:${port}:${dir}`)

For block-local shared vars (template var name shared across ports):

payloadVarId(`p:${blockId}:T:${templateName}`)
unitVarId(`u:${blockId}:U:${templateName}`)

Do not use incremental counters.

Constraint extraction rules

Implement in src/compiler/frontend/extract-constraints.ts or payload-unit/extract.ts.

A) Edge equality constraints

For each DraftEdge e that is not an adapter edge (ie origin.role !== 'adapter'), emit:
•	payloadEq(payloadTerm(fromPort), payloadTerm(toPort), origin=edge(e.id))
•	unitEq(unitTerm(fromPort), unitTerm(toPort), origin=edge(e.id))

This is the default. If you later allow implicit coercions without adapter blocks, those become explicit constraint kinds and must be tied to a declared policy; do not silently coerce.

B) Block internal constraints (port relations)

Each block type defines a small set of internal rules in its registry entry. These rules generate constraints between its own port terms and inst requirements.

Examples (illustrative patterns):

1) Identity / pass-through
   out payload/unit equal to in:
   •	payloadEq(out, in)
   •	unitEq(out, in)

2) Binary component-wise op (Add/Sub)
   •	payloadEq(out, a)
   •	payloadEq(out, b)
   •	unitEq(a, b)
   •	unitEq(out, a)

This enforces same payload shape and same unit.

3) ScaleBias (float scale/bias applied to vector)
   If scale/bias are scalar floats and input may be vector:
   •	payloadEq(out, in)
   •	unitEq(out, in)
   •	requirePayloadIn(scale, [float])
   •	requirePayloadIn(bias, [float])
   •	unitEq(scale, unitless) (or preserve? pick one policy and stick to it)
   •	unitEq(bias, unitless)

If you want scale/bias to preserve units, then bias must share unit with input and scale must be unitless. Do not keep “scalar” as a unit.

4) Expression block
   If expression supports multiple payloads: its varargs inputs should have payload vars with allowed-set constraints (not float locks). Units: default requireUnitless for trig, otherwise preserve if you support it; if you can’t infer unit from expression, requireUnitless for safety.

C) Allowed-set constraints (sugar)

For templates like anyVectorOrScalar, generate:
•	a payload var, plus requirePayloadIn(var, allowedSet).

Do not expand allowed sets in the solver; treat them as constraints checked against the final representative.

D) Default sources and adapters
•	Default source policy must produce a source whose payload/unit matches the sink port constraints; it should not “pick float/scalar” just because.
•	Adapters are explicit blocks; their port types are part of normal block constraint generation. The presence of the adapter edge means the original edge equality is already satisfied structurally via intermediate ports.

Solver algorithm (payload + unit)

Implement in src/compiler/frontend/payload-unit/solve.ts as a pure function.

Input
•	portBaseTypes: Map<DraftPortKey, InferenceCanonicalType>
•	constraints: PUConstraint[]

Output

interface PayloadUnitSolveResult {
payloads: ReadonlyMap<PayloadVarId, PayloadTypeId>;
units: ReadonlyMap<UnitVarId, UnitTypeId>;
errors: readonly PUSolveError[];
}

Core unification model

Use union-find separately for payload and unit:
•	PayloadUF nodes represent either a payload var or a payload inst.
•	UnitUF nodes represent either a unit var or a unit inst.

Track per UF component:
•	inst if fixed to an inst
•	list of requirePayloadIn allowed sets (intersect)
•	list of requireUnitless constraints (a special allowed set)

Payload constraints
•	payloadEq(a,b): union their reps.
•	requirePayloadIn(term, allowed): attach allowed set to rep (intersection).
•	Conflict if:
•	rep has inst not in allowed set, OR
•	intersection becomes empty, OR
•	two different insts forced into same rep.

Unit constraints
•	unitEq(a,b): union.
•	requireUnitless(term): attach “mustBeUnitless” to rep.
•	Conflict if:
•	rep inst != unitless, OR
•	unitless requirement + non-unitless inst, OR
•	two different insts forced.

Substitution extraction

For each var ID encountered:
•	find its rep.
•	if rep has inst, bind var -> inst.
•	else leave unresolved (no entry in substitution map).

Unresolved is not necessarily an error until strict finalization; it yields unknown in TypeFacts.

Diagnostics classification (refactor encouragement)

Every error must be classified as one of:
•	UserPatchTypeError: likely user wired incompatible types.
•	BlockDefTooSpecific: likely BlockDef incorrectly monomorphized.
•	MissingAdapterPolicy: mismatch could be resolvable by adapter but policy can’t plan it.

Classification heuristic (deterministic, no guessing):
•	If conflict origin includes a portDef for a block type where the port template was inst(float) or inst(scalar) but internal rules require equality across more general payloads, label BlockDefTooSpecific.
•	If conflict comes from edge constraints between two ports with different concrete insts and neither is a var, label UserPatchTypeError.
•	If one side is var with allowed set that excludes the other, and the allowed set came from portDef rather than user structure, label BlockDefTooSpecific.

Agents must treat BlockDefTooSpecific as a trigger to change port templates to vars and tighten via constraints, not to add implicit coercions.

TypeFacts integration (how results flow)

In final-normalization.ts solve step:
1.	Build base inference type per port (with vars per the normalized templates).
2.	Extract PU constraints.
3.	Solve -> payloads, units.
4.	Extend global Substitution with these maps.
5.	For each port, compute hint:
•	Apply partial substitution to its inference type.
•	If isInferenceCanonicalizable(inf, subst) => ok with canonical.
•	Else unknown with partially substituted inference.
•	If conflicts => conflict.

Strict finalization requires no unresolved vars in payload/unit/axes for required ports.

“Normalization” of legacy float/scalar ports (how agents should fix)

This is an explicit deliverable, not optional.

Required agent workflow during implementation

Whenever an agent encounters a port whose template is a concrete float or unit scalar but:
•	The block’s IR lowering is component-wise / pass-through / swizzle-capable, OR
•	The UI/DSL already supports vec2/vec3/color for that block, OR
•	The solver repeatedly creates conflicts that would disappear if it were generic,

Then the agent must:
1.	Change the BlockDef port template to a block-local var ({kind:'var', name:'T'} / {kind:'var', name:'U'}), and
2.	Add the minimal correct constraints (allowed set if needed), and
3.	Add/adjust tests that assert the block accepts vecN and color where appropriate.

No silent coercions. No “float scaler” unit. Fix the definition.

Canonical “scalar unit” removal rule

If you have a “scalar” unit value in the unit system:
•	It must not be used as a default for general numeric values.
•	Replace with unitless or with a unit var depending on operation.

If “scalar” is actually a payload concept, move it there; do not keep semantic duplication.

Tests (minimum)

Create src/compiler/frontend/payload-unit/__tests__/solve.test.ts plus integration tests.

Solver unit tests
1.	payloadEq(var, inst(float)) binds var to float.
2.	Two inst payloads unify => conflict.
3.	Allowed-set intersection empties => conflict.
4.	requireUnitless(var) binds var to unitless when later unified.
5.	Unit conflict: unitless required but inst is ms.

Integration tests targeting legacy wrong-typing
6.	A block previously typed float should accept vec3 after template fix (edge equality + internal constraints).
7.	Expression varargs accept color/vec2 without forcing float.
8.	No unit “scalar” appears in any canonicalized type for a patch (grep test).

Deliverables summary
1.	Payload/unit templates on ports that correctly represent polymorphism (vars), not legacy float/scalar locks.
2.	Constraint extraction producing edge equalities + block internal constraints + allowed-set/unitless requirements.
3.	Pure union-find solver returning substitutions.
4.	Diagnostics that explicitly flag BlockDef defects as first-class problems.
5.	Tests demonstrating that wrong legacy types were corrected (not worked around).