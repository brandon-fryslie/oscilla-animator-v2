Frontend normalization passes (final pipeline order)
1.	Composite expansion
      •	Expand composite blocks into internal blocks/edges.
      •	Preserve stable IDs and origin metadata.
2.	Lens expansion
      •	Rewrite user-authored lens constructs into explicit blocks/edges (purely structural).
      •	Must run before any constraint extraction so Solve sees the real graph.
3.	Build DraftGraph
      •	Convert expanded Patch -> DraftGraph (blocks, edges, origins, stable ordering).
      •	Create initial obligations:
      •	missingInputSource for every unconnected input.
4.	Fixpoint loop
      •	Repeat until no plans are produced (or max iterations):
      4.1 Extract constraints
      •	From current DraftGraph, derive constraints for:
      •	payload
      •	unit
      •	cardinality (including zip groups, clampOne/forceMany, edge equalities)
      •	any other axes you’re actually solving now
      4.2 Solve types
      •	Pure solvers return substitutions (no graph mutation):
      •	payload/unit substitution
      •	cardinality substitution (+ instances if used)
      •	(later: temporality/binding/etc)
      4.3 Compute TypeFacts
      •	For each port, produce ok | unknown | conflict with inference/canonical where possible.
      4.4 Derive obligations (type-dependent)
      •	Create obligations that require solved facts, e.g.:
      •	needsAdapter for edges whose endpoints are canonicalizable and mismatched
      •	(later) needsLaneAlignment, needsDomainElaboration, needsVarargMaterialization
      •	Add-if-missing (deterministic IDs) so the set is stable across iterations.
      4.5 Plan discharge
      •	For each open obligation (sorted by ID), if deps satisfied:
      •	DefaultSourcePolicy -> plans default sources
      •	AdapterPolicy -> plans adapter insertion
      •	(later) LaneAlignmentPolicy / DomainElaborationPolicy / VarargPolicy
      •	Obligations waiting on deps remain open; truly unsupported become blocked.
      4.6 Apply plans
      •	Apply ElaborationPlans (add/replace edges, add blocks), bump graph revision.
      •	Stop fixpoint when plans.length === 0.
5.	Varargs validation/materialization
      •	Validate vararg wiring rules on the finalized DraftGraph.
      •	If you do vararg expansion/materialization, it belongs here (or as an obligation + policy inside the loop).
6.	Block indexing
      •	Produce any index maps the backend lowering expects (toposort groups, port lookup tables, etc).
7.	Strict finalization
      •	If no open obligations and all required ports are TypeFacts.status === 'ok':
      •	finalize inference -> CanonicalType (the only boundary)
      •	produce StrictTypedGraph/StrictTypedPatch product
      •	Otherwise: strict product is null + diagnostics.
8.	Axis validation
      •	Enforce “no var axes leak past strict,” cardinality invariants, domain invariants, etc.
9.	Cycle classification
      •	Analyze cycles for scheduling/runtime rules.
10.	TypedPatch / FrontendCompileResult build

	•	Bridge final graph + canonical port types into the exact structures the backend and UI consume.
	•	Store TypeFacts + obligations for debugging surfaces.

That is the order.

---

03.Spec: Automatic Cycle Breaking via Derived UnitDelay Insertion (Fixpoint Normalization)

Goal

When the user creates an algebraic (same-frame) directed cycle in the patch graph, the frontend must automatically elaborate the graph by inserting a stateful delay block (e.g. UnitDelay) to convert the cycle into a well-defined feedback loop.

This must integrate with the existing final-normalization fixpoint engine:

Solve (pure) -> Derive obligations (pure) -> Plan discharge (pure) -> Apply plans (monotone)
Stop when Apply produces no plans

Non-negotiable invariants
1.	No partial CanonicalType: cycle breaking must not require CanonicalType; it can depend on TypeFacts but must not force canonicalization.
2.	Pure detection: cycle detection and obligation creation are pure functions of (DraftGraph, TypeFacts?).
3.	Monotone elaboration: cycle-break discharge only adds blocks and rewires edges; it never removes user blocks.
4.	Deterministic: same input graph produces identical inserted blocks/edges and IDs.
5.	Idempotent: once a cycle is broken, re-running derive+plan produces no new cycle-break obligations for that same cycle.
6.	Respect explicit state: cycles that are already broken by an explicit user-inserted delay/state block are not “fixed again.”

What counts as a “cycle” that needs fixing

We only care about algebraic cycles: cycles in the same-frame dependency graph.

Same-frame dependency graph definition

Build a directed graph over ports / blocks representing dependencies that occur within the same evaluation tick (frame). An edge A -> B exists if B’s value in the current frame depends on A’s value in the current frame.

Crucial rule: stateful delays break same-frame dependency. For a delay block, the output depends on previous frame input, so it does not contribute a same-frame dependency edge from its input to output.

Required metadata (BlockDef)

Add (or reuse if you already have an equivalent) a minimal timing contract on each block type:

interface BlockTimingSpec {
// True if the block has persistent state across frames.
stateful: boolean;

// Which outputs are guaranteed to be "delayed" (depend on previous-frame state / previous-frame input),
// and therefore break same-frame cycles.
delayedOutputs?: PortName[];

// Optional: conservative fallback. If omitted:
// - stateful=false => no delayed outputs
// - stateful=true  => delayedOutputs must be provided explicitly (do not guess)
}

Examples:
•	UnitDelay: stateful=true, delayedOutputs=['out']
•	Lag (if it uses prior state and current input in same frame): stateful=true, delayedOutputs=[] (it does NOT necessarily break cycles unless an output is actually delayed)
•	Pure math blocks: stateful=false

This metadata is only for cycle detection; it does not replace IR semantics.

New obligation kind

Add to ObligationKind:
•	needsCycleBreak

Concrete obligation:

interface NeedsCycleBreakObligation extends ObligationBase {
kind: 'needsCycleBreak';
anchor: { edgeId: EdgeId; sccId: string }; // edge to cut + SCC identity
deps: []; // purely structural by default
policy: { name: 'cycleBreak.v1'; version: 1 };
}

Obligation ID (deterministic)

Use a semantic ID that is stable across edge renumbering:

needsCycleBreak:${sccId}:${fromBlockId}:${fromPort}->${toBlockId}:${toPort}

sccId must also be deterministic:
•	Compute SCCs on the same-frame dependency graph.
•	For each SCC, define sccId = hash(stableListOfMemberNodeKeys) or just join(sorted(memberKeys), '|') if you can tolerate length.

Where it runs in the fixpoint loop

Derive step

Implement:

function createDerivedObligationsForCycles(
g: DraftGraph,
registry: BlockRegistry
): NeedsCycleBreakObligation[]

Run it in the existing “Derive obligations” phase (same place you derive needsAdapter).

This derive step must:
1.	Build same-frame dependency graph using BlockTimingSpec.
2.	Compute SCCs (Tarjan or Kosaraju).
3.	Identify SCCs that represent an algebraic cycle:
•	SCC size > 1, OR
•	SCC size == 1 with a self-loop edge (in same-frame deps)
4.	For each such SCC, decide if it is already “broken”:
•	If the SCC contains at least one edge that passes through a delayed-output boundary such that the same-frame dependency is not present, it won’t appear as an SCC in the first place (preferred).
•	If your dependency graph is conservative and still forms an SCC, treat presence of an explicit user delay as a reason to skip fixing, based on block type: if SCC contains a UnitDelay (user origin), skip.
5.	Choose exactly one cut edge per SCC to break the cycle (deterministically).
6.	Emit one needsCycleBreak obligation for that cut edge unless an equivalent obligation already exists or the edge is already elaborated as a cycle break.

Planning step

Cycle break planning happens in planDischarge() alongside default sources and adapters:
•	If an obligation is needsCycleBreak and still open, call CycleBreakPolicy.plan(...).
•	No type deps are required unless you introduce type-specific delay variants (see below).

CycleBreakPolicy

Interface

interface CycleBreakPolicy {
name: 'cycleBreak.v1';
version: 1;
plan(o: NeedsCycleBreakObligation, ctx: PolicyContext): PolicyResult;
}

Plan semantics

The plan must:
•	Replace exactly one existing edge with a 2-edge chain through a new delay block.
•	Preserve user intent: keep the original connectivity, just time-shift one edge.

Block selection

Baseline “20-year” choice: a single polymorphic internal helper block:
•	UnitDelay (or FeedbackDelay) that is payload-generic and unit-generic and cardinality-preserving.
•	It must accept and output the same InferenceCanonicalType (payload/unit/extent), except temporality if/when you model it.

If you already have multiple stateful blocks, the policy can select among them, but selection must be deterministic and spec-driven (not heuristic based on runtime).

Deterministic IDs

New block ID:

_cd_${fromBlockId}_${fromPort}__${toBlockId}_${toPort}

New edge IDs:

_ce_${oldEdgeId}_in
_ce_${oldEdgeId}_out

ElaborationPlan shape

Use your existing ElaborationPlan:

plan = {
obligationId: o.id,
role: 'internalHelper', // or add 'cycleBreakHelper' if you want it distinct
addBlocks: [{
id: newDelayBlockId,
type: 'UnitDelay',
params: { /* minimal; ideally none */ },
origin: { kind:'elaboration', obligationId:o.id, role:'internalHelper' }
}],
replaceEdges: [{
remove: anchor.edgeId,
add: [
{ id: newEdgeInId,  from: old.from, to: { blockId:newDelayBlockId, port:'in', dir:'in'  }, role: old.role, origin: elaboratedOrigin },
{ id: newEdgeOutId, from: { blockId:newDelayBlockId, port:'out', dir:'out' }, to: old.to, role: old.role, origin: elaboratedOrigin },
]
}],
notes: 'cycle break'
}

The new edges should preserve the original edge’s role (userWire vs defaultWire) unless you intentionally want a distinct role.

When policy may block

Policy may return { kind:'blocked' } only for permanent reasons:
•	No compatible delay block exists for this edge’s type (only applicable if delay is type-limited).
•	Edge endpoints cannot be delayed by design (if you add “noFeedback” metadata; see below).

If it is merely “waiting for types,” keep obligation open (do not block).

Cut-edge selection algorithm (deterministic, minimal, stable)

For each SCC that needs breaking:
1.	Enumerate candidate edges in the SCC from the actual DraftGraph.edges that correspond to same-frame dependencies.
2.	Exclude edges that are:
•	Already elaborated with origin.kind==='elaboration' and role is cycle-break (however you encode it), or
•	Targeting/coming from a delayed output of an existing delay block (if that already breaks dependency).
3.	Prefer in order:
1.	An edge whose sink input port is explicitly marked feedback-allowed (optional metadata, see below).
2.	An edge whose source block is user-origin (so you cut “later” rather than cutting through internal helpers).
3.	Lowest stable key:

Stable key:

${from.blockId}:${from.port} -> ${to.blockId}:${to.port}

Pick the minimum lexicographically.

This is intentionally dumb but durable; any smarter heuristic will rot unless you can prove it preserves determinism and user expectations.

Optional metadata: “feedback-allowed” / “feedback-forbidden”

If you want a long-term guardrail, add a port-level policy hint:

interface PortFeedbackPolicy {
allowFeedback?: boolean;   // default true
}

Use it only for candidate filtering; do not make it affect type solving.

Interaction with adapters and default sources
•	Cycle breaking is structural and can be derived without types.
•	If your delay block is polymorphic, it should not require adapters purely due to payload/unit.
•	Cardinality mismatches introduced by cycle breaking (rare) are handled by the adapter obligation system the same way as any other mismatch.

Ordering inside fixpoint (recommended):
1.	Solve (payload/unit/cardinality)
2.	Derive obligations:
•	default sources are not derived; they are initial obligations from holes
•	needsAdapter
•	needsCycleBreak
3.	Plan discharge in priority order (deterministic):
1.	default sources (they unblock types)
2.	cycle breaks (they unblock cycle legality)
3.	adapters (they clean mismatches; may be required after the above)

Then apply all plans in sorted obligation-id order.

Convergence guarantees

This elaboration is monotone and bounded:
•	Each application inserts exactly one new delay block and replaces one edge.
•	The number of algebraic SCCs strictly decreases or stays the same; the specific SCC targeted is eliminated because the chosen edge is now delayed and removed from same-frame dependency graph.
•	Because you never re-derive a cycle-break obligation on an already cycle-broken edge, you cannot oscillate.

You still keep the global maxIterations safety valve, but cycle breaking should converge in <= (#cycleBreak insertions + other insertions).

Diagnostics and debugging

What you must record

In ObligationDebug for needsCycleBreak:
•	createdBy: 'deriveCycles.v1'
•	note: 'scc members: ...; cut edge: ...' (short, stable)

In FinalNormalizationResult.trace (if you have it):
•	number of SCCs found
•	number of cycle-break obligations created
•	which obligations discharged this iteration

This answers your earlier “wouldn’t we need that for debugging?”: yes, you keep structural trace at the obligation level; you do not need a special extra output from the solver to debug cycles.

Tests (minimum)
1.	Simple self-loop
•	One block output wired to its own input (same-frame dependency).
•	Expect: one UnitDelay inserted, cycle gone.
2.	Two-block cycle
•	A->B->A.
•	Expect: exactly one cut edge chosen deterministically and delayed.
3.	Cycle already broken by explicit UnitDelay
•	User inserts UnitDelay in the loop.
•	Expect: no auto insertion.
4.	Multiple SCCs
•	Two disjoint cycles.
•	Expect: one insertion per SCC (potentially across iterations, deterministic order).
5.	Idempotence
•	Run normalization twice.
•	Expect: second run produces no additional cycle-break plans.
6.	Interplay with adapters
•	Create a cycle whose cut edge requires adapter after insertion (or vice versa).
•	Expect: both obligations discharge, converges, stable result.

Implementation placement (frontend passes)

In your “final passes” world, cycle breaking is not a separate linear pass; it is a derived obligation + policy inside final normalization, exactly like adapters. It lives in:
•	createDerivedObligations() (cycle detection) and
•	CycleBreakPolicy.plan() (delay insertion), and
•	applyElaborationPlan() (rewire).

That is the whole mechanism.