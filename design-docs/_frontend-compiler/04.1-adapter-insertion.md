Frontend normalization passes (final pipeline order)
1.	Composite expansion
      •	Expand composite blocks into internal blocks/edges.
      •	Preserve stable IDs and origin metadata.
2.	Lens expansion
      •	Rewrite user-authored lens constructs into explicit blocks/edges (purely structural).
      •	Must run before any constraint extraction so Solve sees the real graph.
3.	Build DraftGraph
      •	Convert expanded Patch -> DraftGraph (blocks, edges, origins, stable ordering).
      •	Create initial obligations:
      •	missingInputSource for every unconnected input.
4.	Fixpoint loop
      •	Repeat until no plans are produced (or max iterations):
      4.1 Extract constraints
      •	From current DraftGraph, derive constraints for:
      •	payload
      •	unit
      •	cardinality (including zip groups, clampOne/forceMany, edge equalities)
      •	any other axes you’re actually solving now
      4.2 Solve types
      •	Pure solvers return substitutions (no graph mutation):
      •	payload/unit substitution
      •	cardinality substitution (+ instances if used)
      •	(later: temporality/binding/etc)
      4.3 Compute TypeFacts
      •	For each port, produce ok | unknown | conflict with inference/canonical where possible.
      4.4 Derive obligations (type-dependent)
      •	Create obligations that require solved facts, e.g.:
      •	needsAdapter for edges whose endpoints are canonicalizable and mismatched
      •	(later) needsLaneAlignment, needsDomainElaboration, needsVarargMaterialization
      •	Add-if-missing (deterministic IDs) so the set is stable across iterations.
      4.5 Plan discharge
      •	For each open obligation (sorted by ID), if deps satisfied:
      •	DefaultSourcePolicy -> plans default sources
      •	AdapterPolicy -> plans adapter insertion
      •	(later) LaneAlignmentPolicy / DomainElaborationPolicy / VarargPolicy
      •	Obligations waiting on deps remain open; truly unsupported become blocked.
      4.6 Apply plans
      •	Apply ElaborationPlans (add/replace edges, add blocks), bump graph revision.
      •	Stop fixpoint when plans.length === 0.
5.	Varargs validation/materialization
      •	Validate vararg wiring rules on the finalized DraftGraph.
      •	If you do vararg expansion/materialization, it belongs here (or as an obligation + policy inside the loop).
6.	Block indexing
      •	Produce any index maps the backend lowering expects (toposort groups, port lookup tables, etc).
7.	Strict finalization
      •	If no open obligations and all required ports are TypeFacts.status === 'ok':
      •	finalize inference -> CanonicalType (the only boundary)
      •	produce StrictTypedGraph/StrictTypedPatch product
      •	Otherwise: strict product is null + diagnostics.
8.	Axis validation
      •	Enforce “no var axes leak past strict,” cardinality invariants, domain invariants, etc.
9.	Cycle classification
      •	Analyze cycles for scheduling/runtime rules.
10.	TypedPatch / FrontendCompileResult build

	•	Bridge final graph + canonical port types into the exact structures the backend and UI consume.
	•	Store TypeFacts + obligations for debugging surfaces.

That is the order.

---

Adapter Insertion Spec for Final Normalization Fixpoint

Context

In the fixpoint normalizer, adapters are not a pre-type-solve pass. They are elaboration driven by Obligations created from the current graph + current solved type facts. Adapter insertion must be:
•	Type-driven (uses solved types, never BlockDef static types).
•	Pure in planning (Plan is computed from (graph, facts); Apply is the only mutator).
•	Monotone (only adds blocks/rewires edges; never “undoes” user intent).
•	Deterministic (same input graph -> same adapter blocks/edges IDs and same rewiring).

This spec is compatible with your fixpoint architecture and with a strict “CanonicalType is never partial” rule.

⸻

Non-negotiable invariants
1.	CanonicalType is never partial
Adapter planning only uses CanonicalType when a port’s hint is status:'ok'. Otherwise it does nothing or emits a dependency-driven open obligation.
2.	Solve is pure
Adapter insertion is not part of Solve. Solve produces facts/diagnostics; adapter insertion is Plan/Apply.
3.	Adapter insertion is monotone and local
Adapter plans only:
•	add adapter blocks,
•	replace one edge with a short chain,
•	optionally add helper edges/blocks tied to that obligation.
It does not remove arbitrary blocks or rewire unrelated edges.
4.	Convergence is on structure
The fixpoint terminates when plans.length === 0. Adapter planning must therefore be stable (no oscillation) and idempotent under re-run.
5.	Stable IDs
Adapter obligation IDs and adapter block/edge IDs are derived from semantic edge identity, not incidental runtime ordering.

⸻

Definitions

DraftGraph entities
•	DraftEdge has:
•	from: PortRef
•	to: PortRef
•	role: EdgeRole (userWire | defaultWire | implicitCoerce | internalHelper)
•	origin: EdgeOrigin (user | compositeInternal | { kind:'elaboration', obligationId, role })

Type facts interface used by adapter planning

TypeFacts.getHint(port: PortRef) -> PortTypeHint

PortTypeHint:
•	status: 'ok' | 'unknown' | 'conflict'
•	canonical?: CanonicalType (only if ok)
•	inference?: InferenceCanonicalType (optional)
•	diagIds: string[]

Adapter planning only uses canonical values.

⸻

Adapter-related obligation kinds

NeedsAdapterObligation

Purpose: One graph edge connects two ports whose resolved canonical types are not directly assignable without an adapter.

Fields:
•	kind: 'needsAdapter'
•	anchor: { edgeId: EdgeId }
•	deps: [{ kind:'portCanonicalizable', port: from }, { kind:'portCanonicalizable', port: to }]
•	policy: { name:'adapters.v1', version:1 }
•	status: open | discharged | blocked

Optional: NeedsBroadcastObligation (recommended)

Purpose: When cardinality solving reports a hard conflict (e.g. forced-one meets forced-many through equality/zip), you need a way to turn that into structure (a Broadcast block) even if the conflicting ports are not status:'ok'.

This is the clean way to reconcile:
•	“solver is strict” and
•	“adapter/obligation system resolves it by inserting Broadcast”.

Fields:
•	kind: 'needsBroadcast'
•	anchor: { edgeId: EdgeId } or { port: PortRef } depending on the witness
•	deps: can still be portCanonicalizable (if you require canonical types) or a weaker dep like { kind:'portAxisResolved', axis:'cardinality' } if Broadcast only depends on extent; pick one and be consistent
•	policy: { name:'broadcast.v1', version:1 }

If you do not add this, then strict cardinality conflicts will permanently prevent adapter planning (because endpoints never become ok), and the fixpoint will stall.

⸻

Where adapter obligations come from

Adapter obligations are derived inside the fixpoint loop after Solve, in a pure step:

createDerivedObligations(graph, facts, solveDiagnostics) -> Obligation[]

This step is pure and deterministic.

Rule A: Edge mismatch obligations (canonical)

For every DraftEdge e where:
•	e.role in { 'userWire', 'defaultWire' }
•	e.origin is not { kind:'elaboration', role:'adapter' } (skip already-adapted edges)
•	Let fromHint = facts.getHint(e.from)
•	Let toHint = facts.getHint(e.to)
•	If both are status:'ok':
•	If isAssignable(fromHint.canonical, toHint.canonical) => no obligation.
•	Else => create NeedsAdapterObligation for this edge.

Notes:
•	“Assignable” must match your existing adapter semantics (see “Adapter selection” below).
•	This rule never fires for unknown/conflict types; it waits.

Rule B: Cardinality conflict obligations (recommended)

If Solve produced a cardinality conflict diagnostic with witness ports/edges, create a broadcast-related obligation even though facts aren’t ok.

Minimum required diagnostic payload from the cardinality solver to enable this:
•	kind: 'CardinalityConflict'
•	subkind at least distinguishes:
•	one_vs_many_through_equal
•	one_vs_many_in_zipGroup
•	instance_mismatch_in_zipGroup
•	witnessPorts: PortRef[]
•	witnessEdges: EdgeId[] (if available)

Creation logic:
•	If subkind is one-vs-many and there exists a specific edge whose removal/adapterization would break the conflict path, anchor to that edge (preferred), else anchor to the “most local” port in the witness set.

This is what turns a strict conflict into a plan-able elaboration.

⸻

Obligation IDs (deterministic)

For NeedsAdapterObligation

Do not use the runtime edge id as the semantic identity. Use a deterministic semantic key:

needsAdapter:${fromBlockId}:${fromPort}:${fromDir}->${toBlockId}:${toPort}:${toDir}

This remains stable even if edge IDs are regenerated.

For conflict-driven broadcast obligations

Anchor similarly on semantic edge identity if possible:

needsBroadcast:${from...}->${to...}

If anchored to a port:

needsBroadcastPort:${blockId}:${port}:${dir}

⸻

AdapterPolicy interface

AdapterPolicy (adapters.v1)

Input context:
•	graph
•	facts
•	registry (adapter registry + block defs)
•	obligation (must include anchor.edgeId)
•	getEdge(edgeId) helper
•	getHint(port) helper

Output:
•	{ kind:'plan', plan: ElaborationPlan }
•	{ kind:'blocked', reason, diagIds }

Blocked means permanent (unsupported), not “waiting”.

Waiting happens by leaving the obligation open when deps aren’t satisfied.

⸻

Adapter selection

Canonical assignability test

Define a function consistent with your existing adapter definitions:

isAssignable(from: CanonicalType, to: CanonicalType) -> boolean

Rules must match your system, but structurally it should be:
•	payload: identical or convertible
•	unit: identical or convertible
•	extent axes (at least cardinality, possibly others): identical or convertible
•	contracts: compatible

If isAssignable is false, planning proceeds.

Adapter lookup / chain

Use your existing adapter registry entry point:

findAdapterChain(from: CanonicalType, to: CanonicalType) -> AdapterChain | null

Where AdapterChain is a short sequence (length 1..N) of adapter steps, each step describing:
•	adapter block type (e.g. Broadcast, UnitConvert, PayloadCoerce, etc.)
•	parameterization (if any)
•	input/output port names (or standard adapter port schema)

If you only have single-step adapters today, define AdapterChain anyway; it future-proofs without changing the planning contract.

If findAdapterChain(...) returns null:
•	policy returns { kind:'blocked', reason:'no_adapter', diagIds:[...] }

⸻

Elaboration plan for adapters

Structure

ElaborationPlan fields used:
•	obligationId
•	role: 'adapter'
•	replaceEdges: [{ remove: EdgeId, add: DraftEdge[] }]
•	addBlocks: DraftBlock[]
•	optional notes

Rewire semantics

Given original edge e: A -> B:

Replace it with either:
•	Single adapter:
•	A -> Adapter0 -> B
•	Chain:
•	A -> Adapter0 -> Adapter1 -> ... -> B

All new edges should generally use role: 'implicitCoerce' (or keep userWire on the first segment if you explicitly want to preserve UI semantics; pick one rule globally and keep it consistent).

All inserted blocks/edges must have:
•	origin: { kind:'elaboration', obligationId, role:'adapter' }

Deterministic IDs (block + edges)

Base key for the adapter chain should be derived from the semantic edge identity (not the incidental edge id):

base = hashOrSafeKey("adapt:" + semanticEdgeKey)

Then:
•	Adapter blocks:
•	blockId = "_ad_" + base + "_k" + i (i = 0..chainLen-1)
•	New edges:
•	edgeId = "_ae_" + base + "_e" + j (j = 0..chainLen)
(chainLen+1 edges: source->0, 0->1, …, last->sink)

If you refuse hashing, you can use a fully textual key, but then you must guarantee it stays within your ID constraints.

Idempotence requirement

applyElaborationPlan must treat “plan already applied” as a no-op. For adapters this is achieved by:
•	deterministic IDs as above, and
•	checking for existence before insertion (block/edge id collisions mean “already applied”).

⸻

When adapter obligations discharge

In planDischarge(...):

For each NeedsAdapterObligation o:
1.	If o.status is discharged or blocked: skip.
2.	Locate edge by o.anchor.edgeId (or by semantic key if you store that).
•	If edge no longer exists because it was already replaced: mark discharged (or just skip and let idempotence handle it; pick one rule and stick to it).
3.	Check deps:
•	If either endpoint port hint is not canonicalizable: keep open.
4.	If both endpoints status:'ok':
•	call AdapterPolicy.plan(o, ctx)
•	if plan returned: collect plan
•	if blocked returned: set o.status = blocked(...)

On Apply:
•	apply all plans in stable order (by obligationId)

⸻

Lens interaction rules

Keep lens expansion

Lens expansion is structural and user-driven. It must remain as a separate pre-loop step:
•	Composite expansion
•	Build DraftGraph
•	Lens expansion
•	Fixpoint loop

Lens expansion can create new edges and blocks that change type constraints; this is fine. Adapter insertion happens after Solve based on the now-visible structure.

“User inserted broadcast” vs “auto-insert broadcast”

This is not a conceptual conflict:
•	A user-inserted Broadcast is a normal block; it participates in Solve like any other.
•	Auto-inserted Broadcast is just an adapter plan that inserts the same block type with origin.kind:'elaboration'.

Potential duplication is possible if the user inserts a Broadcast and the system would also insert one. Your rules prevent this in practice because if the user’s Broadcast makes the edge assignable, the mismatch obligation won’t be created. If the user’s Broadcast is insufficient (wrong place or still mismatched), additional adapters may still be inserted; that is correct behavior.

⸻

Diagnostics required for “20 year” debugging

You need debugging that answers: why was an adapter inserted and why wasn’t one inserted.

Minimum:
1.	Obligation record (already in graph)
•	obligationId
•	anchor (edge id)
•	deps
•	status transitions (open -> discharged/blocked)
•	policy name/version
2.	Policy decision diagnostics
•	If blocked: reason + diagIds
•	If planned: a diag record that includes:
•	from/to canonical types (stringified summary)
•	chosen adapter chain (block types)
•	semantic edge key
3.	Cardinality solver conflict witnesses (if you support conflict-driven obligations)
•	ports involved
•	whether it spawned a broadcast obligation

This gives you “post-mortem determinism”: you can reproduce and inspect decisions without adding heuristics.

⸻

Pass ordering (frontend normalization, final form)

This is the stable order that makes the system correct:
1.	Composite expansion (pure structural; produces expanded Patch)
2.	Build DraftGraph (blocks/edges + initial obligations for missing inputs)
3.	Lens expansion (pure structural; may add blocks/edges; no type dependency)
4.	Fixpoint loop (repeat until plans.length === 0 or max iterations):
•	4.1 Solve (payload/unit/cardinality/etc.) -> TypeFacts + diagnostics
•	4.2 Derive obligations (pure; from edges + diagnostics)
•	4.3 Plan discharge (policies: default sources, adapters, lane alignment, etc.)
•	4.4 Apply plans (mutate graph; bump revision)
5.	Strict finalization (only if all required ports are canonicalizable and no open obligations)
6.	Post-fixpoint validations / indexing:
•	varargs normalization/validation
•	block indexing
•	axis validation
•	cycle classification
7.	Bridge to backend TypedPatch

That is the order.